//
// This file was auto-generated using the following command:
//
// jai ./generate.jai
//



B3_USE_CLEW :: 1;
BT_SHARED :: 1;
BT_BULLET_VERSION :: 324;

BT_LARGE_FLOAT :: 1.0e18;

SIMD_PI :: 3.1415926535897932384626433832795029;
SIMD_2_PI :: 2.0 * SIMD_PI;
SIMD_HALF_PI :: SIMD_PI * 0.5;
SIMD_RADS_PER_DEG :: SIMD_2_PI / 360.0;
SIMD_DEGS_PER_RAD :: 360.0 / SIMD_2_PI;
SIMDSQRT12 :: 0.7071067811865475244008443621048490;

BT_ONE :: 1.0;
BT_ZERO :: 0.0;
BT_TWO :: 2.0;
BT_HALF :: 0.5;

btVector3Data :: btVector3FloatData;
btVector3DataName :: "btVector3FloatData";

btQuaternionData :: btQuaternionFloatData;
btQuaternionDataName :: "btQuaternionFloatData";

btMatrix3x3Data :: btMatrix3x3FloatData;

btTransformData :: btTransformFloatData;

ACTIVE_TAG :: 1;
ISLAND_SLEEPING :: 2;
WANTS_DEACTIVATION :: 3;
DISABLE_DEACTIVATION :: 4;
DISABLE_SIMULATION :: 5;
FIXED_BASE_MULTI_BODY :: 6;

BT_USE_PLACEMENT_NEW :: 1;

btCollisionObjectData :: btCollisionObjectFloatData;
btCollisionObjectDataName :: "btCollisionObjectFloatData";

ANGULAR_MOTION_THRESHOLD :: 0.5 * SIMD_HALF_PI;

MANIFOLD_CACHE_SIZE :: 4;

MAINTAIN_PERSISTENCY :: 1;

btPersistentManifoldData :: btPersistentManifoldFloatData;
btPersistentManifoldDataName :: "btPersistentManifoldFloatData";

USE_DISPATCH_REGISTRY_ARRAY :: 1;

CONVEX_DISTANCE_MARGIN :: 0.04;

MAX_PREFERRED_PENETRATION_DIRECTIONS :: 10;

USE_BANCHLESS :: 1;

btQuantizedBvhData :: btQuantizedBvhFloatData;
btOptimizedBvhNodeData :: btOptimizedBvhNodeFloatData;
btQuantizedBvhDataName :: "btQuantizedBvhFloatData";

MAX_SUBTREE_SIZE_IN_BYTES :: 2048;

MAX_NUM_PARTS_IN_BITS :: 10;

BT_HEADER_LENGTH :: 12;

TRI_INFO_V0V1_CONVEX :: 1;
TRI_INFO_V1V2_CONVEX :: 2;
TRI_INFO_V2V0_CONVEX :: 4;

TRI_INFO_V0V1_SWAP_NORMALB :: 8;
TRI_INFO_V1V2_SWAP_NORMALB :: 16;
TRI_INFO_V2V0_SWAP_NORMALB :: 32;

DBVT_IMPL_GENERIC :: 0;
DBVT_IMPL_SSE :: 1;

DBVT_USE_TEMPLATE :: 1;

DBVT_USE_INTRINSIC_SSE :: 1;

DBVT_USE_MEMMOVE :: 1;

DBVT_ENABLE_BENCHMARK :: 0;

DBVT_SELECT_IMPL :: DBVT_IMPL_GENERIC;
DBVT_MERGE_IMPL :: DBVT_IMPL_GENERIC;
DBVT_INT0_IMPL :: DBVT_IMPL_GENERIC;

DBVT_BP_PROFILE :: 0;

DBVT_BP_PREVENTFALSEUPDATE :: 0;
DBVT_BP_ACCURATESLEEPING :: 0;
DBVT_BP_ENABLE_BENCHMARK :: 0;

USE_OVERLAP_TEST_ON_REMOVES :: 1;

CLEAN_INVALID_PAIRS :: 1;

USE_BT_CLOCK :: 1;

BT_NO_PROFILE :: 1;

btRigidBodyData :: btRigidBodyFloatData;
btRigidBodyDataName :: "btRigidBodyFloatData";

btSimdScalar :: btScalar;

btTypedConstraintData2 :: btTypedConstraintFloatData;
btTypedConstraintDataName :: "btTypedConstraintFloatData";

btPoint2PointConstraintData2 :: btPoint2PointConstraintFloatData;
btPoint2PointConstraintDataName :: "btPoint2PointConstraintFloatData";

_BT_USE_CENTER_LIMIT_ :: 1;

btHingeConstraintData :: btHingeConstraintFloatData;
btHingeConstraintDataName :: "btHingeConstraintFloatData";

btConeTwistConstraintData2 :: btConeTwistConstraintData;
btConeTwistConstraintDataName :: "btConeTwistConstraintData";

btGeneric6DofConstraintData2 :: btGeneric6DofConstraintData;
btGeneric6DofConstraintDataName :: "btGeneric6DofConstraintData";

BT_6DOF_FLAGS_AXIS_SHIFT :: 3;

btSliderConstraintData2 :: btSliderConstraintData;
btSliderConstraintDataName :: "btSliderConstraintData";

SLIDER_CONSTRAINT_DEF_SOFTNESS :: 1.0;
SLIDER_CONSTRAINT_DEF_DAMPING :: 1.0;
SLIDER_CONSTRAINT_DEF_RESTITUTION :: 0.7;
SLIDER_CONSTRAINT_DEF_CFM :: 0.;

btGeneric6DofSpringConstraintData2 :: btGeneric6DofSpringConstraintData;
btGeneric6DofSpringConstraintDataName :: "btGeneric6DofSpringConstraintData";

btGeneric6DofSpring2ConstraintData2 :: btGeneric6DofSpring2ConstraintData;
btGeneric6DofSpring2ConstraintDataName :: "btGeneric6DofSpring2ConstraintData";

BT_6DOF_FLAGS_AXIS_SHIFT2 :: 4;

btGearConstraintData :: btGearConstraintFloatData;
btGearConstraintDataName :: "btGearConstraintFloatData";

B3_BULLET_VERSION :: 300;

B3_LARGE_FLOAT :: 1.0e18;

B3_2_PI :: 6.283185307179586232;
B3_PI :: B3_2_PI * 0.5;
B3_HALF_PI :: B3_2_PI * 0.25;
B3_RADS_PER_DEG :: B3_2_PI / 360.0;
B3_DEGS_PER_RAD :: 360.0 / B3_2_P;
B3_SQRT12 :: 0.7071067811865475244008443621048490;

B3_USE_PLACEMENT_NEW :: 1;

b3Vector3Data :: b3Vector3FloatData;
b3Vector3DataName :: "b3Vector3FloatData";

b3Matrix3x3Data :: b3Matrix3x3FloatData;

b3TransformData :: b3TransformFloatData;

B3_ANGULAR_MOTION_THRESHOLD :: 0.5 * B3_HALF_PI;

B3_USE_BANCHLESS :: 1;

btMultiBodyData :: btMultiBodyFloatData;
btMultiBodyDataName :: "btMultiBodyFloatData";
btMultiBodyLinkData :: btMultiBodyLinkFloatData;
btMultiBodyLinkDataName :: "btMultiBodyLinkFloatData";

btMultiBodyLinkColliderData :: btMultiBodyLinkColliderFloatData;
btMultiBodyLinkColliderDataName :: "btMultiBodyLinkColliderFloatData";

btSoftBodyData :: btSoftBodyFloatData;
btSoftBodyDataName :: "btSoftBodyFloatData";

TETRA_FLAT_THRESHOLD :: 0.01;

USE_PATH_COMPRESSION :: 1;

STATIC_SIMULATION_ISLAND_OPTIMIZATION :: 1;

CL_CHAR_BIT :: 8;
CL_SCHAR_MAX :: 127;
CL_SCHAR_MIN :: -127 - 1;
CL_CHAR_MAX :: CL_SCHAR_MAX;
CL_CHAR_MIN :: CL_SCHAR_MIN;
CL_UCHAR_MAX :: 255;
CL_SHRT_MAX :: 32767;
CL_SHRT_MIN :: -32767 - 1;
CL_USHRT_MAX :: 65535;
CL_INT_MAX :: 2147483647;
CL_INT_MIN :: -2147483647 - 1;
CL_UINT_MAX :: 0xffffffff;
CL_LONG_MAX :: cast(cl_long)0x7FFFFFFFFFFFFFFF;
CL_LONG_MIN :: cast,trunc(cl_long)-0x7FFFFFFFFFFFFFFF - 1;
CL_ULONG_MAX :: cast(cl_ulong)0xFFFFFFFFFFFFFFFF;

CL_FLT_DIG :: 6;
CL_FLT_MANT_DIG :: 24;
CL_FLT_MAX_10_EXP :: +38;
CL_FLT_MAX_EXP :: +128;
CL_FLT_MIN_10_EXP :: -37;
CL_FLT_MIN_EXP :: -125;
CL_FLT_RADIX :: 2;
CL_FLT_MAX :: 340282346638528859811704183484516925440.0;
CL_FLT_MIN :: 1.175494350822287507969e-38;

CL_DBL_DIG :: 15;
CL_DBL_MANT_DIG :: 53;
CL_DBL_MAX_10_EXP :: +308;
CL_DBL_MAX_EXP :: +1024;
CL_DBL_MIN_10_EXP :: -307;
CL_DBL_MIN_EXP :: -1021;
CL_DBL_RADIX :: 2;
CL_DBL_MAX :: 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0;
CL_DBL_MIN :: 2.225e-307;
CL_DBL_EPSILON :: 2.220446049250313080847e-16;

CL_M_E :: 2.718281828459045090796;
CL_M_LOG2E :: 1.442695040888963387005;
CL_M_LOG10E :: 0.434294481903251816668;
CL_M_LN2 :: 0.693147180559945286227;
CL_M_LN10 :: 2.302585092994045901094;
CL_M_PI :: 3.141592653589793115998;
CL_M_PI_2 :: 1.570796326794896557999;
CL_M_PI_4 :: 0.785398163397448278999;
CL_M_1_PI :: 0.318309886183790691216;
CL_M_2_PI :: 0.636619772367581382433;
CL_M_2_SQRTPI :: 1.128379167095512558561;
CL_M_SQRT2 :: 1.414213562373095145475;
CL_M_SQRT1_2 :: 0.707106781186547572737;

CL_M_E_F :: 2.71828174591064;
CL_M_LOG2E_F :: 1.44269502162933;
CL_M_LOG10E_F :: 0.43429449200630;
CL_M_LN2_F :: 0.69314718246460;
CL_M_LN10_F :: 2.30258512496948;
CL_M_PI_F :: 3.14159274101257;
CL_M_PI_2_F :: 1.57079637050629;
CL_M_PI_4_F :: 0.78539818525314;
CL_M_1_PI_F :: 0.31830987334251;
CL_M_2_PI_F :: 0.63661974668503;
CL_M_2_SQRTPI_F :: 1.12837922573090;
CL_M_SQRT2_F :: 1.41421353816986;
CL_M_SQRT1_2_F :: 0.70710676908493;

CL_NAN :: CL_INFINITY - CL_INFINITY;
CL_HUGE_VALF :: cast(cl_float)1.0e50;
CL_HUGE_VAL :: cast(cl_double)1.0e500;
CL_MAXFLOAT :: CL_FLT_MAX;
CL_INFINITY :: CL_HUGE_VALF;

__CL_FLOAT4__ :: 1;

__CL_UCHAR16__ :: 1;
__CL_CHAR16__ :: 1;
__CL_USHORT8__ :: 1;
__CL_SHORT8__ :: 1;
__CL_INT4__ :: 1;
__CL_UINT4__ :: 1;
__CL_ULONG2__ :: 1;
__CL_LONG2__ :: 1;
__CL_DOUBLE2__ :: 1;

__CL_UCHAR8__ :: 1;
__CL_CHAR8__ :: 1;
__CL_USHORT4__ :: 1;
__CL_SHORT4__ :: 1;
__CL_INT2__ :: 1;
__CL_UINT2__ :: 1;
__CL_ULONG1__ :: 1;
__CL_LONG1__ :: 1;
__CL_FLOAT2__ :: 1;

CL_HAS_NAMED_VECTOR_FIELDS :: 1;

CL_HAS_HI_LO_VECTOR_FIELDS :: 1;

CL_SUCCESS :: 0;
CL_DEVICE_NOT_FOUND :: -1;
CL_DEVICE_NOT_AVAILABLE :: -2;
CL_COMPILER_NOT_AVAILABLE :: -3;
CL_MEM_OBJECT_ALLOCATION_FAILURE :: -4;
CL_OUT_OF_RESOURCES :: -5;
CL_OUT_OF_HOST_MEMORY :: -6;
CL_PROFILING_INFO_NOT_AVAILABLE :: -7;
CL_MEM_COPY_OVERLAP :: -8;
CL_IMAGE_FORMAT_MISMATCH :: -9;
CL_IMAGE_FORMAT_NOT_SUPPORTED :: -10;
CL_BUILD_PROGRAM_FAILURE :: -11;
CL_MAP_FAILURE :: -12;
CL_MISALIGNED_SUB_BUFFER_OFFSET :: -13;
CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST :: -14;

CL_INVALID_VALUE :: -30;
CL_INVALID_DEVICE_TYPE :: -31;
CL_INVALID_PLATFORM :: -32;
CL_INVALID_DEVICE :: -33;
CL_INVALID_CONTEXT :: -34;
CL_INVALID_QUEUE_PROPERTIES :: -35;
CL_INVALID_COMMAND_QUEUE :: -36;
CL_INVALID_HOST_PTR :: -37;
CL_INVALID_MEM_OBJECT :: -38;
CL_INVALID_IMAGE_FORMAT_DESCRIPTOR :: -39;
CL_INVALID_IMAGE_SIZE :: -40;
CL_INVALID_SAMPLER :: -41;
CL_INVALID_BINARY :: -42;
CL_INVALID_BUILD_OPTIONS :: -43;
CL_INVALID_PROGRAM :: -44;
CL_INVALID_PROGRAM_EXECUTABLE :: -45;
CL_INVALID_KERNEL_NAME :: -46;
CL_INVALID_KERNEL_DEFINITION :: -47;
CL_INVALID_KERNEL :: -48;
CL_INVALID_ARG_INDEX :: -49;
CL_INVALID_ARG_VALUE :: -50;
CL_INVALID_ARG_SIZE :: -51;
CL_INVALID_KERNEL_ARGS :: -52;
CL_INVALID_WORK_DIMENSION :: -53;
CL_INVALID_WORK_GROUP_SIZE :: -54;
CL_INVALID_WORK_ITEM_SIZE :: -55;
CL_INVALID_GLOBAL_OFFSET :: -56;
CL_INVALID_EVENT_WAIT_LIST :: -57;
CL_INVALID_EVENT :: -58;
CL_INVALID_OPERATION :: -59;
CL_INVALID_GL_OBJECT :: -60;
CL_INVALID_BUFFER_SIZE :: -61;
CL_INVALID_MIP_LEVEL :: -62;
CL_INVALID_GLOBAL_WORK_SIZE :: -63;
CL_INVALID_PROPERTY :: -64;

CL_VERSION_1_0 :: 1;
CL_VERSION_1_1 :: 1;

CL_FALSE :: 0;
CL_TRUE :: 1;

CL_PLATFORM_PROFILE :: 0x0900;
CL_PLATFORM_VERSION :: 0x0901;
CL_PLATFORM_NAME :: 0x0902;
CL_PLATFORM_VENDOR :: 0x0903;
CL_PLATFORM_EXTENSIONS :: 0x0904;

CL_DEVICE_TYPE_DEFAULT :: 1 << 0;
CL_DEVICE_TYPE_CPU :: 1 << 1;
CL_DEVICE_TYPE_GPU :: 1 << 2;
CL_DEVICE_TYPE_ACCELERATOR :: 1 << 3;
CL_DEVICE_TYPE_ALL :: 0xFFFFFFFF;

CL_DEVICE_TYPE :: 0x1000;
CL_DEVICE_VENDOR_ID :: 0x1001;
CL_DEVICE_MAX_COMPUTE_UNITS :: 0x1002;
CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS :: 0x1003;
CL_DEVICE_MAX_WORK_GROUP_SIZE :: 0x1004;
CL_DEVICE_MAX_WORK_ITEM_SIZES :: 0x1005;
CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR :: 0x1006;
CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT :: 0x1007;
CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT :: 0x1008;
CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG :: 0x1009;
CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT :: 0x100A;
CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE :: 0x100B;
CL_DEVICE_MAX_CLOCK_FREQUENCY :: 0x100C;
CL_DEVICE_ADDRESS_BITS :: 0x100D;
CL_DEVICE_MAX_READ_IMAGE_ARGS :: 0x100E;
CL_DEVICE_MAX_WRITE_IMAGE_ARGS :: 0x100F;
CL_DEVICE_MAX_MEM_ALLOC_SIZE :: 0x1010;
CL_DEVICE_IMAGE2D_MAX_WIDTH :: 0x1011;
CL_DEVICE_IMAGE2D_MAX_HEIGHT :: 0x1012;
CL_DEVICE_IMAGE3D_MAX_WIDTH :: 0x1013;
CL_DEVICE_IMAGE3D_MAX_HEIGHT :: 0x1014;
CL_DEVICE_IMAGE3D_MAX_DEPTH :: 0x1015;
CL_DEVICE_IMAGE_SUPPORT :: 0x1016;
CL_DEVICE_MAX_PARAMETER_SIZE :: 0x1017;
CL_DEVICE_MAX_SAMPLERS :: 0x1018;
CL_DEVICE_MEM_BASE_ADDR_ALIGN :: 0x1019;
CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE :: 0x101A;
CL_DEVICE_SINGLE_FP_CONFIG :: 0x101B;
CL_DEVICE_GLOBAL_MEM_CACHE_TYPE :: 0x101C;
CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE :: 0x101D;
CL_DEVICE_GLOBAL_MEM_CACHE_SIZE :: 0x101E;
CL_DEVICE_GLOBAL_MEM_SIZE :: 0x101F;
CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE :: 0x1020;
CL_DEVICE_MAX_CONSTANT_ARGS :: 0x1021;
CL_DEVICE_LOCAL_MEM_TYPE :: 0x1022;
CL_DEVICE_LOCAL_MEM_SIZE :: 0x1023;
CL_DEVICE_ERROR_CORRECTION_SUPPORT :: 0x1024;
CL_DEVICE_PROFILING_TIMER_RESOLUTION :: 0x1025;
CL_DEVICE_ENDIAN_LITTLE :: 0x1026;
CL_DEVICE_AVAILABLE :: 0x1027;
CL_DEVICE_COMPILER_AVAILABLE :: 0x1028;
CL_DEVICE_EXECUTION_CAPABILITIES :: 0x1029;
CL_DEVICE_QUEUE_PROPERTIES :: 0x102A;
CL_DEVICE_NAME :: 0x102B;
CL_DEVICE_VENDOR :: 0x102C;
CL_DRIVER_VERSION :: 0x102D;
CL_DEVICE_PROFILE :: 0x102E;
CL_DEVICE_VERSION :: 0x102F;
CL_DEVICE_EXTENSIONS :: 0x1030;
CL_DEVICE_PLATFORM :: 0x1031;

CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF :: 0x1034;
CL_DEVICE_HOST_UNIFIED_MEMORY :: 0x1035;
CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR :: 0x1036;
CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT :: 0x1037;
CL_DEVICE_NATIVE_VECTOR_WIDTH_INT :: 0x1038;
CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG :: 0x1039;
CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT :: 0x103A;
CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE :: 0x103B;
CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF :: 0x103C;
CL_DEVICE_OPENCL_C_VERSION :: 0x103D;

CL_FP_DENORM :: 1 << 0;
CL_FP_INF_NAN :: 1 << 1;
CL_FP_ROUND_TO_NEAREST :: 1 << 2;
CL_FP_ROUND_TO_ZERO :: 1 << 3;
CL_FP_ROUND_TO_INF :: 1 << 4;
CL_FP_FMA :: 1 << 5;
CL_FP_SOFT_FLOAT :: 1 << 6;

CL_NONE :: 0x0;
CL_READ_ONLY_CACHE :: 0x1;
CL_READ_WRITE_CACHE :: 0x2;

CL_LOCAL :: 0x1;
CL_GLOBAL :: 0x2;

CL_EXEC_KERNEL :: 1 << 0;
CL_EXEC_NATIVE_KERNEL :: 1 << 1;

CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE :: 1 << 0;
CL_QUEUE_PROFILING_ENABLE :: 1 << 1;

CL_CONTEXT_REFERENCE_COUNT :: 0x1080;
CL_CONTEXT_DEVICES :: 0x1081;
CL_CONTEXT_PROPERTIES :: 0x1082;
CL_CONTEXT_NUM_DEVICES :: 0x1083;

CL_CONTEXT_PLATFORM :: 0x1084;

CL_QUEUE_CONTEXT :: 0x1090;
CL_QUEUE_DEVICE :: 0x1091;
CL_QUEUE_REFERENCE_COUNT :: 0x1092;
CL_QUEUE_PROPERTIES :: 0x1093;

CL_MEM_READ_WRITE :: 1 << 0;
CL_MEM_WRITE_ONLY :: 1 << 1;
CL_MEM_READ_ONLY :: 1 << 2;
CL_MEM_USE_HOST_PTR :: 1 << 3;
CL_MEM_ALLOC_HOST_PTR :: 1 << 4;
CL_MEM_COPY_HOST_PTR :: 1 << 5;

CL_R :: 0x10B0;
CL_A :: 0x10B1;
CL_RG :: 0x10B2;
CL_RA :: 0x10B3;
CL_RGB :: 0x10B4;
CL_RGBA :: 0x10B5;
CL_BGRA :: 0x10B6;
CL_ARGB :: 0x10B7;
CL_INTENSITY :: 0x10B8;
CL_LUMINANCE :: 0x10B9;
CL_Rx :: 0x10BA;
CL_RGx :: 0x10BB;
CL_RGBx :: 0x10BC;

CL_SNORM_INT8 :: 0x10D0;
CL_SNORM_INT16 :: 0x10D1;
CL_UNORM_INT8 :: 0x10D2;
CL_UNORM_INT16 :: 0x10D3;
CL_UNORM_SHORT_565 :: 0x10D4;
CL_UNORM_SHORT_555 :: 0x10D5;
CL_UNORM_INT_101010 :: 0x10D6;
CL_SIGNED_INT8 :: 0x10D7;
CL_SIGNED_INT16 :: 0x10D8;
CL_SIGNED_INT32 :: 0x10D9;
CL_UNSIGNED_INT8 :: 0x10DA;
CL_UNSIGNED_INT16 :: 0x10DB;
CL_UNSIGNED_INT32 :: 0x10DC;
CL_HALF_FLOAT :: 0x10DD;
CL_FLOAT :: 0x10DE;

CL_MEM_OBJECT_BUFFER :: 0x10F0;
CL_MEM_OBJECT_IMAGE2D :: 0x10F1;
CL_MEM_OBJECT_IMAGE3D :: 0x10F2;

CL_MEM_TYPE :: 0x1100;
CL_MEM_FLAGS :: 0x1101;
CL_MEM_SIZE :: 0x1102;
CL_MEM_HOST_PTR :: 0x1103;
CL_MEM_MAP_COUNT :: 0x1104;
CL_MEM_REFERENCE_COUNT :: 0x1105;
CL_MEM_CONTEXT :: 0x1106;
CL_MEM_ASSOCIATED_MEMOBJECT :: 0x1107;
CL_MEM_OFFSET :: 0x1108;

CL_IMAGE_FORMAT :: 0x1110;
CL_IMAGE_ELEMENT_SIZE :: 0x1111;
CL_IMAGE_ROW_PITCH :: 0x1112;
CL_IMAGE_SLICE_PITCH :: 0x1113;
CL_IMAGE_WIDTH :: 0x1114;
CL_IMAGE_HEIGHT :: 0x1115;
CL_IMAGE_DEPTH :: 0x1116;

CL_ADDRESS_NONE :: 0x1130;
CL_ADDRESS_CLAMP_TO_EDGE :: 0x1131;
CL_ADDRESS_CLAMP :: 0x1132;
CL_ADDRESS_REPEAT :: 0x1133;
CL_ADDRESS_MIRRORED_REPEAT :: 0x1134;

CL_FILTER_NEAREST :: 0x1140;
CL_FILTER_LINEAR :: 0x1141;

CL_SAMPLER_REFERENCE_COUNT :: 0x1150;
CL_SAMPLER_CONTEXT :: 0x1151;
CL_SAMPLER_NORMALIZED_COORDS :: 0x1152;
CL_SAMPLER_ADDRESSING_MODE :: 0x1153;
CL_SAMPLER_FILTER_MODE :: 0x1154;

CL_MAP_READ :: 1 << 0;
CL_MAP_WRITE :: 1 << 1;

CL_PROGRAM_REFERENCE_COUNT :: 0x1160;
CL_PROGRAM_CONTEXT :: 0x1161;
CL_PROGRAM_NUM_DEVICES :: 0x1162;
CL_PROGRAM_DEVICES :: 0x1163;
CL_PROGRAM_SOURCE :: 0x1164;
CL_PROGRAM_BINARY_SIZES :: 0x1165;
CL_PROGRAM_BINARIES :: 0x1166;

CL_PROGRAM_BUILD_STATUS :: 0x1181;
CL_PROGRAM_BUILD_OPTIONS :: 0x1182;
CL_PROGRAM_BUILD_LOG :: 0x1183;

CL_BUILD_SUCCESS :: 0;
CL_BUILD_NONE :: -1;
CL_BUILD_ERROR :: -2;
CL_BUILD_IN_PROGRESS :: -3;

CL_KERNEL_FUNCTION_NAME :: 0x1190;
CL_KERNEL_NUM_ARGS :: 0x1191;
CL_KERNEL_REFERENCE_COUNT :: 0x1192;
CL_KERNEL_CONTEXT :: 0x1193;
CL_KERNEL_PROGRAM :: 0x1194;

CL_KERNEL_WORK_GROUP_SIZE :: 0x11B0;
CL_KERNEL_COMPILE_WORK_GROUP_SIZE :: 0x11B1;
CL_KERNEL_LOCAL_MEM_SIZE :: 0x11B2;
CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE :: 0x11B3;
CL_KERNEL_PRIVATE_MEM_SIZE :: 0x11B4;

CL_EVENT_COMMAND_QUEUE :: 0x11D0;
CL_EVENT_COMMAND_TYPE :: 0x11D1;
CL_EVENT_REFERENCE_COUNT :: 0x11D2;
CL_EVENT_COMMAND_EXECUTION_STATUS :: 0x11D3;
CL_EVENT_CONTEXT :: 0x11D4;

CL_COMMAND_NDRANGE_KERNEL :: 0x11F0;
CL_COMMAND_TASK :: 0x11F1;
CL_COMMAND_NATIVE_KERNEL :: 0x11F2;
CL_COMMAND_READ_BUFFER :: 0x11F3;
CL_COMMAND_WRITE_BUFFER :: 0x11F4;
CL_COMMAND_COPY_BUFFER :: 0x11F5;
CL_COMMAND_READ_IMAGE :: 0x11F6;
CL_COMMAND_WRITE_IMAGE :: 0x11F7;
CL_COMMAND_COPY_IMAGE :: 0x11F8;
CL_COMMAND_COPY_IMAGE_TO_BUFFER :: 0x11F9;
CL_COMMAND_COPY_BUFFER_TO_IMAGE :: 0x11FA;
CL_COMMAND_MAP_BUFFER :: 0x11FB;
CL_COMMAND_MAP_IMAGE :: 0x11FC;
CL_COMMAND_UNMAP_MEM_OBJECT :: 0x11FD;
CL_COMMAND_MARKER :: 0x11FE;
CL_COMMAND_ACQUIRE_GL_OBJECTS :: 0x11FF;
CL_COMMAND_RELEASE_GL_OBJECTS :: 0x1200;
CL_COMMAND_READ_BUFFER_RECT :: 0x1201;
CL_COMMAND_WRITE_BUFFER_RECT :: 0x1202;
CL_COMMAND_COPY_BUFFER_RECT :: 0x1203;
CL_COMMAND_USER :: 0x1204;

CL_COMPLETE :: 0x0;
CL_RUNNING :: 0x1;
CL_SUBMITTED :: 0x2;
CL_QUEUED :: 0x3;

CL_BUFFER_CREATE_TYPE_REGION :: 0x1220;

CL_PROFILING_COMMAND_QUEUED :: 0x1280;
CL_PROFILING_COMMAND_SUBMIT :: 0x1281;
CL_PROFILING_COMMAND_START :: 0x1282;
CL_PROFILING_COMMAND_END :: 0x1283;

CLEW_SUCCESS :: 0;
CLEW_ERROR_OPEN_FAILED :: -1;
CLEW_ERROR_ATEXIT_FAILED :: -2;

btVectorXu :: btVectorXf;
btMatrixXu :: btMatrixXf;

B3_DBVT_IMPL_GENERIC :: 0;
B3_DBVT_IMPL_SSE :: 1;

B3_DBVT_USE_TEMPLATE :: 1;

B3_DBVT_USE_INTRINSIC_SSE :: 1;

B3_DBVT_USE_MEMMOVE :: 1;

B3_DBVT_ENABLE_BENCHMARK :: 0;

B3_DBVT_SELECT_IMPL :: B3_DBVT_IMPL_GENERIC;
B3_DBVT_MERGE_IMPL :: B3_DBVT_IMPL_GENERIC;
B3_DBVT_INT0_IMPL :: B3_DBVT_IMPL_GENERIC;

B3_NEW_PAIR_MARKER :: -1;
B3_REMOVED_PAIR_MARKER :: -2;

B3_DBVT_BP_PROFILE :: 0;

B3_DBVT_BP_PREVENTFALSEUPDATE :: 0;
B3_DBVT_BP_ACCURATESLEEPING :: 0;
B3_DBVT_BP_ENABLE_BENCHMARK :: 0;
B3_DBVT_BP_MARGIN :: cast(b3Scalar)0.05;

b3Float4 :: b3Vector3;

b3Quat :: b3Quaternion;

b3Mat3x3 :: b3Matrix3x3;

b3SimdScalar :: b3Scalar;

B3_6DOF_FLAGS_AXIS_SHIFT :: 3;

b3Point2PointConstraintData :: b3Point2PointConstraintFloatData;
b3Point2PointConstraintDataName :: "b3Point2PointConstraintFloatData";

B3_SIZEOFBLENDERHEADER :: 12;

B3_HEADER_LENGTH :: 12;

NO_VIRTUAL_INTERFACE :: 1;

VORONOI_SIMPLEX_MAX_VERTS :: 5;

VORONOI_DEFAULT_EQUAL_VERTEX_THRESHOLD :: 0.0001;

btSimplexSolverInterface :: btVoronoiSimplexSolver;

TEST_INTERNAL_OBJECTS :: 1;

BOX_PLANE_EPSILON :: 0.000001;

PLANEDIREPSILON :: 0.0000001;
PARALELENORMALS :: 0.000001;

MAX_TRI_CLIPPING :: 16;

NORMAL_CONTACT_AVERAGE :: 1;

CONTACT_DIFF_EPSILON :: 0.00001;

BT_DEFAULT_MAX_POOLS :: 16;

GIMPACT_VS_PLANE_COLLISION :: 1;

GREAL :: btScalar;

G_PI :: 3.14159265358979;
G_HALF_PI :: 1.5707963;

G_TWO_PI :: 6.28318530;

G_ROOT3 :: 1.73205;
G_ROOT2 :: 1.41421;
G_UINT_INFINITY :: 0xffffffff;

G_SIGN_BITMASK :: 0x80000000;

GIM_SIMD_MEMORY :: 1;

GIM_ARRAY_GROW_INCREMENT :: 2;
GIM_ARRAY_GROW_FACTOR :: 2;

GUINT_BIT_COUNT :: 32;
GUINT_EXPONENT :: 5;

kHist :: 2048;

GIM_INVALID_HASH :: 0xffffffff;
GIM_DEFAULT_HASH_TABLE_SIZE :: 380;
GIM_DEFAULT_HASH_TABLE_NODE_SIZE :: 4;
GIM_HASH_TABLE_GROW_FACTOR :: 2;

GIM_MIN_RADIX_SORT_SIZE :: 860;

GIM_NUM_PRIME :: 28;

GJK_MAX_ITERATIONS :: 128;
GJK_ACCURARY :: cast(btScalar)0.0001;
GJK_MIN_DISTANCE :: cast(btScalar)0.0001;
GJK_DUPLICATED_EPS :: cast(btScalar)0.0001;
GJK_SIMPLEX2_EPS :: cast(btScalar)0.0;
GJK_SIMPLEX3_EPS :: cast(btScalar)0.0;
GJK_SIMPLEX4_EPS :: cast(btScalar)0.0;

EPA_MAX_VERTICES :: 64;
EPA_MAX_FACES :: EPA_MAX_VERTICES * 2;
EPA_MAX_ITERATIONS :: 255;
EPA_ACCURACY :: cast(btScalar)0.0001;
EPA_FALLBACK :: 10 * EPA_ACCURACY;
EPA_PLANE_EPS :: cast(btScalar)0.00001;
EPA_INSIDE_EPS :: cast(btScalar)0.01;

MAX_CONVEX_CAST_ITERATIONS :: 32;
MAX_CONVEX_CAST_EPSILON :: 0.0001;

BT_MPR_TOLERANCE :: 0.000001;
BT_MPR_MAX_ITERATIONS :: 1000;

B3_MAX_NUM_PARTS_IN_BITS :: 10;

B3_MAX_VERTS :: 1024;

B3_TRIANGLE_NUM_CONVEX_FACES :: 5;

B3_MPR_TOLERANCE :: 0.000001;
B3_MPR_MAX_ITERATIONS :: 1000;

btScalar :: float;

btInfMaskConverter :: struct {
    union {
        mask:    float;
        intmask: s32;
    }
}

///rudimentary class to provide type info
btTypedObject :: struct {
    Constructor :: (this: *btTypedObject, objectType: s32) -> void #cpp_method #foreign bullet3 "??0btTypedObject@@QEAA@H@Z";

    m_objectType: s32;
    getObjectType :: (this: *btTypedObject) -> s32 #cpp_method #foreign bullet3 "?getObjectType@btTypedObject@@QEBAHXZ";
}

size_type :: s32;

btAlignedAllocFunc :: #type (size: size_t, alignment: s32) -> *void #c_call;
btAlignedFreeFunc :: #type (memblock: *void) -> void #c_call;
btAllocFunc :: #type (size: size_t) -> *void #c_call;
btFreeFunc :: #type (memblock: *void) -> void #c_call;

///The btAlignedAllocator is a portable class for aligned memory allocations.
///Default implementations for unaligned and aligned allocations can be overridden by a custom allocator using btAlignedAllocSetCustom and btAlignedAllocSetCustomAligned.
btAlignedAllocator :: struct(T: Type, Alignment: u32) {
    self_type :: btAlignedAllocator(T, UnknownTemplateArgumentPlaceholder);

    const_pointer :: *T;
    const_reference :: *T;
    pointer :: *T;
    reference :: *T;
    value_type :: T;

    rebind :: struct(O: Type) {
        other :: btAlignedAllocator(O, UnknownTemplateArgumentPlaceholder);
    }
}

/**@brief btVector3 can be used to represent 3D points and vectors.
* It has an un-used w component to suit 16-byte alignment when btVector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
* Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
*/
btVector3 :: struct {
    m_floats: [4] btScalar;

    /**@brief No initialization constructor */
    Constructor :: (this: *btVector3) -> void #cpp_method #foreign bullet3 "??0btVector3@@QEAA@XZ";

    /**@brief Constructor from scalars 
    * @param x X value
    * @param y Y value 
    * @param z Z value 
    */
    Constructor :: (this: *btVector3, _x: *btScalar, _y: *btScalar, _z: *btScalar) -> void #cpp_method #foreign bullet3 "??0btVector3@@QEAA@AEBM00@Z";
    Constructor :: (this: *btVector3, _x: btScalar, _y: btScalar, _z: btScalar) #no_context {
        Constructor(this, *_x, *_y, *_z);
    }

    /**@brief Return the dot product
    * @param v The other vector in the dot product */
    dot :: (this: *btVector3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?dot@btVector3@@QEBAMAEBV1@@Z";
    dot :: (this: *btVector3, v: btVector3) -> btScalar #no_context {
        return dot(this, *v);
    }

    /**@brief Return the length of the vector squared */
    length2 :: (this: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?length2@btVector3@@QEBAMXZ";

    /**@brief Return the length of the vector */
    length :: (this: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?length@btVector3@@QEBAMXZ";

    /**@brief Return the norm (length) of the vector */
    norm :: (this: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?norm@btVector3@@QEBAMXZ";

    /**@brief Return the norm (length) of the vector */
    safeNorm :: (this: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?safeNorm@btVector3@@QEBAMXZ";

    /**@brief Return the distance squared between the ends of this and another vector
    * This is symantically treating the vector like a point */
    distance2 :: (this: *btVector3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?distance2@btVector3@@QEBAMAEBV1@@Z";
    distance2 :: (this: *btVector3, v: btVector3) -> btScalar #no_context {
        return distance2(this, *v);
    }

    /**@brief Return the distance between the ends of this and another vector
    * This is symantically treating the vector like a point */
    distance :: (this: *btVector3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?distance@btVector3@@QEBAMAEBV1@@Z";
    distance :: (this: *btVector3, v: btVector3) -> btScalar #no_context {
        return distance(this, *v);
    }

    safeNormalize :: (this: *btVector3) -> *btVector3 #cpp_method #foreign bullet3 "?safeNormalize@btVector3@@QEAAAEAV1@XZ";

    /**@brief Normalize this vector 
    * x^2 + y^2 + z^2 = 1 */
    normalize :: (this: *btVector3) -> *btVector3 #cpp_method #foreign bullet3 "?normalize@btVector3@@QEAAAEAV1@XZ";

    /**@brief Return a normalized version of this vector */
    normalized :: (this: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?normalized@btVector3@@QEBA?AV1@XZ";

    /**@brief Return a rotated version of this vector
    * @param wAxis The axis to rotate about 
    * @param angle The angle to rotate by */
    rotate :: (this: *btVector3, wAxis: *btVector3, angle: btScalar) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?rotate@btVector3@@QEBA?AV1@AEBV1@M@Z";
    rotate :: (this: *btVector3, wAxis: btVector3, angle: btScalar) -> btVector3 #no_context {
        return rotate(this, *wAxis, angle);
    }

    /**@brief Return the angle between this and another vector
    * @param v The other vector */
    angle :: (this: *btVector3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?angle@btVector3@@QEBAMAEBV1@@Z";
    angle :: (this: *btVector3, v: btVector3) -> btScalar #no_context {
        return angle(this, *v);
    }

    /**@brief Return a vector with the absolute values of each element */
    absolute :: (this: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?absolute@btVector3@@QEBA?AV1@XZ";

    /**@brief Return the cross product between this and another vector 
    * @param v The other vector */
    cross :: (this: *btVector3, v: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?cross@btVector3@@QEBA?AV1@AEBV1@@Z";
    cross :: (this: *btVector3, v: btVector3) -> btVector3 #no_context {
        return cross(this, *v);
    }

    triple :: (this: *btVector3, v1: *btVector3, v2: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?triple@btVector3@@QEBAMAEBV1@0@Z";
    triple :: (this: *btVector3, v1: btVector3, v2: btVector3) -> btScalar #no_context {
        return triple(this, *v1, *v2);
    }

    /**@brief Return the axis with the smallest value 
    * Note return values are 0,1,2 for x, y, or z */
    minAxis :: (this: *btVector3) -> s32 #cpp_method #foreign bullet3 "?minAxis@btVector3@@QEBAHXZ";

    /**@brief Return the axis with the largest value 
    * Note return values are 0,1,2 for x, y, or z */
    maxAxis :: (this: *btVector3) -> s32 #cpp_method #foreign bullet3 "?maxAxis@btVector3@@QEBAHXZ";

    furthestAxis :: (this: *btVector3) -> s32 #cpp_method #foreign bullet3 "?furthestAxis@btVector3@@QEBAHXZ";

    closestAxis :: (this: *btVector3) -> s32 #cpp_method #foreign bullet3 "?closestAxis@btVector3@@QEBAHXZ";

    setInterpolate3 :: (this: *btVector3, v0: *btVector3, v1: *btVector3, rt: btScalar) -> void #cpp_method #foreign bullet3 "?setInterpolate3@btVector3@@QEAAXAEBV1@0M@Z";
    setInterpolate3 :: (this: *btVector3, v0: btVector3, v1: btVector3, rt: btScalar) #no_context {
        setInterpolate3(this, *v0, *v1, rt);
    }

    /**@brief Return the linear interpolation between this and another vector 
    * @param v The other vector 
    * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
    lerp :: (this: *btVector3, v: *btVector3, t: *btScalar) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?lerp@btVector3@@QEBA?AV1@AEBV1@AEBM@Z";
    lerp :: (this: *btVector3, v: btVector3, t: btScalar) -> btVector3 #no_context {
        return lerp(this, *v, *t);
    }

    /**@brief Return the x value */
    getX :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?getX@btVector3@@QEBAAEBMXZ";

    /**@brief Return the y value */
    getY :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?getY@btVector3@@QEBAAEBMXZ";

    /**@brief Return the z value */
    getZ :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?getZ@btVector3@@QEBAAEBMXZ";

    /**@brief Set the x value */
    setX :: (this: *btVector3, _x: btScalar) -> void #cpp_method #foreign bullet3 "?setX@btVector3@@QEAAXM@Z";

    /**@brief Set the y value */
    setY :: (this: *btVector3, _y: btScalar) -> void #cpp_method #foreign bullet3 "?setY@btVector3@@QEAAXM@Z";

    /**@brief Set the z value */
    setZ :: (this: *btVector3, _z: btScalar) -> void #cpp_method #foreign bullet3 "?setZ@btVector3@@QEAAXM@Z";

    /**@brief Set the w value */
    setW :: (this: *btVector3, _w: btScalar) -> void #cpp_method #foreign bullet3 "?setW@btVector3@@QEAAXM@Z";

    /**@brief Return the x value */
    x :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?x@btVector3@@QEBAAEBMXZ";

    /**@brief Return the y value */
    y :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?y@btVector3@@QEBAAEBMXZ";

    /**@brief Return the z value */
    z :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?z@btVector3@@QEBAAEBMXZ";

    /**@brief Return the w value */
    w :: (this: *btVector3) -> *btScalar #cpp_method #foreign bullet3 "?w@btVector3@@QEBAAEBMXZ";

    /**@brief Set each element to the max of the current values and the values of another btVector3
    * @param other The other btVector3 to compare with 
    */
    setMax :: (this: *btVector3, other: *btVector3) -> void #cpp_method #foreign bullet3 "?setMax@btVector3@@QEAAXAEBV1@@Z";
    setMax :: (this: *btVector3, other: btVector3) #no_context {
        setMax(this, *other);
    }

    /**@brief Set each element to the min of the current values and the values of another btVector3
    * @param other The other btVector3 to compare with 
    */
    setMin :: (this: *btVector3, other: *btVector3) -> void #cpp_method #foreign bullet3 "?setMin@btVector3@@QEAAXAEBV1@@Z";
    setMin :: (this: *btVector3, other: btVector3) #no_context {
        setMin(this, *other);
    }

    setValue :: (this: *btVector3, _x: *btScalar, _y: *btScalar, _z: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btVector3@@QEAAXAEBM00@Z";
    setValue :: (this: *btVector3, _x: btScalar, _y: btScalar, _z: btScalar) #no_context {
        setValue(this, *_x, *_y, *_z);
    }

    getSkewSymmetricMatrix :: (this: *btVector3, v0: *btVector3, v1: *btVector3, v2: *btVector3) -> void #cpp_method #foreign bullet3 "?getSkewSymmetricMatrix@btVector3@@QEBAXPEAV1@00@Z";

    setZero :: (this: *btVector3) -> void #cpp_method #foreign bullet3 "?setZero@btVector3@@QEAAXXZ";

    isZero :: (this: *btVector3) -> bool #cpp_method #foreign bullet3 "?isZero@btVector3@@QEBA_NXZ";

    fuzzyZero :: (this: *btVector3) -> bool #cpp_method #foreign bullet3 "?fuzzyZero@btVector3@@QEBA_NXZ";

    serialize :: (this: *btVector3, dataOut: *btVector3FloatData) -> void #cpp_method #foreign bullet3 "?serialize@btVector3@@QEBAXAEAUbtVector3FloatData@@@Z";

    deSerialize :: (this: *btVector3, dataIn: *btVector3DoubleData) -> void #cpp_method #foreign bullet3 "?deSerialize@btVector3@@QEAAXAEBUbtVector3DoubleData@@@Z";
    deSerialize :: (this: *btVector3, dataIn: btVector3DoubleData) #no_context {
        deSerialize(this, *dataIn);
    }

    deSerialize :: (this: *btVector3, dataIn: *btVector3FloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@btVector3@@QEAAXAEBUbtVector3FloatData@@@Z";
    deSerialize :: (this: *btVector3, dataIn: btVector3FloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    serializeFloat :: (this: *btVector3, dataOut: *btVector3FloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@btVector3@@QEBAXAEAUbtVector3FloatData@@@Z";

    deSerializeFloat :: (this: *btVector3, dataIn: *btVector3FloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@btVector3@@QEAAXAEBUbtVector3FloatData@@@Z";
    deSerializeFloat :: (this: *btVector3, dataIn: btVector3FloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }

    serializeDouble :: (this: *btVector3, dataOut: *btVector3DoubleData) -> void #cpp_method #foreign bullet3 "?serializeDouble@btVector3@@QEBAXAEAUbtVector3DoubleData@@@Z";

    deSerializeDouble :: (this: *btVector3, dataIn: *btVector3DoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@btVector3@@QEAAXAEBUbtVector3DoubleData@@@Z";
    deSerializeDouble :: (this: *btVector3, dataIn: btVector3DoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }

    /**@brief returns index of maximum dot product between this and vectors in array[]
    * @param array The other vectors 
    * @param array_count The number of other vectors 
    * @param dotOut The maximum dot product */
    maxDot :: (this: *btVector3, array: *btVector3, array_count: s32, dotOut: *btScalar) -> s32 #cpp_method #foreign bullet3 "?maxDot@btVector3@@QEBAJPEBV1@JAEAM@Z";

    /**@brief returns index of minimum dot product between this and vectors in array[]
    * @param array The other vectors 
    * @param array_count The number of other vectors 
    * @param dotOut The minimum dot product */
    minDot :: (this: *btVector3, array: *btVector3, array_count: s32, dotOut: *btScalar) -> s32 #cpp_method #foreign bullet3 "?minDot@btVector3@@QEBAJPEBV1@JAEAM@Z";

    /* create a vector as  btVector3( this->dot( btVector3 v0 ), this->dot( btVector3 v1), this->dot( btVector3 v2 ))  */
    dot3 :: (this: *btVector3, v0: *btVector3, v1: *btVector3, v2: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?dot3@btVector3@@QEBA?AV1@AEBV1@00@Z";
    dot3 :: (this: *btVector3, v0: btVector3, v1: btVector3, v2: btVector3) -> btVector3 #no_context {
        return dot3(this, *v0, *v1, *v2);
    }
}

/**@brief Add a vector to this one 
* @param The vector to add to this one */
operator+= :: (this: *btVector3, v: *btVector3) -> *btVector3 #cpp_method #foreign bullet3 "??YbtVector3@@QEAAAEAV0@AEBV0@@Z";
operator+= :: (this: *btVector3, v: btVector3) -> *btVector3 #no_context {
    return operator+=(this, *v);
}

/**@brief Subtract a vector from this one
* @param The vector to subtract */
operator-= :: (this: *btVector3, v: *btVector3) -> *btVector3 #cpp_method #foreign bullet3 "??ZbtVector3@@QEAAAEAV0@AEBV0@@Z";
operator-= :: (this: *btVector3, v: btVector3) -> *btVector3 #no_context {
    return operator-=(this, *v);
}

/**@brief Scale the vector
* @param s Scale factor */
operator*= :: (this: *btVector3, s: *btScalar) -> *btVector3 #cpp_method #foreign bullet3 "??XbtVector3@@QEAAAEAV0@AEBM@Z";
operator*= :: (this: *btVector3, s: btScalar) -> *btVector3 #no_context {
    return operator*=(this, *s);
}

/**@brief Inversely scale the vector 
* @param s Scale factor to divide by */
operator/= :: (this: *btVector3, s: *btScalar) -> *btVector3 #cpp_method #foreign bullet3 "??_0btVector3@@QEAAAEAV0@AEBM@Z";
operator/= :: (this: *btVector3, s: btScalar) -> *btVector3 #no_context {
    return operator/=(this, *s);
}

/**@brief Elementwise multiply this vector by the other 
* @param v The other vector */
operator*= :: (this: *btVector3, v: *btVector3) -> *btVector3 #cpp_method #foreign bullet3 "??XbtVector3@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *btVector3, v: btVector3) -> *btVector3 #no_context {
    return operator*=(this, *v);
}

operator== :: (this: *btVector3, other: *btVector3) -> bool #cpp_method #foreign bullet3 "??8btVector3@@QEBA_NAEBV0@@Z";
operator== :: (this: btVector3, other: btVector3) -> bool #no_context {
    return operator==(*this, *other);
}

operator!= :: (this: *btVector3, other: *btVector3) -> bool #cpp_method #foreign bullet3 "??9btVector3@@QEBA_NAEBV0@@Z";
operator!= :: (this: btVector3, other: btVector3) -> bool #no_context {
    return operator!=(*this, *other);
}

btVector4 :: struct {
    #as using btvector3: btVector3;

    Constructor :: (this: *btVector4) -> void #cpp_method #foreign bullet3 "??0btVector4@@QEAA@XZ";

    Constructor :: (this: *btVector4, _x: *btScalar, _y: *btScalar, _z: *btScalar, _w: *btScalar) -> void #cpp_method #foreign bullet3 "??0btVector4@@QEAA@AEBM000@Z";
    Constructor :: (this: *btVector4, _x: btScalar, _y: btScalar, _z: btScalar, _w: btScalar) #no_context {
        Constructor(this, *_x, *_y, *_z, *_w);
    }

    absolute4 :: (this: *btVector4) -> btVector4 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?absolute4@btVector4@@QEBA?AV1@XZ";

    getW :: (this: *btVector4) -> btScalar #cpp_method #foreign bullet3 "?getW@btVector4@@QEBAMXZ";

    maxAxis4 :: (this: *btVector4) -> s32 #cpp_method #foreign bullet3 "?maxAxis4@btVector4@@QEBAHXZ";

    minAxis4 :: (this: *btVector4) -> s32 #cpp_method #foreign bullet3 "?minAxis4@btVector4@@QEBAHXZ";

    closestAxis4 :: (this: *btVector4) -> s32 #cpp_method #foreign bullet3 "?closestAxis4@btVector4@@QEBAHXZ";

    /*		void getValue(btScalar *m) const 
    {
    m[0] = m_floats[0];
    m[1] = m_floats[1];
    m[2] =m_floats[2];
    }
    */
    /**@brief Set the values 
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    * @param w Value of w
    */
    setValue :: (this: *btVector4, _x: *btScalar, _y: *btScalar, _z: *btScalar, _w: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btVector4@@QEAAXAEBM000@Z";
    setValue :: (this: *btVector4, _x: btScalar, _y: btScalar, _z: btScalar, _w: btScalar) #no_context {
        setValue(this, *_x, *_y, *_z, *_w);
    }
}

btVector3FloatData :: struct {
    m_floats: [4] float;
}

btVector3DoubleData :: struct {
    m_floats: [4] float64;
}

btQuadWord :: struct {
    m_floats: [4] btScalar;

    /**@brief Return the x value */
    getX :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?getX@btQuadWord@@QEBAAEBMXZ";

    /**@brief Return the y value */
    getY :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?getY@btQuadWord@@QEBAAEBMXZ";

    /**@brief Return the z value */
    getZ :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?getZ@btQuadWord@@QEBAAEBMXZ";

    /**@brief Set the x value */
    setX :: (this: *btQuadWord, _x: btScalar) -> void #cpp_method #foreign bullet3 "?setX@btQuadWord@@QEAAXM@Z";

    /**@brief Set the y value */
    setY :: (this: *btQuadWord, _y: btScalar) -> void #cpp_method #foreign bullet3 "?setY@btQuadWord@@QEAAXM@Z";

    /**@brief Set the z value */
    setZ :: (this: *btQuadWord, _z: btScalar) -> void #cpp_method #foreign bullet3 "?setZ@btQuadWord@@QEAAXM@Z";

    /**@brief Set the w value */
    setW :: (this: *btQuadWord, _w: btScalar) -> void #cpp_method #foreign bullet3 "?setW@btQuadWord@@QEAAXM@Z";

    /**@brief Return the x value */
    x :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?x@btQuadWord@@QEBAAEBMXZ";

    /**@brief Return the y value */
    y :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?y@btQuadWord@@QEBAAEBMXZ";

    /**@brief Return the z value */
    z :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?z@btQuadWord@@QEBAAEBMXZ";

    /**@brief Return the w value */
    w :: (this: *btQuadWord) -> *btScalar #cpp_method #foreign bullet3 "?w@btQuadWord@@QEBAAEBMXZ";

    /**@brief Set x,y,z and zero w 
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    */
    setValue :: (this: *btQuadWord, _x: *btScalar, _y: *btScalar, _z: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btQuadWord@@QEAAXAEBM00@Z";
    setValue :: (this: *btQuadWord, _x: btScalar, _y: btScalar, _z: btScalar) #no_context {
        setValue(this, *_x, *_y, *_z);
    }

    /*		void getValue(btScalar *m) const 
    {
    m[0] = m_floats[0];
    m[1] = m_floats[1];
    m[2] = m_floats[2];
    }
    */
    /**@brief Set the values 
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    * @param w Value of w
    */
    setValue :: (this: *btQuadWord, _x: *btScalar, _y: *btScalar, _z: *btScalar, _w: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btQuadWord@@QEAAXAEBM000@Z";
    setValue :: (this: *btQuadWord, _x: btScalar, _y: btScalar, _z: btScalar, _w: btScalar) #no_context {
        setValue(this, *_x, *_y, *_z, *_w);
    }

    /**@brief No initialization constructor */
    Constructor :: (this: *btQuadWord) -> void #cpp_method #foreign bullet3 "??0btQuadWord@@QEAA@XZ";

    /**@brief Three argument constructor (zeros w)
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    */
    Constructor :: (this: *btQuadWord, _x: *btScalar, _y: *btScalar, _z: *btScalar) -> void #cpp_method #foreign bullet3 "??0btQuadWord@@QEAA@AEBM00@Z";
    Constructor :: (this: *btQuadWord, _x: btScalar, _y: btScalar, _z: btScalar) #no_context {
        Constructor(this, *_x, *_y, *_z);
    }

    /**@brief Initializing constructor
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    * @param w Value of w
    */
    Constructor :: (this: *btQuadWord, _x: *btScalar, _y: *btScalar, _z: *btScalar, _w: *btScalar) -> void #cpp_method #foreign bullet3 "??0btQuadWord@@QEAA@AEBM000@Z";
    Constructor :: (this: *btQuadWord, _x: btScalar, _y: btScalar, _z: btScalar, _w: btScalar) #no_context {
        Constructor(this, *_x, *_y, *_z, *_w);
    }

    /**@brief Set each element to the max of the current values and the values of another btQuadWord
    * @param other The other btQuadWord to compare with 
    */
    setMax :: (this: *btQuadWord, other: *btQuadWord) -> void #cpp_method #foreign bullet3 "?setMax@btQuadWord@@QEAAXAEBV1@@Z";
    setMax :: (this: *btQuadWord, other: btQuadWord) #no_context {
        setMax(this, *other);
    }

    /**@brief Set each element to the min of the current values and the values of another btQuadWord
    * @param other The other btQuadWord to compare with 
    */
    setMin :: (this: *btQuadWord, other: *btQuadWord) -> void #cpp_method #foreign bullet3 "?setMin@btQuadWord@@QEAAXAEBV1@@Z";
    setMin :: (this: *btQuadWord, other: btQuadWord) #no_context {
        setMin(this, *other);
    }
}

operator== :: (this: *btQuadWord, other: *btQuadWord) -> bool #cpp_method #foreign bullet3 "??8btQuadWord@@QEBA_NAEBV0@@Z";
operator== :: (this: btQuadWord, other: btQuadWord) -> bool #no_context {
    return operator==(*this, *other);
}

operator!= :: (this: *btQuadWord, other: *btQuadWord) -> bool #cpp_method #foreign bullet3 "??9btQuadWord@@QEBA_NAEBV0@@Z";
operator!= :: (this: btQuadWord, other: btQuadWord) -> bool #no_context {
    return operator!=(*this, *other);
}

/**@brief The btQuaternion implements quaternion to perform linear algebra rotations in combination with btMatrix3x3, btVector3 and btTransform. */
btQuaternion :: struct {
    #as using btquadword: btQuadWord;

    /**@brief No initialization constructor */
    Constructor :: (this: *btQuaternion) -> void #cpp_method #foreign bullet3 "??0btQuaternion@@QEAA@XZ";

    //		template <typename btScalar>
    //		explicit Quaternion(const btScalar *v) : Tuple4<btScalar>(v) {}
    /**@brief Constructor from scalars */
    Constructor :: (this: *btQuaternion, _x: *btScalar, _y: *btScalar, _z: *btScalar, _w: *btScalar) -> void #cpp_method #foreign bullet3 "??0btQuaternion@@QEAA@AEBM000@Z";
    Constructor :: (this: *btQuaternion, _x: btScalar, _y: btScalar, _z: btScalar, _w: btScalar) #no_context {
        Constructor(this, *_x, *_y, *_z, *_w);
    }

    /**@brief Axis angle Constructor
    * @param axis The axis which the rotation is around
    * @param angle The magnitude of the rotation around the angle (Radians) */
    Constructor :: (this: *btQuaternion, _axis: *btVector3, _angle: *btScalar) -> void #cpp_method #foreign bullet3 "??0btQuaternion@@QEAA@AEBVbtVector3@@AEBM@Z";
    Constructor :: (this: *btQuaternion, _axis: btVector3, _angle: btScalar) #no_context {
        Constructor(this, *_axis, *_angle);
    }

    /**@brief Constructor from Euler angles
    * @param yaw Angle around Y unless BT_EULER_DEFAULT_ZYX defined then Z
    * @param pitch Angle around X unless BT_EULER_DEFAULT_ZYX defined then Y
    * @param roll Angle around Z unless BT_EULER_DEFAULT_ZYX defined then X */
    Constructor :: (this: *btQuaternion, yaw: *btScalar, pitch: *btScalar, roll: *btScalar) -> void #cpp_method #foreign bullet3 "??0btQuaternion@@QEAA@AEBM00@Z";
    Constructor :: (this: *btQuaternion, yaw: btScalar, pitch: btScalar, roll: btScalar) #no_context {
        Constructor(this, *yaw, *pitch, *roll);
    }

    /**@brief Set the rotation using axis angle notation 
    * @param axis The axis around which to rotate
    * @param angle The magnitude of the rotation in Radians */
    setRotation :: (this: *btQuaternion, axis: *btVector3, _angle: *btScalar) -> void #cpp_method #foreign bullet3 "?setRotation@btQuaternion@@QEAAXAEBVbtVector3@@AEBM@Z";
    setRotation :: (this: *btQuaternion, axis: btVector3, _angle: btScalar) #no_context {
        setRotation(this, *axis, *_angle);
    }

    /**@brief Set the quaternion using Euler angles
    * @param yaw Angle around Y
    * @param pitch Angle around X
    * @param roll Angle around Z */
    setEuler :: (this: *btQuaternion, yaw: *btScalar, pitch: *btScalar, roll: *btScalar) -> void #cpp_method #foreign bullet3 "?setEuler@btQuaternion@@QEAAXAEBM00@Z";
    setEuler :: (this: *btQuaternion, yaw: btScalar, pitch: btScalar, roll: btScalar) #no_context {
        setEuler(this, *yaw, *pitch, *roll);
    }

    /**@brief Set the quaternion using euler angles 
    * @param yaw Angle around Z
    * @param pitch Angle around Y
    * @param roll Angle around X */
    setEulerZYX :: (this: *btQuaternion, yawZ: *btScalar, pitchY: *btScalar, rollX: *btScalar) -> void #cpp_method #foreign bullet3 "?setEulerZYX@btQuaternion@@QEAAXAEBM00@Z";
    setEulerZYX :: (this: *btQuaternion, yawZ: btScalar, pitchY: btScalar, rollX: btScalar) #no_context {
        setEulerZYX(this, *yawZ, *pitchY, *rollX);
    }

    /**@brief Get the euler angles from this quaternion
    * @param yaw Angle around Z
    * @param pitch Angle around Y
    * @param roll Angle around X */
    getEulerZYX :: (this: *btQuaternion, yawZ: *btScalar, pitchY: *btScalar, rollX: *btScalar) -> void #cpp_method #foreign bullet3 "?getEulerZYX@btQuaternion@@QEBAXAEAM00@Z";

    /**@brief Return the dot product between this quaternion and another
    * @param q The other quaternion */
    dot :: (this: *btQuaternion, q: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?dot@btQuaternion@@QEBAMAEBV1@@Z";
    dot :: (this: *btQuaternion, q: btQuaternion) -> btScalar #no_context {
        return dot(this, *q);
    }

    /**@brief Return the length squared of the quaternion */
    length2 :: (this: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?length2@btQuaternion@@QEBAMXZ";

    /**@brief Return the length of the quaternion */
    length :: (this: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?length@btQuaternion@@QEBAMXZ";

    safeNormalize :: (this: *btQuaternion) -> *btQuaternion #cpp_method #foreign bullet3 "?safeNormalize@btQuaternion@@QEAAAEAV1@XZ";

    /**@brief Normalize the quaternion 
    * Such that x^2 + y^2 + z^2 +w^2 = 1 */
    normalize :: (this: *btQuaternion) -> *btQuaternion #cpp_method #foreign bullet3 "?normalize@btQuaternion@@QEAAAEAV1@XZ";

    /**@brief Return a normalized version of this quaternion */
    normalized :: (this: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?normalized@btQuaternion@@QEBA?AV1@XZ";

    /**@brief Return the ***half*** angle between this quaternion and the other
    * @param q The other quaternion */
    angle :: (this: *btQuaternion, q: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?angle@btQuaternion@@QEBAMAEBV1@@Z";
    angle :: (this: *btQuaternion, q: btQuaternion) -> btScalar #no_context {
        return angle(this, *q);
    }

    /**@brief Return the angle between this quaternion and the other along the shortest path
    * @param q The other quaternion */
    angleShortestPath :: (this: *btQuaternion, q: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?angleShortestPath@btQuaternion@@QEBAMAEBV1@@Z";
    angleShortestPath :: (this: *btQuaternion, q: btQuaternion) -> btScalar #no_context {
        return angleShortestPath(this, *q);
    }

    /**@brief Return the angle [0, 2Pi] of rotation represented by this quaternion */
    getAngle :: (this: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?getAngle@btQuaternion@@QEBAMXZ";

    /**@brief Return the angle [0, Pi] of rotation represented by this quaternion along the shortest path */
    getAngleShortestPath :: (this: *btQuaternion) -> btScalar #cpp_method #foreign bullet3 "?getAngleShortestPath@btQuaternion@@QEBAMXZ";

    /**@brief Return the axis of the rotation represented by this quaternion */
    getAxis :: (this: *btQuaternion) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAxis@btQuaternion@@QEBA?AVbtVector3@@XZ";

    /**@brief Return the inverse of this quaternion */
    inverse :: (this: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverse@btQuaternion@@QEBA?AV1@XZ";

    /**@todo document this and it's use */
    farthest :: (this: *btQuaternion, qd: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?farthest@btQuaternion@@QEBA?AV1@AEBV1@@Z";
    farthest :: (this: *btQuaternion, qd: btQuaternion) -> btQuaternion #no_context {
        return farthest(this, *qd);
    }

    /**@todo document this and it's use */
    nearest :: (this: *btQuaternion, qd: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?nearest@btQuaternion@@QEBA?AV1@AEBV1@@Z";
    nearest :: (this: *btQuaternion, qd: btQuaternion) -> btQuaternion #no_context {
        return nearest(this, *qd);
    }

    /**@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
    * @param q The other quaternion to interpolate with 
    * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
    * Slerp interpolates assuming constant velocity.  */
    slerp :: (this: *btQuaternion, q: *btQuaternion, t: *btScalar) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?slerp@btQuaternion@@QEBA?AV1@AEBV1@AEBM@Z";
    slerp :: (this: *btQuaternion, q: btQuaternion, t: btScalar) -> btQuaternion #no_context {
        return slerp(this, *q, *t);
    }

    getIdentity :: () -> *btQuaternion #foreign bullet3 "?getIdentity@btQuaternion@@SAAEBV1@XZ";

    getW :: (this: *btQuaternion) -> *btScalar #cpp_method #foreign bullet3 "?getW@btQuaternion@@QEBAAEBMXZ";

    serialize :: (this: *btQuaternion, dataOut: *btQuaternionFloatData) -> void #cpp_method #foreign bullet3 "?serialize@btQuaternion@@QEBAXAEAUbtQuaternionFloatData@@@Z";

    deSerialize :: (this: *btQuaternion, dataIn: *btQuaternionFloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@btQuaternion@@QEAAXAEBUbtQuaternionFloatData@@@Z";
    deSerialize :: (this: *btQuaternion, dataIn: btQuaternionFloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    deSerialize :: (this: *btQuaternion, dataIn: *btQuaternionDoubleData) -> void #cpp_method #foreign bullet3 "?deSerialize@btQuaternion@@QEAAXAEBUbtQuaternionDoubleData@@@Z";
    deSerialize :: (this: *btQuaternion, dataIn: btQuaternionDoubleData) #no_context {
        deSerialize(this, *dataIn);
    }

    serializeFloat :: (this: *btQuaternion, dataOut: *btQuaternionFloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@btQuaternion@@QEBAXAEAUbtQuaternionFloatData@@@Z";

    deSerializeFloat :: (this: *btQuaternion, dataIn: *btQuaternionFloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@btQuaternion@@QEAAXAEBUbtQuaternionFloatData@@@Z";
    deSerializeFloat :: (this: *btQuaternion, dataIn: btQuaternionFloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }

    serializeDouble :: (this: *btQuaternion, dataOut: *btQuaternionDoubleData) -> void #cpp_method #foreign bullet3 "?serializeDouble@btQuaternion@@QEBAXAEAUbtQuaternionDoubleData@@@Z";

    deSerializeDouble :: (this: *btQuaternion, dataIn: *btQuaternionDoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@btQuaternion@@QEAAXAEBUbtQuaternionDoubleData@@@Z";
    deSerializeDouble :: (this: *btQuaternion, dataIn: btQuaternionDoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }
}

/**@brief Add two quaternions
* @param q The quaternion to add to this one */
operator+= :: (this: *btQuaternion, q: *btQuaternion) -> *btQuaternion #cpp_method #foreign bullet3 "??YbtQuaternion@@QEAAAEAV0@AEBV0@@Z";
operator+= :: (this: *btQuaternion, q: btQuaternion) -> *btQuaternion #no_context {
    return operator+=(this, *q);
}

/**@brief Subtract out a quaternion
* @param q The quaternion to subtract from this one */
operator-= :: (this: *btQuaternion, q: *btQuaternion) -> *btQuaternion #cpp_method #foreign bullet3 "??ZbtQuaternion@@QEAAAEAV0@AEBV0@@Z";
operator-= :: (this: *btQuaternion, q: btQuaternion) -> *btQuaternion #no_context {
    return operator-=(this, *q);
}

/**@brief Scale this quaternion
* @param s The scalar to scale by */
operator*= :: (this: *btQuaternion, s: *btScalar) -> *btQuaternion #cpp_method #foreign bullet3 "??XbtQuaternion@@QEAAAEAV0@AEBM@Z";
operator*= :: (this: *btQuaternion, s: btScalar) -> *btQuaternion #no_context {
    return operator*=(this, *s);
}

/**@brief Multiply this quaternion by q on the right
* @param q The other quaternion 
* Equivilant to this = this * q */
operator*= :: (this: *btQuaternion, q: *btQuaternion) -> *btQuaternion #cpp_method #foreign bullet3 "??XbtQuaternion@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *btQuaternion, q: btQuaternion) -> *btQuaternion #no_context {
    return operator*=(this, *q);
}

/**@brief Return a scaled version of this quaternion
* @param s The scale factor */
operator* :: (this: *btQuaternion, s: *btScalar) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtQuaternion@@QEBA?AV0@AEBM@Z";
operator* :: (this: btQuaternion, s: btScalar) -> btQuaternion #no_context {
    return operator*(*this, *s);
}

/**@brief Return an inversely scaled versionof this quaternion
* @param s The inverse scale factor */
operator/ :: (this: *btQuaternion, s: *btScalar) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??KbtQuaternion@@QEBA?AV0@AEBM@Z";
operator/ :: (this: btQuaternion, s: btScalar) -> btQuaternion #no_context {
    return operator/(*this, *s);
}

/**@brief Inversely scale this quaternion
* @param s The scale factor */
operator/= :: (this: *btQuaternion, s: *btScalar) -> *btQuaternion #cpp_method #foreign bullet3 "??_0btQuaternion@@QEAAAEAV0@AEBM@Z";
operator/= :: (this: *btQuaternion, s: btScalar) -> *btQuaternion #no_context {
    return operator/=(this, *s);
}

/**@brief Return the sum of this quaternion and the other 
* @param q2 The other quaternion */
operator+ :: (this: *btQuaternion, q2: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??HbtQuaternion@@QEBA?AV0@AEBV0@@Z";
operator+ :: (this: btQuaternion, q2: btQuaternion) -> btQuaternion #no_context {
    return operator+(*this, *q2);
}

/**@brief Return the difference between this quaternion and the other 
* @param q2 The other quaternion */
operator- :: (this: *btQuaternion, q2: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtQuaternion@@QEBA?AV0@AEBV0@@Z";
operator- :: (this: btQuaternion, q2: btQuaternion) -> btQuaternion #no_context {
    return operator-(*this, *q2);
}

/**@brief Return the negative of this quaternion 
* This simply negates each element */
operator- :: (this: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtQuaternion@@QEBA?AV0@XZ";
operator- :: (this: btQuaternion) -> btQuaternion #no_context {
    return operator-(*this);
}

btQuaternionFloatData :: struct {
    m_floats: [4] float;
}

btQuaternionDoubleData :: struct {
    m_floats: [4] float64;
}

/**@brief The btMatrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with btQuaternion, btTransform and btVector3.
* Make sure to only include a pure orthogonal matrix without scaling. */
btMatrix3x3 :: struct {
    ///Data storage for the matrix, each vector is a row of the matrix
    m_el: [3] btVector3;

    /** @brief No initializaion constructor */
    Constructor :: (this: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "??0btMatrix3x3@@QEAA@XZ";

    /**@brief Constructor from Quaternion */
    Constructor :: (this: *btMatrix3x3, q: *btQuaternion) -> void #cpp_method #foreign bullet3 "??0btMatrix3x3@@QEAA@AEBVbtQuaternion@@@Z";
    Constructor :: (this: *btMatrix3x3, q: btQuaternion) #no_context {
        Constructor(this, *q);
    }

    /*
    template <typename btScalar>
    Matrix3x3(const btScalar& yaw, const btScalar& pitch, const btScalar& roll)
    { 
    setEulerYPR(yaw, pitch, roll);
    }
    */
    /** @brief Constructor with row major formatting */
    Constructor :: (this: *btMatrix3x3, _xx: *btScalar, xy: *btScalar, xz: *btScalar, yx: *btScalar, yy: *btScalar, yz: *btScalar, zx: *btScalar, zy: *btScalar, zz: *btScalar) -> void #cpp_method #foreign bullet3 "??0btMatrix3x3@@QEAA@AEBM00000000@Z";
    Constructor :: (this: *btMatrix3x3, _xx: btScalar, xy: btScalar, xz: btScalar, yx: btScalar, yy: btScalar, yz: btScalar, zx: btScalar, zy: btScalar, zz: btScalar) #no_context {
        Constructor(this, *_xx, *xy, *xz, *yx, *yy, *yz, *zx, *zy, *zz);
    }

    /** @brief Copy constructor */
    CopyConstructor :: (this: *btMatrix3x3, other: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "??0btMatrix3x3@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btMatrix3x3, other: btMatrix3x3) #no_context {
        CopyConstructor(this, *other);
    }

    Constructor :: (this: *btMatrix3x3, v0: *btVector3, v1: *btVector3, v2: *btVector3) -> void #cpp_method #foreign bullet3 "??0btMatrix3x3@@QEAA@AEBVbtVector3@@00@Z";
    Constructor :: (this: *btMatrix3x3, v0: btVector3, v1: btVector3, v2: btVector3) #no_context {
        Constructor(this, *v0, *v1, *v2);
    }

    /** @brief Get a column of the matrix as a vector 
    *  @param i Column number 0 indexed */
    getColumn :: (this: *btMatrix3x3, i: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getColumn@btMatrix3x3@@QEBA?AVbtVector3@@H@Z";

    /** @brief Get a row of the matrix as a vector 
    *  @param i Row number 0 indexed */
    getRow :: (this: *btMatrix3x3, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getRow@btMatrix3x3@@QEBAAEBVbtVector3@@H@Z";

    /** @brief Set from the rotational part of a 4x4 OpenGL matrix
    *  @param m A pointer to the beginning of the array of scalars*/
    setFromOpenGLSubMatrix :: (this: *btMatrix3x3, m: *btScalar) -> void #cpp_method #foreign bullet3 "?setFromOpenGLSubMatrix@btMatrix3x3@@QEAAXPEBM@Z";

    /** @brief Set the values of the matrix explicitly (row major)
    *  @param xx Top left
    *  @param xy Top Middle
    *  @param xz Top Right
    *  @param yx Middle Left
    *  @param yy Middle Middle
    *  @param yz Middle Right
    *  @param zx Bottom Left
    *  @param zy Bottom Middle
    *  @param zz Bottom Right*/
    setValue :: (this: *btMatrix3x3, _xx: *btScalar, xy: *btScalar, xz: *btScalar, yx: *btScalar, yy: *btScalar, yz: *btScalar, zx: *btScalar, zy: *btScalar, zz: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btMatrix3x3@@QEAAXAEBM00000000@Z";
    setValue :: (this: *btMatrix3x3, _xx: btScalar, xy: btScalar, xz: btScalar, yx: btScalar, yy: btScalar, yz: btScalar, zx: btScalar, zy: btScalar, zz: btScalar) #no_context {
        setValue(this, *_xx, *xy, *xz, *yx, *yy, *yz, *zx, *zy, *zz);
    }

    /** @brief Set the matrix from a quaternion
    *  @param q The Quaternion to match */
    setRotation :: (this: *btMatrix3x3, q: *btQuaternion) -> void #cpp_method #foreign bullet3 "?setRotation@btMatrix3x3@@QEAAXAEBVbtQuaternion@@@Z";
    setRotation :: (this: *btMatrix3x3, q: btQuaternion) #no_context {
        setRotation(this, *q);
    }

    /** @brief Set the matrix from euler angles using YPR around YXZ respectively
    *  @param yaw Yaw about Y axis
    *  @param pitch Pitch about X axis
    *  @param roll Roll about Z axis 
    */
    setEulerYPR :: (this: *btMatrix3x3, yaw: *btScalar, pitch: *btScalar, roll: *btScalar) -> void #cpp_method #foreign bullet3 "?setEulerYPR@btMatrix3x3@@QEAAXAEBM00@Z";
    setEulerYPR :: (this: *btMatrix3x3, yaw: btScalar, pitch: btScalar, roll: btScalar) #no_context {
        setEulerYPR(this, *yaw, *pitch, *roll);
    }

    /** @brief Set the matrix from euler angles YPR around ZYX axes
    * @param eulerX Roll about X axis
    * @param eulerY Pitch around Y axis
    * @param eulerZ Yaw about Z axis
    * 
    * These angles are used to produce a rotation matrix. The euler
    * angles are applied in ZYX order. I.e a vector is first rotated 
    * about X then Y and then Z
    **/
    setEulerZYX :: (this: *btMatrix3x3, eulerX: btScalar, eulerY: btScalar, eulerZ: btScalar) -> void #cpp_method #foreign bullet3 "?setEulerZYX@btMatrix3x3@@QEAAXMMM@Z";

    /**@brief Set the matrix to the identity */
    setIdentity :: (this: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setIdentity@btMatrix3x3@@QEAAXXZ";

    /**@brief Set the matrix to the identity */
    setZero :: (this: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setZero@btMatrix3x3@@QEAAXXZ";

    getIdentity :: () -> *btMatrix3x3 #foreign bullet3 "?getIdentity@btMatrix3x3@@SAAEBV1@XZ";

    /**@brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
    * @param m The array to be filled */
    getOpenGLSubMatrix :: (this: *btMatrix3x3, m: *btScalar) -> void #cpp_method #foreign bullet3 "?getOpenGLSubMatrix@btMatrix3x3@@QEBAXPEAM@Z";

    /**@brief Get the matrix represented as a quaternion 
    * @param q The quaternion which will be set */
    getRotation :: (this: *btMatrix3x3, q: *btQuaternion) -> void #cpp_method #foreign bullet3 "?getRotation@btMatrix3x3@@QEBAXAEAVbtQuaternion@@@Z";

    /**@brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
    * @param yaw Yaw around Y axis
    * @param pitch Pitch around X axis
    * @param roll around Z axis */
    getEulerYPR :: (this: *btMatrix3x3, yaw: *btScalar, pitch: *btScalar, roll: *btScalar) -> void #cpp_method #foreign bullet3 "?getEulerYPR@btMatrix3x3@@QEBAXAEAM00@Z";

    /**@brief Get the matrix represented as euler angles around ZYX
    * @param yaw Yaw around Z axis
    * @param pitch Pitch around Y axis
    * @param roll around X axis 
    * @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/
    getEulerZYX :: (this: *btMatrix3x3, yaw: *btScalar, pitch: *btScalar, roll: *btScalar, solution_number: u32 = 1) -> void #cpp_method #foreign bullet3 "?getEulerZYX@btMatrix3x3@@QEBAXAEAM00I@Z";

    /**@brief Create a scaled copy of the matrix 
    * @param s Scaling vector The elements of the vector will scale each column */
    scaled :: (this: *btMatrix3x3, s: *btVector3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?scaled@btMatrix3x3@@QEBA?AV1@AEBVbtVector3@@@Z";
    scaled :: (this: *btMatrix3x3, s: btVector3) -> btMatrix3x3 #no_context {
        return scaled(this, *s);
    }

    /**@brief Return the determinant of the matrix */
    determinant :: (this: *btMatrix3x3) -> btScalar #cpp_method #foreign bullet3 "?determinant@btMatrix3x3@@QEBAMXZ";

    /**@brief Return the adjoint of the matrix */
    adjoint :: (this: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?adjoint@btMatrix3x3@@QEBA?AV1@XZ";

    /**@brief Return the matrix with all values non negative */
    absolute :: (this: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?absolute@btMatrix3x3@@QEBA?AV1@XZ";

    /**@brief Return the transpose of the matrix */
    transpose :: (this: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?transpose@btMatrix3x3@@QEBA?AV1@XZ";

    /**@brief Return the inverse of the matrix */
    inverse :: (this: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverse@btMatrix3x3@@QEBA?AV1@XZ";

    /// Solve A * x = b, where b is a column vector. This is more efficient
    /// than computing the inverse in one-shot cases.
    ///Solve33 is from Box2d, thanks to Erin Catto,
    solve33 :: (this: *btMatrix3x3, b: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?solve33@btMatrix3x3@@QEBA?AVbtVector3@@AEBV2@@Z";
    solve33 :: (this: *btMatrix3x3, b: btVector3) -> btVector3 #no_context {
        return solve33(this, *b);
    }

    transposeTimes :: (this: *btMatrix3x3, m: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?transposeTimes@btMatrix3x3@@QEBA?AV1@AEBV1@@Z";
    transposeTimes :: (this: *btMatrix3x3, m: btMatrix3x3) -> btMatrix3x3 #no_context {
        return transposeTimes(this, *m);
    }

    timesTranspose :: (this: *btMatrix3x3, m: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?timesTranspose@btMatrix3x3@@QEBA?AV1@AEBV1@@Z";
    timesTranspose :: (this: *btMatrix3x3, m: btMatrix3x3) -> btMatrix3x3 #no_context {
        return timesTranspose(this, *m);
    }

    tdotx :: (this: *btMatrix3x3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?tdotx@btMatrix3x3@@QEBAMAEBVbtVector3@@@Z";
    tdotx :: (this: *btMatrix3x3, v: btVector3) -> btScalar #no_context {
        return tdotx(this, *v);
    }

    tdoty :: (this: *btMatrix3x3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?tdoty@btMatrix3x3@@QEBAMAEBVbtVector3@@@Z";
    tdoty :: (this: *btMatrix3x3, v: btVector3) -> btScalar #no_context {
        return tdoty(this, *v);
    }

    tdotz :: (this: *btMatrix3x3, v: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?tdotz@btMatrix3x3@@QEBAMAEBVbtVector3@@@Z";
    tdotz :: (this: *btMatrix3x3, v: btVector3) -> btScalar #no_context {
        return tdotz(this, *v);
    }

    ///extractRotation is from "A robust method to extract the rotational part of deformations"
    ///See http://dl.acm.org/citation.cfm?doid=2994258.2994269
    ///decomposes a matrix A in a orthogonal matrix R and a
    ///symmetric matrix S:
    ///A = R*S.
    ///note that R can include both rotation and scaling.
    extractRotation :: (this: *btMatrix3x3, q: *btQuaternion, tolerance: btScalar = 0.0, maxIter: s32 = 100) -> void #cpp_method #foreign bullet3 "?extractRotation@btMatrix3x3@@QEAAXAEAVbtQuaternion@@MH@Z";

    /**@brief diagonalizes this matrix by the Jacobi method.
    * @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
    * coordinate system, i.e., old_this = rot * new_this * rot^T.
    * @param threshold See iteration
    * @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied
    * by the sum of the absolute values of the diagonal, or when maxSteps have been executed.
    *
    * Note that this matrix is assumed to be symmetric.
    */
    diagonalize :: (this: *btMatrix3x3, rot: *btMatrix3x3, threshold: btScalar, maxSteps: s32) -> void #cpp_method #foreign bullet3 "?diagonalize@btMatrix3x3@@QEAAXAEAV1@MH@Z";

    /**@brief Calculate the matrix cofactor 
    * @param r1 The first row to use for calculating the cofactor
    * @param c1 The first column to use for calculating the cofactor
    * @param r1 The second row to use for calculating the cofactor
    * @param c1 The second column to use for calculating the cofactor
    * See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
    */
    cofac :: (this: *btMatrix3x3, r1: s32, c1: s32, r2: s32, c2: s32) -> btScalar #cpp_method #foreign bullet3 "?cofac@btMatrix3x3@@QEBAMHHHH@Z";

    serialize :: (this: *btMatrix3x3, dataOut: *btMatrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?serialize@btMatrix3x3@@QEBAXAEAUbtMatrix3x3FloatData@@@Z";

    serializeFloat :: (this: *btMatrix3x3, dataOut: *btMatrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@btMatrix3x3@@QEBAXAEAUbtMatrix3x3FloatData@@@Z";

    deSerialize :: (this: *btMatrix3x3, dataIn: *btMatrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@btMatrix3x3@@QEAAXAEBUbtMatrix3x3FloatData@@@Z";
    deSerialize :: (this: *btMatrix3x3, dataIn: btMatrix3x3FloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    deSerializeFloat :: (this: *btMatrix3x3, dataIn: *btMatrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@btMatrix3x3@@QEAAXAEBUbtMatrix3x3FloatData@@@Z";
    deSerializeFloat :: (this: *btMatrix3x3, dataIn: btMatrix3x3FloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }

    deSerializeDouble :: (this: *btMatrix3x3, dataIn: *btMatrix3x3DoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@btMatrix3x3@@QEAAXAEBUbtMatrix3x3DoubleData@@@Z";
    deSerializeDouble :: (this: *btMatrix3x3, dataIn: btMatrix3x3DoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }
}

/** @brief Assignment Operator */
operator_assign :: (this: *btMatrix3x3, other: *btMatrix3x3) -> *btMatrix3x3 #cpp_method #foreign bullet3 "??4btMatrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator_assign :: (this: *btMatrix3x3, other: btMatrix3x3) -> *btMatrix3x3 #no_context {
    return operator_assign(this, *other);
}

/** @brief Get a mutable reference to a row of the matrix as a vector 
*  @param i Row number 0 indexed */
operator[] :: (this: *btMatrix3x3, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "??AbtMatrix3x3@@QEAAAEAVbtVector3@@H@Z";
operator[] :: (this: btMatrix3x3, i: s32) -> *btVector3 #no_context {
    return operator[](*this, i);
}

/** @brief Get a const reference to a row of the matrix as a vector 
*  @param i Row number 0 indexed */
operator_brackets_1 :: (this: /*const*/ *btMatrix3x3, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "??AbtMatrix3x3@@QEBAAEBVbtVector3@@H@Z";
operator_brackets_1 :: (this: btMatrix3x3, i: s32) -> *btVector3 #no_context {
    return operator_brackets_1(*this, i);
}

/** @brief Multiply by the target matrix on the right
*  @param m Rotation matrix to be applied 
* Equivilant to this = this * m */
operator*= :: (this: *btMatrix3x3, m: *btMatrix3x3) -> *btMatrix3x3 #cpp_method #foreign bullet3 "??XbtMatrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *btMatrix3x3, m: btMatrix3x3) -> *btMatrix3x3 #no_context {
    return operator*=(this, *m);
}

/** @brief Adds by the target matrix on the right
*  @param m matrix to be applied 
* Equivilant to this = this + m */
operator+= :: (this: *btMatrix3x3, m: *btMatrix3x3) -> *btMatrix3x3 #cpp_method #foreign bullet3 "??YbtMatrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator+= :: (this: *btMatrix3x3, m: btMatrix3x3) -> *btMatrix3x3 #no_context {
    return operator+=(this, *m);
}

/** @brief Substractss by the target matrix on the right
*  @param m matrix to be applied 
* Equivilant to this = this - m */
operator-= :: (this: *btMatrix3x3, m: *btMatrix3x3) -> *btMatrix3x3 #cpp_method #foreign bullet3 "??ZbtMatrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator-= :: (this: *btMatrix3x3, m: btMatrix3x3) -> *btMatrix3x3 #no_context {
    return operator-=(this, *m);
}

///for serialization
btMatrix3x3FloatData :: struct {
    m_el: [3] btVector3FloatData;
}

///for serialization
btMatrix3x3DoubleData :: struct {
    m_el: [3] btVector3DoubleData;
}

/**@brief The btTransform class supports rigid transforms with only translation and rotation and no scaling/shear.
*It can be used in combination with btVector3, btQuaternion and btMatrix3x3 linear algebra classes. */
btTransform :: struct {
    ///Storage for the rotation
    m_basis:  btMatrix3x3;

    ///Storage for the translation
    m_origin: btVector3;

    /**@brief No initialization constructor */
    Constructor :: (this: *btTransform) -> void #cpp_method #foreign bullet3 "??0btTransform@@QEAA@XZ";

    /**@brief Constructor from btQuaternion (optional btVector3 )
    * @param q Rotation from quaternion 
    * @param c Translation from Vector (default 0,0,0) */
    Constructor :: (this: *btTransform, q: *btQuaternion, c: *btVector3) -> void #cpp_method #foreign bullet3 "??0btTransform@@QEAA@AEBVbtQuaternion@@AEBVbtVector3@@@Z";
    Constructor :: (this: *btTransform, q: btQuaternion, c: btVector3) #no_context {
        Constructor(this, *q, *c);
    }

    /**@brief Constructor from btMatrix3x3 (optional btVector3)
    * @param b Rotation from Matrix 
    * @param c Translation from Vector default (0,0,0)*/
    Constructor :: (this: *btTransform, b: *btMatrix3x3, c: *btVector3) -> void #cpp_method #foreign bullet3 "??0btTransform@@QEAA@AEBVbtMatrix3x3@@AEBVbtVector3@@@Z";
    Constructor :: (this: *btTransform, b: btMatrix3x3, c: btVector3) #no_context {
        Constructor(this, *b, *c);
    }

    /**@brief Copy constructor */
    CopyConstructor :: (this: *btTransform, other: *btTransform) -> void #cpp_method #foreign bullet3 "??0btTransform@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btTransform, other: btTransform) #no_context {
        CopyConstructor(this, *other);
    }

    /**@brief Set the current transform as the value of the product of two transforms
    * @param t1 Transform 1
    * @param t2 Transform 2
    * This = Transform1 * Transform2 */
    mult :: (this: *btTransform, t1: *btTransform, t2: *btTransform) -> void #cpp_method #foreign bullet3 "?mult@btTransform@@QEAAXAEBV1@0@Z";
    mult :: (this: *btTransform, t1: btTransform, t2: btTransform) #no_context {
        mult(this, *t1, *t2);
    }

    /**@brief Return the basis matrix for the rotation */
    getBasis :: (this: *btTransform) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getBasis@btTransform@@QEAAAEAVbtMatrix3x3@@XZ";

    /**@brief Return the basis matrix for the rotation */
    getBasis_1 :: (this: /*const*/ *btTransform) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getBasis@btTransform@@QEBAAEBVbtMatrix3x3@@XZ";

    /**@brief Return the origin vector translation */
    getOrigin :: (this: *btTransform) -> *btVector3 #cpp_method #foreign bullet3 "?getOrigin@btTransform@@QEAAAEAVbtVector3@@XZ";

    /**@brief Return the origin vector translation */
    getOrigin_1 :: (this: /*const*/ *btTransform) -> *btVector3 #cpp_method #foreign bullet3 "?getOrigin@btTransform@@QEBAAEBVbtVector3@@XZ";

    /**@brief Return a quaternion representing the rotation */
    getRotation :: (this: *btTransform) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getRotation@btTransform@@QEBA?AVbtQuaternion@@XZ";

    /**@brief Set from an array 
    * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
    setFromOpenGLMatrix :: (this: *btTransform, m: *btScalar) -> void #cpp_method #foreign bullet3 "?setFromOpenGLMatrix@btTransform@@QEAAXPEBM@Z";

    /**@brief Fill an array representation
    * @param m A pointer to a 16 element array (12 rotation(row major padded on the right by 1), and 3 translation */
    getOpenGLMatrix :: (this: *btTransform, m: *btScalar) -> void #cpp_method #foreign bullet3 "?getOpenGLMatrix@btTransform@@QEBAXPEAM@Z";

    /**@brief Set the translational element
    * @param origin The vector to set the translation to */
    setOrigin :: (this: *btTransform, origin: *btVector3) -> void #cpp_method #foreign bullet3 "?setOrigin@btTransform@@QEAAXAEBVbtVector3@@@Z";
    setOrigin :: (this: *btTransform, origin: btVector3) #no_context {
        setOrigin(this, *origin);
    }

    invXform :: (this: *btTransform, inVec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?invXform@btTransform@@QEBA?AVbtVector3@@AEBV2@@Z";
    invXform :: (this: *btTransform, inVec: btVector3) -> btVector3 #no_context {
        return invXform(this, *inVec);
    }

    /**@brief Set the rotational element by btMatrix3x3 */
    setBasis :: (this: *btTransform, basis: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setBasis@btTransform@@QEAAXAEBVbtMatrix3x3@@@Z";
    setBasis :: (this: *btTransform, basis: btMatrix3x3) #no_context {
        setBasis(this, *basis);
    }

    /**@brief Set the rotational element by btQuaternion */
    setRotation :: (this: *btTransform, q: *btQuaternion) -> void #cpp_method #foreign bullet3 "?setRotation@btTransform@@QEAAXAEBVbtQuaternion@@@Z";
    setRotation :: (this: *btTransform, q: btQuaternion) #no_context {
        setRotation(this, *q);
    }

    /**@brief Set this transformation to the identity */
    setIdentity :: (this: *btTransform) -> void #cpp_method #foreign bullet3 "?setIdentity@btTransform@@QEAAXXZ";

    /**@brief Return the inverse of this transform */
    inverse :: (this: *btTransform) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverse@btTransform@@QEBA?AV1@XZ";

    /**@brief Return the inverse of this transform times the other transform
    * @param t The other transform 
    * return this.inverse() * the other */
    inverseTimes :: (this: *btTransform, t: *btTransform) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverseTimes@btTransform@@QEBA?AV1@AEBV1@@Z";
    inverseTimes :: (this: *btTransform, t: btTransform) -> btTransform #no_context {
        return inverseTimes(this, *t);
    }

    /**@brief Return an identity transform */
    getIdentity :: () -> *btTransform #foreign bullet3 "?getIdentity@btTransform@@SAAEBV1@XZ";

    serialize :: (this: *btTransform, dataOut: *btTransformFloatData) -> void #cpp_method #foreign bullet3 "?serialize@btTransform@@QEBAXAEAUbtTransformFloatData@@@Z";

    serializeFloat :: (this: *btTransform, dataOut: *btTransformFloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@btTransform@@QEBAXAEAUbtTransformFloatData@@@Z";

    deSerialize :: (this: *btTransform, dataIn: *btTransformFloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@btTransform@@QEAAXAEBUbtTransformFloatData@@@Z";
    deSerialize :: (this: *btTransform, dataIn: btTransformFloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    deSerializeDouble :: (this: *btTransform, dataIn: *btTransformDoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@btTransform@@QEAAXAEBUbtTransformDoubleData@@@Z";
    deSerializeDouble :: (this: *btTransform, dataIn: btTransformDoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }

    deSerializeFloat :: (this: *btTransform, dataIn: *btTransformFloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@btTransform@@QEAAXAEBUbtTransformFloatData@@@Z";
    deSerializeFloat :: (this: *btTransform, dataIn: btTransformFloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }
}

/**@brief Assignment Operator */
operator_assign :: (this: *btTransform, other: *btTransform) -> *btTransform #cpp_method #foreign bullet3 "??4btTransform@@QEAAAEAV0@AEBV0@@Z";
operator_assign :: (this: *btTransform, other: btTransform) -> *btTransform #no_context {
    return operator_assign(this, *other);
}

/**@brief Return the transform of the vector */
operator_parens :: (this: *btTransform, x: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??RbtTransform@@QEBA?AVbtVector3@@AEBV1@@Z";
operator_parens :: (this: btTransform, x: btVector3) -> btVector3 #no_context {
    return operator_parens(*this, *x);
}

/**@brief Return the transform of the vector */
operator* :: (this: *btTransform, x: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtTransform@@QEBA?AVbtVector3@@AEBV1@@Z";
operator* :: (this: btTransform, x: btVector3) -> btVector3 #no_context {
    return operator*(*this, *x);
}

/**@brief Return the transform of the btQuaternion */
operator* :: (this: *btTransform, q: *btQuaternion) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtTransform@@QEBA?AVbtQuaternion@@AEBV1@@Z";
operator* :: (this: btTransform, q: btQuaternion) -> btQuaternion #no_context {
    return operator*(*this, *q);
}

/**@brief Multiply this Transform by another(this = this * another) 
* @param t The other transform */
operator*= :: (this: *btTransform, t: *btTransform) -> *btTransform #cpp_method #foreign bullet3 "??XbtTransform@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *btTransform, t: btTransform) -> *btTransform #no_context {
    return operator*=(this, *t);
}

/**@brief Return the product of this transform and the other */
operator* :: (this: *btTransform, t: *btTransform) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtTransform@@QEBA?AV0@AEBV0@@Z";
operator* :: (this: btTransform, t: btTransform) -> btTransform #no_context {
    return operator*(*this, *t);
}

///for serialization
btTransformFloatData :: struct {
    m_basis:  btMatrix3x3FloatData;
    m_origin: btVector3FloatData;
}

btTransformDoubleData :: struct {
    m_basis:  btMatrix3x3DoubleData;
    m_origin: btVector3DoubleData;
}

///The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics
///For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)
btMotionState :: struct {
    vtable: *btMotionState_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btMotionState, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMotionState@@UEAA@XZ";
}
btMotionState_VTable :: struct #type_info_none {
    Destructor: (this: *btMotionState, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getWorldTransform: (this: *btMotionState, worldTrans: *btTransform) -> void #cpp_method;

    setWorldTransform: (this: *btMotionState, worldTrans: *btTransform) -> void #cpp_method;
}

btMotionState_Destructor :: inline (this: *btMotionState, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btMotionState_getWorldTransform :: inline (this: *btMotionState, worldTrans: *btTransform) { this.vtable.getWorldTransform(this, worldTrans); }

btMotionState_setWorldTransform :: inline (this: *btMotionState, worldTrans: *btTransform) { this.vtable.setWorldTransform(this, worldTrans); }



///The btAlignedObjectArray template class uses a subset of the stl::vector interface for its methods
///It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
btAlignedObjectArray :: struct(T: Type) {
    m_allocator:  btAlignedAllocator(T, UnknownTemplateArgumentPlaceholder) = 16;

    m_size:       s32;
    m_capacity:   s32;
    m_data:       *T;

    //PCK: added this line
    m_ownsMemory: bool;

    less :: struct {}
}

btCollisionObjectArray :: btAlignedObjectArray(*btCollisionObject);

/// btCollisionObject can be used to manage collision detection objects.
/// btCollisionObject maintains all information that is needed for a collision detection: Shape, Transform and AABB proxy.
/// They can be added to the btCollisionWorld.
btCollisionObject :: struct {
    vtable: *btCollisionObject_VTable;
    m_worldTransform:               btTransform;

    ///m_interpolationWorldTransform is used for CCD and interpolation
    ///it can be either previous or future (predicted) transform
    m_interpolationWorldTransform:  btTransform;

    //those two are experimental: just added for bullet time effect, so you can still apply impulses (directly modifying velocities)
    //without destroying the continuous interpolated motion (which uses this interpolation velocities)
    m_interpolationLinearVelocity:  btVector3;
    m_interpolationAngularVelocity: btVector3;

    m_anisotropicFriction:          btVector3;
    m_hasAnisotropicFriction:       s32;
    m_contactProcessingThreshold:   btScalar;

    m_broadphaseHandle:             *btBroadphaseProxy;
    m_collisionShape:               *btCollisionShape;

    ///m_extensionPointer is used by some internal low-level Bullet extensions.
    m_extensionPointer:             *void;

    ///m_rootCollisionShape is temporarily used to store the original collision shape
    ///The m_collisionShape might be temporarily replaced by a child collision shape during collision detection purposes
    ///If it is NULL, the m_collisionShape is not temporarily replaced.
    m_rootCollisionShape:           *btCollisionShape;

    m_collisionFlags:               s32;

    m_islandTag1:                   s32;
    m_companionId:                  s32;
    m_worldArrayIndex:              s32; // index of object in world's collisionObjects array

    m_activationState1:             s32;
    m_deactivationTime:             btScalar;

    m_friction:                     btScalar;
    m_restitution:                  btScalar;
    m_rollingFriction:              btScalar; //torsional friction orthogonal to contact normal (useful to stop spheres rolling forever)
    m_spinningFriction:             btScalar; // torsional friction around the contact normal (useful for grasping)
    m_contactDamping:               btScalar;
    m_contactStiffness:             btScalar;

    ///m_internalType is reserved to distinguish Bullet's btCollisionObject, btRigidBody, btSoftBody, btGhostObject etc.
    ///do not assign your own m_internalType unless you write a new dynamics object class.
    m_internalType:                 s32;

    ///users can point to their objects, m_userPointer is not used by Bullet, see setUserPointer/getUserPointer
    m_userObjectPointer:            *void;

    m_userIndex2:                   s32;

    m_userIndex:                    s32;

    m_userIndex3:                   s32;

    ///time of impact calculation
    m_hitFraction:                  btScalar;

    ///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
    m_ccdSweptSphereRadius:         btScalar;

    /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
    m_ccdMotionThreshold:           btScalar;

    /// If some object should have elaborate collision filtering by sub-classes
    m_checkCollideWith:             s32;

    m_objectsWithoutCollisionCheck: btAlignedObjectArray(*btCollisionObject);

    ///internal update revision number. It will be increased when the object changes. This allows some subsystems to perform lazy evaluation.
    m_updateRevision:               s32;

    m_customDebugColorRGB:          btVector3 #align 8;

    CollisionFlags :: enum s32 {
        DYNAMIC_OBJECT                   :: 0;
        STATIC_OBJECT                    :: 1;
        KINEMATIC_OBJECT                 :: 2;
        NO_CONTACT_RESPONSE              :: 4;
        CUSTOM_MATERIAL_CALLBACK         :: 8;
        CHARACTER_OBJECT                 :: 16;
        DISABLE_VISUALIZE_OBJECT         :: 32;
        DISABLE_SPU_COLLISION_PROCESSING :: 64;
        HAS_CONTACT_STIFFNESS_DAMPING    :: 128;
        HAS_CUSTOM_DEBUG_RENDERING_COLOR :: 256;
        HAS_FRICTION_ANCHOR              :: 512;
        HAS_COLLISION_SOUND_TRIGGER      :: 1024;

        CF_DYNAMIC_OBJECT                   :: DYNAMIC_OBJECT;
        CF_STATIC_OBJECT                    :: STATIC_OBJECT;
        CF_KINEMATIC_OBJECT                 :: KINEMATIC_OBJECT;
        CF_NO_CONTACT_RESPONSE              :: NO_CONTACT_RESPONSE;
        CF_CUSTOM_MATERIAL_CALLBACK         :: CUSTOM_MATERIAL_CALLBACK;
        CF_CHARACTER_OBJECT                 :: CHARACTER_OBJECT;
        CF_DISABLE_VISUALIZE_OBJECT         :: DISABLE_VISUALIZE_OBJECT;
        CF_DISABLE_SPU_COLLISION_PROCESSING :: DISABLE_SPU_COLLISION_PROCESSING;
        CF_HAS_CONTACT_STIFFNESS_DAMPING    :: HAS_CONTACT_STIFFNESS_DAMPING;
        CF_HAS_CUSTOM_DEBUG_RENDERING_COLOR :: HAS_CUSTOM_DEBUG_RENDERING_COLOR;
        CF_HAS_FRICTION_ANCHOR              :: HAS_FRICTION_ANCHOR;
        CF_HAS_COLLISION_SOUND_TRIGGER      :: HAS_COLLISION_SOUND_TRIGGER;
    }

    CollisionObjectTypes :: enum s32 {
        COLLISION_OBJECT  :: 1;
        RIGID_BODY        :: 2;

        GHOST_OBJECT      :: 4;
        SOFT_BODY         :: 8;
        HF_FLUID          :: 16;
        USER_TYPE         :: 32;
        FEATHERSTONE_LINK :: 64;

        CO_COLLISION_OBJECT  :: COLLISION_OBJECT;
        CO_RIGID_BODY        :: RIGID_BODY;

        CO_GHOST_OBJECT      :: GHOST_OBJECT;
        CO_SOFT_BODY         :: SOFT_BODY;
        CO_HF_FLUID          :: HF_FLUID;
        CO_USER_TYPE         :: USER_TYPE;
        CO_FEATHERSTONE_LINK :: FEATHERSTONE_LINK;
    }

    AnisotropicFrictionFlags :: enum s32 {
        FRICTION_DISABLED :: 0;
        FRICTION          :: 1;
        ROLLING_FRICTION  :: 2;

        CF_ANISOTROPIC_FRICTION_DISABLED :: FRICTION_DISABLED;
        CF_ANISOTROPIC_FRICTION          :: FRICTION;
        CF_ANISOTROPIC_ROLLING_FRICTION  :: ROLLING_FRICTION;
    }

    mergesSimulationIslands :: (this: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?mergesSimulationIslands@btCollisionObject@@QEBA_NXZ";

    getAnisotropicFriction :: (this: *btCollisionObject) -> *btVector3 #cpp_method #foreign bullet3 "?getAnisotropicFriction@btCollisionObject@@QEBAAEBVbtVector3@@XZ";

    setAnisotropicFriction :: (this: *btCollisionObject, anisotropicFriction: *btVector3, frictionMode: s32 = xx AnisotropicFrictionFlags.FRICTION) -> void #cpp_method #foreign bullet3 "?setAnisotropicFriction@btCollisionObject@@QEAAXAEBVbtVector3@@H@Z";
    setAnisotropicFriction :: (this: *btCollisionObject, anisotropicFriction: btVector3, frictionMode: s32 = xx AnisotropicFrictionFlags.FRICTION) #no_context {
        setAnisotropicFriction(this, *anisotropicFriction, frictionMode);
    }

    hasAnisotropicFriction :: (this: *btCollisionObject, frictionMode: s32 = xx AnisotropicFrictionFlags.FRICTION) -> bool #cpp_method #foreign bullet3 "?hasAnisotropicFriction@btCollisionObject@@QEBA_NH@Z";

    ///the constraint solver can discard solving contacts, if the distance is above this threshold. 0 by default.
    ///Note that using contacts with positive distance can improve stability. It increases, however, the chance of colliding with degerate contacts, such as 'interior' triangle edges
    setContactProcessingThreshold :: (this: *btCollisionObject, contactProcessingThreshold: btScalar) -> void #cpp_method #foreign bullet3 "?setContactProcessingThreshold@btCollisionObject@@QEAAXM@Z";

    getContactProcessingThreshold :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getContactProcessingThreshold@btCollisionObject@@QEBAMXZ";

    isStaticObject :: (this: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?isStaticObject@btCollisionObject@@QEBA_NXZ";

    isKinematicObject :: (this: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?isKinematicObject@btCollisionObject@@QEBA_NXZ";

    isStaticOrKinematicObject :: (this: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?isStaticOrKinematicObject@btCollisionObject@@QEBA_NXZ";

    hasContactResponse :: (this: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?hasContactResponse@btCollisionObject@@QEBA_NXZ";

    Constructor :: (this: *btCollisionObject) -> void #cpp_method #foreign bullet3 "??0btCollisionObject@@QEAA@XZ";

    getCollisionShape :: (this: /*const*/ *btCollisionObject) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShape@btCollisionObject@@QEBAPEBVbtCollisionShape@@XZ";

    getCollisionShape_1 :: (this: *btCollisionObject) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShape@btCollisionObject@@QEAAPEAVbtCollisionShape@@XZ";

    setIgnoreCollisionCheck :: (this: *btCollisionObject, co: *btCollisionObject, ignoreCollisionCheck: bool) -> void #cpp_method #foreign bullet3 "?setIgnoreCollisionCheck@btCollisionObject@@QEAAXPEBV1@_N@Z";

    getNumObjectsWithoutCollision :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getNumObjectsWithoutCollision@btCollisionObject@@QEBAHXZ";

    getObjectWithoutCollision :: (this: *btCollisionObject, index: s32) -> *btCollisionObject #cpp_method #foreign bullet3 "?getObjectWithoutCollision@btCollisionObject@@QEAAPEBV1@H@Z";

    ///Avoid using this internal API call, the extension pointer is used by some Bullet extensions.
    ///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
    internalGetExtensionPointer :: (this: *btCollisionObject) -> *void #cpp_method #foreign bullet3 "?internalGetExtensionPointer@btCollisionObject@@QEBAPEAXXZ";

    ///Avoid using this internal API call, the extension pointer is used by some Bullet extensions
    ///If you need to store your own user pointer, use 'setUserPointer/getUserPointer' instead.
    internalSetExtensionPointer :: (this: *btCollisionObject, pointer: *void) -> void #cpp_method #foreign bullet3 "?internalSetExtensionPointer@btCollisionObject@@QEAAXPEAX@Z";

    getActivationState :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getActivationState@btCollisionObject@@QEBAHXZ";

    setActivationState :: (this: *btCollisionObject, newState: s32) -> void #cpp_method #foreign bullet3 "?setActivationState@btCollisionObject@@QEBAXH@Z";

    setDeactivationTime :: (this: *btCollisionObject, time: btScalar) -> void #cpp_method #foreign bullet3 "?setDeactivationTime@btCollisionObject@@QEAAXM@Z";

    getDeactivationTime :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getDeactivationTime@btCollisionObject@@QEBAMXZ";

    forceActivationState :: (this: *btCollisionObject, newState: s32) -> void #cpp_method #foreign bullet3 "?forceActivationState@btCollisionObject@@QEBAXH@Z";

    activate :: (this: *btCollisionObject, forceActivation := false) -> void #cpp_method #foreign bullet3 "?activate@btCollisionObject@@QEBAX_N@Z";

    isActive :: (this: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?isActive@btCollisionObject@@QEBA_NXZ";

    setRestitution :: (this: *btCollisionObject, rest: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitution@btCollisionObject@@QEAAXM@Z";

    getRestitution :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getRestitution@btCollisionObject@@QEBAMXZ";

    setFriction :: (this: *btCollisionObject, frict: btScalar) -> void #cpp_method #foreign bullet3 "?setFriction@btCollisionObject@@QEAAXM@Z";

    getFriction :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getFriction@btCollisionObject@@QEBAMXZ";

    setRollingFriction :: (this: *btCollisionObject, frict: btScalar) -> void #cpp_method #foreign bullet3 "?setRollingFriction@btCollisionObject@@QEAAXM@Z";

    getRollingFriction :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getRollingFriction@btCollisionObject@@QEBAMXZ";

    setSpinningFriction :: (this: *btCollisionObject, frict: btScalar) -> void #cpp_method #foreign bullet3 "?setSpinningFriction@btCollisionObject@@QEAAXM@Z";

    getSpinningFriction :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getSpinningFriction@btCollisionObject@@QEBAMXZ";

    setContactStiffnessAndDamping :: (this: *btCollisionObject, stiffness: btScalar, damping: btScalar) -> void #cpp_method #foreign bullet3 "?setContactStiffnessAndDamping@btCollisionObject@@QEAAXMM@Z";

    getContactStiffness :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getContactStiffness@btCollisionObject@@QEBAMXZ";

    getContactDamping :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getContactDamping@btCollisionObject@@QEBAMXZ";

    ///reserved for Bullet internal usage
    getInternalType :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getInternalType@btCollisionObject@@QEBAHXZ";

    getWorldTransform :: (this: *btCollisionObject) -> *btTransform #cpp_method #foreign bullet3 "?getWorldTransform@btCollisionObject@@QEAAAEAVbtTransform@@XZ";

    getWorldTransform_1 :: (this: /*const*/ *btCollisionObject) -> *btTransform #cpp_method #foreign bullet3 "?getWorldTransform@btCollisionObject@@QEBAAEBVbtTransform@@XZ";

    setWorldTransform :: (this: *btCollisionObject, worldTrans: *btTransform) -> void #cpp_method #foreign bullet3 "?setWorldTransform@btCollisionObject@@QEAAXAEBVbtTransform@@@Z";
    setWorldTransform :: (this: *btCollisionObject, worldTrans: btTransform) #no_context {
        setWorldTransform(this, *worldTrans);
    }

    getBroadphaseHandle :: (this: *btCollisionObject) -> *btBroadphaseProxy #cpp_method #foreign bullet3 "?getBroadphaseHandle@btCollisionObject@@QEAAPEAUbtBroadphaseProxy@@XZ";

    getBroadphaseHandle_1 :: (this: /*const*/ *btCollisionObject) -> *btBroadphaseProxy #cpp_method #foreign bullet3 "?getBroadphaseHandle@btCollisionObject@@QEBAPEBUbtBroadphaseProxy@@XZ";

    setBroadphaseHandle :: (this: *btCollisionObject, handle: *btBroadphaseProxy) -> void #cpp_method #foreign bullet3 "?setBroadphaseHandle@btCollisionObject@@QEAAXPEAUbtBroadphaseProxy@@@Z";

    getInterpolationWorldTransform :: (this: /*const*/ *btCollisionObject) -> *btTransform #cpp_method #foreign bullet3 "?getInterpolationWorldTransform@btCollisionObject@@QEBAAEBVbtTransform@@XZ";

    getInterpolationWorldTransform_1 :: (this: *btCollisionObject) -> *btTransform #cpp_method #foreign bullet3 "?getInterpolationWorldTransform@btCollisionObject@@QEAAAEAVbtTransform@@XZ";

    setInterpolationWorldTransform :: (this: *btCollisionObject, trans: *btTransform) -> void #cpp_method #foreign bullet3 "?setInterpolationWorldTransform@btCollisionObject@@QEAAXAEBVbtTransform@@@Z";
    setInterpolationWorldTransform :: (this: *btCollisionObject, trans: btTransform) #no_context {
        setInterpolationWorldTransform(this, *trans);
    }

    setInterpolationLinearVelocity :: (this: *btCollisionObject, linvel: *btVector3) -> void #cpp_method #foreign bullet3 "?setInterpolationLinearVelocity@btCollisionObject@@QEAAXAEBVbtVector3@@@Z";
    setInterpolationLinearVelocity :: (this: *btCollisionObject, linvel: btVector3) #no_context {
        setInterpolationLinearVelocity(this, *linvel);
    }

    setInterpolationAngularVelocity :: (this: *btCollisionObject, angvel: *btVector3) -> void #cpp_method #foreign bullet3 "?setInterpolationAngularVelocity@btCollisionObject@@QEAAXAEBVbtVector3@@@Z";
    setInterpolationAngularVelocity :: (this: *btCollisionObject, angvel: btVector3) #no_context {
        setInterpolationAngularVelocity(this, *angvel);
    }

    getInterpolationLinearVelocity :: (this: *btCollisionObject) -> *btVector3 #cpp_method #foreign bullet3 "?getInterpolationLinearVelocity@btCollisionObject@@QEBAAEBVbtVector3@@XZ";

    getInterpolationAngularVelocity :: (this: *btCollisionObject) -> *btVector3 #cpp_method #foreign bullet3 "?getInterpolationAngularVelocity@btCollisionObject@@QEBAAEBVbtVector3@@XZ";

    getIslandTag :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getIslandTag@btCollisionObject@@QEBAHXZ";

    setIslandTag :: (this: *btCollisionObject, tag: s32) -> void #cpp_method #foreign bullet3 "?setIslandTag@btCollisionObject@@QEAAXH@Z";

    getCompanionId :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getCompanionId@btCollisionObject@@QEBAHXZ";

    setCompanionId :: (this: *btCollisionObject, id: s32) -> void #cpp_method #foreign bullet3 "?setCompanionId@btCollisionObject@@QEAAXH@Z";

    getWorldArrayIndex :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getWorldArrayIndex@btCollisionObject@@QEBAHXZ";

    // only should be called by CollisionWorld
    setWorldArrayIndex :: (this: *btCollisionObject, ix: s32) -> void #cpp_method #foreign bullet3 "?setWorldArrayIndex@btCollisionObject@@QEAAXH@Z";

    getHitFraction :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getHitFraction@btCollisionObject@@QEBAMXZ";

    setHitFraction :: (this: *btCollisionObject, hitFraction: btScalar) -> void #cpp_method #foreign bullet3 "?setHitFraction@btCollisionObject@@QEAAXM@Z";

    getCollisionFlags :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getCollisionFlags@btCollisionObject@@QEBAHXZ";

    setCollisionFlags :: (this: *btCollisionObject, flags: s32) -> void #cpp_method #foreign bullet3 "?setCollisionFlags@btCollisionObject@@QEAAXH@Z";

    ///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
    getCcdSweptSphereRadius :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getCcdSweptSphereRadius@btCollisionObject@@QEBAMXZ";

    ///Swept sphere radius (0.0 by default), see btConvexConvexAlgorithm::
    setCcdSweptSphereRadius :: (this: *btCollisionObject, radius: btScalar) -> void #cpp_method #foreign bullet3 "?setCcdSweptSphereRadius@btCollisionObject@@QEAAXM@Z";

    getCcdMotionThreshold :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getCcdMotionThreshold@btCollisionObject@@QEBAMXZ";

    getCcdSquareMotionThreshold :: (this: *btCollisionObject) -> btScalar #cpp_method #foreign bullet3 "?getCcdSquareMotionThreshold@btCollisionObject@@QEBAMXZ";

    /// Don't do continuous collision detection if the motion (in one step) is less then m_ccdMotionThreshold
    setCcdMotionThreshold :: (this: *btCollisionObject, ccdMotionThreshold: btScalar) -> void #cpp_method #foreign bullet3 "?setCcdMotionThreshold@btCollisionObject@@QEAAXM@Z";

    ///users can point to their objects, userPointer is not used by Bullet
    getUserPointer :: (this: *btCollisionObject) -> *void #cpp_method #foreign bullet3 "?getUserPointer@btCollisionObject@@QEBAPEAXXZ";

    getUserIndex :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getUserIndex@btCollisionObject@@QEBAHXZ";

    getUserIndex2 :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getUserIndex2@btCollisionObject@@QEBAHXZ";

    getUserIndex3 :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getUserIndex3@btCollisionObject@@QEBAHXZ";

    ///users can point to their objects, userPointer is not used by Bullet
    setUserPointer :: (this: *btCollisionObject, userPointer: *void) -> void #cpp_method #foreign bullet3 "?setUserPointer@btCollisionObject@@QEAAXPEAX@Z";

    ///users can point to their objects, userPointer is not used by Bullet
    setUserIndex :: (this: *btCollisionObject, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex@btCollisionObject@@QEAAXH@Z";

    setUserIndex2 :: (this: *btCollisionObject, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex2@btCollisionObject@@QEAAXH@Z";

    setUserIndex3 :: (this: *btCollisionObject, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex3@btCollisionObject@@QEAAXH@Z";

    getUpdateRevisionInternal :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?getUpdateRevisionInternal@btCollisionObject@@QEBAHXZ";

    setCustomDebugColor :: (this: *btCollisionObject, colorRGB: *btVector3) -> void #cpp_method #foreign bullet3 "?setCustomDebugColor@btCollisionObject@@QEAAXAEBVbtVector3@@@Z";
    setCustomDebugColor :: (this: *btCollisionObject, colorRGB: btVector3) #no_context {
        setCustomDebugColor(this, *colorRGB);
    }

    removeCustomDebugColor :: (this: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCustomDebugColor@btCollisionObject@@QEAAXXZ";

    getCustomDebugColor :: (this: *btCollisionObject, colorRGB: *btVector3) -> bool #cpp_method #foreign bullet3 "?getCustomDebugColor@btCollisionObject@@QEBA_NAEAVbtVector3@@@Z";

    checkCollideWith :: (this: *btCollisionObject, co: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?checkCollideWith@btCollisionObject@@QEBA_NPEBV1@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCollisionObject, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionObject@@UEAA@XZ";

    virtual_setCollisionShape :: (this: *btCollisionObject, collisionShape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?setCollisionShape@btCollisionObject@@UEAAXPEAVbtCollisionShape@@@Z";

    virtual_checkCollideWithOverride :: (this: *btCollisionObject, co: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?checkCollideWithOverride@btCollisionObject@@UEBA_NPEBV1@@Z";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btCollisionObject) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btCollisionObject@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btCollisionObject, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btCollisionObject@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";

    virtual_serializeSingleObject :: (this: *btCollisionObject, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSingleObject@btCollisionObject@@UEBAXPEAVbtSerializer@@@Z";
}
btCollisionObject_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionObject, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    setCollisionShape: (this: *btCollisionObject, collisionShape: *btCollisionShape) -> void #cpp_method;

    checkCollideWithOverride: (this: *btCollisionObject, co: *btCollisionObject) -> bool #cpp_method;

    calculateSerializeBufferSize: (this: *btCollisionObject) -> s32 #cpp_method;

    serialize: (this: *btCollisionObject, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;

    serializeSingleObject: (this: *btCollisionObject, serializer: *btSerializer) -> void #cpp_method;
}

btCollisionObject_Destructor :: inline (this: *btCollisionObject, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionObject_setCollisionShape :: inline (this: *btCollisionObject, collisionShape: *btCollisionShape) { this.vtable.setCollisionShape(this, collisionShape); }

btCollisionObject_checkCollideWithOverride :: inline (this: *btCollisionObject, co: *btCollisionObject) -> bool { return this.vtable.checkCollideWithOverride(this, co); }

btCollisionObject_calculateSerializeBufferSize :: inline (this: *btCollisionObject) -> s32 { return this.vtable.calculateSerializeBufferSize(this); }

btCollisionObject_serialize :: inline (this: *btCollisionObject, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }

btCollisionObject_serializeSingleObject :: inline (this: *btCollisionObject, serializer: *btSerializer) { this.vtable.serializeSingleObject(this, serializer); }


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCollisionObjectDoubleData :: struct {
    m_broadphaseHandle:             *void;
    m_collisionShape:               *void;
    m_rootCollisionShape:           *btCollisionShapeData;
    m_name:                         *u8;

    m_worldTransform:               btTransformDoubleData;
    m_interpolationWorldTransform:  btTransformDoubleData;
    m_interpolationLinearVelocity:  btVector3DoubleData;
    m_interpolationAngularVelocity: btVector3DoubleData;
    m_anisotropicFriction:          btVector3DoubleData;
    m_contactProcessingThreshold:   float64;
    m_deactivationTime:             float64;
    m_friction:                     float64;
    m_rollingFriction:              float64;
    m_contactDamping:               float64;
    m_contactStiffness:             float64;
    m_restitution:                  float64;
    m_hitFraction:                  float64;
    m_ccdSweptSphereRadius:         float64;
    m_ccdMotionThreshold:           float64;
    m_hasAnisotropicFriction:       s32;
    m_collisionFlags:               s32;
    m_islandTag1:                   s32;
    m_companionId:                  s32;
    m_activationState1:             s32;
    m_internalType:                 s32;
    m_checkCollideWith:             s32;
    m_collisionFilterGroup:         s32;
    m_collisionFilterMask:          s32;
    m_uniqueId:                     s32; //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCollisionObjectFloatData :: struct {
    m_broadphaseHandle:             *void;
    m_collisionShape:               *void;
    m_rootCollisionShape:           *btCollisionShapeData;
    m_name:                         *u8;

    m_worldTransform:               btTransformFloatData;
    m_interpolationWorldTransform:  btTransformFloatData;
    m_interpolationLinearVelocity:  btVector3FloatData;
    m_interpolationAngularVelocity: btVector3FloatData;
    m_anisotropicFriction:          btVector3FloatData;
    m_contactProcessingThreshold:   float;
    m_deactivationTime:             float;
    m_friction:                     float;
    m_rollingFriction:              float;
    m_contactDamping:               float;
    m_contactStiffness:             float;
    m_restitution:                  float;
    m_hitFraction:                  float;
    m_ccdSweptSphereRadius:         float;
    m_ccdMotionThreshold:           float;
    m_hasAnisotropicFriction:       s32;
    m_collisionFlags:               s32;
    m_islandTag1:                   s32;
    m_companionId:                  s32;
    m_activationState1:             s32;
    m_internalType:                 s32;
    m_checkCollideWith:             s32;
    m_collisionFilterGroup:         s32;
    m_collisionFilterMask:          s32;
    m_uniqueId:                     s32;
}

btPoolAllocator :: struct {}

btDispatcherInfo :: struct {
    DispatchFunc :: enum s32 {
        DISCRETE   :: 1;
        CONTINUOUS :: 2;

        DISPATCH_DISCRETE   :: DISCRETE;
        DISPATCH_CONTINUOUS :: CONTINUOUS;
    }

    Constructor :: (this: *btDispatcherInfo) -> void #cpp_method #foreign bullet3 "??0btDispatcherInfo@@QEAA@XZ";

    m_timeStep:                            btScalar;
    m_stepCount:                           s32;
    m_dispatchFunc:                        s32;
    m_timeOfImpact:                        btScalar;
    m_useContinuous:                       bool;
    m_debugDraw:                           *btIDebugDraw;
    m_enableSatConvex:                     bool;
    m_enableSPU:                           bool;
    m_useEpa:                              bool;
    m_allowedCcdPenetration:               btScalar;
    m_useConvexConservativeDistanceUtil:   bool;
    m_convexConservativeDistanceThreshold: btScalar;
    m_deterministicOverlappingPairs:       bool;
}

ebtDispatcherQueryType :: enum s32 {
    CONTACT_POINT_ALGORITHMS :: 1;
    CLOSEST_POINT_ALGORITHMS :: 2;

    BT_CONTACT_POINT_ALGORITHMS :: CONTACT_POINT_ALGORITHMS;
    BT_CLOSEST_POINT_ALGORITHMS :: CLOSEST_POINT_ALGORITHMS;
}

///The btDispatcher interface class can be used in combination with broadphase to dispatch calculations for overlapping pairs.
///For example for pairwise collision detection, calculating contact points stored in btPersistentManifold or user callbacks (game logic).
btDispatcher :: struct {
    vtable: *btDispatcher_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btDispatcher, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDispatcher@@UEAA@XZ";
}
btDispatcher_VTable :: struct #type_info_none {
    Destructor: (this: *btDispatcher, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    findAlgorithm: (this: *btDispatcher, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, sharedManifold: *btPersistentManifold, queryType: ebtDispatcherQueryType) -> *btCollisionAlgorithm #cpp_method;

    getNewManifold: (this: *btDispatcher, b0: *btCollisionObject, b1: *btCollisionObject) -> *btPersistentManifold #cpp_method;

    releaseManifold: (this: *btDispatcher, manifold: *btPersistentManifold) -> void #cpp_method;

    clearManifold: (this: *btDispatcher, manifold: *btPersistentManifold) -> void #cpp_method;

    needsCollision: (this: *btDispatcher, body0: *btCollisionObject, body1: *btCollisionObject) -> bool #cpp_method;

    needsResponse: (this: *btDispatcher, body0: *btCollisionObject, body1: *btCollisionObject) -> bool #cpp_method;

    dispatchAllCollisionPairs: (this: *btDispatcher, pairCache: *btOverlappingPairCache, dispatchInfo: *btDispatcherInfo, dispatcher: *btDispatcher) -> void #cpp_method;

    getNumManifolds: (this: *btDispatcher) -> s32 #cpp_method;

    getManifoldByIndexInternal: (this: *btDispatcher, index: s32) -> *btPersistentManifold #cpp_method;

    getInternalManifoldPointer: (this: *btDispatcher) -> **btPersistentManifold #cpp_method;

    getInternalManifoldPool_1: (this: /*const*/ *btDispatcher) -> *btPoolAllocator #cpp_method;

    getInternalManifoldPool: (this: *btDispatcher) -> *btPoolAllocator #cpp_method;

    allocateCollisionAlgorithm: (this: *btDispatcher, size: s32) -> *void #cpp_method;

    freeCollisionAlgorithm: (this: *btDispatcher, ptr: *void) -> void #cpp_method;
}

btDispatcher_Destructor :: inline (this: *btDispatcher, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btDispatcher_findAlgorithm :: inline (this: *btDispatcher, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, sharedManifold: *btPersistentManifold, queryType: ebtDispatcherQueryType) -> *btCollisionAlgorithm { return this.vtable.findAlgorithm(this, body0Wrap, body1Wrap, sharedManifold, queryType); }

btDispatcher_getNewManifold :: inline (this: *btDispatcher, b0: *btCollisionObject, b1: *btCollisionObject) -> *btPersistentManifold { return this.vtable.getNewManifold(this, b0, b1); }

btDispatcher_releaseManifold :: inline (this: *btDispatcher, manifold: *btPersistentManifold) { this.vtable.releaseManifold(this, manifold); }

btDispatcher_clearManifold :: inline (this: *btDispatcher, manifold: *btPersistentManifold) { this.vtable.clearManifold(this, manifold); }

btDispatcher_needsCollision :: inline (this: *btDispatcher, body0: *btCollisionObject, body1: *btCollisionObject) -> bool { return this.vtable.needsCollision(this, body0, body1); }

btDispatcher_needsResponse :: inline (this: *btDispatcher, body0: *btCollisionObject, body1: *btCollisionObject) -> bool { return this.vtable.needsResponse(this, body0, body1); }

btDispatcher_dispatchAllCollisionPairs :: inline (this: *btDispatcher, pairCache: *btOverlappingPairCache, dispatchInfo: *btDispatcherInfo, dispatcher: *btDispatcher) { this.vtable.dispatchAllCollisionPairs(this, pairCache, dispatchInfo, dispatcher); }

btDispatcher_getNumManifolds :: inline (this: *btDispatcher) -> s32 { return this.vtable.getNumManifolds(this); }

btDispatcher_getManifoldByIndexInternal :: inline (this: *btDispatcher, index: s32) -> *btPersistentManifold { return this.vtable.getManifoldByIndexInternal(this, index); }

btDispatcher_getInternalManifoldPointer :: inline (this: *btDispatcher) -> **btPersistentManifold { return this.vtable.getInternalManifoldPointer(this); }

btDispatcher_getInternalManifoldPool_1 :: inline (this: /*const*/ *btDispatcher) -> *btPoolAllocator { return this.vtable.getInternalManifoldPool_1(this); }

btDispatcher_getInternalManifoldPool :: inline (this: *btDispatcher) -> *btPoolAllocator { return this.vtable.getInternalManifoldPool(this); }

btDispatcher_allocateCollisionAlgorithm :: inline (this: *btDispatcher, size: s32) -> *void { return this.vtable.allocateCollisionAlgorithm(this, size); }

btDispatcher_freeCollisionAlgorithm :: inline (this: *btDispatcher, ptr: *void) { this.vtable.freeCollisionAlgorithm(this, ptr); }



/// Utils related to temporal transforms
btTransformUtil :: struct {
    integrateTransform :: (curTrans: *btTransform, linvel: *btVector3, angvel: *btVector3, timeStep: btScalar, predictedTransform: *btTransform) -> void #foreign bullet3 "?integrateTransform@btTransformUtil@@SAXAEBVbtTransform@@AEBVbtVector3@@1MAEAV2@@Z";
    integrateTransform :: (curTrans: btTransform, linvel: btVector3, angvel: btVector3, timeStep: btScalar, predictedTransform: *btTransform) #no_context {
        integrateTransform(*curTrans, *linvel, *angvel, timeStep, predictedTransform);
    }

    calculateVelocityQuaternion :: (pos0: *btVector3, pos1: *btVector3, orn0: *btQuaternion, orn1: *btQuaternion, timeStep: btScalar, linVel: *btVector3, angVel: *btVector3) -> void #foreign bullet3 "?calculateVelocityQuaternion@btTransformUtil@@SAXAEBVbtVector3@@0AEBVbtQuaternion@@1MAEAV2@2@Z";
    calculateVelocityQuaternion :: (pos0: btVector3, pos1: btVector3, orn0: btQuaternion, orn1: btQuaternion, timeStep: btScalar, linVel: *btVector3, angVel: *btVector3) #no_context {
        calculateVelocityQuaternion(*pos0, *pos1, *orn0, *orn1, timeStep, linVel, angVel);
    }

    calculateDiffAxisAngleQuaternion :: (orn0: *btQuaternion, orn1a: *btQuaternion, axis: *btVector3, angle: *btScalar) -> void #foreign bullet3 "?calculateDiffAxisAngleQuaternion@btTransformUtil@@SAXAEBVbtQuaternion@@0AEAVbtVector3@@AEAM@Z";
    calculateDiffAxisAngleQuaternion :: (orn0: btQuaternion, orn1a: btQuaternion, axis: *btVector3, angle: *btScalar) #no_context {
        calculateDiffAxisAngleQuaternion(*orn0, *orn1a, axis, angle);
    }

    calculateVelocity :: (transform0: *btTransform, transform1: *btTransform, timeStep: btScalar, linVel: *btVector3, angVel: *btVector3) -> void #foreign bullet3 "?calculateVelocity@btTransformUtil@@SAXAEBVbtTransform@@0MAEAVbtVector3@@1@Z";
    calculateVelocity :: (transform0: btTransform, transform1: btTransform, timeStep: btScalar, linVel: *btVector3, angVel: *btVector3) #no_context {
        calculateVelocity(*transform0, *transform1, timeStep, linVel, angVel);
    }

    calculateDiffAxisAngle :: (transform0: *btTransform, transform1: *btTransform, axis: *btVector3, angle: *btScalar) -> void #foreign bullet3 "?calculateDiffAxisAngle@btTransformUtil@@SAXAEBVbtTransform@@0AEAVbtVector3@@AEAM@Z";
    calculateDiffAxisAngle :: (transform0: btTransform, transform1: btTransform, axis: *btVector3, angle: *btScalar) #no_context {
        calculateDiffAxisAngle(*transform0, *transform1, axis, angle);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///The btConvexSeparatingDistanceUtil can help speed up convex collision detection
///by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
btConvexSeparatingDistanceUtil :: struct {
    m_ornA:               btQuaternion;
    m_ornB:               btQuaternion;
    m_posA:               btVector3;
    m_posB:               btVector3;

    m_separatingNormal:   btVector3;

    m_boundingRadiusA:    btScalar;
    m_boundingRadiusB:    btScalar;
    m_separatingDistance: btScalar;

    Constructor :: (this: *btConvexSeparatingDistanceUtil, boundingRadiusA: btScalar, boundingRadiusB: btScalar) -> void #cpp_method #foreign bullet3 "??0btConvexSeparatingDistanceUtil@@QEAA@MM@Z";

    getConservativeSeparatingDistance :: (this: *btConvexSeparatingDistanceUtil) -> btScalar #cpp_method #foreign bullet3 "?getConservativeSeparatingDistance@btConvexSeparatingDistanceUtil@@QEAAMXZ";

    updateSeparatingDistance :: (this: *btConvexSeparatingDistanceUtil, transA: *btTransform, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?updateSeparatingDistance@btConvexSeparatingDistanceUtil@@QEAAXAEBVbtTransform@@0@Z";
    updateSeparatingDistance :: (this: *btConvexSeparatingDistanceUtil, transA: btTransform, transB: btTransform) #no_context {
        updateSeparatingDistance(this, *transA, *transB);
    }

    initSeparatingDistance :: (this: *btConvexSeparatingDistanceUtil, separatingVector: *btVector3, separatingDistance: btScalar, transA: *btTransform, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?initSeparatingDistance@btConvexSeparatingDistanceUtil@@QEAAXAEBVbtVector3@@MAEBVbtTransform@@1@Z";
    initSeparatingDistance :: (this: *btConvexSeparatingDistanceUtil, separatingVector: btVector3, separatingDistance: btScalar, transA: btTransform, transB: btTransform) #no_context {
        initSeparatingDistance(this, *separatingVector, separatingDistance, *transA, *transB);
    }
}

// Don't change following order of parameters
btConstraintRow :: struct {
    m_normal:       [3] btScalar;
    m_rhs:          btScalar;
    m_jacDiagInv:   btScalar;
    m_lowerLimit:   btScalar;
    m_upperLimit:   btScalar;
    m_accumImpulse: btScalar;
}

PfxConstraintRow :: btConstraintRow;

btContactPointFlags :: enum s32 {
    LATERAL_FRICTION_INITIALIZED :: 1;
    HAS_CONTACT_CFM              :: 2;
    HAS_CONTACT_ERP              :: 4;
    CONTACT_STIFFNESS_DAMPING    :: 8;
    FRICTION_ANCHOR              :: 16;

    BT_CONTACT_FLAG_LATERAL_FRICTION_INITIALIZED :: LATERAL_FRICTION_INITIALIZED;
    BT_CONTACT_FLAG_HAS_CONTACT_CFM              :: HAS_CONTACT_CFM;
    BT_CONTACT_FLAG_HAS_CONTACT_ERP              :: HAS_CONTACT_ERP;
    BT_CONTACT_FLAG_CONTACT_STIFFNESS_DAMPING    :: CONTACT_STIFFNESS_DAMPING;
    BT_CONTACT_FLAG_FRICTION_ANCHOR              :: FRICTION_ANCHOR;
}

/// ManifoldContactPoint collects and maintains persistent contactpoints.
/// used to improve stability and performance of rigidbody dynamics response.
btManifoldPoint :: struct {
    Constructor :: (this: *btManifoldPoint) -> void #cpp_method #foreign bullet3 "??0btManifoldPoint@@QEAA@XZ";

    Constructor :: (this: *btManifoldPoint, pointA: *btVector3, pointB: *btVector3, normal: *btVector3, distance: btScalar) -> void #cpp_method #foreign bullet3 "??0btManifoldPoint@@QEAA@AEBVbtVector3@@00M@Z";
    Constructor :: (this: *btManifoldPoint, pointA: btVector3, pointB: btVector3, normal: btVector3, distance: btScalar) #no_context {
        Constructor(this, *pointA, *pointB, *normal, distance);
    }

    m_localPointA:              btVector3;
    m_localPointB:              btVector3;
    m_positionWorldOnB:         btVector3;

    ///m_positionWorldOnA is redundant information, see getPositionWorldOnA(), but for clarity
    m_positionWorldOnA:         btVector3;
    m_normalWorldOnB:           btVector3;

    m_distance1:                btScalar;
    m_combinedFriction:         btScalar;
    m_combinedRollingFriction:  btScalar; //torsional friction orthogonal to contact normal, useful to make spheres stop rolling forever
    m_combinedSpinningFriction: btScalar; //torsional friction around contact normal, useful for grasping objects
    m_combinedRestitution:      btScalar;

    //BP mod, store contact triangles.
    m_partId0:                  s32;
    m_partId1:                  s32;
    m_index0:                   s32;
    m_index1:                   s32;

    m_userPersistentData:       *void;

    //bool			m_lateralFrictionInitialized;
    m_contactPointFlags:        s32;

    m_appliedImpulse:           btScalar;
    m_prevRHS:                  btScalar;
    m_appliedImpulseLateral1:   btScalar;
    m_appliedImpulseLateral2:   btScalar;
    m_contactMotion1:           btScalar;
    m_contactMotion2:           btScalar;

    union {
        m_contactCFM:                btScalar;
        m_combinedContactStiffness1: btScalar;
    }

    union {
        m_contactERP:              btScalar;
        m_combinedContactDamping1: btScalar;
    }

    m_frictionCFM:              btScalar;

    m_lifeTime:                 s32; //lifetime of the contactpoint in frames

    m_lateralFrictionDir1:      btVector3 #align 8;
    m_lateralFrictionDir2:      btVector3;

    getDistance :: (this: *btManifoldPoint) -> btScalar #cpp_method #foreign bullet3 "?getDistance@btManifoldPoint@@QEBAMXZ";

    getLifeTime :: (this: *btManifoldPoint) -> s32 #cpp_method #foreign bullet3 "?getLifeTime@btManifoldPoint@@QEBAHXZ";

    getPositionWorldOnA :: (this: *btManifoldPoint) -> *btVector3 #cpp_method #foreign bullet3 "?getPositionWorldOnA@btManifoldPoint@@QEBAAEBVbtVector3@@XZ";

    getPositionWorldOnB :: (this: *btManifoldPoint) -> *btVector3 #cpp_method #foreign bullet3 "?getPositionWorldOnB@btManifoldPoint@@QEBAAEBVbtVector3@@XZ";

    setDistance :: (this: *btManifoldPoint, dist: btScalar) -> void #cpp_method #foreign bullet3 "?setDistance@btManifoldPoint@@QEAAXM@Z";

    ///this returns the most recent applied impulse, to satisfy contact constraints by the constraint solver
    getAppliedImpulse :: (this: *btManifoldPoint) -> btScalar #cpp_method #foreign bullet3 "?getAppliedImpulse@btManifoldPoint@@QEBAMXZ";
}

btCollisionResult :: struct {}

ContactDestroyedCallback :: #type (userPersistentData: *void) -> bool #c_call;
ContactProcessedCallback :: #type (cp: *btManifoldPoint, body0: *void, body1: *void) -> bool #c_call;
ContactStartedCallback :: #type (manifold: **btPersistentManifold) -> void #c_call;
ContactEndedCallback :: #type (manifold: **btPersistentManifold) -> void #c_call;

//the enum starts at 1024 to avoid type conflicts with btTypedConstraint
btContactManifoldTypes :: enum s32 {
    MIN_CONTACT_MANIFOLD_TYPE   :: 1024;
    BT_PERSISTENT_MANIFOLD_TYPE :: 1025;
}

//ATTRIBUTE_ALIGNED128( class) btPersistentManifold : public btTypedObject
btPersistentManifold :: struct {
    #as using bttypedobject: btTypedObject;

    m_pointCache:                 [4] btManifoldPoint;

    /// this two body pointers can point to the physics rigidbody class.
    m_body0:                      *btCollisionObject;
    m_body1:                      *btCollisionObject;

    m_cachedPoints:               s32;

    m_contactBreakingThreshold:   btScalar;
    m_contactProcessingThreshold: btScalar;

    /// sort cached points so most isolated points come first
    sortCachedPoints :: (this: *btPersistentManifold, pt: *btManifoldPoint) -> s32 #cpp_method #foreign bullet3 "?sortCachedPoints@btPersistentManifold@@AEAAHAEBVbtManifoldPoint@@@Z";
    sortCachedPoints :: (this: *btPersistentManifold, pt: btManifoldPoint) -> s32 #no_context {
        return sortCachedPoints(this, *pt);
    }

    m_companionIdA:               s32;
    m_companionIdB:               s32;

    m_index1a:                    s32;

    Constructor :: (this: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "??0btPersistentManifold@@QEAA@XZ";

    Constructor :: (this: *btPersistentManifold, body0: *btCollisionObject, body1: *btCollisionObject, unknown0: s32, contactBreakingThreshold: btScalar, contactProcessingThreshold: btScalar) -> void #cpp_method #foreign bullet3 "??0btPersistentManifold@@QEAA@PEBVbtCollisionObject@@0HMM@Z";

    getBody0 :: (this: *btPersistentManifold) -> *btCollisionObject #cpp_method #foreign bullet3 "?getBody0@btPersistentManifold@@QEBAPEBVbtCollisionObject@@XZ";
    getBody1 :: (this: *btPersistentManifold) -> *btCollisionObject #cpp_method #foreign bullet3 "?getBody1@btPersistentManifold@@QEBAPEBVbtCollisionObject@@XZ";

    setBodies :: (this: *btPersistentManifold, body0: *btCollisionObject, body1: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?setBodies@btPersistentManifold@@QEAAXPEBVbtCollisionObject@@0@Z";

    clearUserCache :: (this: *btPersistentManifold, pt: *btManifoldPoint) -> void #cpp_method #foreign bullet3 "?clearUserCache@btPersistentManifold@@QEAAXAEAVbtManifoldPoint@@@Z";

    getNumContacts :: (this: *btPersistentManifold) -> s32 #cpp_method #foreign bullet3 "?getNumContacts@btPersistentManifold@@QEBAHXZ";

    /// the setNumContacts API is usually not used, except when you gather/fill all contacts manually
    setNumContacts :: (this: *btPersistentManifold, cachedPoints: s32) -> void #cpp_method #foreign bullet3 "?setNumContacts@btPersistentManifold@@QEAAXH@Z";

    getContactPoint :: (this: /*const*/ *btPersistentManifold, index: s32) -> *btManifoldPoint #cpp_method #foreign bullet3 "?getContactPoint@btPersistentManifold@@QEBAAEBVbtManifoldPoint@@H@Z";

    getContactPoint_1 :: (this: *btPersistentManifold, index: s32) -> *btManifoldPoint #cpp_method #foreign bullet3 "?getContactPoint@btPersistentManifold@@QEAAAEAVbtManifoldPoint@@H@Z";

    ///@todo: get this margin from the current physics / collision environment
    getContactBreakingThreshold :: (this: *btPersistentManifold) -> btScalar #cpp_method #foreign bullet3 "?getContactBreakingThreshold@btPersistentManifold@@QEBAMXZ";

    getContactProcessingThreshold :: (this: *btPersistentManifold) -> btScalar #cpp_method #foreign bullet3 "?getContactProcessingThreshold@btPersistentManifold@@QEBAMXZ";

    setContactBreakingThreshold :: (this: *btPersistentManifold, contactBreakingThreshold: btScalar) -> void #cpp_method #foreign bullet3 "?setContactBreakingThreshold@btPersistentManifold@@QEAAXM@Z";

    setContactProcessingThreshold :: (this: *btPersistentManifold, contactProcessingThreshold: btScalar) -> void #cpp_method #foreign bullet3 "?setContactProcessingThreshold@btPersistentManifold@@QEAAXM@Z";

    getCacheEntry :: (this: *btPersistentManifold, newPoint: *btManifoldPoint) -> s32 #cpp_method #foreign bullet3 "?getCacheEntry@btPersistentManifold@@QEBAHAEBVbtManifoldPoint@@@Z";
    getCacheEntry :: (this: *btPersistentManifold, newPoint: btManifoldPoint) -> s32 #no_context {
        return getCacheEntry(this, *newPoint);
    }

    addManifoldPoint :: (this: *btPersistentManifold, newPoint: *btManifoldPoint, isPredictive := false) -> s32 #cpp_method #foreign bullet3 "?addManifoldPoint@btPersistentManifold@@QEAAHAEBVbtManifoldPoint@@_N@Z";
    addManifoldPoint :: (this: *btPersistentManifold, newPoint: btManifoldPoint, isPredictive := false) -> s32 #no_context {
        return addManifoldPoint(this, *newPoint, isPredictive);
    }

    removeContactPoint :: (this: *btPersistentManifold, index: s32) -> void #cpp_method #foreign bullet3 "?removeContactPoint@btPersistentManifold@@QEAAXH@Z";

    replaceContactPoint :: (this: *btPersistentManifold, newPoint: *btManifoldPoint, insertIndex: s32) -> void #cpp_method #foreign bullet3 "?replaceContactPoint@btPersistentManifold@@QEAAXAEBVbtManifoldPoint@@H@Z";
    replaceContactPoint :: (this: *btPersistentManifold, newPoint: btManifoldPoint, insertIndex: s32) #no_context {
        replaceContactPoint(this, *newPoint, insertIndex);
    }

    validContactDistance :: (this: *btPersistentManifold, pt: *btManifoldPoint) -> bool #cpp_method #foreign bullet3 "?validContactDistance@btPersistentManifold@@QEBA_NAEBVbtManifoldPoint@@@Z";
    validContactDistance :: (this: *btPersistentManifold, pt: btManifoldPoint) -> bool #no_context {
        return validContactDistance(this, *pt);
    }

    /// calculated new worldspace coordinates and depth, and reject points that exceed the collision margin
    refreshContactPoints :: (this: *btPersistentManifold, trA: *btTransform, trB: *btTransform) -> void #cpp_method #foreign bullet3 "?refreshContactPoints@btPersistentManifold@@QEAAXAEBVbtTransform@@0@Z";
    refreshContactPoints :: (this: *btPersistentManifold, trA: btTransform, trB: btTransform) #no_context {
        refreshContactPoints(this, *trA, *trB);
    }

    clearManifold :: (this: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "?clearManifold@btPersistentManifold@@QEAAXXZ";

    calculateSerializeBufferSize :: (this: *btPersistentManifold) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btPersistentManifold@@QEBAHXZ";
    serialize :: (this: *btPersistentManifold, manifold: *btPersistentManifold, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btPersistentManifold@@QEBAPEBDPEBV1@PEAXPEAVbtSerializer@@@Z";
    deSerialize :: (this: *btPersistentManifold, manifoldDataPtr: *btPersistentManifoldDoubleData) -> void #cpp_method #foreign bullet3 "?deSerialize@btPersistentManifold@@QEAAXPEBUbtPersistentManifoldDoubleData@@@Z";
    deSerialize :: (this: *btPersistentManifold, manifoldDataPtr: *btPersistentManifoldFloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@btPersistentManifold@@QEAAXPEBUbtPersistentManifoldFloatData@@@Z";
}


// clang-format off
btPersistentManifoldDoubleData :: struct {
    m_pointCacheLocalPointA:               [4] btVector3DoubleData;
    m_pointCacheLocalPointB:               [4] btVector3DoubleData;
    m_pointCachePositionWorldOnA:          [4] btVector3DoubleData;
    m_pointCachePositionWorldOnB:          [4] btVector3DoubleData;
    m_pointCacheNormalWorldOnB:            [4] btVector3DoubleData;
    m_pointCacheLateralFrictionDir1:       [4] btVector3DoubleData;
    m_pointCacheLateralFrictionDir2:       [4] btVector3DoubleData;
    m_pointCacheDistance:                  [4] float64;
    m_pointCacheAppliedImpulse:            [4] float64;
    m_pointCachePrevRHS:                   [4] float64;
    m_pointCacheCombinedFriction:          [4] float64;
    m_pointCacheCombinedRollingFriction:   [4] float64;
    m_pointCacheCombinedSpinningFriction:  [4] float64;
    m_pointCacheCombinedRestitution:       [4] float64;
    m_pointCachePartId0:                   [4] s32;
    m_pointCachePartId1:                   [4] s32;
    m_pointCacheIndex0:                    [4] s32;
    m_pointCacheIndex1:                    [4] s32;
    m_pointCacheContactPointFlags:         [4] s32;
    m_pointCacheAppliedImpulseLateral1:    [4] float64;
    m_pointCacheAppliedImpulseLateral2:    [4] float64;
    m_pointCacheContactMotion1:            [4] float64;
    m_pointCacheContactMotion2:            [4] float64;
    m_pointCacheContactCFM:                [4] float64;
    m_pointCacheCombinedContactStiffness1: [4] float64;
    m_pointCacheContactERP:                [4] float64;
    m_pointCacheCombinedContactDamping1:   [4] float64;
    m_pointCacheFrictionCFM:               [4] float64;
    m_pointCacheLifeTime:                  [4] s32;

    m_numCachedPoints:                     s32;
    m_companionIdA:                        s32;
    m_companionIdB:                        s32;
    m_index1a:                             s32;

    m_objectType:                          s32;
    m_contactBreakingThreshold:            float64;
    m_contactProcessingThreshold:          float64;
    m_padding:                             s32;

    m_body0:                               *btCollisionObjectDoubleData;
    m_body1:                               *btCollisionObjectDoubleData;
}

btPersistentManifoldFloatData :: struct {
    m_pointCacheLocalPointA:               [4] btVector3FloatData;
    m_pointCacheLocalPointB:               [4] btVector3FloatData;
    m_pointCachePositionWorldOnA:          [4] btVector3FloatData;
    m_pointCachePositionWorldOnB:          [4] btVector3FloatData;
    m_pointCacheNormalWorldOnB:            [4] btVector3FloatData;
    m_pointCacheLateralFrictionDir1:       [4] btVector3FloatData;
    m_pointCacheLateralFrictionDir2:       [4] btVector3FloatData;
    m_pointCacheDistance:                  [4] float;
    m_pointCacheAppliedImpulse:            [4] float;
    m_pointCachePrevRHS:                   [4] float;
    m_pointCacheCombinedFriction:          [4] float;
    m_pointCacheCombinedRollingFriction:   [4] float;
    m_pointCacheCombinedSpinningFriction:  [4] float;
    m_pointCacheCombinedRestitution:       [4] float;
    m_pointCachePartId0:                   [4] s32;
    m_pointCachePartId1:                   [4] s32;
    m_pointCacheIndex0:                    [4] s32;
    m_pointCacheIndex1:                    [4] s32;
    m_pointCacheContactPointFlags:         [4] s32;
    m_pointCacheAppliedImpulseLateral1:    [4] float;
    m_pointCacheAppliedImpulseLateral2:    [4] float;
    m_pointCacheContactMotion1:            [4] float;
    m_pointCacheContactMotion2:            [4] float;
    m_pointCacheContactCFM:                [4] float;
    m_pointCacheCombinedContactStiffness1: [4] float;
    m_pointCacheContactERP:                [4] float;
    m_pointCacheCombinedContactDamping1:   [4] float;
    m_pointCacheFrictionCFM:               [4] float;
    m_pointCacheLifeTime:                  [4] s32;

    m_numCachedPoints:                     s32;
    m_companionIdA:                        s32;
    m_companionIdB:                        s32;
    m_index1a:                             s32;

    m_objectType:                          s32;
    m_contactBreakingThreshold:            float;
    m_contactProcessingThreshold:          float;
    m_padding:                             s32;

    m_body0:                               *btCollisionObjectFloatData;
    m_body1:                               *btCollisionObjectFloatData;
}

/// This interface is made to be used by an iterative approach to do TimeOfImpact calculations
/// This interface allows to query for closest points and penetration depth between two (convex) objects
/// the closest point is on the second object (B), and the normal points from the surface on B towards A.
/// distance is between closest points on B and closest point on A. So you can calculate closest point on A
/// by taking closestPointInA = closestPointInB + m_distance * m_normalOnSurfaceB
btDiscreteCollisionDetectorInterface :: struct {
    vtable: *btDiscreteCollisionDetectorInterface_VTable;
    Result :: struct {
        vtable: *Result_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *Result, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1Result@btDiscreteCollisionDetectorInterface@@UEAA@XZ";
    }
    Result_VTable :: struct #type_info_none {
        Destructor: (this: *Result, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        setShapeIdentifiersA: (this: *Result, partId0: s32, index0: s32) -> void #cpp_method;
        setShapeIdentifiersB: (this: *Result, partId1: s32, index1: s32) -> void #cpp_method;
        addContactPoint: (this: *Result, normalOnBInWorld: *btVector3, pointInWorld: *btVector3, depth: btScalar) -> void #cpp_method;
    }

    Result_Destructor :: inline (this: *Result, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    Result_setShapeIdentifiersA :: inline (this: *Result, partId0: s32, index0: s32) { this.vtable.setShapeIdentifiersA(this, partId0, index0); }
    Result_setShapeIdentifiersB :: inline (this: *Result, partId1: s32, index1: s32) { this.vtable.setShapeIdentifiersB(this, partId1, index1); }
    Result_addContactPoint :: inline (this: *Result, normalOnBInWorld: *btVector3, pointInWorld: *btVector3, depth: btScalar) { this.vtable.addContactPoint(this, normalOnBInWorld, pointInWorld, depth); }


    ClosestPointInput :: struct {
        Constructor :: (this: *ClosestPointInput) -> void #cpp_method #foreign bullet3 "??0ClosestPointInput@btDiscreteCollisionDetectorInterface@@QEAA@XZ";

        m_transformA:             btTransform;
        m_transformB:             btTransform;
        m_maximumDistanceSquared: btScalar;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDiscreteCollisionDetectorInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDiscreteCollisionDetectorInterface@@UEAA@XZ";
}
btDiscreteCollisionDetectorInterface_VTable :: struct #type_info_none {
    Destructor: (this: *btDiscreteCollisionDetectorInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getClosestPoints: (this: *btDiscreteCollisionDetectorInterface, input: *btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw, swapResults := false) -> void #cpp_method;
}

btDiscreteCollisionDetectorInterface_Destructor :: inline (this: *btDiscreteCollisionDetectorInterface, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btDiscreteCollisionDetectorInterface_getClosestPoints :: inline (this: *btDiscreteCollisionDetectorInterface, input: *btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw, swapResults := false) { this.vtable.getClosestPoints(this, input, output, debugDraw, swapResults); }



btStorageResult :: struct {
    #as using result: btDiscreteCollisionDetectorInterface.Result;

    m_normalOnSurfaceB: btVector3;
    m_closestPointInB:  btVector3;
    m_distance:         btScalar; //negative means penetration !

    Constructor :: (this: *btStorageResult) -> void #cpp_method #foreign bullet3 "??0btStorageResult@@IEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btStorageResult, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btStorageResult@@UEAA@XZ";

    virtual_addContactPoint :: (this: *btStorageResult, normalOnBInWorld: *btVector3, pointInWorld: *btVector3, depth: btScalar) -> void #cpp_method #foreign bullet3 "?addContactPoint@btStorageResult@@UEAAXAEBVbtVector3@@0M@Z";
}

btCollisionObjectWrapper :: struct {
    m_parent:          *btCollisionObjectWrapper;
    m_shape:           *btCollisionShape;
    m_collisionObject: *btCollisionObject;
    m_worldTransform:  *btTransform;
    m_preTransform:    *btTransform;
    m_partId:          s32;
    m_index:           s32;

    Constructor :: (this: *btCollisionObjectWrapper, parent: *btCollisionObjectWrapper, shape: *btCollisionShape, collisionObject: *btCollisionObject, worldTransform: *btTransform, partId: s32, index: s32) -> void #cpp_method #foreign bullet3 "??0btCollisionObjectWrapper@@QEAA@PEBU0@PEBVbtCollisionShape@@PEBVbtCollisionObject@@AEBVbtTransform@@HH@Z";
    Constructor :: (this: *btCollisionObjectWrapper, parent: *btCollisionObjectWrapper, shape: *btCollisionShape, collisionObject: *btCollisionObject, worldTransform: btTransform, partId: s32, index: s32) #no_context {
        Constructor(this, parent, shape, collisionObject, *worldTransform, partId, index);
    }

    Constructor :: (this: *btCollisionObjectWrapper, parent: *btCollisionObjectWrapper, shape: *btCollisionShape, collisionObject: *btCollisionObject, worldTransform: *btTransform, preTransform: *btTransform, partId: s32, index: s32) -> void #cpp_method #foreign bullet3 "??0btCollisionObjectWrapper@@QEAA@PEBU0@PEBVbtCollisionShape@@PEBVbtCollisionObject@@AEBVbtTransform@@3HH@Z";
    Constructor :: (this: *btCollisionObjectWrapper, parent: *btCollisionObjectWrapper, shape: *btCollisionShape, collisionObject: *btCollisionObject, worldTransform: btTransform, preTransform: btTransform, partId: s32, index: s32) #no_context {
        Constructor(this, parent, shape, collisionObject, *worldTransform, *preTransform, partId, index);
    }

    getWorldTransform :: (this: *btCollisionObjectWrapper) -> *btTransform #cpp_method #foreign bullet3 "?getWorldTransform@btCollisionObjectWrapper@@QEBAAEBVbtTransform@@XZ";
    getCollisionObject :: (this: *btCollisionObjectWrapper) -> *btCollisionObject #cpp_method #foreign bullet3 "?getCollisionObject@btCollisionObjectWrapper@@QEBAPEBVbtCollisionObject@@XZ";
    getCollisionShape :: (this: *btCollisionObjectWrapper) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShape@btCollisionObjectWrapper@@QEBAPEBVbtCollisionShape@@XZ";
}

ContactAddedCallback :: #type (cp: *btManifoldPoint, colObj0Wrap: *btCollisionObjectWrapper, partId0: s32, index0: s32, colObj1Wrap: *btCollisionObjectWrapper, partId1: s32, index1: s32) -> bool #c_call;

/// These callbacks are used to customize the algorith that combine restitution, friction, damping, Stiffness
CalculateCombinedCallback :: #type (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #c_call;

///btManifoldResult is a helper class to manage  contact results.
btManifoldResult :: struct {
    #as using result: btDiscreteCollisionDetectorInterface.Result;

    m_manifoldPtr:                   *btPersistentManifold;

    m_body0Wrap:                     *btCollisionObjectWrapper;
    m_body1Wrap:                     *btCollisionObjectWrapper;
    m_partId0:                       s32;
    m_partId1:                       s32;
    m_index0:                        s32;
    m_index1:                        s32;

    Constructor :: (this: *btManifoldResult) -> void #cpp_method #foreign bullet3 "??0btManifoldResult@@QEAA@XZ";

    Constructor :: (this: *btManifoldResult, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btManifoldResult@@QEAA@PEBUbtCollisionObjectWrapper@@0@Z";

    setPersistentManifold :: (this: *btManifoldResult, manifoldPtr: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "?setPersistentManifold@btManifoldResult@@QEAAXPEAVbtPersistentManifold@@@Z";

    getPersistentManifold :: (this: /*const*/ *btManifoldResult) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getPersistentManifold@btManifoldResult@@QEBAPEBVbtPersistentManifold@@XZ";

    getPersistentManifold_1 :: (this: *btManifoldResult) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getPersistentManifold@btManifoldResult@@QEAAPEAVbtPersistentManifold@@XZ";

    refreshContactPoints :: (this: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?refreshContactPoints@btManifoldResult@@QEAAXXZ";

    getBody0Wrap :: (this: *btManifoldResult) -> *btCollisionObjectWrapper #cpp_method #foreign bullet3 "?getBody0Wrap@btManifoldResult@@QEBAPEBUbtCollisionObjectWrapper@@XZ";

    getBody1Wrap :: (this: *btManifoldResult) -> *btCollisionObjectWrapper #cpp_method #foreign bullet3 "?getBody1Wrap@btManifoldResult@@QEBAPEBUbtCollisionObjectWrapper@@XZ";

    setBody0Wrap :: (this: *btManifoldResult, obj0Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?setBody0Wrap@btManifoldResult@@QEAAXPEBUbtCollisionObjectWrapper@@@Z";

    setBody1Wrap :: (this: *btManifoldResult, obj1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?setBody1Wrap@btManifoldResult@@QEAAXPEBUbtCollisionObjectWrapper@@@Z";

    getBody0Internal :: (this: *btManifoldResult) -> *btCollisionObject #cpp_method #foreign bullet3 "?getBody0Internal@btManifoldResult@@QEBAPEBVbtCollisionObject@@XZ";

    getBody1Internal :: (this: *btManifoldResult) -> *btCollisionObject #cpp_method #foreign bullet3 "?getBody1Internal@btManifoldResult@@QEBAPEBVbtCollisionObject@@XZ";

    m_closestPointDistanceThreshold: btScalar;

    /// in the future we can let the user override the methods to combine restitution and friction
    calculateCombinedRestitution :: (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #foreign bullet3 "?calculateCombinedRestitution@btManifoldResult@@SAMPEBVbtCollisionObject@@0@Z";
    calculateCombinedFriction :: (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #foreign bullet3 "?calculateCombinedFriction@btManifoldResult@@SAMPEBVbtCollisionObject@@0@Z";
    calculateCombinedRollingFriction :: (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #foreign bullet3 "?calculateCombinedRollingFriction@btManifoldResult@@SAMPEBVbtCollisionObject@@0@Z";
    calculateCombinedSpinningFriction :: (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #foreign bullet3 "?calculateCombinedSpinningFriction@btManifoldResult@@SAMPEBVbtCollisionObject@@0@Z";
    calculateCombinedContactDamping :: (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #foreign bullet3 "?calculateCombinedContactDamping@btManifoldResult@@SAMPEBVbtCollisionObject@@0@Z";
    calculateCombinedContactStiffness :: (body0: *btCollisionObject, body1: *btCollisionObject) -> btScalar #foreign bullet3 "?calculateCombinedContactStiffness@btManifoldResult@@SAMPEBVbtCollisionObject@@0@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btManifoldResult, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btManifoldResult@@UEAA@XZ";

    virtual_setShapeIdentifiersA :: (this: *btManifoldResult, partId0: s32, index0: s32) -> void #cpp_method #foreign bullet3 "?setShapeIdentifiersA@btManifoldResult@@UEAAXHH@Z";

    virtual_setShapeIdentifiersB :: (this: *btManifoldResult, partId1: s32, index1: s32) -> void #cpp_method #foreign bullet3 "?setShapeIdentifiersB@btManifoldResult@@UEAAXHH@Z";

    virtual_addContactPoint :: (this: *btManifoldResult, normalOnBInWorld: *btVector3, pointInWorld: *btVector3, depth: btScalar) -> void #cpp_method #foreign bullet3 "?addContactPoint@btManifoldResult@@UEAAXAEBVbtVector3@@0M@Z";
}

/// btDispatcher uses these types
/// IMPORTANT NOTE:The types are ordered polyhedral, implicit convex and concave
/// to facilitate type checking
/// CUSTOM_POLYHEDRAL_SHAPE_TYPE,CUSTOM_CONVEX_SHAPE_TYPE and CUSTOM_CONCAVE_SHAPE_TYPE can be used to extend Bullet without modifying source code
BroadphaseNativeTypes :: enum s32 {
    BOX_SHAPE_PROXYTYPE                    :: 0;
    TRIANGLE_SHAPE_PROXYTYPE               :: 1;
    TETRAHEDRAL_SHAPE_PROXYTYPE            :: 2;
    CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE    :: 3;
    CONVEX_HULL_SHAPE_PROXYTYPE            :: 4;
    CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE     :: 5;
    CUSTOM_POLYHEDRAL_SHAPE_TYPE           :: 6;

    IMPLICIT_CONVEX_SHAPES_START_HERE      :: 7;
    SPHERE_SHAPE_PROXYTYPE                 :: 8;
    MULTI_SPHERE_SHAPE_PROXYTYPE           :: 9;
    CAPSULE_SHAPE_PROXYTYPE                :: 10;
    CONE_SHAPE_PROXYTYPE                   :: 11;
    CONVEX_SHAPE_PROXYTYPE                 :: 12;
    CYLINDER_SHAPE_PROXYTYPE               :: 13;
    UNIFORM_SCALING_SHAPE_PROXYTYPE        :: 14;
    MINKOWSKI_SUM_SHAPE_PROXYTYPE          :: 15;
    MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE   :: 16;
    BOX_2D_SHAPE_PROXYTYPE                 :: 17;
    CONVEX_2D_SHAPE_PROXYTYPE              :: 18;
    CUSTOM_CONVEX_SHAPE_TYPE               :: 19;

    CONCAVE_SHAPES_START_HERE              :: 20;

    TRIANGLE_MESH_SHAPE_PROXYTYPE          :: 21;
    SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE   :: 22;

    FAST_CONCAVE_MESH_PROXYTYPE            :: 23;

    TERRAIN_SHAPE_PROXYTYPE                :: 24;

    GIMPACT_SHAPE_PROXYTYPE                :: 25;

    MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE  :: 26;

    EMPTY_SHAPE_PROXYTYPE                  :: 27;
    STATIC_PLANE_PROXYTYPE                 :: 28;
    CUSTOM_CONCAVE_SHAPE_TYPE              :: 29;
    SDF_SHAPE_PROXYTYPE                    :: 29;
    CONCAVE_SHAPES_END_HERE                :: 30;

    COMPOUND_SHAPE_PROXYTYPE               :: 31;

    SOFTBODY_SHAPE_PROXYTYPE               :: 32;
    HFFLUID_SHAPE_PROXYTYPE                :: 33;
    HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE :: 34;
    INVALID_SHAPE_PROXYTYPE                :: 35;

    MAX_BROADPHASE_COLLISION_TYPES         :: 36;
}

///The btBroadphaseProxy is the main class that can be used with the Bullet broadphases.
///It stores collision shape type information, collision filter information and a client object, typically a btCollisionObject or btRigidBody.
btBroadphaseProxy :: struct {
    ///optional filtering to cull potential collisions
    CollisionFilterGroups :: enum s32 {
        DefaultFilter   :: 1;
        StaticFilter    :: 2;
        KinematicFilter :: 4;
        DebrisFilter    :: 8;
        SensorTrigger   :: 16;
        CharacterFilter :: 32;
        AllFilter       :: -1;
    }

    //Usually the client btCollisionObject or Rigidbody class
    m_clientObject:         *void;
    m_collisionFilterGroup: s32;
    m_collisionFilterMask:  s32;

    m_uniqueId:             s32; //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.

    m_aabbMin:              btVector3;
    m_aabbMax:              btVector3;

    getUid :: (this: *btBroadphaseProxy) -> s32 #cpp_method #foreign bullet3 "?getUid@btBroadphaseProxy@@QEBAHXZ";

    //used for memory pools
    Constructor :: (this: *btBroadphaseProxy) -> void #cpp_method #foreign bullet3 "??0btBroadphaseProxy@@QEAA@XZ";

    Constructor :: (this: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> void #cpp_method #foreign bullet3 "??0btBroadphaseProxy@@QEAA@AEBVbtVector3@@0PEAXHH@Z";
    Constructor :: (this: *btBroadphaseProxy, aabbMin: btVector3, aabbMax: btVector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) #no_context {
        Constructor(this, *aabbMin, *aabbMax, userPtr, collisionFilterGroup, collisionFilterMask);
    }

    isPolyhedral :: (proxyType: s32) -> bool #foreign bullet3 "?isPolyhedral@btBroadphaseProxy@@SA_NH@Z";

    isConvex :: (proxyType: s32) -> bool #foreign bullet3 "?isConvex@btBroadphaseProxy@@SA_NH@Z";

    isNonMoving :: (proxyType: s32) -> bool #foreign bullet3 "?isNonMoving@btBroadphaseProxy@@SA_NH@Z";

    isConcave :: (proxyType: s32) -> bool #foreign bullet3 "?isConcave@btBroadphaseProxy@@SA_NH@Z";

    isCompound :: (proxyType: s32) -> bool #foreign bullet3 "?isCompound@btBroadphaseProxy@@SA_NH@Z";

    isSoftBody :: (proxyType: s32) -> bool #foreign bullet3 "?isSoftBody@btBroadphaseProxy@@SA_NH@Z";

    isInfinite :: (proxyType: s32) -> bool #foreign bullet3 "?isInfinite@btBroadphaseProxy@@SA_NH@Z";

    isConvex2d :: (proxyType: s32) -> bool #foreign bullet3 "?isConvex2d@btBroadphaseProxy@@SA_NH@Z";
}

///The btBroadphasePair class contains a pair of aabb-overlapping objects.
///A btDispatcher can search a btCollisionAlgorithm that performs exact/narrowphase collision detection on the actual collision shapes.
btBroadphasePair :: struct {
    Constructor :: (this: *btBroadphasePair) -> void #cpp_method #foreign bullet3 "??0btBroadphasePair@@QEAA@XZ";

    Constructor :: (this: *btBroadphasePair, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> void #cpp_method #foreign bullet3 "??0btBroadphasePair@@QEAA@AEAUbtBroadphaseProxy@@0@Z";

    m_pProxy0:   *btBroadphaseProxy;
    m_pProxy1:   *btBroadphaseProxy;

    m_algorithm: *btCollisionAlgorithm;
    union {
        m_internalInfo1:    *void;
        m_internalTmpValue: s32;
    }
}


/*
//comparison for set operation, see Solid DT_Encounter
SIMD_FORCE_INLINE bool operator<(const btBroadphasePair& a, const btBroadphasePair& b) 
{ 
return a.m_pProxy0 < b.m_pProxy0 || 
(a.m_pProxy0 == b.m_pProxy0 && a.m_pProxy1 < b.m_pProxy1); 
}
*/
btBroadphasePairSortPredicate :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}
operator_parens :: (this: *btBroadphasePairSortPredicate, a: *btBroadphasePair, b: *btBroadphasePair) -> bool #cpp_method #foreign bullet3 "??RbtBroadphasePairSortPredicate@@QEBA_NAEBUbtBroadphasePair@@0@Z";
operator_parens :: (this: btBroadphasePairSortPredicate, a: btBroadphasePair, b: btBroadphasePair) -> bool #no_context {
    return operator_parens(*this, *a, *b);
}

///Used by the btCollisionDispatcher to register and create instances for btCollisionAlgorithm
btCollisionAlgorithmCreateFunc :: struct {
    vtable: *btCollisionAlgorithmCreateFunc_VTable;
    m_swapped: bool;

    Constructor :: (this: *btCollisionAlgorithmCreateFunc) -> void #cpp_method #foreign bullet3 "??0btCollisionAlgorithmCreateFunc@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCollisionAlgorithmCreateFunc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionAlgorithmCreateFunc@@UEAA@XZ";

    virtual_CreateCollisionAlgorithm :: (this: *btCollisionAlgorithmCreateFunc, unknown0: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> *btCollisionAlgorithm #cpp_method #foreign bullet3 "?CreateCollisionAlgorithm@btCollisionAlgorithmCreateFunc@@UEAAPEAVbtCollisionAlgorithm@@AEAUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1@Z";
}
btCollisionAlgorithmCreateFunc_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionAlgorithmCreateFunc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    CreateCollisionAlgorithm: (this: *btCollisionAlgorithmCreateFunc, unknown0: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> *btCollisionAlgorithm #cpp_method;
}

btCollisionAlgorithmCreateFunc_Destructor :: inline (this: *btCollisionAlgorithmCreateFunc, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionAlgorithmCreateFunc_CreateCollisionAlgorithm :: inline (this: *btCollisionAlgorithmCreateFunc, unknown0: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> *btCollisionAlgorithm { return this.vtable.CreateCollisionAlgorithm(this, unknown0, body0Wrap, body1Wrap); }



///user can override this nearcallback for collision filtering and more finegrained control over collision detection
btNearCallback :: #type (collisionPair: *btBroadphasePair, dispatcher: *btCollisionDispatcher, dispatchInfo: *btDispatcherInfo) -> void #c_call;

///btCollisionDispatcher supports algorithms that handle ConvexConvex and ConvexConcave collision pairs.
///Time of Impact, Closest Points and Penetration Depth.
btCollisionDispatcher :: struct {
    #as using btdispatcher: btDispatcher;

    m_dispatcherFlags:                 s32;

    m_manifoldsPtr:                    btAlignedObjectArray(*btPersistentManifold);

    m_nearCallback:                    btNearCallback;

    m_collisionAlgorithmPoolAllocator: *btPoolAllocator;

    m_persistentManifoldPoolAllocator: *btPoolAllocator;

    m_doubleDispatchContactPoints:     [36] [36] *btCollisionAlgorithmCreateFunc;

    m_doubleDispatchClosestPoints:     [36] [36] *btCollisionAlgorithmCreateFunc;

    m_collisionConfiguration:          *btCollisionConfiguration;

    DispatcherFlags :: enum s32 {
        STATIC_STATIC_REPORTED                  :: 1;
        USE_RELATIVE_CONTACT_BREAKING_THRESHOLD :: 2;
        DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION  :: 4;

        CD_STATIC_STATIC_REPORTED                  :: STATIC_STATIC_REPORTED;
        CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD :: USE_RELATIVE_CONTACT_BREAKING_THRESHOLD;
        CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION  :: DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION;
    }

    getDispatcherFlags :: (this: *btCollisionDispatcher) -> s32 #cpp_method #foreign bullet3 "?getDispatcherFlags@btCollisionDispatcher@@QEBAHXZ";

    setDispatcherFlags :: (this: *btCollisionDispatcher, flags: s32) -> void #cpp_method #foreign bullet3 "?setDispatcherFlags@btCollisionDispatcher@@QEAAXH@Z";

    ///registerCollisionCreateFunc allows registration of custom/alternative collision create functions
    registerCollisionCreateFunc :: (this: *btCollisionDispatcher, proxyType0: s32, proxyType1: s32, createFunc: *btCollisionAlgorithmCreateFunc) -> void #cpp_method #foreign bullet3 "?registerCollisionCreateFunc@btCollisionDispatcher@@QEAAXHHPEAUbtCollisionAlgorithmCreateFunc@@@Z";

    registerClosestPointsCreateFunc :: (this: *btCollisionDispatcher, proxyType0: s32, proxyType1: s32, createFunc: *btCollisionAlgorithmCreateFunc) -> void #cpp_method #foreign bullet3 "?registerClosestPointsCreateFunc@btCollisionDispatcher@@QEAAXHHPEAUbtCollisionAlgorithmCreateFunc@@@Z";

    getManifoldByIndexInternal :: (this: /*const*/ *btCollisionDispatcher, index: s32) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getManifoldByIndexInternal@btCollisionDispatcher@@QEBAPEBVbtPersistentManifold@@H@Z";

    Constructor :: (this: *btCollisionDispatcher, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btCollisionDispatcher@@QEAA@PEAVbtCollisionConfiguration@@@Z";

    setNearCallback :: (this: *btCollisionDispatcher, nearCallback: btNearCallback) -> void #cpp_method #foreign bullet3 "?setNearCallback@btCollisionDispatcher@@QEAAXP6AXAEAUbtBroadphasePair@@AEAV1@AEBUbtDispatcherInfo@@@Z@Z";

    getNearCallback :: (this: *btCollisionDispatcher) -> btNearCallback #cpp_method #foreign bullet3 "?getNearCallback@btCollisionDispatcher@@QEBAP6AXAEAUbtBroadphasePair@@AEAV1@AEBUbtDispatcherInfo@@@ZXZ";

    //by default, Bullet will use this near callback
    defaultNearCallback :: (collisionPair: *btBroadphasePair, dispatcher: *btCollisionDispatcher, dispatchInfo: *btDispatcherInfo) -> void #foreign bullet3 "?defaultNearCallback@btCollisionDispatcher@@SAXAEAUbtBroadphasePair@@AEAV1@AEBUbtDispatcherInfo@@@Z";
    defaultNearCallback :: (collisionPair: *btBroadphasePair, dispatcher: *btCollisionDispatcher, dispatchInfo: btDispatcherInfo) #no_context {
        defaultNearCallback(collisionPair, dispatcher, *dispatchInfo);
    }

    getCollisionConfiguration :: (this: *btCollisionDispatcher) -> *btCollisionConfiguration #cpp_method #foreign bullet3 "?getCollisionConfiguration@btCollisionDispatcher@@QEAAPEAVbtCollisionConfiguration@@XZ";

    getCollisionConfiguration_1 :: (this: /*const*/ *btCollisionDispatcher) -> *btCollisionConfiguration #cpp_method #foreign bullet3 "?getCollisionConfiguration@btCollisionDispatcher@@QEBAPEBVbtCollisionConfiguration@@XZ";

    setCollisionConfiguration :: (this: *btCollisionDispatcher, config: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "?setCollisionConfiguration@btCollisionDispatcher@@QEAAXPEAVbtCollisionConfiguration@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getNumManifolds :: (this: *btCollisionDispatcher) -> s32 #cpp_method #foreign bullet3 "?getNumManifolds@btCollisionDispatcher@@UEBAHXZ";

    virtual_getInternalManifoldPointer :: (this: *btCollisionDispatcher) -> **btPersistentManifold #cpp_method #foreign bullet3 "?getInternalManifoldPointer@btCollisionDispatcher@@UEAAPEAPEAVbtPersistentManifold@@XZ";

    virtual_getManifoldByIndexInternal_1 :: (this: *btCollisionDispatcher, index: s32) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getManifoldByIndexInternal@btCollisionDispatcher@@UEAAPEAVbtPersistentManifold@@H@Z";

    virtual_Destructor :: (this: *btCollisionDispatcher, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionDispatcher@@UEAA@XZ";

    virtual_getNewManifold :: (this: *btCollisionDispatcher, b0: *btCollisionObject, b1: *btCollisionObject) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getNewManifold@btCollisionDispatcher@@UEAAPEAVbtPersistentManifold@@PEBVbtCollisionObject@@0@Z";

    virtual_releaseManifold :: (this: *btCollisionDispatcher, manifold: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "?releaseManifold@btCollisionDispatcher@@UEAAXPEAVbtPersistentManifold@@@Z";

    virtual_clearManifold :: (this: *btCollisionDispatcher, manifold: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "?clearManifold@btCollisionDispatcher@@UEAAXPEAVbtPersistentManifold@@@Z";

    virtual_findAlgorithm :: (this: *btCollisionDispatcher, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, sharedManifold: *btPersistentManifold, queryType: ebtDispatcherQueryType) -> *btCollisionAlgorithm #cpp_method #foreign bullet3 "?findAlgorithm@btCollisionDispatcher@@UEAAPEAVbtCollisionAlgorithm@@PEBUbtCollisionObjectWrapper@@0PEAVbtPersistentManifold@@W4ebtDispatcherQueryType@@@Z";

    virtual_needsCollision :: (this: *btCollisionDispatcher, body0: *btCollisionObject, body1: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?needsCollision@btCollisionDispatcher@@UEAA_NPEBVbtCollisionObject@@0@Z";

    virtual_needsResponse :: (this: *btCollisionDispatcher, body0: *btCollisionObject, body1: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?needsResponse@btCollisionDispatcher@@UEAA_NPEBVbtCollisionObject@@0@Z";

    virtual_dispatchAllCollisionPairs :: (this: *btCollisionDispatcher, pairCache: *btOverlappingPairCache, dispatchInfo: *btDispatcherInfo, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?dispatchAllCollisionPairs@btCollisionDispatcher@@UEAAXPEAVbtOverlappingPairCache@@AEBUbtDispatcherInfo@@PEAVbtDispatcher@@@Z";

    virtual_allocateCollisionAlgorithm :: (this: *btCollisionDispatcher, size: s32) -> *void #cpp_method #foreign bullet3 "?allocateCollisionAlgorithm@btCollisionDispatcher@@UEAAPEAXH@Z";

    virtual_freeCollisionAlgorithm :: (this: *btCollisionDispatcher, ptr: *void) -> void #cpp_method #foreign bullet3 "?freeCollisionAlgorithm@btCollisionDispatcher@@UEAAXPEAX@Z";

    virtual_getInternalManifoldPool :: (this: *btCollisionDispatcher) -> *btPoolAllocator #cpp_method #foreign bullet3 "?getInternalManifoldPool@btCollisionDispatcher@@UEAAPEAVbtPoolAllocator@@XZ";

    virtual_getInternalManifoldPool_1 :: (this: /*const*/ *btCollisionDispatcher) -> *btPoolAllocator #cpp_method #foreign bullet3 "?getInternalManifoldPool@btCollisionDispatcher@@UEBAPEBVbtPoolAllocator@@XZ";
}

btBroadphaseAabbCallback :: struct {
    vtable: *btBroadphaseAabbCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btBroadphaseAabbCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBroadphaseAabbCallback@@UEAA@XZ";
}
btBroadphaseAabbCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btBroadphaseAabbCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    process: (this: *btBroadphaseAabbCallback, proxy: *btBroadphaseProxy) -> bool #cpp_method;
}

btBroadphaseAabbCallback_Destructor :: inline (this: *btBroadphaseAabbCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
btBroadphaseAabbCallback_process :: inline (this: *btBroadphaseAabbCallback, proxy: *btBroadphaseProxy) -> bool { return this.vtable.process(this, proxy); }



btBroadphaseRayCallback :: struct {
    #as using btbroadphaseaabbcallback: btBroadphaseAabbCallback;

    ///added some cached data to accelerate ray-AABB tests
    m_rayDirectionInverse: btVector3;
    m_signs:               [3] u32;
    m_lambda_max:          btScalar;

    Constructor :: (this: *btBroadphaseRayCallback) -> void #cpp_method #foreign bullet3 "??0btBroadphaseRayCallback@@IEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btBroadphaseRayCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBroadphaseRayCallback@@UEAA@XZ";
}

//#endif //BT_USE_DOUBLE_PRECISION
btBroadphaseInterface :: struct {
    vtable: *btBroadphaseInterface_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btBroadphaseInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBroadphaseInterface@@UEAA@XZ";

    ///reset broadphase internal structures, to ensure determinism/reproducability
    virtual_resetPool :: (this: *btBroadphaseInterface, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?resetPool@btBroadphaseInterface@@UEAAXPEAVbtDispatcher@@@Z";
}
btBroadphaseInterface_VTable :: struct #type_info_none {
    Destructor: (this: *btBroadphaseInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    createProxy: (this: *btBroadphaseInterface, aabbMin: *btVector3, aabbMax: *btVector3, shapeType: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32, dispatcher: *btDispatcher) -> *btBroadphaseProxy #cpp_method;
    destroyProxy: (this: *btBroadphaseInterface, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method;
    setAabb: (this: *btBroadphaseInterface, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3, dispatcher: *btDispatcher) -> void #cpp_method;
    getAabb: (this: *btBroadphaseInterface, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    rayTest: (this: *btBroadphaseInterface, rayFrom: *btVector3, rayTo: *btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;
    // rayTest :: (this: *btBroadphaseInterface, rayFrom: btVector3, rayTo: btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: btVector3 = btVector3.{0, 0, 0}, aabbMax: btVector3 = btVector3.{0, 0, 0}) #no_context {
    //     rayTest(this, *rayFrom, *rayTo, rayCallback, *aabbMin, *aabbMax);
    // }

    aabbTest: (this: *btBroadphaseInterface, aabbMin: *btVector3, aabbMax: *btVector3, callback: *btBroadphaseAabbCallback) -> void #cpp_method;

    calculateOverlappingPairs: (this: *btBroadphaseInterface, dispatcher: *btDispatcher) -> void #cpp_method;

    getOverlappingPairCache_1: (this: /*const*/ *btBroadphaseInterface) -> *btOverlappingPairCache #cpp_method;

    getOverlappingPairCache: (this: *btBroadphaseInterface) -> *btOverlappingPairCache #cpp_method;

    getBroadphaseAabb: (this: *btBroadphaseInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    resetPool: (this: *btBroadphaseInterface, dispatcher: *btDispatcher) -> void #cpp_method;

    printStats: (this: *btBroadphaseInterface) -> void #cpp_method;
}

btBroadphaseInterface_Destructor :: inline (this: *btBroadphaseInterface, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btBroadphaseInterface_createProxy :: inline (this: *btBroadphaseInterface, aabbMin: *btVector3, aabbMax: *btVector3, shapeType: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32, dispatcher: *btDispatcher) -> *btBroadphaseProxy { return this.vtable.createProxy(this, aabbMin, aabbMax, shapeType, userPtr, collisionFilterGroup, collisionFilterMask, dispatcher); }
btBroadphaseInterface_destroyProxy :: inline (this: *btBroadphaseInterface, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) { this.vtable.destroyProxy(this, proxy, dispatcher); }
btBroadphaseInterface_setAabb :: inline (this: *btBroadphaseInterface, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3, dispatcher: *btDispatcher) { this.vtable.setAabb(this, proxy, aabbMin, aabbMax, dispatcher); }
btBroadphaseInterface_getAabb :: inline (this: *btBroadphaseInterface, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.getAabb(this, proxy, aabbMin, aabbMax); }

btBroadphaseInterface_rayTest :: inline (this: *btBroadphaseInterface, rayFrom: *btVector3, rayTo: *btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.rayTest(this, rayFrom, rayTo, rayCallback, aabbMin, aabbMax); }

btBroadphaseInterface_aabbTest :: inline (this: *btBroadphaseInterface, aabbMin: *btVector3, aabbMax: *btVector3, callback: *btBroadphaseAabbCallback) { this.vtable.aabbTest(this, aabbMin, aabbMax, callback); }

btBroadphaseInterface_calculateOverlappingPairs :: inline (this: *btBroadphaseInterface, dispatcher: *btDispatcher) { this.vtable.calculateOverlappingPairs(this, dispatcher); }

btBroadphaseInterface_getOverlappingPairCache_1 :: inline (this: /*const*/ *btBroadphaseInterface) -> *btOverlappingPairCache { return this.vtable.getOverlappingPairCache_1(this); }

btBroadphaseInterface_getOverlappingPairCache :: inline (this: *btBroadphaseInterface) -> *btOverlappingPairCache { return this.vtable.getOverlappingPairCache(this); }

btBroadphaseInterface_getBroadphaseAabb :: inline (this: *btBroadphaseInterface, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.getBroadphaseAabb(this, aabbMin, aabbMax); }

btBroadphaseInterface_resetPool :: inline (this: *btBroadphaseInterface, dispatcher: *btDispatcher) { this.vtable.resetPool(this, dispatcher); }

btBroadphaseInterface_printStats :: inline (this: *btBroadphaseInterface) { this.vtable.printStats(this); }



///The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
btOverlappingPairCallback :: struct {
    vtable: *btOverlappingPairCallback_VTable;
    Constructor :: (this: *btOverlappingPairCallback) -> void #cpp_method #foreign bullet3 "??0btOverlappingPairCallback@@IEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btOverlappingPairCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btOverlappingPairCallback@@UEAA@XZ";
}
btOverlappingPairCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btOverlappingPairCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    addOverlappingPair: (this: *btOverlappingPairCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method;

    removeOverlappingPair: (this: *btOverlappingPairCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy, dispatcher: *btDispatcher) -> *void #cpp_method;

    removeOverlappingPairsContainingProxy: (this: *btOverlappingPairCallback, proxy0: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method;
}

btOverlappingPairCallback_Destructor :: inline (this: *btOverlappingPairCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btOverlappingPairCallback_addOverlappingPair :: inline (this: *btOverlappingPairCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair { return this.vtable.addOverlappingPair(this, proxy0, proxy1); }

btOverlappingPairCallback_removeOverlappingPair :: inline (this: *btOverlappingPairCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy, dispatcher: *btDispatcher) -> *void { return this.vtable.removeOverlappingPair(this, proxy0, proxy1, dispatcher); }

btOverlappingPairCallback_removeOverlappingPairsContainingProxy :: inline (this: *btOverlappingPairCallback, proxy0: *btBroadphaseProxy, dispatcher: *btDispatcher) { this.vtable.removeOverlappingPairsContainingProxy(this, proxy0, dispatcher); }



btBroadphasePairArray :: btAlignedObjectArray(btBroadphasePair);

btOverlapCallback :: struct {
    vtable: *btOverlapCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btOverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btOverlapCallback@@UEAA@XZ";
}
btOverlapCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btOverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    processOverlap: (this: *btOverlapCallback, pair: *btBroadphasePair) -> bool #cpp_method;
}

btOverlapCallback_Destructor :: inline (this: *btOverlapCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btOverlapCallback_processOverlap :: inline (this: *btOverlapCallback, pair: *btBroadphasePair) -> bool { return this.vtable.processOverlap(this, pair); }



btOverlapFilterCallback :: struct {
    vtable: *btOverlapFilterCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btOverlapFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btOverlapFilterCallback@@UEAA@XZ";
}
btOverlapFilterCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btOverlapFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    needBroadphaseCollision: (this: *btOverlapFilterCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool #cpp_method;
}

btOverlapFilterCallback_Destructor :: inline (this: *btOverlapFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btOverlapFilterCallback_needBroadphaseCollision :: inline (this: *btOverlapFilterCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool { return this.vtable.needBroadphaseCollision(this, proxy0, proxy1); }



///The btOverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the btBroadphaseInterface broadphases.
///The btHashedOverlappingPairCache and btSortedOverlappingPairCache classes are two implementations.
btOverlappingPairCache :: struct {
    #as using btoverlappingpaircallback: btOverlappingPairCallback;
    #place btoverlappingpaircallback; btoverlappingpaircache_vtable: *btOverlappingPairCache_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btOverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btOverlappingPairCache@@UEAA@XZ";

    virtual_processAllOverlappingPairs :: (this: *btOverlappingPairCache, callback: *btOverlapCallback, dispatcher: *btDispatcher, unknown0: *btDispatcherInfo) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@btOverlappingPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@AEBUbtDispatcherInfo@@@Z";
}
btOverlappingPairCache_VTable :: struct #type_info_none {
    using btoverlappingpaircallback: btOverlappingPairCallback_VTable;
    getOverlappingPairArrayPtr_1: (this: /*const*/ *btOverlappingPairCache) -> *btBroadphasePair #cpp_method;

    getOverlappingPairArrayPtr: (this: *btOverlappingPairCache) -> *btBroadphasePair #cpp_method;

    getOverlappingPairArray: (this: *btOverlappingPairCache) -> *btBroadphasePairArray #cpp_method;

    cleanOverlappingPair: (this: *btOverlappingPairCache, pair: *btBroadphasePair, dispatcher: *btDispatcher) -> void #cpp_method;

    getNumOverlappingPairs: (this: *btOverlappingPairCache) -> s32 #cpp_method;
    needsBroadphaseCollision: (this: *btOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool #cpp_method;
    getOverlapFilterCallback: (this: *btOverlappingPairCache) -> *btOverlapFilterCallback #cpp_method;
    cleanProxyFromPairs: (this: *btOverlappingPairCache, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method;

    setOverlapFilterCallback: (this: *btOverlappingPairCache, callback: *btOverlapFilterCallback) -> void #cpp_method;

    processAllOverlappingPairs: (this: *btOverlappingPairCache, callback: *btOverlapCallback, dispatcher: *btDispatcher, unknown0: *btDispatcherInfo) -> void #cpp_method;

    processAllOverlappingPairs_1: (this: *btOverlappingPairCache, unknown0: *btOverlapCallback, dispatcher: *btDispatcher) -> void #cpp_method;

    findPair: (this: *btOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method;

    hasDeferredRemoval: (this: *btOverlappingPairCache) -> bool #cpp_method;

    setInternalGhostPairCallback: (this: *btOverlappingPairCache, ghostPairCallback: *btOverlappingPairCallback) -> void #cpp_method;

    sortOverlappingPairs: (this: *btOverlappingPairCache, dispatcher: *btDispatcher) -> void #cpp_method;
}

btOverlappingPairCache_getOverlappingPairArrayPtr_1 :: inline (this: /*const*/ *btOverlappingPairCache) -> *btBroadphasePair { return this.btoverlappingpaircache_vtable.getOverlappingPairArrayPtr_1(this); }

btOverlappingPairCache_getOverlappingPairArrayPtr :: inline (this: *btOverlappingPairCache) -> *btBroadphasePair { return this.btoverlappingpaircache_vtable.getOverlappingPairArrayPtr(this); }

btOverlappingPairCache_getOverlappingPairArray :: inline (this: *btOverlappingPairCache) -> *btBroadphasePairArray { return this.btoverlappingpaircache_vtable.getOverlappingPairArray(this); }

btOverlappingPairCache_cleanOverlappingPair :: inline (this: *btOverlappingPairCache, pair: *btBroadphasePair, dispatcher: *btDispatcher) { this.btoverlappingpaircache_vtable.cleanOverlappingPair(this, pair, dispatcher); }

btOverlappingPairCache_getNumOverlappingPairs :: inline (this: *btOverlappingPairCache) -> s32 { return this.btoverlappingpaircache_vtable.getNumOverlappingPairs(this); }
btOverlappingPairCache_needsBroadphaseCollision :: inline (this: *btOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool { return this.btoverlappingpaircache_vtable.needsBroadphaseCollision(this, proxy0, proxy1); }
btOverlappingPairCache_getOverlapFilterCallback :: inline (this: *btOverlappingPairCache) -> *btOverlapFilterCallback { return this.btoverlappingpaircache_vtable.getOverlapFilterCallback(this); }
btOverlappingPairCache_cleanProxyFromPairs :: inline (this: *btOverlappingPairCache, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) { this.btoverlappingpaircache_vtable.cleanProxyFromPairs(this, proxy, dispatcher); }

btOverlappingPairCache_setOverlapFilterCallback :: inline (this: *btOverlappingPairCache, callback: *btOverlapFilterCallback) { this.btoverlappingpaircache_vtable.setOverlapFilterCallback(this, callback); }

btOverlappingPairCache_processAllOverlappingPairs :: inline (this: *btOverlappingPairCache, callback: *btOverlapCallback, dispatcher: *btDispatcher, unknown0: /*const reference*/ *btDispatcherInfo) { this.btoverlappingpaircache_vtable.processAllOverlappingPairs(this, callback, dispatcher, unknown0); }

btOverlappingPairCache_processAllOverlappingPairs_1 :: inline (this: *btOverlappingPairCache, unknown0: *btOverlapCallback, dispatcher: *btDispatcher) { this.btoverlappingpaircache_vtable.processAllOverlappingPairs_1(this, unknown0, dispatcher); }

btOverlappingPairCache_findPair :: inline (this: *btOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair { return this.btoverlappingpaircache_vtable.findPair(this, proxy0, proxy1); }

btOverlappingPairCache_hasDeferredRemoval :: inline (this: *btOverlappingPairCache) -> bool { return this.btoverlappingpaircache_vtable.hasDeferredRemoval(this); }

btOverlappingPairCache_setInternalGhostPairCallback :: inline (this: *btOverlappingPairCache, ghostPairCallback: *btOverlappingPairCallback) { this.btoverlappingpaircache_vtable.setInternalGhostPairCallback(this, ghostPairCallback); }

btOverlappingPairCache_sortOverlappingPairs :: inline (this: *btOverlappingPairCache, dispatcher: *btDispatcher) { this.btoverlappingpaircache_vtable.sortOverlappingPairs(this, dispatcher); }

vtable :: (obj: *btOverlappingPairCache) -> *btOverlappingPairCache_VTable { return obj.btoverlappingpaircache_vtable; }


/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
btHashedOverlappingPairCache :: struct {
    #as using btoverlappingpaircache: btOverlappingPairCache;

    m_overlappingPairArray:  btBroadphasePairArray;
    m_overlapFilterCallback: *btOverlapFilterCallback;

    m_hashTable:             btAlignedObjectArray(s32);
    m_next:                  btAlignedObjectArray(s32);
    m_ghostPairCallback:     *btOverlappingPairCallback;

    Constructor :: (this: *btHashedOverlappingPairCache) -> void #cpp_method #foreign bullet3 "??0btHashedOverlappingPairCache@@QEAA@XZ";

    getOverlappingPairArray :: (this: /*const*/ *btHashedOverlappingPairCache) -> *btBroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btHashedOverlappingPairCache@@QEBAAEBV?$btAlignedObjectArray@UbtBroadphasePair@@@@XZ";

    GetCount :: (this: *btHashedOverlappingPairCache) -> s32 #cpp_method #foreign bullet3 "?GetCount@btHashedOverlappingPairCache@@QEBAHXZ";

    internalAddPair :: (this: *btHashedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?internalAddPair@btHashedOverlappingPairCache@@AEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    growTables :: (this: *btHashedOverlappingPairCache) -> void #cpp_method #foreign bullet3 "?growTables@btHashedOverlappingPairCache@@AEAAXXZ";

    equalsPair :: (this: *btHashedOverlappingPairCache, pair: *btBroadphasePair, proxyId1: s32, proxyId2: s32) -> bool #cpp_method #foreign bullet3 "?equalsPair@btHashedOverlappingPairCache@@AEAA_NAEBUbtBroadphasePair@@HH@Z";
    equalsPair :: (this: *btHashedOverlappingPairCache, pair: btBroadphasePair, proxyId1: s32, proxyId2: s32) -> bool #no_context {
        return equalsPair(this, *pair, proxyId1, proxyId2);
    }

    /*
    // Thomas Wang's hash, see: http://www.concentric.net/~Ttwang/tech/inthash.htm
    // This assumes proxyId1 and proxyId2 are 16-bit.
    SIMD_FORCE_INLINE int getHash(int proxyId1, int proxyId2)
    {
    int key = (proxyId2 << 16) | proxyId1;
    key = ~key + (key << 15);
    key = key ^ (key >> 12);
    key = key + (key << 2);
    key = key ^ (key >> 4);
    key = key * 2057;
    key = key ^ (key >> 16);
    return key;
    }
    */
    getHash :: (this: *btHashedOverlappingPairCache, proxyId1: u32, proxyId2: u32) -> u32 #cpp_method #foreign bullet3 "?getHash@btHashedOverlappingPairCache@@AEAAIII@Z";

    internalFindPair :: (this: *btHashedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy, hash: s32) -> *btBroadphasePair #cpp_method #foreign bullet3 "?internalFindPair@btHashedOverlappingPairCache@@AEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0H@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btHashedOverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btHashedOverlappingPairCache@@UEAA@XZ";

    virtual_removeOverlappingPairsContainingProxy :: (this: *btHashedOverlappingPairCache, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@btHashedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";

    virtual_removeOverlappingPair :: (this: *btHashedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy, dispatcher: *btDispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@btHashedOverlappingPairCache@@UEAAPEAXPEAUbtBroadphaseProxy@@0PEAVbtDispatcher@@@Z";

    virtual_needsBroadphaseCollision :: (this: *btHashedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?needsBroadphaseCollision@btHashedOverlappingPairCache@@UEBA_NPEAUbtBroadphaseProxy@@0@Z";

    // Add a pair and return the new pair. If the pair already exists,
    // no new pair is created and the old one is returned.
    virtual_addOverlappingPair :: (this: *btHashedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@btHashedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    virtual_cleanProxyFromPairs :: (this: *btHashedOverlappingPairCache, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?cleanProxyFromPairs@btHashedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";

    virtual_processAllOverlappingPairs :: (this: *btHashedOverlappingPairCache, unknown0: *btOverlapCallback, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@btHashedOverlappingPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@@Z";

    virtual_processAllOverlappingPairs :: (this: *btHashedOverlappingPairCache, callback: *btOverlapCallback, dispatcher: *btDispatcher, dispatchInfo: *btDispatcherInfo) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@btHashedOverlappingPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@AEBUbtDispatcherInfo@@@Z";

    virtual_getOverlappingPairArrayPtr :: (this: *btHashedOverlappingPairCache) -> *btBroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btHashedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@XZ";

    virtual_getOverlappingPairArrayPtr_1 :: (this: /*const*/ *btHashedOverlappingPairCache) -> *btBroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btHashedOverlappingPairCache@@UEBAPEBUbtBroadphasePair@@XZ";

    virtual_getOverlappingPairArray_1 :: (this: *btHashedOverlappingPairCache) -> *btBroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btHashedOverlappingPairCache@@UEAAAEAV?$btAlignedObjectArray@UbtBroadphasePair@@@@XZ";

    virtual_cleanOverlappingPair :: (this: *btHashedOverlappingPairCache, pair: *btBroadphasePair, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?cleanOverlappingPair@btHashedOverlappingPairCache@@UEAAXAEAUbtBroadphasePair@@PEAVbtDispatcher@@@Z";

    virtual_findPair :: (this: *btHashedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?findPair@btHashedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    //	btBroadphasePair* GetPairs() { return m_pairs; }
    virtual_getOverlapFilterCallback :: (this: *btHashedOverlappingPairCache) -> *btOverlapFilterCallback #cpp_method #foreign bullet3 "?getOverlapFilterCallback@btHashedOverlappingPairCache@@UEAAPEAUbtOverlapFilterCallback@@XZ";

    virtual_setOverlapFilterCallback :: (this: *btHashedOverlappingPairCache, callback: *btOverlapFilterCallback) -> void #cpp_method #foreign bullet3 "?setOverlapFilterCallback@btHashedOverlappingPairCache@@UEAAXPEAUbtOverlapFilterCallback@@@Z";

    virtual_getNumOverlappingPairs :: (this: *btHashedOverlappingPairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@btHashedOverlappingPairCache@@UEBAHXZ";

    virtual_hasDeferredRemoval :: (this: *btHashedOverlappingPairCache) -> bool #cpp_method #foreign bullet3 "?hasDeferredRemoval@btHashedOverlappingPairCache@@EEAA_NXZ";

    virtual_setInternalGhostPairCallback :: (this: *btHashedOverlappingPairCache, ghostPairCallback: *btOverlappingPairCallback) -> void #cpp_method #foreign bullet3 "?setInternalGhostPairCallback@btHashedOverlappingPairCache@@EEAAXPEAVbtOverlappingPairCallback@@@Z";

    virtual_sortOverlappingPairs :: (this: *btHashedOverlappingPairCache, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?sortOverlappingPairs@btHashedOverlappingPairCache@@EEAAXPEAVbtDispatcher@@@Z";
}


///btSortedOverlappingPairCache maintains the objects with overlapping AABB
///Typically managed by the Broadphase, Axis3Sweep or btSimpleBroadphase
btSortedOverlappingPairCache :: struct {
    #as using btoverlappingpaircache: btOverlappingPairCache;

    //avoid brute-force finding all the time
    m_overlappingPairArray:  btBroadphasePairArray;

    //during the dispatch, check that user doesn't destroy/create proxy
    m_blockedForChanges:     bool;

    ///by default, do the removal during the pair traversal
    m_hasDeferredRemoval:    bool;

    //if set, use the callback instead of the built in filter in needBroadphaseCollision
    m_overlapFilterCallback: *btOverlapFilterCallback;

    m_ghostPairCallback:     *btOverlappingPairCallback;

    Constructor :: (this: *btSortedOverlappingPairCache) -> void #cpp_method #foreign bullet3 "??0btSortedOverlappingPairCache@@QEAA@XZ";

    getOverlappingPairArray :: (this: /*const*/ *btSortedOverlappingPairCache) -> *btBroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btSortedOverlappingPairCache@@QEBAAEBV?$btAlignedObjectArray@UbtBroadphasePair@@@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSortedOverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSortedOverlappingPairCache@@UEAA@XZ";

    virtual_processAllOverlappingPairs :: (this: *btSortedOverlappingPairCache, unknown0: *btOverlapCallback, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@btSortedOverlappingPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@@Z";

    virtual_removeOverlappingPair :: (this: *btSortedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy, dispatcher: *btDispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@btSortedOverlappingPairCache@@UEAAPEAXPEAUbtBroadphaseProxy@@0PEAVbtDispatcher@@@Z";

    virtual_cleanOverlappingPair :: (this: *btSortedOverlappingPairCache, pair: *btBroadphasePair, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?cleanOverlappingPair@btSortedOverlappingPairCache@@UEAAXAEAUbtBroadphasePair@@PEAVbtDispatcher@@@Z";

    virtual_addOverlappingPair :: (this: *btSortedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@btSortedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    virtual_findPair :: (this: *btSortedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?findPair@btSortedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    virtual_cleanProxyFromPairs :: (this: *btSortedOverlappingPairCache, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?cleanProxyFromPairs@btSortedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";

    virtual_removeOverlappingPairsContainingProxy :: (this: *btSortedOverlappingPairCache, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@btSortedOverlappingPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";

    virtual_needsBroadphaseCollision :: (this: *btSortedOverlappingPairCache, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?needsBroadphaseCollision@btSortedOverlappingPairCache@@UEBA_NPEAUbtBroadphaseProxy@@0@Z";

    virtual_getOverlappingPairArray_1 :: (this: *btSortedOverlappingPairCache) -> *btBroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btSortedOverlappingPairCache@@UEAAAEAV?$btAlignedObjectArray@UbtBroadphasePair@@@@XZ";

    virtual_getOverlappingPairArrayPtr :: (this: *btSortedOverlappingPairCache) -> *btBroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btSortedOverlappingPairCache@@UEAAPEAUbtBroadphasePair@@XZ";

    virtual_getOverlappingPairArrayPtr_1 :: (this: /*const*/ *btSortedOverlappingPairCache) -> *btBroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btSortedOverlappingPairCache@@UEBAPEBUbtBroadphasePair@@XZ";

    virtual_getNumOverlappingPairs :: (this: *btSortedOverlappingPairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@btSortedOverlappingPairCache@@UEBAHXZ";

    virtual_getOverlapFilterCallback :: (this: *btSortedOverlappingPairCache) -> *btOverlapFilterCallback #cpp_method #foreign bullet3 "?getOverlapFilterCallback@btSortedOverlappingPairCache@@UEAAPEAUbtOverlapFilterCallback@@XZ";

    virtual_setOverlapFilterCallback :: (this: *btSortedOverlappingPairCache, callback: *btOverlapFilterCallback) -> void #cpp_method #foreign bullet3 "?setOverlapFilterCallback@btSortedOverlappingPairCache@@UEAAXPEAUbtOverlapFilterCallback@@@Z";

    virtual_hasDeferredRemoval :: (this: *btSortedOverlappingPairCache) -> bool #cpp_method #foreign bullet3 "?hasDeferredRemoval@btSortedOverlappingPairCache@@UEAA_NXZ";

    virtual_setInternalGhostPairCallback :: (this: *btSortedOverlappingPairCache, ghostPairCallback: *btOverlappingPairCallback) -> void #cpp_method #foreign bullet3 "?setInternalGhostPairCallback@btSortedOverlappingPairCache@@UEAAXPEAVbtOverlappingPairCallback@@@Z";

    virtual_sortOverlappingPairs :: (this: *btSortedOverlappingPairCache, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?sortOverlappingPairs@btSortedOverlappingPairCache@@UEAAXPEAVbtDispatcher@@@Z";
}

///btNullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
btNullPairCache :: struct {
    #as using btoverlappingpaircache: btOverlappingPairCache;

    m_overlappingPairArray: btBroadphasePairArray;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getOverlappingPairArrayPtr :: (this: *btNullPairCache) -> *btBroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btNullPairCache@@UEAAPEAUbtBroadphasePair@@XZ";

    virtual_getOverlappingPairArrayPtr_1 :: (this: /*const*/ *btNullPairCache) -> *btBroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btNullPairCache@@UEBAPEBUbtBroadphasePair@@XZ";

    virtual_getOverlappingPairArray :: (this: *btNullPairCache) -> *btBroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btNullPairCache@@UEAAAEAV?$btAlignedObjectArray@UbtBroadphasePair@@@@XZ";

    virtual_cleanOverlappingPair :: (this: *btNullPairCache, unknown0: *btBroadphasePair, unknown1: *btDispatcher) -> void #cpp_method #foreign bullet3 "?cleanOverlappingPair@btNullPairCache@@UEAAXAEAUbtBroadphasePair@@PEAVbtDispatcher@@@Z";

    virtual_getNumOverlappingPairs :: (this: *btNullPairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@btNullPairCache@@UEBAHXZ";

    virtual_cleanProxyFromPairs :: (this: *btNullPairCache, unknown0: *btBroadphaseProxy, unknown1: *btDispatcher) -> void #cpp_method #foreign bullet3 "?cleanProxyFromPairs@btNullPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";

    virtual_needsBroadphaseCollision :: (this: *btNullPairCache, unknown0: *btBroadphaseProxy, unknown1: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?needsBroadphaseCollision@btNullPairCache@@UEBA_NPEAUbtBroadphaseProxy@@0@Z";

    virtual_getOverlapFilterCallback :: (this: *btNullPairCache) -> *btOverlapFilterCallback #cpp_method #foreign bullet3 "?getOverlapFilterCallback@btNullPairCache@@UEAAPEAUbtOverlapFilterCallback@@XZ";

    virtual_setOverlapFilterCallback :: (this: *btNullPairCache, unknown0: *btOverlapFilterCallback) -> void #cpp_method #foreign bullet3 "?setOverlapFilterCallback@btNullPairCache@@UEAAXPEAUbtOverlapFilterCallback@@@Z";

    virtual_processAllOverlappingPairs :: (this: *btNullPairCache, unknown0: *btOverlapCallback, unknown1: *btDispatcher) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@btNullPairCache@@UEAAXPEAUbtOverlapCallback@@PEAVbtDispatcher@@@Z";

    virtual_findPair :: (this: *btNullPairCache, unknown0: *btBroadphaseProxy, unknown1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?findPair@btNullPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    virtual_hasDeferredRemoval :: (this: *btNullPairCache) -> bool #cpp_method #foreign bullet3 "?hasDeferredRemoval@btNullPairCache@@UEAA_NXZ";

    virtual_setInternalGhostPairCallback :: (this: *btNullPairCache, unknown0: *btOverlappingPairCallback) -> void #cpp_method #foreign bullet3 "?setInternalGhostPairCallback@btNullPairCache@@UEAAXPEAVbtOverlappingPairCallback@@@Z";

    virtual_addOverlappingPair :: (this: *btNullPairCache, unknown0: *btBroadphaseProxy, unknown1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@btNullPairCache@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    virtual_removeOverlappingPair :: (this: *btNullPairCache, unknown0: *btBroadphaseProxy, unknown1: *btBroadphaseProxy, unknown2: *btDispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@btNullPairCache@@UEAAPEAXPEAUbtBroadphaseProxy@@0PEAVbtDispatcher@@@Z";

    virtual_removeOverlappingPairsContainingProxy :: (this: *btNullPairCache, unknown0: *btBroadphaseProxy, unknown1: *btDispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@btNullPairCache@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";

    virtual_sortOverlappingPairs :: (this: *btNullPairCache, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?sortOverlappingPairs@btNullPairCache@@UEAAXPEAVbtDispatcher@@@Z";
}

///CollisionWorld is interface and container for the collision detection
btCollisionWorld :: struct {
    vtable: *btCollisionWorld_VTable;
    m_collisionObjects:    btAlignedObjectArray(*btCollisionObject);

    m_dispatcher1:         *btDispatcher;

    m_dispatchInfo:        btDispatcherInfo;

    m_broadphasePairCache: *btBroadphaseInterface;

    m_debugDrawer:         *btIDebugDraw;

    ///m_forceUpdateAllAabbs can be set to false as an optimization to only update active object AABBs
    ///it is true by default, because it is error-prone (setting the position of static objects wouldn't update their AABB)
    m_forceUpdateAllAabbs: bool;

    serializeCollisionObjects :: (this: *btCollisionWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeCollisionObjects@btCollisionWorld@@IEAAXPEAVbtSerializer@@@Z";

    serializeContactManifolds :: (this: *btCollisionWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeContactManifolds@btCollisionWorld@@IEAAXPEAVbtSerializer@@@Z";

    //this constructor doesn't own the dispatcher and paircache/broadphase
    Constructor :: (this: *btCollisionWorld, dispatcher: *btDispatcher, broadphasePairCache: *btBroadphaseInterface, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btCollisionWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtCollisionConfiguration@@@Z";

    setBroadphase :: (this: *btCollisionWorld, pairCache: *btBroadphaseInterface) -> void #cpp_method #foreign bullet3 "?setBroadphase@btCollisionWorld@@QEAAXPEAVbtBroadphaseInterface@@@Z";

    getBroadphase :: (this: /*const*/ *btCollisionWorld) -> *btBroadphaseInterface #cpp_method #foreign bullet3 "?getBroadphase@btCollisionWorld@@QEBAPEBVbtBroadphaseInterface@@XZ";

    getBroadphase_1 :: (this: *btCollisionWorld) -> *btBroadphaseInterface #cpp_method #foreign bullet3 "?getBroadphase@btCollisionWorld@@QEAAPEAVbtBroadphaseInterface@@XZ";

    getPairCache :: (this: *btCollisionWorld) -> *btOverlappingPairCache #cpp_method #foreign bullet3 "?getPairCache@btCollisionWorld@@QEAAPEAVbtOverlappingPairCache@@XZ";

    getDispatcher :: (this: *btCollisionWorld) -> *btDispatcher #cpp_method #foreign bullet3 "?getDispatcher@btCollisionWorld@@QEAAPEAVbtDispatcher@@XZ";

    getDispatcher_1 :: (this: /*const*/ *btCollisionWorld) -> *btDispatcher #cpp_method #foreign bullet3 "?getDispatcher@btCollisionWorld@@QEBAPEBVbtDispatcher@@XZ";

    updateSingleAabb :: (this: *btCollisionWorld, colObj: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?updateSingleAabb@btCollisionWorld@@QEAAXPEAVbtCollisionObject@@@Z";

    ///LocalShapeInfo gives extra information for complex shapes
    ///Currently, only btTriangleMeshShape is available, so it just contains triangleIndex and subpart
    LocalShapeInfo :: struct {
        m_shapePart:     s32;
        m_triangleIndex: s32;
    }

    LocalRayResult :: struct {
        Constructor :: (this: *LocalRayResult, collisionObject: *btCollisionObject, localShapeInfo: *LocalShapeInfo, hitNormalLocal: *btVector3, hitFraction: btScalar) -> void #cpp_method #foreign bullet3 "??0LocalRayResult@btCollisionWorld@@QEAA@PEBVbtCollisionObject@@PEAULocalShapeInfo@1@AEBVbtVector3@@M@Z";
        Constructor :: (this: *LocalRayResult, collisionObject: *btCollisionObject, localShapeInfo: *LocalShapeInfo, hitNormalLocal: btVector3, hitFraction: btScalar) #no_context {
            Constructor(this, collisionObject, localShapeInfo, *hitNormalLocal, hitFraction);
        }

        m_collisionObject: *btCollisionObject;
        m_localShapeInfo:  *LocalShapeInfo;
        m_hitNormalLocal:  btVector3;
        m_hitFraction:     btScalar;
    }

    ///RayResultCallback is used to report new raycast results
    RayResultCallback :: struct {
        vtable: *RayResultCallback_VTable;
        m_closestHitFraction:   btScalar;
        m_collisionObject:      *btCollisionObject;
        m_collisionFilterGroup: s32;
        m_collisionFilterMask:  s32;

        //@BP Mod - Custom flags, currently used to enable backface culling on tri-meshes, see btRaycastCallback.h. Apply any of the EFlags defined there on m_flags here to invoke.
        m_flags:                u32;

        hasHit :: (this: *RayResultCallback) -> bool #cpp_method #foreign bullet3 "?hasHit@RayResultCallback@btCollisionWorld@@QEBA_NXZ";

        Constructor :: (this: *RayResultCallback) -> void #cpp_method #foreign bullet3 "??0RayResultCallback@btCollisionWorld@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *RayResultCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1RayResultCallback@btCollisionWorld@@UEAA@XZ";

        virtual_needsCollision :: (this: *RayResultCallback, proxy0: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?needsCollision@RayResultCallback@btCollisionWorld@@UEBA_NPEAUbtBroadphaseProxy@@@Z";
    }
    RayResultCallback_VTable :: struct #type_info_none {
        Destructor: (this: *RayResultCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        needsCollision: (this: *RayResultCallback, proxy0: *btBroadphaseProxy) -> bool #cpp_method;

        addSingleResult: (this: *RayResultCallback, rayResult: *LocalRayResult, normalInWorldSpace: bool) -> btScalar #cpp_method;
    }

    RayResultCallback_Destructor :: inline (this: *RayResultCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    RayResultCallback_needsCollision :: inline (this: *RayResultCallback, proxy0: *btBroadphaseProxy) -> bool { return this.vtable.needsCollision(this, proxy0); }

    RayResultCallback_addSingleResult :: inline (this: *RayResultCallback, rayResult: *LocalRayResult, normalInWorldSpace: bool) -> btScalar { return this.vtable.addSingleResult(this, rayResult, normalInWorldSpace); }


    ClosestRayResultCallback :: struct {
        #as using rayresultcallback: RayResultCallback;

        Constructor :: (this: *ClosestRayResultCallback, rayFromWorld: *btVector3, rayToWorld: *btVector3) -> void #cpp_method #foreign bullet3 "??0ClosestRayResultCallback@btCollisionWorld@@QEAA@AEBVbtVector3@@0@Z";
        Constructor :: (this: *ClosestRayResultCallback, rayFromWorld: btVector3, rayToWorld: btVector3) #no_context {
            Constructor(this, *rayFromWorld, *rayToWorld);
        }

        m_rayFromWorld:   btVector3; //used to calculate hitPointWorld from hitFraction
        m_rayToWorld:     btVector3;

        m_hitNormalWorld: btVector3;
        m_hitPointWorld:  btVector3;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_addSingleResult :: (this: *ClosestRayResultCallback, rayResult: *LocalRayResult, normalInWorldSpace: bool) -> btScalar #cpp_method #foreign bullet3 "?addSingleResult@ClosestRayResultCallback@btCollisionWorld@@UEAAMAEAULocalRayResult@2@_N@Z";
    }

    AllHitsRayResultCallback :: struct {
        #as using rayresultcallback: RayResultCallback;

        Constructor :: (this: *AllHitsRayResultCallback, rayFromWorld: *btVector3, rayToWorld: *btVector3) -> void #cpp_method #foreign bullet3 "??0AllHitsRayResultCallback@btCollisionWorld@@QEAA@AEBVbtVector3@@0@Z";
        Constructor :: (this: *AllHitsRayResultCallback, rayFromWorld: btVector3, rayToWorld: btVector3) #no_context {
            Constructor(this, *rayFromWorld, *rayToWorld);
        }

        m_collisionObjects: btAlignedObjectArray(*btCollisionObject);

        m_rayFromWorld:     btVector3; //used to calculate hitPointWorld from hitFraction
        m_rayToWorld:       btVector3;

        m_hitNormalWorld:   btAlignedObjectArray(btVector3);
        m_hitPointWorld:    btAlignedObjectArray(btVector3);
        m_hitFractions:     btAlignedObjectArray(btScalar);

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_addSingleResult :: (this: *AllHitsRayResultCallback, rayResult: *LocalRayResult, normalInWorldSpace: bool) -> btScalar #cpp_method #foreign bullet3 "?addSingleResult@AllHitsRayResultCallback@btCollisionWorld@@UEAAMAEAULocalRayResult@2@_N@Z";
    }

    LocalConvexResult :: struct {
        Constructor :: (this: *LocalConvexResult, hitCollisionObject: *btCollisionObject, localShapeInfo: *LocalShapeInfo, hitNormalLocal: *btVector3, hitPointLocal: *btVector3, hitFraction: btScalar) -> void #cpp_method #foreign bullet3 "??0LocalConvexResult@btCollisionWorld@@QEAA@PEBVbtCollisionObject@@PEAULocalShapeInfo@1@AEBVbtVector3@@2M@Z";
        Constructor :: (this: *LocalConvexResult, hitCollisionObject: *btCollisionObject, localShapeInfo: *LocalShapeInfo, hitNormalLocal: btVector3, hitPointLocal: btVector3, hitFraction: btScalar) #no_context {
            Constructor(this, hitCollisionObject, localShapeInfo, *hitNormalLocal, *hitPointLocal, hitFraction);
        }

        m_hitCollisionObject: *btCollisionObject;
        m_localShapeInfo:     *LocalShapeInfo;
        m_hitNormalLocal:     btVector3;
        m_hitPointLocal:      btVector3;
        m_hitFraction:        btScalar;
    }

    ///RayResultCallback is used to report new raycast results
    ConvexResultCallback :: struct {
        vtable: *ConvexResultCallback_VTable;
        m_closestHitFraction:   btScalar;
        m_collisionFilterGroup: s32;
        m_collisionFilterMask:  s32;

        Constructor :: (this: *ConvexResultCallback) -> void #cpp_method #foreign bullet3 "??0ConvexResultCallback@btCollisionWorld@@QEAA@XZ";

        hasHit :: (this: *ConvexResultCallback) -> bool #cpp_method #foreign bullet3 "?hasHit@ConvexResultCallback@btCollisionWorld@@QEBA_NXZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *ConvexResultCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1ConvexResultCallback@btCollisionWorld@@UEAA@XZ";

        virtual_needsCollision :: (this: *ConvexResultCallback, proxy0: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?needsCollision@ConvexResultCallback@btCollisionWorld@@UEBA_NPEAUbtBroadphaseProxy@@@Z";
    }
    ConvexResultCallback_VTable :: struct #type_info_none {
        Destructor: (this: *ConvexResultCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        needsCollision: (this: *ConvexResultCallback, proxy0: *btBroadphaseProxy) -> bool #cpp_method;

        addSingleResult: (this: *ConvexResultCallback, convexResult: *LocalConvexResult, normalInWorldSpace: bool) -> btScalar #cpp_method;
    }

    ConvexResultCallback_Destructor :: inline (this: *ConvexResultCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    ConvexResultCallback_needsCollision :: inline (this: *ConvexResultCallback, proxy0: *btBroadphaseProxy) -> bool { return this.vtable.needsCollision(this, proxy0); }

    ConvexResultCallback_addSingleResult :: inline (this: *ConvexResultCallback, convexResult: *LocalConvexResult, normalInWorldSpace: bool) -> btScalar { return this.vtable.addSingleResult(this, convexResult, normalInWorldSpace); }



    ClosestConvexResultCallback :: struct {
        #as using convexresultcallback: ConvexResultCallback;

        Constructor :: (this: *ClosestConvexResultCallback, convexFromWorld: *btVector3, convexToWorld: *btVector3) -> void #cpp_method #foreign bullet3 "??0ClosestConvexResultCallback@btCollisionWorld@@QEAA@AEBVbtVector3@@0@Z";
        Constructor :: (this: *ClosestConvexResultCallback, convexFromWorld: btVector3, convexToWorld: btVector3) #no_context {
            Constructor(this, *convexFromWorld, *convexToWorld);
        }

        m_convexFromWorld:    btVector3; //used to calculate hitPointWorld from hitFraction
        m_convexToWorld:      btVector3;

        m_hitNormalWorld:     btVector3;
        m_hitPointWorld:      btVector3;
        m_hitCollisionObject: *btCollisionObject;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_addSingleResult :: (this: *ClosestConvexResultCallback, convexResult: *LocalConvexResult, normalInWorldSpace: bool) -> btScalar #cpp_method #foreign bullet3 "?addSingleResult@ClosestConvexResultCallback@btCollisionWorld@@UEAAMAEAULocalConvexResult@2@_N@Z";
    }

    ///ContactResultCallback is used to report contact points
    ContactResultCallback :: struct {
        vtable: *ContactResultCallback_VTable;
        m_collisionFilterGroup:     s32;
        m_collisionFilterMask:      s32;
        m_closestDistanceThreshold: btScalar;

        Constructor :: (this: *ContactResultCallback) -> void #cpp_method #foreign bullet3 "??0ContactResultCallback@btCollisionWorld@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *ContactResultCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1ContactResultCallback@btCollisionWorld@@UEAA@XZ";

        virtual_needsCollision :: (this: *ContactResultCallback, proxy0: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?needsCollision@ContactResultCallback@btCollisionWorld@@UEBA_NPEAUbtBroadphaseProxy@@@Z";
    }
    ContactResultCallback_VTable :: struct #type_info_none {
        Destructor: (this: *ContactResultCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        needsCollision: (this: *ContactResultCallback, proxy0: *btBroadphaseProxy) -> bool #cpp_method;

        addSingleResult: (this: *ContactResultCallback, cp: *btManifoldPoint, colObj0Wrap: *btCollisionObjectWrapper, partId0: s32, index0: s32, colObj1Wrap: *btCollisionObjectWrapper, partId1: s32, index1: s32) -> btScalar #cpp_method;
    }

    ContactResultCallback_Destructor :: inline (this: *ContactResultCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    ContactResultCallback_needsCollision :: inline (this: *ContactResultCallback, proxy0: *btBroadphaseProxy) -> bool { return this.vtable.needsCollision(this, proxy0); }

    ContactResultCallback_addSingleResult :: inline (this: *ContactResultCallback, cp: *btManifoldPoint, colObj0Wrap: *btCollisionObjectWrapper, partId0: s32, index0: s32, colObj1Wrap: *btCollisionObjectWrapper, partId1: s32, index1: s32) -> btScalar { return this.vtable.addSingleResult(this, cp, colObj0Wrap, partId0, index0, colObj1Wrap, partId1, index1); }



    getNumCollisionObjects :: (this: *btCollisionWorld) -> s32 #cpp_method #foreign bullet3 "?getNumCollisionObjects@btCollisionWorld@@QEBAHXZ";

    /// convexTest performs a swept convex cast on all objects in the btCollisionWorld, and calls the resultCallback
    /// This allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback.
    convexSweepTest :: (this: *btCollisionWorld, castShape: *btConvexShape, from: *btTransform, to: *btTransform, resultCallback: *ConvexResultCallback, allowedCcdPenetration: btScalar) -> void #cpp_method #foreign bullet3 "?convexSweepTest@btCollisionWorld@@QEBAXPEBVbtConvexShape@@AEBVbtTransform@@1AEAUConvexResultCallback@1@M@Z";
    convexSweepTest :: (this: *btCollisionWorld, castShape: *btConvexShape, from: btTransform, to: btTransform, resultCallback: *ConvexResultCallback, allowedCcdPenetration: btScalar) #no_context {
        convexSweepTest(this, castShape, *from, *to, resultCallback, allowedCcdPenetration);
    }

    ///contactTest performs a discrete collision test between colObj against all objects in the btCollisionWorld, and calls the resultCallback.
    ///it reports one or more contact points for every overlapping object (including the one with deepest penetration)
    contactTest :: (this: *btCollisionWorld, colObj: *btCollisionObject, resultCallback: *ContactResultCallback) -> void #cpp_method #foreign bullet3 "?contactTest@btCollisionWorld@@QEAAXPEAVbtCollisionObject@@AEAUContactResultCallback@1@@Z";

    ///contactTest performs a discrete collision test between two collision objects and calls the resultCallback if overlap if detected.
    ///it reports one or more contact points (including the one with deepest penetration)
    contactPairTest :: (this: *btCollisionWorld, colObjA: *btCollisionObject, colObjB: *btCollisionObject, resultCallback: *ContactResultCallback) -> void #cpp_method #foreign bullet3 "?contactPairTest@btCollisionWorld@@QEAAXPEAVbtCollisionObject@@0AEAUContactResultCallback@1@@Z";

    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// This allows more customization.
    rayTestSingle :: (rayFromTrans: *btTransform, rayToTrans: *btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: *btTransform, resultCallback: *RayResultCallback) -> void #foreign bullet3 "?rayTestSingle@btCollisionWorld@@SAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@1@@Z";
    rayTestSingle :: (rayFromTrans: btTransform, rayToTrans: btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: btTransform, resultCallback: *RayResultCallback) #no_context {
        rayTestSingle(*rayFromTrans, *rayToTrans, collisionObject, collisionShape, *colObjWorldTransform, resultCallback);
    }

    rayTestSingleInternal :: (rayFromTrans: *btTransform, rayToTrans: *btTransform, collisionObjectWrap: *btCollisionObjectWrapper, resultCallback: *RayResultCallback) -> void #foreign bullet3 "?rayTestSingleInternal@btCollisionWorld@@SAXAEBVbtTransform@@0PEBUbtCollisionObjectWrapper@@AEAURayResultCallback@1@@Z";
    rayTestSingleInternal :: (rayFromTrans: btTransform, rayToTrans: btTransform, collisionObjectWrap: *btCollisionObjectWrapper, resultCallback: *RayResultCallback) #no_context {
        rayTestSingleInternal(*rayFromTrans, *rayToTrans, collisionObjectWrap, resultCallback);
    }

    /// objectQuerySingle performs a collision detection query and calls the resultCallback. It is used internally by rayTest.
    objectQuerySingle :: (castShape: *btConvexShape, rayFromTrans: *btTransform, rayToTrans: *btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: *btTransform, resultCallback: *ConvexResultCallback, allowedPenetration: btScalar) -> void #foreign bullet3 "?objectQuerySingle@btCollisionWorld@@SAXPEBVbtConvexShape@@AEBVbtTransform@@1PEAVbtCollisionObject@@PEBVbtCollisionShape@@1AEAUConvexResultCallback@1@M@Z";
    objectQuerySingle :: (castShape: *btConvexShape, rayFromTrans: btTransform, rayToTrans: btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: btTransform, resultCallback: *ConvexResultCallback, allowedPenetration: btScalar) #no_context {
        objectQuerySingle(castShape, *rayFromTrans, *rayToTrans, collisionObject, collisionShape, *colObjWorldTransform, resultCallback, allowedPenetration);
    }

    objectQuerySingleInternal :: (castShape: *btConvexShape, convexFromTrans: *btTransform, convexToTrans: *btTransform, colObjWrap: *btCollisionObjectWrapper, resultCallback: *ConvexResultCallback, allowedPenetration: btScalar) -> void #foreign bullet3 "?objectQuerySingleInternal@btCollisionWorld@@SAXPEBVbtConvexShape@@AEBVbtTransform@@1PEBUbtCollisionObjectWrapper@@AEAUConvexResultCallback@1@M@Z";
    objectQuerySingleInternal :: (castShape: *btConvexShape, convexFromTrans: btTransform, convexToTrans: btTransform, colObjWrap: *btCollisionObjectWrapper, resultCallback: *ConvexResultCallback, allowedPenetration: btScalar) #no_context {
        objectQuerySingleInternal(castShape, *convexFromTrans, *convexToTrans, colObjWrap, resultCallback, allowedPenetration);
    }

    getCollisionObjectArray :: (this: *btCollisionWorld) -> *btCollisionObjectArray #cpp_method #foreign bullet3 "?getCollisionObjectArray@btCollisionWorld@@QEAAAEAV?$btAlignedObjectArray@PEAVbtCollisionObject@@@@XZ";

    getCollisionObjectArray_1 :: (this: /*const*/ *btCollisionWorld) -> *btCollisionObjectArray #cpp_method #foreign bullet3 "?getCollisionObjectArray@btCollisionWorld@@QEBAAEBV?$btAlignedObjectArray@PEAVbtCollisionObject@@@@XZ";

    getDispatchInfo :: (this: *btCollisionWorld) -> *btDispatcherInfo #cpp_method #foreign bullet3 "?getDispatchInfo@btCollisionWorld@@QEAAAEAUbtDispatcherInfo@@XZ";

    getDispatchInfo_1 :: (this: /*const*/ *btCollisionWorld) -> *btDispatcherInfo #cpp_method #foreign bullet3 "?getDispatchInfo@btCollisionWorld@@QEBAAEBUbtDispatcherInfo@@XZ";

    getForceUpdateAllAabbs :: (this: *btCollisionWorld) -> bool #cpp_method #foreign bullet3 "?getForceUpdateAllAabbs@btCollisionWorld@@QEBA_NXZ";

    setForceUpdateAllAabbs :: (this: *btCollisionWorld, forceUpdateAllAabbs: bool) -> void #cpp_method #foreign bullet3 "?setForceUpdateAllAabbs@btCollisionWorld@@QEAAX_N@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCollisionWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionWorld@@UEAA@XZ";

    virtual_updateAabbs :: (this: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?updateAabbs@btCollisionWorld@@UEAAXXZ";

    ///the computeOverlappingPairs is usually already called by performDiscreteCollisionDetection (or stepSimulation)
    ///it can be useful to use if you perform ray tests without collision detection/simulation
    virtual_computeOverlappingPairs :: (this: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?computeOverlappingPairs@btCollisionWorld@@UEAAXXZ";

    virtual_setDebugDrawer :: (this: *btCollisionWorld, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?setDebugDrawer@btCollisionWorld@@UEAAXPEAVbtIDebugDraw@@@Z";

    virtual_getDebugDrawer :: (this: *btCollisionWorld) -> *btIDebugDraw #cpp_method #foreign bullet3 "?getDebugDrawer@btCollisionWorld@@UEAAPEAVbtIDebugDraw@@XZ";

    virtual_debugDrawWorld :: (this: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btCollisionWorld@@UEAAXXZ";

    virtual_debugDrawObject :: (this: *btCollisionWorld, worldTransform: *btTransform, shape: *btCollisionShape, color: *btVector3) -> void #cpp_method #foreign bullet3 "?debugDrawObject@btCollisionWorld@@UEAAXAEBVbtTransform@@PEBVbtCollisionShape@@AEBVbtVector3@@@Z";

    /// rayTest performs a raycast on all objects in the btCollisionWorld, and calls the resultCallback
    /// This allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback.
    virtual_rayTest :: (this: *btCollisionWorld, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btCollisionWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@1@@Z";

    virtual_addCollisionObject :: (this: *btCollisionWorld, collisionObject: *btCollisionObject, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method #foreign bullet3 "?addCollisionObject@btCollisionWorld@@UEAAXPEAVbtCollisionObject@@HH@Z";

    virtual_refreshBroadphaseProxy :: (this: *btCollisionWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?refreshBroadphaseProxy@btCollisionWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_removeCollisionObject :: (this: *btCollisionWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCollisionObject@btCollisionWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_performDiscreteCollisionDetection :: (this: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?performDiscreteCollisionDetection@btCollisionWorld@@UEAAXXZ";

    ///Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (Bullet/Demos/SerializeDemo)
    virtual_serialize :: (this: *btCollisionWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serialize@btCollisionWorld@@UEAAXPEAVbtSerializer@@@Z";
}
btCollisionWorld_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    updateAabbs: (this: *btCollisionWorld) -> void #cpp_method;

    computeOverlappingPairs: (this: *btCollisionWorld) -> void #cpp_method;

    setDebugDrawer: (this: *btCollisionWorld, debugDrawer: *btIDebugDraw) -> void #cpp_method;

    getDebugDrawer: (this: *btCollisionWorld) -> *btIDebugDraw #cpp_method;

    debugDrawWorld: (this: *btCollisionWorld) -> void #cpp_method;

    debugDrawObject: (this: *btCollisionWorld, worldTransform: *btTransform, shape: *btCollisionShape, color: *btVector3) -> void #cpp_method;

    rayTest: (this: *btCollisionWorld, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method;

    addCollisionObject: (this: *btCollisionWorld, collisionObject: *btCollisionObject, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method;

    refreshBroadphaseProxy: (this: *btCollisionWorld, collisionObject: *btCollisionObject) -> void #cpp_method;

    removeCollisionObject: (this: *btCollisionWorld, collisionObject: *btCollisionObject) -> void #cpp_method;

    performDiscreteCollisionDetection: (this: *btCollisionWorld) -> void #cpp_method;

    serialize: (this: *btCollisionWorld, serializer: *btSerializer) -> void #cpp_method;
}

btCollisionWorld_Destructor :: inline (this: *btCollisionWorld, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionWorld_updateAabbs :: inline (this: *btCollisionWorld) { this.vtable.updateAabbs(this); }

btCollisionWorld_computeOverlappingPairs :: inline (this: *btCollisionWorld) { this.vtable.computeOverlappingPairs(this); }

btCollisionWorld_setDebugDrawer :: inline (this: *btCollisionWorld, debugDrawer: *btIDebugDraw) { this.vtable.setDebugDrawer(this, debugDrawer); }

btCollisionWorld_getDebugDrawer :: inline (this: *btCollisionWorld) -> *btIDebugDraw { return this.vtable.getDebugDrawer(this); }

btCollisionWorld_debugDrawWorld :: inline (this: *btCollisionWorld) { this.vtable.debugDrawWorld(this); }

btCollisionWorld_debugDrawObject :: inline (this: *btCollisionWorld, worldTransform: *btTransform, shape: *btCollisionShape, color: *btVector3) { this.vtable.debugDrawObject(this, worldTransform, shape, color); }

btCollisionWorld_rayTest :: inline (this: *btCollisionWorld, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) { this.vtable.rayTest(this, rayFromWorld, rayToWorld, resultCallback); }

btCollisionWorld_addCollisionObject :: inline (this: *btCollisionWorld, collisionObject: *btCollisionObject, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) { this.vtable.addCollisionObject(this, collisionObject, collisionFilterGroup, collisionFilterMask); }

btCollisionWorld_refreshBroadphaseProxy :: inline (this: *btCollisionWorld, collisionObject: *btCollisionObject) { this.vtable.refreshBroadphaseProxy(this, collisionObject); }

btCollisionWorld_removeCollisionObject :: inline (this: *btCollisionWorld, collisionObject: *btCollisionObject) { this.vtable.removeCollisionObject(this, collisionObject); }

btCollisionWorld_performDiscreteCollisionDetection :: inline (this: *btCollisionWorld) { this.vtable.performDiscreteCollisionDetection(this); }

btCollisionWorld_serialize :: inline (this: *btCollisionWorld, serializer: *btSerializer) { this.vtable.serialize(this, serializer); }



///The btCollisionShape class provides an interface for collision shapes that can be shared among btCollisionObjects.
btCollisionShape :: struct {
    vtable: *btCollisionShape_VTable;
    m_shapeType:   s32;
    m_userPointer: *void;
    m_userIndex:   s32;
    m_userIndex2:  s32;

    Constructor :: (this: *btCollisionShape) -> void #cpp_method #foreign bullet3 "??0btCollisionShape@@QEAA@XZ";

    ///calculateTemporalAabb calculates the enclosing aabb for the moving object over interval [0..timeStep)
    ///result is conservative
    calculateTemporalAabb :: (this: *btCollisionShape, curTrans: *btTransform, linvel: *btVector3, angvel: *btVector3, timeStep: btScalar, temporalAabbMin: *btVector3, temporalAabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateTemporalAabb@btCollisionShape@@QEBAXAEBVbtTransform@@AEBVbtVector3@@1MAEAV3@2@Z";
    calculateTemporalAabb :: (this: *btCollisionShape, curTrans: btTransform, linvel: btVector3, angvel: btVector3, timeStep: btScalar, temporalAabbMin: *btVector3, temporalAabbMax: *btVector3) #no_context {
        calculateTemporalAabb(this, *curTrans, *linvel, *angvel, timeStep, temporalAabbMin, temporalAabbMax);
    }

    isPolyhedral :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isPolyhedral@btCollisionShape@@QEBA_NXZ";

    isConvex2d :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isConvex2d@btCollisionShape@@QEBA_NXZ";

    isConvex :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isConvex@btCollisionShape@@QEBA_NXZ";

    isNonMoving :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isNonMoving@btCollisionShape@@QEBA_NXZ";

    isConcave :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isConcave@btCollisionShape@@QEBA_NXZ";

    isCompound :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isCompound@btCollisionShape@@QEBA_NXZ";

    isSoftBody :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isSoftBody@btCollisionShape@@QEBA_NXZ";

    ///isInfinite is used to catch simulation error (aabb check)
    isInfinite :: (this: *btCollisionShape) -> bool #cpp_method #foreign bullet3 "?isInfinite@btCollisionShape@@QEBA_NXZ";

    getShapeType :: (this: *btCollisionShape) -> s32 #cpp_method #foreign bullet3 "?getShapeType@btCollisionShape@@QEBAHXZ";

    ///optional user data pointer
    setUserPointer :: (this: *btCollisionShape, userPtr: *void) -> void #cpp_method #foreign bullet3 "?setUserPointer@btCollisionShape@@QEAAXPEAX@Z";

    getUserPointer :: (this: *btCollisionShape) -> *void #cpp_method #foreign bullet3 "?getUserPointer@btCollisionShape@@QEBAPEAXXZ";

    setUserIndex :: (this: *btCollisionShape, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex@btCollisionShape@@QEAAXH@Z";

    getUserIndex :: (this: *btCollisionShape) -> s32 #cpp_method #foreign bullet3 "?getUserIndex@btCollisionShape@@QEBAHXZ";

    setUserIndex2 :: (this: *btCollisionShape, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex2@btCollisionShape@@QEAAXH@Z";

    getUserIndex2 :: (this: *btCollisionShape) -> s32 #cpp_method #foreign bullet3 "?getUserIndex2@btCollisionShape@@QEBAHXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCollisionShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionShape@@UEAA@XZ";

    virtual_getBoundingSphere :: (this: *btCollisionShape, center: *btVector3, radius: *btScalar) -> void #cpp_method #foreign bullet3 "?getBoundingSphere@btCollisionShape@@UEBAXAEAVbtVector3@@AEAM@Z";

    ///getAngularMotionDisc returns the maximum radius needed for Conservative Advancement to handle time-of-impact with rotations.
    virtual_getAngularMotionDisc :: (this: *btCollisionShape) -> btScalar #cpp_method #foreign bullet3 "?getAngularMotionDisc@btCollisionShape@@UEBAMXZ";

    virtual_getContactBreakingThreshold :: (this: *btCollisionShape, defaultContactThresholdFactor: btScalar) -> btScalar #cpp_method #foreign bullet3 "?getContactBreakingThreshold@btCollisionShape@@UEBAMM@Z";

    ///the getAnisotropicRollingFrictionDirection can be used in combination with setAnisotropicFriction
    ///See Bullet/Demos/RollingFrictionDemo for an example
    virtual_getAnisotropicRollingFrictionDirection :: (this: *btCollisionShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAnisotropicRollingFrictionDirection@btCollisionShape@@UEBA?AVbtVector3@@XZ";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btCollisionShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btCollisionShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btCollisionShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btCollisionShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";

    virtual_serializeSingleShape :: (this: *btCollisionShape, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSingleShape@btCollisionShape@@UEBAXPEAVbtSerializer@@@Z";
}
btCollisionShape_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getAabb: (this: *btCollisionShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    getBoundingSphere: (this: *btCollisionShape, center: *btVector3, radius: *btScalar) -> void #cpp_method;

    getAngularMotionDisc: (this: *btCollisionShape) -> btScalar #cpp_method;

    getContactBreakingThreshold: (this: *btCollisionShape, defaultContactThresholdFactor: btScalar) -> btScalar #cpp_method;

    setLocalScaling: (this: *btCollisionShape, scaling: *btVector3) -> void #cpp_method;
    getLocalScaling: (this: *btCollisionShape) -> *btVector3 #cpp_method;
    calculateLocalInertia: (this: *btCollisionShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method;

    getName: (this: *btCollisionShape) -> *u8 #cpp_method;

    getAnisotropicRollingFrictionDirection: (this: *btCollisionShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    setMargin: (this: *btCollisionShape, margin: btScalar) -> void #cpp_method;
    getMargin: (this: *btCollisionShape) -> btScalar #cpp_method;

    calculateSerializeBufferSize: (this: *btCollisionShape) -> s32 #cpp_method;

    serialize: (this: *btCollisionShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;

    serializeSingleShape: (this: *btCollisionShape, serializer: *btSerializer) -> void #cpp_method;
}

btCollisionShape_Destructor :: inline (this: *btCollisionShape, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionShape_getAabb :: inline (this: *btCollisionShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.getAabb(this, t, aabbMin, aabbMax); }

btCollisionShape_getBoundingSphere :: inline (this: *btCollisionShape, center: *btVector3, radius: *btScalar) { this.vtable.getBoundingSphere(this, center, radius); }

btCollisionShape_getAngularMotionDisc :: inline (this: *btCollisionShape) -> btScalar { return this.vtable.getAngularMotionDisc(this); }

btCollisionShape_getContactBreakingThreshold :: inline (this: *btCollisionShape, defaultContactThresholdFactor: btScalar) -> btScalar { return this.vtable.getContactBreakingThreshold(this, defaultContactThresholdFactor); }

btCollisionShape_setLocalScaling :: inline (this: *btCollisionShape, scaling: *btVector3) { this.vtable.setLocalScaling(this, scaling); }
btCollisionShape_getLocalScaling :: inline (this: *btCollisionShape) -> *btVector3 { return this.vtable.getLocalScaling(this); }
btCollisionShape_calculateLocalInertia :: inline (this: *btCollisionShape, mass: btScalar, inertia: *btVector3) { this.vtable.calculateLocalInertia(this, mass, inertia); }

btCollisionShape_getName :: inline (this: *btCollisionShape) -> *u8 { return this.vtable.getName(this); }

btCollisionShape_getAnisotropicRollingFrictionDirection :: inline (this: *btCollisionShape) -> btVector3 { return this.vtable.getAnisotropicRollingFrictionDirection(this); }

btCollisionShape_setMargin :: inline (this: *btCollisionShape, margin: btScalar) { this.vtable.setMargin(this, margin); }
btCollisionShape_getMargin :: inline (this: *btCollisionShape) -> btScalar { return this.vtable.getMargin(this); }

btCollisionShape_calculateSerializeBufferSize :: inline (this: *btCollisionShape) -> s32 { return this.vtable.calculateSerializeBufferSize(this); }

btCollisionShape_serialize :: inline (this: *btCollisionShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }

btCollisionShape_serializeSingleShape :: inline (this: *btCollisionShape, serializer: *btSerializer) { this.vtable.serializeSingleShape(this, serializer); }




// clang-format off
// parser needs * with the name
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCollisionShapeData :: struct {
    m_name:      *u8;
    m_shapeType: s32;
    m_padding:   [4] u8;
}

/// The btConvexShape is an abstract shape interface, implemented by all convex shapes such as btBoxShape, btConvexHullShape etc.
/// It describes general convex shapes using the localGetSupportingVertex interface, used by collision detectors such as btGjkPairDetector.
btConvexShape :: struct {
    #as using btcollisionshape: btCollisionShape;

    Constructor :: (this: *btConvexShape) -> void #cpp_method #foreign bullet3 "??0btConvexShape@@QEAA@XZ";

    localGetSupportVertexWithoutMarginNonVirtual :: (this: *btConvexShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportVertexWithoutMarginNonVirtual@btConvexShape@@QEBA?AVbtVector3@@AEBV2@@Z";
    localGetSupportVertexWithoutMarginNonVirtual :: (this: *btConvexShape, vec: btVector3) -> btVector3 #no_context {
        return localGetSupportVertexWithoutMarginNonVirtual(this, *vec);
    }
    localGetSupportVertexNonVirtual :: (this: *btConvexShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportVertexNonVirtual@btConvexShape@@QEBA?AVbtVector3@@AEBV2@@Z";
    localGetSupportVertexNonVirtual :: (this: *btConvexShape, vec: btVector3) -> btVector3 #no_context {
        return localGetSupportVertexNonVirtual(this, *vec);
    }
    getMarginNonVirtual :: (this: *btConvexShape) -> btScalar #cpp_method #foreign bullet3 "?getMarginNonVirtual@btConvexShape@@QEBAMXZ";
    getAabbNonVirtual :: (this: *btConvexShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabbNonVirtual@btConvexShape@@QEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";
    getAabbNonVirtual :: (this: *btConvexShape, t: btTransform, aabbMin: *btVector3, aabbMax: *btVector3) #no_context {
        getAabbNonVirtual(this, *t, aabbMin, aabbMax);
    }
    #place btcollisionshape; btconvexshape_vtable: *btConvexShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexShape@@UEAA@XZ";

    virtual_project :: (this: *btConvexShape, trans: *btTransform, dir: *btVector3, minProj: *btScalar, maxProj: *btScalar, witnesPtMin: *btVector3, witnesPtMax: *btVector3) -> void #cpp_method #foreign bullet3 "?project@btConvexShape@@UEBAXAEBVbtTransform@@AEBVbtVector3@@AEAM2AEAV3@3@Z";
}
btConvexShape_VTable :: struct #type_info_none {
    using btcollisionshape: btCollisionShape_VTable;
    localGetSupportingVertex: (this: *btConvexShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    localGetSupportingVertexWithoutMargin: (this: *btConvexShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    project: (this: *btConvexShape, trans: *btTransform, dir: *btVector3, minProj: *btScalar, maxProj: *btScalar, witnesPtMin: *btVector3, witnesPtMax: *btVector3) -> void #cpp_method;

    batchedUnitVectorGetSupportingVertexWithoutMargin: (this: *btConvexShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method;

    getAabbSlow: (this: *btConvexShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    getNumPreferredPenetrationDirections: (this: *btConvexShape) -> s32 #cpp_method;

    getPreferredPenetrationDirection: (this: *btConvexShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method;
}

btConvexShape_localGetSupportingVertex :: inline (this: *btConvexShape, vec: *btVector3) -> btVector3 { return this.btconvexshape_vtable.localGetSupportingVertex(this, vec); }

btConvexShape_localGetSupportingVertexWithoutMargin :: inline (this: *btConvexShape, vec: *btVector3) -> btVector3 { return this.btconvexshape_vtable.localGetSupportingVertexWithoutMargin(this, vec); }

btConvexShape_project :: inline (this: *btConvexShape, trans: *btTransform, dir: *btVector3, minProj: *btScalar, maxProj: *btScalar, witnesPtMin: *btVector3, witnesPtMax: *btVector3) { this.btconvexshape_vtable.project(this, trans, dir, minProj, maxProj, witnesPtMin, witnesPtMax); }

btConvexShape_batchedUnitVectorGetSupportingVertexWithoutMargin :: inline (this: *btConvexShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) { this.btconvexshape_vtable.batchedUnitVectorGetSupportingVertexWithoutMargin(this, vectors, supportVerticesOut, numVectors); }

btConvexShape_getAabbSlow :: inline (this: *btConvexShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) { this.btconvexshape_vtable.getAabbSlow(this, t, aabbMin, aabbMax); }

btConvexShape_getNumPreferredPenetrationDirections :: inline (this: *btConvexShape) -> s32 { return this.btconvexshape_vtable.getNumPreferredPenetrationDirections(this); }

btConvexShape_getPreferredPenetrationDirection :: inline (this: *btConvexShape, index: s32, penetrationVector: *btVector3) { this.btconvexshape_vtable.getPreferredPenetrationDirection(this, index, penetrationVector); }

vtable :: (obj: *btConvexShape) -> *btConvexShape_VTable { return obj.btconvexshape_vtable; }



///The btConvexInternalShape is an internal base class, shared by most convex shape implementations.
///The btConvexInternalShape uses a default collision margin set to CONVEX_DISTANCE_MARGIN.
///This collision margin used by Gjk and some other algorithms, see also btCollisionMargin.h
///Note that when creating small shapes (derived from btConvexInternalShape),
///you need to make sure to set a smaller collision margin, using the 'setMargin' API
///There is a automatic mechanism 'setSafeMargin' used by btBoxShape and btCylinderShape
btConvexInternalShape :: struct {
    #as using btconvexshape: btConvexShape;

    //local scaling. collisionMargin is not scaled !
    m_localScaling:            btVector3;

    m_implicitShapeDimensions: btVector3;

    m_collisionMargin:         btScalar;

    m_padding:                 btScalar;

    Constructor :: (this: *btConvexInternalShape) -> void #cpp_method #foreign bullet3 "??0btConvexInternalShape@@IEAA@XZ";

    getImplicitShapeDimensions :: (this: *btConvexInternalShape) -> *btVector3 #cpp_method #foreign bullet3 "?getImplicitShapeDimensions@btConvexInternalShape@@QEBAAEBVbtVector3@@XZ";

    ///warning: use setImplicitShapeDimensions with care
    ///changing a collision shape while the body is in the world is not recommended,
    ///it is best to remove the body from the world, then make the change, and re-add it
    ///alternatively flush the contact points, see documentation for 'cleanProxyFromPairs'
    setImplicitShapeDimensions :: (this: *btConvexInternalShape, dimensions: *btVector3) -> void #cpp_method #foreign bullet3 "?setImplicitShapeDimensions@btConvexInternalShape@@QEAAXAEBVbtVector3@@@Z";
    setImplicitShapeDimensions :: (this: *btConvexInternalShape, dimensions: btVector3) #no_context {
        setImplicitShapeDimensions(this, *dimensions);
    }

    setSafeMargin :: (this: *btConvexInternalShape, minDimension: btScalar, defaultMarginMultiplier: btScalar = 0.1) -> void #cpp_method #foreign bullet3 "?setSafeMargin@btConvexInternalShape@@QEAAXMM@Z";

    setSafeMargin :: (this: *btConvexInternalShape, halfExtents: *btVector3, defaultMarginMultiplier: btScalar = 0.1) -> void #cpp_method #foreign bullet3 "?setSafeMargin@btConvexInternalShape@@QEAAXAEBVbtVector3@@M@Z";
    setSafeMargin :: (this: *btConvexInternalShape, halfExtents: btVector3, defaultMarginMultiplier: btScalar = 0.1) #no_context {
        setSafeMargin(this, *halfExtents, defaultMarginMultiplier);
    }

    getLocalScalingNV :: (this: *btConvexInternalShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScalingNV@btConvexInternalShape@@QEBAAEBVbtVector3@@XZ";

    getMarginNV :: (this: *btConvexInternalShape) -> btScalar #cpp_method #foreign bullet3 "?getMarginNV@btConvexInternalShape@@QEBAMXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexInternalShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexInternalShape@@UEAA@XZ";

    virtual_localGetSupportingVertex :: (this: *btConvexInternalShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btConvexInternalShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    ///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    virtual_getAabb :: (this: *btConvexInternalShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btConvexInternalShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_getAabbSlow :: (this: *btConvexInternalShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabbSlow@btConvexInternalShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_setLocalScaling :: (this: *btConvexInternalShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConvexInternalShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btConvexInternalShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btConvexInternalShape@@UEBAAEBVbtVector3@@XZ";

    virtual_setMargin :: (this: *btConvexInternalShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btConvexInternalShape@@UEAAXM@Z";

    virtual_getMargin :: (this: *btConvexInternalShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btConvexInternalShape@@UEBAMXZ";

    virtual_getNumPreferredPenetrationDirections :: (this: *btConvexInternalShape) -> s32 #cpp_method #foreign bullet3 "?getNumPreferredPenetrationDirections@btConvexInternalShape@@UEBAHXZ";

    virtual_getPreferredPenetrationDirection :: (this: *btConvexInternalShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method #foreign bullet3 "?getPreferredPenetrationDirection@btConvexInternalShape@@UEBAXHAEAVbtVector3@@@Z";

    virtual_calculateSerializeBufferSize :: (this: *btConvexInternalShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btConvexInternalShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btConvexInternalShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btConvexInternalShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btConvexInternalShapeData :: struct {
    m_collisionShapeData:      btCollisionShapeData;

    m_localScaling:            btVector3FloatData;

    m_implicitShapeDimensions: btVector3FloatData;

    m_collisionMargin:         float;

    m_padding:                 s32;
}

///btConvexInternalAabbCachingShape adds local aabb caching for convex shapes, to avoid expensive bounding box calculations
btConvexInternalAabbCachingShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_localAabbMin:     btVector3;
    m_localAabbMax:     btVector3;
    m_isLocalAabbValid: bool;

    Constructor :: (this: *btConvexInternalAabbCachingShape) -> void #cpp_method #foreign bullet3 "??0btConvexInternalAabbCachingShape@@IEAA@XZ";

    setCachedLocalAabb :: (this: *btConvexInternalAabbCachingShape, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?setCachedLocalAabb@btConvexInternalAabbCachingShape@@IEAAXAEBVbtVector3@@0@Z";
    setCachedLocalAabb :: (this: *btConvexInternalAabbCachingShape, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        setCachedLocalAabb(this, *aabbMin, *aabbMax);
    }

    getCachedLocalAabb :: (this: *btConvexInternalAabbCachingShape, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getCachedLocalAabb@btConvexInternalAabbCachingShape@@IEBAXAEAVbtVector3@@0@Z";

    getNonvirtualAabb :: (this: *btConvexInternalAabbCachingShape, trans: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3, margin: btScalar) -> void #cpp_method #foreign bullet3 "?getNonvirtualAabb@btConvexInternalAabbCachingShape@@IEBAXAEBVbtTransform@@AEAVbtVector3@@1M@Z";
    getNonvirtualAabb :: (this: *btConvexInternalAabbCachingShape, trans: btTransform, aabbMin: *btVector3, aabbMax: *btVector3, margin: btScalar) #no_context {
        getNonvirtualAabb(this, *trans, aabbMin, aabbMax, margin);
    }

    recalcLocalAabb :: (this: *btConvexInternalAabbCachingShape) -> void #cpp_method #foreign bullet3 "?recalcLocalAabb@btConvexInternalAabbCachingShape@@QEAAXXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_setLocalScaling :: (this: *btConvexInternalAabbCachingShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConvexInternalAabbCachingShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getAabb :: (this: *btConvexInternalAabbCachingShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btConvexInternalAabbCachingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";
}

///The btPolyhedralConvexShape is an internal interface class for polyhedral convex shapes.
btPolyhedralConvexShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_polyhedron: *btConvexPolyhedron;

    Constructor :: (this: *btPolyhedralConvexShape) -> void #cpp_method #foreign bullet3 "??0btPolyhedralConvexShape@@QEAA@XZ";

    getConvexPolyhedron :: (this: *btPolyhedralConvexShape) -> *btConvexPolyhedron #cpp_method #foreign bullet3 "?getConvexPolyhedron@btPolyhedralConvexShape@@QEBAPEBVbtConvexPolyhedron@@XZ";
    #place btconvexinternalshape; btpolyhedralconvexshape_vtable: *btPolyhedralConvexShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btPolyhedralConvexShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btPolyhedralConvexShape@@UEAA@XZ";

    ///optional method mainly used to generate multiple contact points by clipping polyhedral features (faces/edges)
    ///experimental/work-in-progress
    virtual_initializePolyhedralFeatures :: (this: *btPolyhedralConvexShape, shiftVerticesByMargin: s32 = 0) -> bool #cpp_method #foreign bullet3 "?initializePolyhedralFeatures@btPolyhedralConvexShape@@UEAA_NH@Z";

    virtual_setPolyhedralFeatures :: (this: *btPolyhedralConvexShape, polyhedron: *btConvexPolyhedron) -> void #cpp_method #foreign bullet3 "?setPolyhedralFeatures@btPolyhedralConvexShape@@UEAAXAEAVbtConvexPolyhedron@@@Z";

    //brute force implementations
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btPolyhedralConvexShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btPolyhedralConvexShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btPolyhedralConvexShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btPolyhedralConvexShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btPolyhedralConvexShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btPolyhedralConvexShape@@UEBAXMAEAVbtVector3@@@Z";
}
btPolyhedralConvexShape_VTable :: struct #type_info_none {
    using btconvexshape: btConvexShape_VTable;
    initializePolyhedralFeatures: (this: *btPolyhedralConvexShape, shiftVerticesByMargin: s32 = 0) -> bool #cpp_method;

    setPolyhedralFeatures: (this: *btPolyhedralConvexShape, polyhedron: *btConvexPolyhedron) -> void #cpp_method;

    getNumVertices: (this: *btPolyhedralConvexShape) -> s32 #cpp_method;
    getNumEdges: (this: *btPolyhedralConvexShape) -> s32 #cpp_method;
    getEdge: (this: *btPolyhedralConvexShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method;
    getVertex: (this: *btPolyhedralConvexShape, i: s32, vtx: *btVector3) -> void #cpp_method;
    getNumPlanes: (this: *btPolyhedralConvexShape) -> s32 #cpp_method;
    getPlane: (this: *btPolyhedralConvexShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method;

    isInside: (this: *btPolyhedralConvexShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method;
}

btPolyhedralConvexShape_initializePolyhedralFeatures :: inline (this: *btPolyhedralConvexShape, shiftVerticesByMargin: s32 = 0) -> bool { return this.btpolyhedralconvexshape_vtable.initializePolyhedralFeatures(this, shiftVerticesByMargin); }

btPolyhedralConvexShape_setPolyhedralFeatures :: inline (this: *btPolyhedralConvexShape, polyhedron: *btConvexPolyhedron) { this.btpolyhedralconvexshape_vtable.setPolyhedralFeatures(this, polyhedron); }

btPolyhedralConvexShape_getNumVertices :: inline (this: *btPolyhedralConvexShape) -> s32 { return this.btpolyhedralconvexshape_vtable.getNumVertices(this); }
btPolyhedralConvexShape_getNumEdges :: inline (this: *btPolyhedralConvexShape) -> s32 { return this.btpolyhedralconvexshape_vtable.getNumEdges(this); }
btPolyhedralConvexShape_getEdge :: inline (this: *btPolyhedralConvexShape, i: s32, pa: *btVector3, pb: *btVector3) { this.btpolyhedralconvexshape_vtable.getEdge(this, i, pa, pb); }
btPolyhedralConvexShape_getVertex :: inline (this: *btPolyhedralConvexShape, i: s32, vtx: *btVector3) { this.btpolyhedralconvexshape_vtable.getVertex(this, i, vtx); }
btPolyhedralConvexShape_getNumPlanes :: inline (this: *btPolyhedralConvexShape) -> s32 { return this.btpolyhedralconvexshape_vtable.getNumPlanes(this); }
btPolyhedralConvexShape_getPlane :: inline (this: *btPolyhedralConvexShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) { this.btpolyhedralconvexshape_vtable.getPlane(this, planeNormal, planeSupport, i); }

btPolyhedralConvexShape_isInside :: inline (this: *btPolyhedralConvexShape, pt: *btVector3, tolerance: btScalar) -> bool { return this.btpolyhedralconvexshape_vtable.isInside(this, pt, tolerance); }

vtable :: (obj: *btPolyhedralConvexShape) -> *btPolyhedralConvexShape_VTable { return obj.btpolyhedralconvexshape_vtable; }



///The btPolyhedralConvexAabbCachingShape adds aabb caching to the btPolyhedralConvexShape
btPolyhedralConvexAabbCachingShape :: struct {
    #as using btpolyhedralconvexshape: btPolyhedralConvexShape;

    m_localAabbMin:     btVector3;
    m_localAabbMax:     btVector3;
    m_isLocalAabbValid: bool;

    setCachedLocalAabb :: (this: *btPolyhedralConvexAabbCachingShape, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?setCachedLocalAabb@btPolyhedralConvexAabbCachingShape@@IEAAXAEBVbtVector3@@0@Z";
    setCachedLocalAabb :: (this: *btPolyhedralConvexAabbCachingShape, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        setCachedLocalAabb(this, *aabbMin, *aabbMax);
    }

    getCachedLocalAabb :: (this: *btPolyhedralConvexAabbCachingShape, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getCachedLocalAabb@btPolyhedralConvexAabbCachingShape@@IEBAXAEAVbtVector3@@0@Z";

    Constructor :: (this: *btPolyhedralConvexAabbCachingShape) -> void #cpp_method #foreign bullet3 "??0btPolyhedralConvexAabbCachingShape@@IEAA@XZ";

    getNonvirtualAabb :: (this: *btPolyhedralConvexAabbCachingShape, trans: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3, margin: btScalar) -> void #cpp_method #foreign bullet3 "?getNonvirtualAabb@btPolyhedralConvexAabbCachingShape@@QEBAXAEBVbtTransform@@AEAVbtVector3@@1M@Z";
    getNonvirtualAabb :: (this: *btPolyhedralConvexAabbCachingShape, trans: btTransform, aabbMin: *btVector3, aabbMax: *btVector3, margin: btScalar) #no_context {
        getNonvirtualAabb(this, *trans, aabbMin, aabbMax, margin);
    }

    recalcLocalAabb :: (this: *btPolyhedralConvexAabbCachingShape) -> void #cpp_method #foreign bullet3 "?recalcLocalAabb@btPolyhedralConvexAabbCachingShape@@QEAAXXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_setLocalScaling :: (this: *btPolyhedralConvexAabbCachingShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btPolyhedralConvexAabbCachingShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getAabb :: (this: *btPolyhedralConvexAabbCachingShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btPolyhedralConvexAabbCachingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";
}

///The btBoxShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
btBoxShape :: struct {
    #as using btpolyhedralconvexshape: btPolyhedralConvexShape;

    getHalfExtentsWithMargin :: (this: *btBoxShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getHalfExtentsWithMargin@btBoxShape@@QEBA?AVbtVector3@@XZ";

    getHalfExtentsWithoutMargin :: (this: *btBoxShape) -> *btVector3 #cpp_method #foreign bullet3 "?getHalfExtentsWithoutMargin@btBoxShape@@QEBAAEBVbtVector3@@XZ";

    Constructor :: (this: *btBoxShape, boxHalfExtents: *btVector3) -> void #cpp_method #foreign bullet3 "??0btBoxShape@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btBoxShape, boxHalfExtents: btVector3) #no_context {
        Constructor(this, *boxHalfExtents);
    }
    #place btpolyhedralconvexshape; btboxshape_vtable: *btBoxShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btBoxShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btBoxShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btBoxShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btBoxShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btBoxShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btBoxShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_setMargin :: (this: *btBoxShape, collisionMargin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btBoxShape@@UEAAXM@Z";

    virtual_setLocalScaling :: (this: *btBoxShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btBoxShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getAabb :: (this: *btBoxShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btBoxShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_calculateLocalInertia :: (this: *btBoxShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btBoxShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getPlane :: (this: *btBoxShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btBoxShape@@UEBAXAEAVbtVector3@@0H@Z";

    virtual_getNumPlanes :: (this: *btBoxShape) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btBoxShape@@UEBAHXZ";

    virtual_getNumVertices :: (this: *btBoxShape) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btBoxShape@@UEBAHXZ";

    virtual_getNumEdges :: (this: *btBoxShape) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btBoxShape@@UEBAHXZ";

    virtual_getVertex :: (this: *btBoxShape, i: s32, vtx: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btBoxShape@@UEBAXHAEAVbtVector3@@@Z";

    virtual_getPlaneEquation :: (this: *btBoxShape, plane: *btVector4, i: s32) -> void #cpp_method #foreign bullet3 "?getPlaneEquation@btBoxShape@@UEBAXAEAVbtVector4@@H@Z";

    virtual_getEdge :: (this: *btBoxShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btBoxShape@@UEBAXHAEAVbtVector3@@0@Z";

    virtual_isInside :: (this: *btBoxShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btBoxShape@@UEBA_NAEBVbtVector3@@M@Z";

    //debugging
    virtual_getName :: (this: *btBoxShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btBoxShape@@UEBAPEBDXZ";

    virtual_getNumPreferredPenetrationDirections :: (this: *btBoxShape) -> s32 #cpp_method #foreign bullet3 "?getNumPreferredPenetrationDirections@btBoxShape@@UEBAHXZ";

    virtual_getPreferredPenetrationDirection :: (this: *btBoxShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method #foreign bullet3 "?getPreferredPenetrationDirection@btBoxShape@@UEBAXHAEAVbtVector3@@@Z";
}
btBoxShape_VTable :: struct #type_info_none {
    using btpolyhedralconvexshape: btPolyhedralConvexShape_VTable;
    getPlaneEquation: (this: *btBoxShape, plane: *btVector4, i: s32) -> void #cpp_method;
}
btBoxShape_getPlaneEquation :: inline (this: *btBoxShape, plane: *btVector4, i: s32) { this.btboxshape_vtable.getPlaneEquation(this, plane, i); }

vtable :: (obj: *btBoxShape) -> *btBoxShape_VTable { return obj.btboxshape_vtable; }



///The btSphereShape implements an implicit sphere, centered around a local origin with radius.
btSphereShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    Constructor :: (this: *btSphereShape, radius: btScalar) -> void #cpp_method #foreign bullet3 "??0btSphereShape@@QEAA@M@Z";

    getRadius :: (this: *btSphereShape) -> btScalar #cpp_method #foreign bullet3 "?getRadius@btSphereShape@@QEBAMXZ";

    setUnscaledRadius :: (this: *btSphereShape, radius: btScalar) -> void #cpp_method #foreign bullet3 "?setUnscaledRadius@btSphereShape@@QEAAXM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btSphereShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btSphereShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btSphereShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btSphereShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    //notice that the vectors should be unit length
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btSphereShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btSphereShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btSphereShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btSphereShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getAabb :: (this: *btSphereShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btSphereShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    //debugging
    virtual_getName :: (this: *btSphereShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btSphereShape@@UEBAPEBDXZ";

    virtual_setMargin :: (this: *btSphereShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btSphereShape@@UEAAXM@Z";

    virtual_getMargin :: (this: *btSphereShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btSphereShape@@UEBAMXZ";
}


///The btCapsuleShape represents a capsule around the Y axis, there is also the btCapsuleShapeX aligned around the X axis and btCapsuleShapeZ around the Z axis.
///The total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
///The btCapsuleShape is a convex hull of two spheres. The btMultiSphereShape is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres.
btCapsuleShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_upAxis: s32;

    ///only used for btCapsuleShapeZ and btCapsuleShapeX subclasses.
    Constructor :: (this: *btCapsuleShape) -> void #cpp_method #foreign bullet3 "??0btCapsuleShape@@IEAA@XZ";

    Constructor :: (this: *btCapsuleShape, radius: btScalar, height: btScalar) -> void #cpp_method #foreign bullet3 "??0btCapsuleShape@@QEAA@MM@Z";

    getUpAxis :: (this: *btCapsuleShape) -> s32 #cpp_method #foreign bullet3 "?getUpAxis@btCapsuleShape@@QEBAHXZ";

    getRadius :: (this: *btCapsuleShape) -> btScalar #cpp_method #foreign bullet3 "?getRadius@btCapsuleShape@@QEBAMXZ";

    getHalfHeight :: (this: *btCapsuleShape) -> btScalar #cpp_method #foreign bullet3 "?getHalfHeight@btCapsuleShape@@QEBAMXZ";

    deSerializeFloat :: (this: *btCapsuleShape, dataBuffer: *btCapsuleShapeData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@btCapsuleShape@@QEAAXPEAUbtCapsuleShapeData@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    ///CollisionShape Interface
    virtual_calculateLocalInertia :: (this: *btCapsuleShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btCapsuleShape@@UEBAXMAEAVbtVector3@@@Z";

    /// btConvexShape Interface
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btCapsuleShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btCapsuleShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btCapsuleShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btCapsuleShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_setMargin :: (this: *btCapsuleShape, collisionMargin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btCapsuleShape@@UEAAXM@Z";

    virtual_getAabb :: (this: *btCapsuleShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btCapsuleShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_getName :: (this: *btCapsuleShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btCapsuleShape@@UEBAPEBDXZ";

    virtual_setLocalScaling :: (this: *btCapsuleShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btCapsuleShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getAnisotropicRollingFrictionDirection :: (this: *btCapsuleShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAnisotropicRollingFrictionDirection@btCapsuleShape@@UEBA?AVbtVector3@@XZ";

    virtual_calculateSerializeBufferSize :: (this: *btCapsuleShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btCapsuleShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btCapsuleShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btCapsuleShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


///btCapsuleShapeX represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
btCapsuleShapeX :: struct {
    #as using btcapsuleshape: btCapsuleShape;

    Constructor :: (this: *btCapsuleShapeX, radius: btScalar, height: btScalar) -> void #cpp_method #foreign bullet3 "??0btCapsuleShapeX@@QEAA@MM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //debugging
    virtual_getName :: (this: *btCapsuleShapeX) -> *u8 #cpp_method #foreign bullet3 "?getName@btCapsuleShapeX@@UEBAPEBDXZ";
}

///btCapsuleShapeZ represents a capsule around the Z axis
///the total height is height+2*radius, so the height is just the height between the center of each 'sphere' of the capsule caps.
btCapsuleShapeZ :: struct {
    #as using btcapsuleshape: btCapsuleShape;

    Constructor :: (this: *btCapsuleShapeZ, radius: btScalar, height: btScalar) -> void #cpp_method #foreign bullet3 "??0btCapsuleShapeZ@@QEAA@MM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //debugging
    virtual_getName :: (this: *btCapsuleShapeZ) -> *u8 #cpp_method #foreign bullet3 "?getName@btCapsuleShapeZ@@UEBAPEBDXZ";
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCapsuleShapeData :: struct {
    m_convexInternalShapeData: btConvexInternalShapeData;

    m_upAxis:                  s32;

    m_padding:                 [4] u8;
}

/// The btCylinderShape class implements a cylinder shape primitive, centered around the origin. Its central axis aligned with the Y axis. btCylinderShapeX is aligned with the X axis and btCylinderShapeZ around the Z axis.
btCylinderShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_upAxis: s32;

    getHalfExtentsWithMargin :: (this: *btCylinderShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getHalfExtentsWithMargin@btCylinderShape@@QEBA?AVbtVector3@@XZ";

    getHalfExtentsWithoutMargin :: (this: *btCylinderShape) -> *btVector3 #cpp_method #foreign bullet3 "?getHalfExtentsWithoutMargin@btCylinderShape@@QEBAAEBVbtVector3@@XZ";

    Constructor :: (this: *btCylinderShape, halfExtents: *btVector3) -> void #cpp_method #foreign bullet3 "??0btCylinderShape@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btCylinderShape, halfExtents: btVector3) #no_context {
        Constructor(this, *halfExtents);
    }

    //use box inertia
    //	virtual void	calculateLocalInertia(btScalar mass,btVector3& inertia) const;
    getUpAxis :: (this: *btCylinderShape) -> s32 #cpp_method #foreign bullet3 "?getUpAxis@btCylinderShape@@QEBAHXZ";
    #place btconvexinternalshape; btcylindershape_vtable: *btCylinderShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getAabb :: (this: *btCylinderShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btCylinderShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_calculateLocalInertia :: (this: *btCylinderShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btCylinderShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btCylinderShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btCylinderShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btCylinderShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btCylinderShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_setMargin :: (this: *btCylinderShape, collisionMargin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btCylinderShape@@UEAAXM@Z";

    virtual_localGetSupportingVertex :: (this: *btCylinderShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btCylinderShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_getAnisotropicRollingFrictionDirection :: (this: *btCylinderShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAnisotropicRollingFrictionDirection@btCylinderShape@@UEBA?AVbtVector3@@XZ";

    virtual_getRadius :: (this: *btCylinderShape) -> btScalar #cpp_method #foreign bullet3 "?getRadius@btCylinderShape@@UEBAMXZ";

    virtual_setLocalScaling :: (this: *btCylinderShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btCylinderShape@@UEAAXAEBVbtVector3@@@Z";

    //debugging
    virtual_getName :: (this: *btCylinderShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btCylinderShape@@UEBAPEBDXZ";

    virtual_calculateSerializeBufferSize :: (this: *btCylinderShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btCylinderShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btCylinderShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btCylinderShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btCylinderShape_VTable :: struct #type_info_none {
    using btconvexshape: btConvexShape_VTable;
    getRadius: (this: *btCylinderShape) -> btScalar #cpp_method;
}
btCylinderShape_getRadius :: inline (this: *btCylinderShape) -> btScalar { return this.btcylindershape_vtable.getRadius(this); }

vtable :: (obj: *btCylinderShape) -> *btCylinderShape_VTable { return obj.btcylindershape_vtable; }



btCylinderShapeX :: struct {
    #as using btcylindershape: btCylinderShape;

    Constructor :: (this: *btCylinderShapeX, halfExtents: *btVector3) -> void #cpp_method #foreign bullet3 "??0btCylinderShapeX@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btCylinderShapeX, halfExtents: btVector3) #no_context {
        Constructor(this, *halfExtents);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btCylinderShapeX, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btCylinderShapeX@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btCylinderShapeX, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btCylinderShapeX@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    //debugging
    virtual_getName :: (this: *btCylinderShapeX) -> *u8 #cpp_method #foreign bullet3 "?getName@btCylinderShapeX@@UEBAPEBDXZ";

    virtual_getRadius :: (this: *btCylinderShapeX) -> btScalar #cpp_method #foreign bullet3 "?getRadius@btCylinderShapeX@@UEBAMXZ";
}


btCylinderShapeZ :: struct {
    #as using btcylindershape: btCylinderShape;

    Constructor :: (this: *btCylinderShapeZ, halfExtents: *btVector3) -> void #cpp_method #foreign bullet3 "??0btCylinderShapeZ@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btCylinderShapeZ, halfExtents: btVector3) #no_context {
        Constructor(this, *halfExtents);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btCylinderShapeZ, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btCylinderShapeZ@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btCylinderShapeZ, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btCylinderShapeZ@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    //debugging
    virtual_getName :: (this: *btCylinderShapeZ) -> *u8 #cpp_method #foreign bullet3 "?getName@btCylinderShapeZ@@UEBAPEBDXZ";

    virtual_getRadius :: (this: *btCylinderShapeZ) -> btScalar #cpp_method #foreign bullet3 "?getRadius@btCylinderShapeZ@@UEBAMXZ";
}


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCylinderShapeData :: struct {
    m_convexInternalShapeData: btConvexInternalShapeData;

    m_upAxis:                  s32;

    m_padding:                 [4] u8;
}

///The btConeShape implements a cone shape primitive, centered around the origin and aligned with the Y axis. The btConeShapeX is aligned around the X axis and btConeShapeZ around the Z axis.
btConeShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_sinAngle:    btScalar;
    m_radius:      btScalar;
    m_height:      btScalar;
    m_coneIndices: [3] s32;
    coneLocalSupport :: (this: *btConeShape, v: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?coneLocalSupport@btConeShape@@AEBA?AVbtVector3@@AEBV2@@Z";
    coneLocalSupport :: (this: *btConeShape, v: btVector3) -> btVector3 #no_context {
        return coneLocalSupport(this, *v);
    }

    Constructor :: (this: *btConeShape, radius: btScalar, height: btScalar) -> void #cpp_method #foreign bullet3 "??0btConeShape@@QEAA@MM@Z";

    getRadius :: (this: *btConeShape) -> btScalar #cpp_method #foreign bullet3 "?getRadius@btConeShape@@QEBAMXZ";
    getHeight :: (this: *btConeShape) -> btScalar #cpp_method #foreign bullet3 "?getHeight@btConeShape@@QEBAMXZ";

    setRadius :: (this: *btConeShape, radius: btScalar) -> void #cpp_method #foreign bullet3 "?setRadius@btConeShape@@QEAAXM@Z";

    setHeight :: (this: *btConeShape, height: btScalar) -> void #cpp_method #foreign bullet3 "?setHeight@btConeShape@@QEAAXM@Z";

    ///choose upAxis index
    setConeUpIndex :: (this: *btConeShape, upIndex: s32) -> void #cpp_method #foreign bullet3 "?setConeUpIndex@btConeShape@@QEAAXH@Z";

    getConeUpIndex :: (this: *btConeShape) -> s32 #cpp_method #foreign bullet3 "?getConeUpIndex@btConeShape@@QEBAHXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btConeShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btConeShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btConeShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btConeShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btConeShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btConeShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btConeShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btConeShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btConeShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btConeShape@@UEBAPEBDXZ";

    virtual_getAnisotropicRollingFrictionDirection :: (this: *btConeShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAnisotropicRollingFrictionDirection@btConeShape@@UEBA?AVbtVector3@@XZ";

    virtual_setLocalScaling :: (this: *btConeShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConeShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_calculateSerializeBufferSize :: (this: *btConeShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btConeShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btConeShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btConeShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


///btConeShape implements a Cone shape, around the X axis
btConeShapeX :: struct {
    #as using btconeshape: btConeShape;

    Constructor :: (this: *btConeShapeX, radius: btScalar, height: btScalar) -> void #cpp_method #foreign bullet3 "??0btConeShapeX@@QEAA@MM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getAnisotropicRollingFrictionDirection :: (this: *btConeShapeX) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAnisotropicRollingFrictionDirection@btConeShapeX@@UEBA?AVbtVector3@@XZ";

    //debugging
    virtual_getName :: (this: *btConeShapeX) -> *u8 #cpp_method #foreign bullet3 "?getName@btConeShapeX@@UEBAPEBDXZ";
}

///btConeShapeZ implements a Cone shape, around the Z axis
btConeShapeZ :: struct {
    #as using btconeshape: btConeShape;

    Constructor :: (this: *btConeShapeZ, radius: btScalar, height: btScalar) -> void #cpp_method #foreign bullet3 "??0btConeShapeZ@@QEAA@MM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getAnisotropicRollingFrictionDirection :: (this: *btConeShapeZ) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAnisotropicRollingFrictionDirection@btConeShapeZ@@UEBA?AVbtVector3@@XZ";

    //debugging
    virtual_getName :: (this: *btConeShapeZ) -> *u8 #cpp_method #foreign bullet3 "?getName@btConeShapeZ@@UEBAPEBDXZ";
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btConeShapeData :: struct {
    m_convexInternalShapeData: btConvexInternalShapeData;

    m_upIndex:                 s32;

    m_padding:                 [4] u8;
}

///The btTriangleCallback provides a callback for each overlapping triangle when calling processAllTriangles.
///This callback is called by processAllTriangles for all btConcaveShape derived class, such as  btBvhTriangleMeshShape, btStaticPlaneShape and btHeightfieldTerrainShape.
btTriangleCallback :: struct {
    vtable: *btTriangleCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btTriangleCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btTriangleCallback@@UEAA@XZ";
}
btTriangleCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btTriangleCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    processTriangle: (this: *btTriangleCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method;
}

btTriangleCallback_Destructor :: inline (this: *btTriangleCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
btTriangleCallback_processTriangle :: inline (this: *btTriangleCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) { this.vtable.processTriangle(this, triangle, partId, triangleIndex); }



btInternalTriangleIndexCallback :: struct {
    vtable: *btInternalTriangleIndexCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btInternalTriangleIndexCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btInternalTriangleIndexCallback@@UEAA@XZ";
}
btInternalTriangleIndexCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btInternalTriangleIndexCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    internalProcessTriangleIndex: (this: *btInternalTriangleIndexCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method;
}

btInternalTriangleIndexCallback_Destructor :: inline (this: *btInternalTriangleIndexCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
btInternalTriangleIndexCallback_internalProcessTriangleIndex :: inline (this: *btInternalTriangleIndexCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) { this.vtable.internalProcessTriangleIndex(this, triangle, partId, triangleIndex); }



/// PHY_ScalarType enumerates possible scalar types.
/// See the btStridingMeshInterface or btHeightfieldTerrainShape for its use
PHY_ScalarType :: enum s32 {
    FLOAT        :: 0;
    DOUBLE       :: 1;
    INTEGER      :: 2;
    SHORT        :: 3;
    FIXEDPOINT88 :: 4;
    UCHAR        :: 5;

    PHY_FLOAT        :: FLOAT;
    PHY_DOUBLE       :: DOUBLE;
    PHY_INTEGER      :: INTEGER;
    PHY_SHORT        :: SHORT;
    PHY_FIXEDPOINT88 :: FIXEDPOINT88;
    PHY_UCHAR        :: UCHAR;
}

///The btConcaveShape class provides an interface for non-moving (static) concave shapes.
///It has been implemented by the btStaticPlaneShape, btBvhTriangleMeshShape and btHeightfieldTerrainShape.
btConcaveShape :: struct {
    #as using btcollisionshape: btCollisionShape;

    m_collisionMargin: btScalar;

    Constructor :: (this: *btConcaveShape) -> void #cpp_method #foreign bullet3 "??0btConcaveShape@@QEAA@XZ";
    #place btcollisionshape; btconcaveshape_vtable: *btConcaveShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConcaveShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConcaveShape@@UEAA@XZ";

    virtual_getMargin :: (this: *btConcaveShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btConcaveShape@@UEBAMXZ";

    virtual_setMargin :: (this: *btConcaveShape, collisionMargin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btConcaveShape@@UEAAXM@Z";
}
btConcaveShape_VTable :: struct #type_info_none {
    using btcollisionshape: btCollisionShape_VTable;
    processAllTriangles: (this: *btConcaveShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;
}
btConcaveShape_processAllTriangles :: inline (this: *btConcaveShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) { this.btconcaveshape_vtable.processAllTriangles(this, callback, aabbMin, aabbMax); }

vtable :: (obj: *btConcaveShape) -> *btConcaveShape_VTable { return obj.btconcaveshape_vtable; }



///The btStaticPlaneShape simulates an infinite non-moving (static) collision plane.
btStaticPlaneShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    m_localAabbMin:  btVector3;
    m_localAabbMax:  btVector3;

    m_planeNormal:   btVector3;
    m_planeConstant: btScalar;
    m_localScaling:  btVector3;

    Constructor :: (this: *btStaticPlaneShape, planeNormal: *btVector3, planeConstant: btScalar) -> void #cpp_method #foreign bullet3 "??0btStaticPlaneShape@@QEAA@AEBVbtVector3@@M@Z";
    Constructor :: (this: *btStaticPlaneShape, planeNormal: btVector3, planeConstant: btScalar) #no_context {
        Constructor(this, *planeNormal, planeConstant);
    }

    getPlaneNormal :: (this: *btStaticPlaneShape) -> *btVector3 #cpp_method #foreign bullet3 "?getPlaneNormal@btStaticPlaneShape@@QEBAAEBVbtVector3@@XZ";

    getPlaneConstant :: (this: *btStaticPlaneShape) -> *btScalar #cpp_method #foreign bullet3 "?getPlaneConstant@btStaticPlaneShape@@QEBAAEBMXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btStaticPlaneShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btStaticPlaneShape@@UEAA@XZ";

    virtual_getAabb :: (this: *btStaticPlaneShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btStaticPlaneShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_processAllTriangles :: (this: *btStaticPlaneShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btStaticPlaneShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    virtual_calculateLocalInertia :: (this: *btStaticPlaneShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btStaticPlaneShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_setLocalScaling :: (this: *btStaticPlaneShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btStaticPlaneShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btStaticPlaneShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btStaticPlaneShape@@UEBAAEBVbtVector3@@XZ";

    //debugging
    virtual_getName :: (this: *btStaticPlaneShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btStaticPlaneShape@@UEBAPEBDXZ";

    virtual_calculateSerializeBufferSize :: (this: *btStaticPlaneShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btStaticPlaneShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btStaticPlaneShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btStaticPlaneShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btStaticPlaneShapeData :: struct {
    m_collisionShapeData: btCollisionShapeData;

    m_localScaling:       btVector3FloatData;
    m_planeNormal:        btVector3FloatData;
    m_planeConstant:      float;
    m_pad:                [4] u8;
}

///The btConvexHullShape implements an implicit convex hull of an array of vertices.
///Bullet provides a general and fast collision detector for convex shapes based on GJK and EPA using localGetSupportingVertex.
btConvexHullShape :: struct {
    #as using btpolyhedralconvexaabbcachingshape: btPolyhedralConvexAabbCachingShape;

    m_unscaledPoints: btAlignedObjectArray(btVector3);

    ///this constructor optionally takes in a pointer to points. Each point is assumed to be 3 consecutive btScalar (x,y,z), the striding defines the number of bytes between each point, in memory.
    ///It is easier to not pass any points in the constructor, and just add one point at a time, using addPoint.
    ///btConvexHullShape make an internal copy of the points.
    Constructor :: (this: *btConvexHullShape, points: *btScalar = null, numPoints: s32 = 0, stride: s32 = 16) -> void #cpp_method #foreign bullet3 "??0btConvexHullShape@@QEAA@PEBMHH@Z";

    addPoint :: (this: *btConvexHullShape, point: *btVector3, recalculateLocalAabb := true) -> void #cpp_method #foreign bullet3 "?addPoint@btConvexHullShape@@QEAAXAEBVbtVector3@@_N@Z";
    addPoint :: (this: *btConvexHullShape, point: btVector3, recalculateLocalAabb := true) #no_context {
        addPoint(this, *point, recalculateLocalAabb);
    }

    getUnscaledPoints :: (this: *btConvexHullShape) -> *btVector3 #cpp_method #foreign bullet3 "?getUnscaledPoints@btConvexHullShape@@QEAAPEAVbtVector3@@XZ";

    getUnscaledPoints_1 :: (this: /*const*/ *btConvexHullShape) -> *btVector3 #cpp_method #foreign bullet3 "?getUnscaledPoints@btConvexHullShape@@QEBAPEBVbtVector3@@XZ";

    ///getPoints is obsolete, please use getUnscaledPoints
    getPoints :: (this: *btConvexHullShape) -> *btVector3 #cpp_method #foreign bullet3 "?getPoints@btConvexHullShape@@QEBAPEBVbtVector3@@XZ";

    optimizeConvexHull :: (this: *btConvexHullShape) -> void #cpp_method #foreign bullet3 "?optimizeConvexHull@btConvexHullShape@@QEAAXXZ";

    getScaledPoint :: (this: *btConvexHullShape, i: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getScaledPoint@btConvexHullShape@@QEBA?AVbtVector3@@H@Z";

    getNumPoints :: (this: *btConvexHullShape) -> s32 #cpp_method #foreign bullet3 "?getNumPoints@btConvexHullShape@@QEBAHXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btConvexHullShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btConvexHullShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btConvexHullShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btConvexHullShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btConvexHullShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvexHullShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_project :: (this: *btConvexHullShape, trans: *btTransform, dir: *btVector3, minProj: *btScalar, maxProj: *btScalar, witnesPtMin: *btVector3, witnesPtMax: *btVector3) -> void #cpp_method #foreign bullet3 "?project@btConvexHullShape@@UEBAXAEBVbtTransform@@AEBVbtVector3@@AEAM2AEAV3@3@Z";

    //debugging
    virtual_getName :: (this: *btConvexHullShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btConvexHullShape@@UEBAPEBDXZ";

    virtual_getNumVertices :: (this: *btConvexHullShape) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btConvexHullShape@@UEBAHXZ";
    virtual_getNumEdges :: (this: *btConvexHullShape) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btConvexHullShape@@UEBAHXZ";
    virtual_getEdge :: (this: *btConvexHullShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btConvexHullShape@@UEBAXHAEAVbtVector3@@0@Z";
    virtual_getVertex :: (this: *btConvexHullShape, i: s32, vtx: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btConvexHullShape@@UEBAXHAEAVbtVector3@@@Z";
    virtual_getNumPlanes :: (this: *btConvexHullShape) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btConvexHullShape@@UEBAHXZ";
    virtual_getPlane :: (this: *btConvexHullShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btConvexHullShape@@UEBAXAEAVbtVector3@@0H@Z";
    virtual_isInside :: (this: *btConvexHullShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btConvexHullShape@@UEBA_NAEBVbtVector3@@M@Z";

    ///in case we receive negative scaling
    virtual_setLocalScaling :: (this: *btConvexHullShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConvexHullShape@@UEAAXAEBVbtVector3@@@Z";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btConvexHullShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btConvexHullShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btConvexHullShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btConvexHullShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btConvexHullShapeData :: struct {
    m_convexInternalShapeData: btConvexInternalShapeData;

    m_unscaledPointsFloatPtr:  *btVector3FloatData;
    m_unscaledPointsDoublePtr: *btVector3DoubleData;

    m_numUnscaledPoints:       s32;
    m_padding3:                [4] u8;
}

///	The btStridingMeshInterface is the interface class for high performance generic access to triangle meshes, used in combination with btBvhTriangleMeshShape and some other collision shapes.
/// Using index striding of 3*sizeof(integer) it can use triangle arrays, using index striding of 1*sizeof(integer) it can handle triangle strips.
/// It allows for sharing graphics and collision meshes. Also it provides locking/unlocking of graphics meshes that are in gpu memory.
btStridingMeshInterface :: struct {
    vtable: *btStridingMeshInterface_VTable;
    m_scaling: btVector3;

    Constructor :: (this: *btStridingMeshInterface) -> void #cpp_method #foreign bullet3 "??0btStridingMeshInterface@@QEAA@XZ";

    ///brute force method to calculate aabb
    calculateAabbBruteForce :: (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateAabbBruteForce@btStridingMeshInterface@@QEAAXAEAVbtVector3@@0@Z";

    getScaling :: (this: *btStridingMeshInterface) -> *btVector3 #cpp_method #foreign bullet3 "?getScaling@btStridingMeshInterface@@QEBAAEBVbtVector3@@XZ";

    setScaling :: (this: *btStridingMeshInterface, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setScaling@btStridingMeshInterface@@QEAAXAEBVbtVector3@@@Z";
    setScaling :: (this: *btStridingMeshInterface, scaling: btVector3) #no_context {
        setScaling(this, *scaling);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btStridingMeshInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btStridingMeshInterface@@UEAA@XZ";

    virtual_InternalProcessAllTriangles :: (this: *btStridingMeshInterface, callback: *btInternalTriangleIndexCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?InternalProcessAllTriangles@btStridingMeshInterface@@UEBAXPEAVbtInternalTriangleIndexCallback@@AEBVbtVector3@@1@Z";

    virtual_hasPremadeAabb :: (this: *btStridingMeshInterface) -> bool #cpp_method #foreign bullet3 "?hasPremadeAabb@btStridingMeshInterface@@UEBA_NXZ";
    virtual_setPremadeAabb :: (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?setPremadeAabb@btStridingMeshInterface@@UEBAXAEBVbtVector3@@0@Z";

    virtual_getPremadeAabb :: (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getPremadeAabb@btStridingMeshInterface@@UEBAXPEAVbtVector3@@0@Z";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btStridingMeshInterface) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btStridingMeshInterface@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btStridingMeshInterface, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btStridingMeshInterface@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btStridingMeshInterface_VTable :: struct #type_info_none {
    Destructor: (this: *btStridingMeshInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    InternalProcessAllTriangles: (this: *btStridingMeshInterface, callback: *btInternalTriangleIndexCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    getLockedVertexIndexBase: (this: *btStridingMeshInterface, vertexbase: **u8, numverts: *s32, type: *PHY_ScalarType, stride: *s32, indexbase: **u8, indexstride: *s32, numfaces: *s32, indicestype: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method;

    getLockedReadOnlyVertexIndexBase: (this: *btStridingMeshInterface, vertexbase: **u8, numverts: *s32, type: *PHY_ScalarType, stride: *s32, indexbase: **u8, indexstride: *s32, numfaces: *s32, indicestype: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method;

    unLockVertexBase: (this: *btStridingMeshInterface, subpart: s32) -> void #cpp_method;

    unLockReadOnlyVertexBase: (this: *btStridingMeshInterface, subpart: s32) -> void #cpp_method;

    getNumSubParts: (this: *btStridingMeshInterface) -> s32 #cpp_method;

    preallocateVertices: (this: *btStridingMeshInterface, numverts: s32) -> void #cpp_method;
    preallocateIndices: (this: *btStridingMeshInterface, numindices: s32) -> void #cpp_method;

    hasPremadeAabb: (this: *btStridingMeshInterface) -> bool #cpp_method;
    setPremadeAabb: (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    getPremadeAabb: (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    calculateSerializeBufferSize: (this: *btStridingMeshInterface) -> s32 #cpp_method;

    serialize: (this: *btStridingMeshInterface, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;
}

btStridingMeshInterface_Destructor :: inline (this: *btStridingMeshInterface, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btStridingMeshInterface_InternalProcessAllTriangles :: inline (this: *btStridingMeshInterface, callback: *btInternalTriangleIndexCallback, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.InternalProcessAllTriangles(this, callback, aabbMin, aabbMax); }

btStridingMeshInterface_getLockedVertexIndexBase :: inline (this: *btStridingMeshInterface, vertexbase: **u8, numverts: *s32, type: *PHY_ScalarType, stride: *s32, indexbase: **u8, indexstride: *s32, numfaces: *s32, indicestype: *PHY_ScalarType, subpart: s32 = 0) { this.vtable.getLockedVertexIndexBase(this, vertexbase, numverts, type, stride, indexbase, indexstride, numfaces, indicestype, subpart); }

btStridingMeshInterface_getLockedReadOnlyVertexIndexBase :: inline (this: *btStridingMeshInterface, vertexbase: **u8, numverts: *s32, type: *PHY_ScalarType, stride: *s32, indexbase: **u8, indexstride: *s32, numfaces: *s32, indicestype: *PHY_ScalarType, subpart: s32 = 0) { this.vtable.getLockedReadOnlyVertexIndexBase(this, vertexbase, numverts, type, stride, indexbase, indexstride, numfaces, indicestype, subpart); }

btStridingMeshInterface_unLockVertexBase :: inline (this: *btStridingMeshInterface, subpart: s32) { this.vtable.unLockVertexBase(this, subpart); }

btStridingMeshInterface_unLockReadOnlyVertexBase :: inline (this: *btStridingMeshInterface, subpart: s32) { this.vtable.unLockReadOnlyVertexBase(this, subpart); }

btStridingMeshInterface_getNumSubParts :: inline (this: *btStridingMeshInterface) -> s32 { return this.vtable.getNumSubParts(this); }

btStridingMeshInterface_preallocateVertices :: inline (this: *btStridingMeshInterface, numverts: s32) { this.vtable.preallocateVertices(this, numverts); }
btStridingMeshInterface_preallocateIndices :: inline (this: *btStridingMeshInterface, numindices: s32) { this.vtable.preallocateIndices(this, numindices); }

btStridingMeshInterface_hasPremadeAabb :: inline (this: *btStridingMeshInterface) -> bool { return this.vtable.hasPremadeAabb(this); }
btStridingMeshInterface_setPremadeAabb :: inline (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.setPremadeAabb(this, aabbMin, aabbMax); }

btStridingMeshInterface_getPremadeAabb :: inline (this: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) { this.vtable.getPremadeAabb(this, aabbMin, aabbMax); }

btStridingMeshInterface_calculateSerializeBufferSize :: inline (this: *btStridingMeshInterface) -> s32 { return this.vtable.calculateSerializeBufferSize(this); }

btStridingMeshInterface_serialize :: inline (this: *btStridingMeshInterface, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }




btIntIndexData :: struct {
    m_value: s32;
}

btShortIntIndexData :: struct {
    m_value: s16;
    m_pad:   [2] u8;
}

btShortIntIndexTripletData :: struct {
    m_values: [3] s16;
    m_pad:    [2] u8;
}

btCharIndexTripletData :: struct {
    m_values: [3] u8;
    m_pad:    u8;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btMeshPartData :: struct {
    m_vertices3f:   *btVector3FloatData;
    m_vertices3d:   *btVector3DoubleData;

    m_indices32:    *btIntIndexData;
    m_3indices16:   *btShortIntIndexTripletData;
    m_3indices8:    *btCharIndexTripletData;

    m_indices16:    *btShortIntIndexData; //backwards compatibility

    m_numTriangles: s32; //length of m_indices = m_numTriangles
    m_numVertices:  s32;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btStridingMeshInterfaceData :: struct {
    m_meshPartsPtr: *btMeshPartData;
    m_scaling:      btVector3FloatData;
    m_numMeshParts: s32;
    m_padding:      [4] u8;
}

///The btIndexedMesh indexes a single vertex and index array. Multiple btIndexedMesh objects can be passed into a btTriangleIndexVertexArray using addIndexedMesh.
///Instead of the number of indices, we pass the number of triangles.
btIndexedMesh :: struct {
    m_numTriangles:        s32;
    m_triangleIndexBase:   *u8;

    // Size in byte of the indices for one triangle (3*sizeof(index_type) if the indices are tightly packed)
    m_triangleIndexStride: s32;
    m_numVertices:         s32;
    m_vertexBase:          *u8;

    // Size of a vertex, in bytes
    m_vertexStride:        s32;

    // The index type is set when adding an indexed mesh to the
    // btTriangleIndexVertexArray, do not set it manually
    m_indexType:           PHY_ScalarType;

    // The vertex type has a default type similar to Bullet's precision mode (float or double)
    // but can be set manually if you for example run Bullet with double precision but have
    // mesh data in single precision..
    m_vertexType:          PHY_ScalarType;

    Constructor :: (this: *btIndexedMesh) -> void #cpp_method #foreign bullet3 "??0btIndexedMesh@@QEAA@XZ";
}


IndexedMeshArray :: btAlignedObjectArray(btIndexedMesh);

///The btTriangleIndexVertexArray allows to access multiple triangle meshes, by indexing into existing triangle/index arrays.
///Additional meshes can be added using addIndexedMesh
///No duplicate is made of the vertex/index data, it only indexes into external vertex/index arrays.
///So keep those arrays around during the lifetime of this btTriangleIndexVertexArray.
btTriangleIndexVertexArray :: struct {
    #as using btstridingmeshinterface: btStridingMeshInterface;

    m_indexedMeshes: IndexedMeshArray;
    m_pad:           [2] s32;
    m_hasAabb:       s32; // using int instead of bool to maintain alignment
    m_aabbMin:       btVector3 #align 8;
    m_aabbMax:       btVector3;

    Constructor :: (this: *btTriangleIndexVertexArray) -> void #cpp_method #foreign bullet3 "??0btTriangleIndexVertexArray@@QEAA@XZ";

    //just to be backwards compatible
    Constructor :: (this: *btTriangleIndexVertexArray, numTriangles: s32, triangleIndexBase: *s32, triangleIndexStride: s32, numVertices: s32, vertexBase: *btScalar, vertexStride: s32) -> void #cpp_method #foreign bullet3 "??0btTriangleIndexVertexArray@@QEAA@HPEAHHHPEAMH@Z";

    addIndexedMesh :: (this: *btTriangleIndexVertexArray, mesh: *btIndexedMesh, indexType: PHY_ScalarType = .INTEGER) -> void #cpp_method #foreign bullet3 "?addIndexedMesh@btTriangleIndexVertexArray@@QEAAXAEBUbtIndexedMesh@@W4PHY_ScalarType@@@Z";
    addIndexedMesh :: (this: *btTriangleIndexVertexArray, mesh: btIndexedMesh, indexType: PHY_ScalarType = .INTEGER) #no_context {
        addIndexedMesh(this, *mesh, indexType);
    }

    getIndexedMeshArray :: (this: *btTriangleIndexVertexArray) -> *IndexedMeshArray #cpp_method #foreign bullet3 "?getIndexedMeshArray@btTriangleIndexVertexArray@@QEAAAEAV?$btAlignedObjectArray@UbtIndexedMesh@@@@XZ";

    getIndexedMeshArray_1 :: (this: /*const*/ *btTriangleIndexVertexArray) -> *IndexedMeshArray #cpp_method #foreign bullet3 "?getIndexedMeshArray@btTriangleIndexVertexArray@@QEBAAEBV?$btAlignedObjectArray@UbtIndexedMesh@@@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btTriangleIndexVertexArray, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btTriangleIndexVertexArray@@UEAA@XZ";

    virtual_getLockedVertexIndexBase :: (this: *btTriangleIndexVertexArray, vertexbase: **u8, numverts: *s32, type: *PHY_ScalarType, vertexStride: *s32, indexbase: **u8, indexstride: *s32, numfaces: *s32, indicestype: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method #foreign bullet3 "?getLockedVertexIndexBase@btTriangleIndexVertexArray@@UEAAXPEAPEAEAEAHAEAW4PHY_ScalarType@@10112H@Z";

    virtual_getLockedReadOnlyVertexIndexBase :: (this: *btTriangleIndexVertexArray, vertexbase: **u8, numverts: *s32, type: *PHY_ScalarType, vertexStride: *s32, indexbase: **u8, indexstride: *s32, numfaces: *s32, indicestype: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method #foreign bullet3 "?getLockedReadOnlyVertexIndexBase@btTriangleIndexVertexArray@@UEBAXPEAPEBEAEAHAEAW4PHY_ScalarType@@10112H@Z";

    /// unLockVertexBase finishes the access to a subpart of the triangle mesh
    /// make a call to unLockVertexBase when the read and write access (using getLockedVertexIndexBase) is finished
    virtual_unLockVertexBase :: (this: *btTriangleIndexVertexArray, subpart: s32) -> void #cpp_method #foreign bullet3 "?unLockVertexBase@btTriangleIndexVertexArray@@UEAAXH@Z";

    virtual_unLockReadOnlyVertexBase :: (this: *btTriangleIndexVertexArray, subpart: s32) -> void #cpp_method #foreign bullet3 "?unLockReadOnlyVertexBase@btTriangleIndexVertexArray@@UEBAXH@Z";

    /// getNumSubParts returns the number of separate subparts
    /// each subpart has a continuous array of vertices and indices
    virtual_getNumSubParts :: (this: *btTriangleIndexVertexArray) -> s32 #cpp_method #foreign bullet3 "?getNumSubParts@btTriangleIndexVertexArray@@UEBAHXZ";

    virtual_preallocateVertices :: (this: *btTriangleIndexVertexArray, numverts: s32) -> void #cpp_method #foreign bullet3 "?preallocateVertices@btTriangleIndexVertexArray@@UEAAXH@Z";
    virtual_preallocateIndices :: (this: *btTriangleIndexVertexArray, numindices: s32) -> void #cpp_method #foreign bullet3 "?preallocateIndices@btTriangleIndexVertexArray@@UEAAXH@Z";

    virtual_hasPremadeAabb :: (this: *btTriangleIndexVertexArray) -> bool #cpp_method #foreign bullet3 "?hasPremadeAabb@btTriangleIndexVertexArray@@UEBA_NXZ";
    virtual_setPremadeAabb :: (this: *btTriangleIndexVertexArray, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?setPremadeAabb@btTriangleIndexVertexArray@@UEBAXAEBVbtVector3@@0@Z";
    virtual_getPremadeAabb :: (this: *btTriangleIndexVertexArray, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getPremadeAabb@btTriangleIndexVertexArray@@UEBAXPEAVbtVector3@@0@Z";
}


///The btTriangleMesh class is a convenience class derived from btTriangleIndexVertexArray, that provides storage for a concave triangle mesh. It can be used as data for the btBvhTriangleMeshShape.
///It allows either 32bit or 16bit indices, and 4 (x-y-z-w) or 3 (x-y-z) component vertices.
///If you want to share triangle/index data between graphics mesh and collision mesh (btBvhTriangleMeshShape), you can directly use btTriangleIndexVertexArray or derive your own class from btStridingMeshInterface.
///Performance of btTriangleMesh and btTriangleIndexVertexArray used in a btBvhTriangleMeshShape is the same.
btTriangleMesh :: struct {
    #as using bttriangleindexvertexarray: btTriangleIndexVertexArray;

    m_4componentVertices:    btAlignedObjectArray(btVector3);
    m_3componentVertices:    btAlignedObjectArray(btScalar);

    m_32bitIndices:          btAlignedObjectArray(u32);
    m_16bitIndices:          btAlignedObjectArray(u16);
    m_use32bitIndices:       bool;
    m_use4componentVertices: bool;

    m_weldingThreshold:      btScalar;

    Constructor :: (this: *btTriangleMesh, use32bitIndices := true, use4componentVertices := true) -> void #cpp_method #foreign bullet3 "??0btTriangleMesh@@QEAA@_N0@Z";

    getUse32bitIndices :: (this: *btTriangleMesh) -> bool #cpp_method #foreign bullet3 "?getUse32bitIndices@btTriangleMesh@@QEBA_NXZ";

    getUse4componentVertices :: (this: *btTriangleMesh) -> bool #cpp_method #foreign bullet3 "?getUse4componentVertices@btTriangleMesh@@QEBA_NXZ";

    ///By default addTriangle won't search for duplicate vertices, because the search is very slow for large triangle meshes.
    ///In general it is better to directly use btTriangleIndexVertexArray instead.
    addTriangle :: (this: *btTriangleMesh, vertex0: *btVector3, vertex1: *btVector3, vertex2: *btVector3, removeDuplicateVertices := false) -> void #cpp_method #foreign bullet3 "?addTriangle@btTriangleMesh@@QEAAXAEBVbtVector3@@00_N@Z";
    addTriangle :: (this: *btTriangleMesh, vertex0: btVector3, vertex1: btVector3, vertex2: btVector3, removeDuplicateVertices := false) #no_context {
        addTriangle(this, *vertex0, *vertex1, *vertex2, removeDuplicateVertices);
    }

    ///Add a triangle using its indices. Make sure the indices are pointing within the vertices array, so add the vertices first (and to be sure, avoid removal of duplicate vertices)
    addTriangleIndices :: (this: *btTriangleMesh, index1: s32, index2: s32, index3: s32) -> void #cpp_method #foreign bullet3 "?addTriangleIndices@btTriangleMesh@@QEAAXHHH@Z";

    getNumTriangles :: (this: *btTriangleMesh) -> s32 #cpp_method #foreign bullet3 "?getNumTriangles@btTriangleMesh@@QEBAHXZ";

    ///findOrAddVertex is an internal method, use addTriangle instead
    findOrAddVertex :: (this: *btTriangleMesh, vertex: *btVector3, removeDuplicateVertices: bool) -> s32 #cpp_method #foreign bullet3 "?findOrAddVertex@btTriangleMesh@@QEAAHAEBVbtVector3@@_N@Z";
    findOrAddVertex :: (this: *btTriangleMesh, vertex: btVector3, removeDuplicateVertices: bool) -> s32 #no_context {
        return findOrAddVertex(this, *vertex, removeDuplicateVertices);
    }

    ///addIndex is an internal method, use addTriangle instead
    addIndex :: (this: *btTriangleMesh, index: s32) -> void #cpp_method #foreign bullet3 "?addIndex@btTriangleMesh@@QEAAXH@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_preallocateVertices :: (this: *btTriangleMesh, numverts: s32) -> void #cpp_method #foreign bullet3 "?preallocateVertices@btTriangleMesh@@UEAAXH@Z";
    virtual_preallocateIndices :: (this: *btTriangleMesh, numindices: s32) -> void #cpp_method #foreign bullet3 "?preallocateIndices@btTriangleMesh@@UEAAXH@Z";
}

/// The btConvexTriangleMeshShape is a convex hull of a triangle mesh, but the performance is not as good as btConvexHullShape.
/// A small benefit of this class is that it uses the btStridingMeshInterface, so you can avoid the duplication of the triangle mesh data. Nevertheless, most users should use the much better performing btConvexHullShape instead.
btConvexTriangleMeshShape :: struct {
    #as using btpolyhedralconvexaabbcachingshape: btPolyhedralConvexAabbCachingShape;

    m_stridingMesh: *btStridingMeshInterface;

    Constructor :: (this: *btConvexTriangleMeshShape, meshInterface: *btStridingMeshInterface, calcAabb := true) -> void #cpp_method #foreign bullet3 "??0btConvexTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_N@Z";

    getMeshInterface :: (this: *btConvexTriangleMeshShape) -> *btStridingMeshInterface #cpp_method #foreign bullet3 "?getMeshInterface@btConvexTriangleMeshShape@@QEAAPEAVbtStridingMeshInterface@@XZ";

    getMeshInterface_1 :: (this: /*const*/ *btConvexTriangleMeshShape) -> *btStridingMeshInterface #cpp_method #foreign bullet3 "?getMeshInterface@btConvexTriangleMeshShape@@QEBAPEBVbtStridingMeshInterface@@XZ";

    ///computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
    ///and the center of mass to the current coordinate system. A mass of 1 is assumed, for other masses just multiply the computed "inertia"
    ///by the mass. The resulting transform "principal" has to be applied inversely to the mesh in order for the local coordinate system of the
    ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
    ///of the collision object by the principal transform. This method also computes the volume of the convex mesh.
    calculatePrincipalAxisTransform :: (this: *btConvexTriangleMeshShape, principal: *btTransform, inertia: *btVector3, volume: *btScalar) -> void #cpp_method #foreign bullet3 "?calculatePrincipalAxisTransform@btConvexTriangleMeshShape@@QEBAXAEAVbtTransform@@AEAVbtVector3@@AEAM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btConvexTriangleMeshShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btConvexTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btConvexTriangleMeshShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btConvexTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btConvexTriangleMeshShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvexTriangleMeshShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    //debugging
    virtual_getName :: (this: *btConvexTriangleMeshShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btConvexTriangleMeshShape@@UEBAPEBDXZ";

    virtual_getNumVertices :: (this: *btConvexTriangleMeshShape) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btConvexTriangleMeshShape@@UEBAHXZ";
    virtual_getNumEdges :: (this: *btConvexTriangleMeshShape) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btConvexTriangleMeshShape@@UEBAHXZ";
    virtual_getEdge :: (this: *btConvexTriangleMeshShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btConvexTriangleMeshShape@@UEBAXHAEAVbtVector3@@0@Z";
    virtual_getVertex :: (this: *btConvexTriangleMeshShape, i: s32, vtx: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btConvexTriangleMeshShape@@UEBAXHAEAVbtVector3@@@Z";
    virtual_getNumPlanes :: (this: *btConvexTriangleMeshShape) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btConvexTriangleMeshShape@@UEBAHXZ";
    virtual_getPlane :: (this: *btConvexTriangleMeshShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btConvexTriangleMeshShape@@UEBAXAEAVbtVector3@@0H@Z";
    virtual_isInside :: (this: *btConvexTriangleMeshShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btConvexTriangleMeshShape@@UEBA_NAEBVbtVector3@@M@Z";

    virtual_setLocalScaling :: (this: *btConvexTriangleMeshShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConvexTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btConvexTriangleMeshShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btConvexTriangleMeshShape@@UEBAAEBVbtVector3@@XZ";
}


///The btTriangleMeshShape is an internal concave triangle mesh interface. Don't use this class directly, use btBvhTriangleMeshShape instead.
btTriangleMeshShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    m_localAabbMin:  btVector3;
    m_localAabbMax:  btVector3;
    m_meshInterface: *btStridingMeshInterface;

    ///btTriangleMeshShape constructor has been disabled/protected, so that users will not mistakenly use this class.
    ///Don't use btTriangleMeshShape but use btBvhTriangleMeshShape instead!
    Constructor :: (this: *btTriangleMeshShape, meshInterface: *btStridingMeshInterface) -> void #cpp_method #foreign bullet3 "??0btTriangleMeshShape@@IEAA@PEAVbtStridingMeshInterface@@@Z";

    recalcLocalAabb :: (this: *btTriangleMeshShape) -> void #cpp_method #foreign bullet3 "?recalcLocalAabb@btTriangleMeshShape@@QEAAXXZ";

    getMeshInterface :: (this: *btTriangleMeshShape) -> *btStridingMeshInterface #cpp_method #foreign bullet3 "?getMeshInterface@btTriangleMeshShape@@QEAAPEAVbtStridingMeshInterface@@XZ";

    getMeshInterface_1 :: (this: /*const*/ *btTriangleMeshShape) -> *btStridingMeshInterface #cpp_method #foreign bullet3 "?getMeshInterface@btTriangleMeshShape@@QEBAPEBVbtStridingMeshInterface@@XZ";

    getLocalAabbMin :: (this: *btTriangleMeshShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalAabbMin@btTriangleMeshShape@@QEBAAEBVbtVector3@@XZ";

    getLocalAabbMax :: (this: *btTriangleMeshShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalAabbMax@btTriangleMeshShape@@QEBAAEBVbtVector3@@XZ";
    #place btconcaveshape; bttrianglemeshshape_vtable: *btTriangleMeshShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btTriangleMeshShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btTriangleMeshShape@@UEAA@XZ";

    virtual_localGetSupportingVertex :: (this: *btTriangleMeshShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btTriangleMeshShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btTriangleMeshShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_getAabb :: (this: *btTriangleMeshShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btTriangleMeshShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_processAllTriangles :: (this: *btTriangleMeshShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btTriangleMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    virtual_calculateLocalInertia :: (this: *btTriangleMeshShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btTriangleMeshShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_setLocalScaling :: (this: *btTriangleMeshShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btTriangleMeshShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btTriangleMeshShape@@UEBAAEBVbtVector3@@XZ";

    //debugging
    virtual_getName :: (this: *btTriangleMeshShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btTriangleMeshShape@@UEBAPEBDXZ";
}
btTriangleMeshShape_VTable :: struct #type_info_none {
    using btconcaveshape: btConcaveShape_VTable;
    localGetSupportingVertex: (this: *btTriangleMeshShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    localGetSupportingVertexWithoutMargin: (this: *btTriangleMeshShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;
}

btTriangleMeshShape_localGetSupportingVertex :: inline (this: *btTriangleMeshShape, vec: *btVector3) -> btVector3 { return this.bttrianglemeshshape_vtable.localGetSupportingVertex(this, vec); }

btTriangleMeshShape_localGetSupportingVertexWithoutMargin :: inline (this: *btTriangleMeshShape, vec: *btVector3) -> btVector3 { return this.bttrianglemeshshape_vtable.localGetSupportingVertexWithoutMargin(this, vec); }

vtable :: (obj: *btTriangleMeshShape) -> *btTriangleMeshShape_VTable { return obj.bttrianglemeshshape_vtable; }



///btQuantizedBvhNode is a compressed aabb node, 16 bytes.
///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
btQuantizedBvhNode :: struct {
    //12 bytes
    m_quantizedAabbMin:           [3] u16;
    m_quantizedAabbMax:           [3] u16;

    //4 bytes
    m_escapeIndexOrTriangleIndex: s32;
}

/// btOptimizedBvhNode contains both internal and leaf node information.
/// Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
btOptimizedBvhNode :: struct {
    //32 bytes
    m_aabbMinOrg:    btVector3;
    m_aabbMaxOrg:    btVector3;

    //4
    m_escapeIndex:   s32;

    //8
    //for child nodes
    m_subPart:       s32;
    m_triangleIndex: s32;

    //pad the size to 64 bytes
    m_padding:       [20] u8;
}

///btBvhSubtreeInfo provides info to gather a subtree of limited size
btBvhSubtreeInfo :: struct {
    //12 bytes
    m_quantizedAabbMin: [3] u16;
    m_quantizedAabbMax: [3] u16;

    //4 bytes, points to the root of the subtree
    m_rootNodeIndex:    s32;

    //4 bytes
    m_subtreeSize:      s32;
    m_padding:          [3] s32;

    Constructor :: (this: *btBvhSubtreeInfo) -> void #cpp_method #foreign bullet3 "??0btBvhSubtreeInfo@@QEAA@XZ";

    setAabbFromQuantizeNode :: (this: *btBvhSubtreeInfo, quantizedNode: *btQuantizedBvhNode) -> void #cpp_method #foreign bullet3 "?setAabbFromQuantizeNode@btBvhSubtreeInfo@@QEAAXAEBUbtQuantizedBvhNode@@@Z";
    setAabbFromQuantizeNode :: (this: *btBvhSubtreeInfo, quantizedNode: btQuantizedBvhNode) #no_context {
        setAabbFromQuantizeNode(this, *quantizedNode);
    }
}


btNodeOverlapCallback :: struct {
    vtable: *btNodeOverlapCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btNodeOverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btNodeOverlapCallback@@UEAA@XZ";
}
btNodeOverlapCallback_VTable :: struct #type_info_none {
    Destructor: (this: *btNodeOverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    processNode: (this: *btNodeOverlapCallback, subPart: s32, triangleIndex: s32) -> void #cpp_method;
}

btNodeOverlapCallback_Destructor :: inline (this: *btNodeOverlapCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btNodeOverlapCallback_processNode :: inline (this: *btNodeOverlapCallback, subPart: s32, triangleIndex: s32) { this.vtable.processNode(this, subPart, triangleIndex); }



///for code readability:
NodeArray :: btAlignedObjectArray(btOptimizedBvhNode);
QuantizedNodeArray :: btAlignedObjectArray(btQuantizedBvhNode);
BvhSubtreeInfoArray :: btAlignedObjectArray(btBvhSubtreeInfo);

///The btQuantizedBvh class stores an AABB tree that can be quickly traversed on CPU and Cell SPU.
///It is used by the btBvhTriangleMeshShape as midphase.
///It is recommended to use quantization for better performance and lower memory requirements.
btQuantizedBvh :: struct {
    vtable: *btQuantizedBvh_VTable;
    btTraversalMode :: enum s32 {
        STACKLESS                :: 0;
        STACKLESS_CACHE_FRIENDLY :: 1;
        RECURSIVE                :: 2;

        TRAVERSAL_STACKLESS                :: STACKLESS;
        TRAVERSAL_STACKLESS_CACHE_FRIENDLY :: STACKLESS_CACHE_FRIENDLY;
        TRAVERSAL_RECURSIVE                :: RECURSIVE;
    }

    m_bvhAabbMin:               btVector3;
    m_bvhAabbMax:               btVector3;
    m_bvhQuantization:          btVector3;

    m_bulletVersion:            s32; //for serialization versioning. It could also be used to detect endianess.

    m_curNodeIndex:             s32;

    //quantization data
    m_useQuantization:          bool;

    m_leafNodes:                NodeArray;
    m_contiguousNodes:          NodeArray;
    m_quantizedLeafNodes:       QuantizedNodeArray;
    m_quantizedContiguousNodes: QuantizedNodeArray;

    m_traversalMode:            btTraversalMode;
    m_SubtreeHeaders:           BvhSubtreeInfoArray;

    //This is only used for serialization so we don't have to add serialization directly to btAlignedObjectArray
    m_subtreeHeaderCount:       s32;

    ///two versions, one for quantized and normal nodes. This allows code-reuse while maintaining readability (no template/macro!)
    ///this might be refactored into a virtual, it is usually not calculated at run-time
    setInternalNodeAabbMin :: (this: *btQuantizedBvh, nodeIndex: s32, aabbMin: *btVector3) -> void #cpp_method #foreign bullet3 "?setInternalNodeAabbMin@btQuantizedBvh@@IEAAXHAEBVbtVector3@@@Z";
    setInternalNodeAabbMin :: (this: *btQuantizedBvh, nodeIndex: s32, aabbMin: btVector3) #no_context {
        setInternalNodeAabbMin(this, nodeIndex, *aabbMin);
    }

    setInternalNodeAabbMax :: (this: *btQuantizedBvh, nodeIndex: s32, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?setInternalNodeAabbMax@btQuantizedBvh@@IEAAXHAEBVbtVector3@@@Z";
    setInternalNodeAabbMax :: (this: *btQuantizedBvh, nodeIndex: s32, aabbMax: btVector3) #no_context {
        setInternalNodeAabbMax(this, nodeIndex, *aabbMax);
    }

    getAabbMin :: (this: *btQuantizedBvh, nodeIndex: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAabbMin@btQuantizedBvh@@IEBA?AVbtVector3@@H@Z";

    getAabbMax :: (this: *btQuantizedBvh, nodeIndex: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAabbMax@btQuantizedBvh@@IEBA?AVbtVector3@@H@Z";

    setInternalNodeEscapeIndex :: (this: *btQuantizedBvh, nodeIndex: s32, escapeIndex: s32) -> void #cpp_method #foreign bullet3 "?setInternalNodeEscapeIndex@btQuantizedBvh@@IEAAXHH@Z";

    mergeInternalNodeAabb :: (this: *btQuantizedBvh, nodeIndex: s32, newAabbMin: *btVector3, newAabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?mergeInternalNodeAabb@btQuantizedBvh@@IEAAXHAEBVbtVector3@@0@Z";
    mergeInternalNodeAabb :: (this: *btQuantizedBvh, nodeIndex: s32, newAabbMin: btVector3, newAabbMax: btVector3) #no_context {
        mergeInternalNodeAabb(this, nodeIndex, *newAabbMin, *newAabbMax);
    }

    swapLeafNodes :: (this: *btQuantizedBvh, firstIndex: s32, secondIndex: s32) -> void #cpp_method #foreign bullet3 "?swapLeafNodes@btQuantizedBvh@@IEAAXHH@Z";

    assignInternalNodeFromLeafNode :: (this: *btQuantizedBvh, internalNode: s32, leafNodeIndex: s32) -> void #cpp_method #foreign bullet3 "?assignInternalNodeFromLeafNode@btQuantizedBvh@@IEAAXHH@Z";

    buildTree :: (this: *btQuantizedBvh, startIndex: s32, endIndex: s32) -> void #cpp_method #foreign bullet3 "?buildTree@btQuantizedBvh@@IEAAXHH@Z";

    calcSplittingAxis :: (this: *btQuantizedBvh, startIndex: s32, endIndex: s32) -> s32 #cpp_method #foreign bullet3 "?calcSplittingAxis@btQuantizedBvh@@IEAAHHH@Z";

    sortAndCalcSplittingIndex :: (this: *btQuantizedBvh, startIndex: s32, endIndex: s32, splitAxis: s32) -> s32 #cpp_method #foreign bullet3 "?sortAndCalcSplittingIndex@btQuantizedBvh@@IEAAHHHH@Z";

    walkStacklessTree :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?walkStacklessTree@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@1@Z";
    walkStacklessTree :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        walkStacklessTree(this, nodeCallback, *aabbMin, *aabbMax);
    }

    walkStacklessQuantizedTreeAgainstRay :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: *btVector3, rayTarget: *btVector3, aabbMin: *btVector3, aabbMax: *btVector3, startNodeIndex: s32, endNodeIndex: s32) -> void #cpp_method #foreign bullet3 "?walkStacklessQuantizedTreeAgainstRay@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@111HH@Z";
    walkStacklessQuantizedTreeAgainstRay :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: btVector3, rayTarget: btVector3, aabbMin: btVector3, aabbMax: btVector3, startNodeIndex: s32, endNodeIndex: s32) #no_context {
        walkStacklessQuantizedTreeAgainstRay(this, nodeCallback, *raySource, *rayTarget, *aabbMin, *aabbMax, startNodeIndex, endNodeIndex);
    }
    walkStacklessQuantizedTree :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, quantizedQueryAabbMin: *u16, quantizedQueryAabbMax: *u16, startNodeIndex: s32, endNodeIndex: s32) -> void #cpp_method #foreign bullet3 "?walkStacklessQuantizedTree@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@PEAG1HH@Z";
    walkStacklessTreeAgainstRay :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: *btVector3, rayTarget: *btVector3, aabbMin: *btVector3, aabbMax: *btVector3, startNodeIndex: s32, endNodeIndex: s32) -> void #cpp_method #foreign bullet3 "?walkStacklessTreeAgainstRay@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@111HH@Z";
    walkStacklessTreeAgainstRay :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: btVector3, rayTarget: btVector3, aabbMin: btVector3, aabbMax: btVector3, startNodeIndex: s32, endNodeIndex: s32) #no_context {
        walkStacklessTreeAgainstRay(this, nodeCallback, *raySource, *rayTarget, *aabbMin, *aabbMax, startNodeIndex, endNodeIndex);
    }

    ///tree traversal designed for small-memory processors like PS3 SPU
    walkStacklessQuantizedTreeCacheFriendly :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, quantizedQueryAabbMin: *u16, quantizedQueryAabbMax: *u16) -> void #cpp_method #foreign bullet3 "?walkStacklessQuantizedTreeCacheFriendly@btQuantizedBvh@@IEBAXPEAVbtNodeOverlapCallback@@PEAG1@Z";

    ///use the 16-byte stackless 'skipindex' node tree to do a recursive traversal
    walkRecursiveQuantizedTreeAgainstQueryAabb :: (this: *btQuantizedBvh, currentNode: *btQuantizedBvhNode, nodeCallback: *btNodeOverlapCallback, quantizedQueryAabbMin: *u16, quantizedQueryAabbMax: *u16) -> void #cpp_method #foreign bullet3 "?walkRecursiveQuantizedTreeAgainstQueryAabb@btQuantizedBvh@@IEBAXPEBUbtQuantizedBvhNode@@PEAVbtNodeOverlapCallback@@PEAG2@Z";

    updateSubtreeHeaders :: (this: *btQuantizedBvh, leftChildNodexIndex: s32, rightChildNodexIndex: s32) -> void #cpp_method #foreign bullet3 "?updateSubtreeHeaders@btQuantizedBvh@@IEAAXHH@Z";

    Constructor :: (this: *btQuantizedBvh) -> void #cpp_method #foreign bullet3 "??0btQuantizedBvh@@QEAA@XZ";

    ///***************************************** expert/internal use only *************************
    setQuantizationValues :: (this: *btQuantizedBvh, bvhAabbMin: *btVector3, bvhAabbMax: *btVector3, quantizationMargin: btScalar) -> void #cpp_method #foreign bullet3 "?setQuantizationValues@btQuantizedBvh@@QEAAXAEBVbtVector3@@0M@Z";
    setQuantizationValues :: (this: *btQuantizedBvh, bvhAabbMin: btVector3, bvhAabbMax: btVector3, quantizationMargin: btScalar) #no_context {
        setQuantizationValues(this, *bvhAabbMin, *bvhAabbMax, quantizationMargin);
    }
    getLeafNodeArray :: (this: *btQuantizedBvh) -> *QuantizedNodeArray #cpp_method #foreign bullet3 "?getLeafNodeArray@btQuantizedBvh@@QEAAAEAV?$btAlignedObjectArray@UbtQuantizedBvhNode@@@@XZ";

    ///buildInternal is expert use only: assumes that setQuantizationValues and LeafNodeArray are initialized
    buildInternal :: (this: *btQuantizedBvh) -> void #cpp_method #foreign bullet3 "?buildInternal@btQuantizedBvh@@QEAAXXZ";

    ///***************************************** expert/internal use only *************************
    reportAabbOverlappingNodex :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?reportAabbOverlappingNodex@btQuantizedBvh@@QEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@1@Z";
    reportAabbOverlappingNodex :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        reportAabbOverlappingNodex(this, nodeCallback, *aabbMin, *aabbMax);
    }
    reportRayOverlappingNodex :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: *btVector3, rayTarget: *btVector3) -> void #cpp_method #foreign bullet3 "?reportRayOverlappingNodex@btQuantizedBvh@@QEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@1@Z";
    reportRayOverlappingNodex :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: btVector3, rayTarget: btVector3) #no_context {
        reportRayOverlappingNodex(this, nodeCallback, *raySource, *rayTarget);
    }
    reportBoxCastOverlappingNodex :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: *btVector3, rayTarget: *btVector3, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?reportBoxCastOverlappingNodex@btQuantizedBvh@@QEBAXPEAVbtNodeOverlapCallback@@AEBVbtVector3@@111@Z";
    reportBoxCastOverlappingNodex :: (this: *btQuantizedBvh, nodeCallback: *btNodeOverlapCallback, raySource: btVector3, rayTarget: btVector3, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        reportBoxCastOverlappingNodex(this, nodeCallback, *raySource, *rayTarget, *aabbMin, *aabbMax);
    }

    quantize :: (this: *btQuantizedBvh, out: *u16, point: *btVector3, isMax: s32) -> void #cpp_method #foreign bullet3 "?quantize@btQuantizedBvh@@QEBAXPEAGAEBVbtVector3@@H@Z";
    quantize :: (this: *btQuantizedBvh, out: *u16, point: btVector3, isMax: s32) #no_context {
        quantize(this, out, *point, isMax);
    }

    quantizeWithClamp :: (this: *btQuantizedBvh, out: *u16, point2: *btVector3, isMax: s32) -> void #cpp_method #foreign bullet3 "?quantizeWithClamp@btQuantizedBvh@@QEBAXPEAGAEBVbtVector3@@H@Z";
    quantizeWithClamp :: (this: *btQuantizedBvh, out: *u16, point2: btVector3, isMax: s32) #no_context {
        quantizeWithClamp(this, out, *point2, isMax);
    }

    unQuantize :: (this: *btQuantizedBvh, vecIn: *u16) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?unQuantize@btQuantizedBvh@@QEBA?AVbtVector3@@PEBG@Z";

    ///setTraversalMode let's you choose between stackless, recursive or stackless cache friendly tree traversal. Note this is only implemented for quantized trees.
    setTraversalMode :: (this: *btQuantizedBvh, traversalMode: btTraversalMode) -> void #cpp_method #foreign bullet3 "?setTraversalMode@btQuantizedBvh@@QEAAXW4btTraversalMode@1@@Z";

    getQuantizedNodeArray :: (this: *btQuantizedBvh) -> *QuantizedNodeArray #cpp_method #foreign bullet3 "?getQuantizedNodeArray@btQuantizedBvh@@QEAAAEAV?$btAlignedObjectArray@UbtQuantizedBvhNode@@@@XZ";

    getSubtreeInfoArray :: (this: *btQuantizedBvh) -> *BvhSubtreeInfoArray #cpp_method #foreign bullet3 "?getSubtreeInfoArray@btQuantizedBvh@@QEAAAEAV?$btAlignedObjectArray@VbtBvhSubtreeInfo@@@@XZ";

    /////Calculate space needed to store BVH for serialization
    calculateSerializeBufferSize :: (this: *btQuantizedBvh) -> u32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btQuantizedBvh@@QEBAIXZ";

    ///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
    deSerializeInPlace :: (i_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> *btQuantizedBvh #foreign bullet3 "?deSerializeInPlace@btQuantizedBvh@@SAPEAV1@PEAXI_N@Z";

    getAlignmentSerializationPadding :: () -> u32 #foreign bullet3 "?getAlignmentSerializationPadding@btQuantizedBvh@@SAIXZ";

    ////////////////////////////////////////////////////////////////////
    isQuantized :: (this: *btQuantizedBvh) -> bool #cpp_method #foreign bullet3 "?isQuantized@btQuantizedBvh@@QEAA_NXZ";

    // Special "copy" constructor that allows for in-place deserialization
    // Prevents btVector3's default constructor from being called, but doesn't inialize much else
    // ownsMemory should most likely be false if deserializing, and if you are not, don't call this (it also changes the function signature, which we need)
    Constructor :: (this: *btQuantizedBvh, other: *btQuantizedBvh, ownsMemory: bool) -> void #cpp_method #foreign bullet3 "??0btQuantizedBvh@@AEAA@AEAV0@_N@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btQuantizedBvh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btQuantizedBvh@@UEAA@XZ";

    /// Data buffer MUST be 16 byte aligned
    virtual_serialize :: (this: *btQuantizedBvh, o_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> bool #cpp_method #foreign bullet3 "?serialize@btQuantizedBvh@@UEBA_NPEAXI_N@Z";

    //////////////////////////////////////////////////////////////////////
    virtual_calculateSerializeBufferSizeNew :: (this: *btQuantizedBvh) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSizeNew@btQuantizedBvh@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btQuantizedBvh, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btQuantizedBvh@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";

    virtual_deSerializeFloat :: (this: *btQuantizedBvh, quantizedBvhFloatData: *btQuantizedBvhFloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@btQuantizedBvh@@UEAAXAEAUbtQuantizedBvhFloatData@@@Z";

    virtual_deSerializeDouble :: (this: *btQuantizedBvh, quantizedBvhDoubleData: *btQuantizedBvhDoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@btQuantizedBvh@@UEAAXAEAUbtQuantizedBvhDoubleData@@@Z";
}
btQuantizedBvh_VTable :: struct #type_info_none {
    Destructor: (this: *btQuantizedBvh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    serialize: (this: *btQuantizedBvh, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;

    serialize_1: (this: /*const*/ *btQuantizedBvh, o_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> bool #cpp_method;

    calculateSerializeBufferSizeNew: (this: *btQuantizedBvh) -> s32 #cpp_method;

    deSerializeFloat: (this: *btQuantizedBvh, quantizedBvhFloatData: *btQuantizedBvhFloatData) -> void #cpp_method;

    deSerializeDouble: (this: *btQuantizedBvh, quantizedBvhDoubleData: *btQuantizedBvhDoubleData) -> void #cpp_method;
}

btQuantizedBvh_Destructor :: inline (this: *btQuantizedBvh, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btQuantizedBvh_serialize :: inline (this: /*const*/ *btQuantizedBvh, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }

btQuantizedBvh_serialize_1 :: inline (this: /*const*/ *btQuantizedBvh, o_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> bool { return this.vtable.serialize_1(this, o_alignedDataBuffer, i_dataBufferSize, i_swapEndian); }

btQuantizedBvh_calculateSerializeBufferSizeNew :: inline (this: *btQuantizedBvh) -> s32 { return this.vtable.calculateSerializeBufferSizeNew(this); }

btQuantizedBvh_deSerializeFloat :: inline (this: *btQuantizedBvh, quantizedBvhFloatData: *btQuantizedBvhFloatData) { this.vtable.deSerializeFloat(this, quantizedBvhFloatData); }

btQuantizedBvh_deSerializeDouble :: inline (this: *btQuantizedBvh, quantizedBvhDoubleData: *btQuantizedBvhDoubleData) { this.vtable.deSerializeDouble(this, quantizedBvhDoubleData); }




// clang-format off
// parser needs * with the name
btBvhSubtreeInfoData :: struct {
    m_rootNodeIndex:    s32;
    m_subtreeSize:      s32;
    m_quantizedAabbMin: [3] u16;
    m_quantizedAabbMax: [3] u16;
}

btOptimizedBvhNodeFloatData :: struct {
    m_aabbMinOrg:    btVector3FloatData;
    m_aabbMaxOrg:    btVector3FloatData;
    m_escapeIndex:   s32;
    m_subPart:       s32;
    m_triangleIndex: s32;
    m_pad:           [4] u8;
}

btOptimizedBvhNodeDoubleData :: struct {
    m_aabbMinOrg:    btVector3DoubleData;
    m_aabbMaxOrg:    btVector3DoubleData;
    m_escapeIndex:   s32;
    m_subPart:       s32;
    m_triangleIndex: s32;
    m_pad:           [4] u8;
}

btQuantizedBvhNodeData :: struct {
    m_quantizedAabbMin:           [3] u16;
    m_quantizedAabbMax:           [3] u16;
    m_escapeIndexOrTriangleIndex: s32;
}

btQuantizedBvhFloatData :: struct {
    m_bvhAabbMin:                  btVector3FloatData;
    m_bvhAabbMax:                  btVector3FloatData;
    m_bvhQuantization:             btVector3FloatData;
    m_curNodeIndex:                s32;
    m_useQuantization:             s32;
    m_numContiguousLeafNodes:      s32;
    m_numQuantizedContiguousNodes: s32;
    m_contiguousNodesPtr:          *btOptimizedBvhNodeFloatData;
    m_quantizedContiguousNodesPtr: *btQuantizedBvhNodeData;
    m_subTreeInfoPtr:              *btBvhSubtreeInfoData;
    m_traversalMode:               s32;
    m_numSubtreeHeaders:           s32;
}

btQuantizedBvhDoubleData :: struct {
    m_bvhAabbMin:                  btVector3DoubleData;
    m_bvhAabbMax:                  btVector3DoubleData;
    m_bvhQuantization:             btVector3DoubleData;
    m_curNodeIndex:                s32;
    m_useQuantization:             s32;
    m_numContiguousLeafNodes:      s32;
    m_numQuantizedContiguousNodes: s32;
    m_contiguousNodesPtr:          *btOptimizedBvhNodeDoubleData;
    m_quantizedContiguousNodesPtr: *btQuantizedBvhNodeData;

    m_traversalMode:               s32;
    m_numSubtreeHeaders:           s32;
    m_subTreeInfoPtr:              *btBvhSubtreeInfoData;
}

///The btOptimizedBvh extends the btQuantizedBvh to create AABB tree for triangle meshes, through the btStridingMeshInterface.
btOptimizedBvh :: struct {
    #as btquantizedbvh: btQuantizedBvh; // jai: no "using" to avoid name-clashes

    Constructor :: (this: *btOptimizedBvh) -> void #cpp_method #foreign bullet3 "??0btOptimizedBvh@@QEAA@XZ";

    build :: (this: *btOptimizedBvh, triangles: *btStridingMeshInterface, useQuantizedAabbCompression: bool, bvhAabbMin: *btVector3, bvhAabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?build@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@_NAEBVbtVector3@@2@Z";
    build :: (this: *btOptimizedBvh, triangles: *btStridingMeshInterface, useQuantizedAabbCompression: bool, bvhAabbMin: btVector3, bvhAabbMax: btVector3) #no_context {
        build(this, triangles, useQuantizedAabbCompression, *bvhAabbMin, *bvhAabbMax);
    }

    refit :: (this: *btOptimizedBvh, triangles: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?refit@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@AEBVbtVector3@@1@Z";
    refit :: (this: *btOptimizedBvh, triangles: *btStridingMeshInterface, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        refit(this, triangles, *aabbMin, *aabbMax);
    }

    refitPartial :: (this: *btOptimizedBvh, triangles: *btStridingMeshInterface, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?refitPartial@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@AEBVbtVector3@@1@Z";
    refitPartial :: (this: *btOptimizedBvh, triangles: *btStridingMeshInterface, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        refitPartial(this, triangles, *aabbMin, *aabbMax);
    }

    updateBvhNodes :: (this: *btOptimizedBvh, meshInterface: *btStridingMeshInterface, firstNode: s32, endNode: s32, index: s32) -> void #cpp_method #foreign bullet3 "?updateBvhNodes@btOptimizedBvh@@QEAAXPEAVbtStridingMeshInterface@@HHH@Z";

    ///deSerializeInPlace loads and initializes a BVH from a buffer in memory 'in place'
    deSerializeInPlace :: (i_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> *btOptimizedBvh #foreign bullet3 "?deSerializeInPlace@btOptimizedBvh@@SAPEAV1@PEAXI_N@Z";
    #place btquantizedbvh; btoptimizedbvh_vtable: *btOptimizedBvh_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btOptimizedBvh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btOptimizedBvh@@UEAA@XZ";

    /// Data buffer MUST be 16 byte aligned
    virtual_serializeInPlace :: (this: *btOptimizedBvh, o_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> bool #cpp_method #foreign bullet3 "?serializeInPlace@btOptimizedBvh@@UEBA_NPEAXI_N@Z";
}
btOptimizedBvh_VTable :: struct #type_info_none {
    using btquantizedbvh: btQuantizedBvh_VTable;
    serializeInPlace: (this: *btOptimizedBvh, o_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> bool #cpp_method;
}
btOptimizedBvh_serializeInPlace :: inline (this: *btOptimizedBvh, o_alignedDataBuffer: *void, i_dataBufferSize: u32, i_swapEndian: bool) -> bool { return this.btoptimizedbvh_vtable.serializeInPlace(this, o_alignedDataBuffer, i_dataBufferSize, i_swapEndian); }

vtable :: (obj: *btOptimizedBvh) -> *btOptimizedBvh_VTable { return obj.btoptimizedbvh_vtable; }



///very basic hashable string implementation, compatible with btHashMap
btHashString :: struct {
    m_string1: std.string;
    m_hash:    u32;

    getHash :: (this: *btHashString) -> u32 #cpp_method #foreign bullet3 "?getHash@btHashString@@QEBAIXZ";

    Constructor :: (this: *btHashString) -> void #cpp_method #foreign bullet3 "??0btHashString@@QEAA@XZ";

    Constructor :: (this: *btHashString, name: *u8) -> void #cpp_method #foreign bullet3 "??0btHashString@@QEAA@PEBD@Z";

    equals :: (this: *btHashString, other: *btHashString) -> bool #cpp_method #foreign bullet3 "?equals@btHashString@@QEBA_NAEBU1@@Z";
    equals :: (this: *btHashString, other: btHashString) -> bool #no_context {
        return equals(this, *other);
    }
}

btHashInt :: struct {
    m_uid: s32;

    Constructor :: (this: *btHashInt) -> void #cpp_method #foreign bullet3 "??0btHashInt@@QEAA@XZ";

    Constructor :: (this: *btHashInt, uid: s32) -> void #cpp_method #foreign bullet3 "??0btHashInt@@QEAA@H@Z";

    getUid1 :: (this: *btHashInt) -> s32 #cpp_method #foreign bullet3 "?getUid1@btHashInt@@QEBAHXZ";

    setUid1 :: (this: *btHashInt, uid: s32) -> void #cpp_method #foreign bullet3 "?setUid1@btHashInt@@QEAAXH@Z";

    equals :: (this: *btHashInt, other: *btHashInt) -> bool #cpp_method #foreign bullet3 "?equals@btHashInt@@QEBA_NAEBV1@@Z";
    equals :: (this: *btHashInt, other: btHashInt) -> bool #no_context {
        return equals(this, *other);
    }

    //to our success
    getHash :: (this: *btHashInt) -> u32 #cpp_method #foreign bullet3 "?getHash@btHashInt@@QEBAIXZ";
}

btHashPtr :: struct {
    union {
        m_pointer:    *void;
        m_hashValues: [2] u32;
    }

    Constructor :: (this: *btHashPtr, ptr: *void) -> void #cpp_method #foreign bullet3 "??0btHashPtr@@QEAA@PEBX@Z";

    getPointer :: (this: *btHashPtr) -> *void #cpp_method #foreign bullet3 "?getPointer@btHashPtr@@QEBAPEBXXZ";

    equals :: (this: *btHashPtr, other: *btHashPtr) -> bool #cpp_method #foreign bullet3 "?equals@btHashPtr@@QEBA_NAEBV1@@Z";
    equals :: (this: *btHashPtr, other: btHashPtr) -> bool #no_context {
        return equals(this, *other);
    }

    //to our success
    getHash :: (this: *btHashPtr) -> u32 #cpp_method #foreign bullet3 "?getHash@btHashPtr@@QEBAIXZ";
}

btHashKeyPtr :: struct(Value: Type) {
    m_uid: s32;
}

btHashKey :: struct(Value: Type) {
    m_uid: s32;
}

///The btHashMap template class implements a generic and lightweight hashmap.
///A basic sample of how to use btHashMap is located in Demos\BasicDemo\main.cpp
btHashMap :: struct(Key: Type, Value: Type) {
    m_hashTable:  btAlignedObjectArray(s32);
    m_next:       btAlignedObjectArray(s32);

    m_valueArray: btAlignedObjectArray(Value);
    m_keyArray:   btAlignedObjectArray(Key);
}

btChunk :: struct {
    m_chunkCode: s32;
    m_length:    s32;
    m_oldPtr:    *void;
    m_dna_nr:    s32;
    m_number:    s32;
}

btSerializationFlags :: enum s32 {
    NO_BVH              :: 1;
    NO_TRIANGLEINFOMAP  :: 2;
    NO_DUPLICATE_ASSERT :: 4;
    CONTACT_MANIFOLDS   :: 8;

    BT_SERIALIZE_NO_BVH              :: NO_BVH;
    BT_SERIALIZE_NO_TRIANGLEINFOMAP  :: NO_TRIANGLEINFOMAP;
    BT_SERIALIZE_NO_DUPLICATE_ASSERT :: NO_DUPLICATE_ASSERT;
    BT_SERIALIZE_CONTACT_MANIFOLDS   :: CONTACT_MANIFOLDS;
}

btSerializer :: struct {
    vtable: *btSerializer_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSerializer@@UEAA@XZ";
}
btSerializer_VTable :: struct #type_info_none {
    Destructor: (this: *btSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getBufferPointer: (this: *btSerializer) -> *u8 #cpp_method;

    getCurrentBufferSize: (this: *btSerializer) -> s32 #cpp_method;

    allocate: (this: *btSerializer, size: size_t, numElements: s32) -> *btChunk #cpp_method;

    finalizeChunk: (this: *btSerializer, chunk: *btChunk, structType: *u8, chunkCode: s32, oldPtr: *void) -> void #cpp_method;

    findPointer: (this: *btSerializer, oldPtr: *void) -> *void #cpp_method;

    getUniquePointer: (this: *btSerializer, oldPtr: *void) -> *void #cpp_method;

    startSerialization: (this: *btSerializer) -> void #cpp_method;

    finishSerialization: (this: *btSerializer) -> void #cpp_method;

    findNameForPointer: (this: *btSerializer, ptr: *void) -> *u8 #cpp_method;

    registerNameForPointer: (this: *btSerializer, ptr: *void, name: *u8) -> void #cpp_method;

    serializeName: (this: *btSerializer, ptr: *u8) -> void #cpp_method;

    getSerializationFlags: (this: *btSerializer) -> s32 #cpp_method;

    setSerializationFlags: (this: *btSerializer, flags: s32) -> void #cpp_method;

    getNumChunks: (this: *btSerializer) -> s32 #cpp_method;

    getChunk: (this: *btSerializer, chunkIndex: s32) -> *btChunk #cpp_method;
}

btSerializer_Destructor :: inline (this: *btSerializer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btSerializer_getBufferPointer :: inline (this: *btSerializer) -> *u8 { return this.vtable.getBufferPointer(this); }

btSerializer_getCurrentBufferSize :: inline (this: *btSerializer) -> s32 { return this.vtable.getCurrentBufferSize(this); }

btSerializer_allocate :: inline (this: *btSerializer, size: size_t, numElements: s32) -> *btChunk { return this.vtable.allocate(this, size, numElements); }

btSerializer_finalizeChunk :: inline (this: *btSerializer, chunk: *btChunk, structType: *u8, chunkCode: s32, oldPtr: *void) { this.vtable.finalizeChunk(this, chunk, structType, chunkCode, oldPtr); }

btSerializer_findPointer :: inline (this: *btSerializer, oldPtr: *void) -> *void { return this.vtable.findPointer(this, oldPtr); }

btSerializer_getUniquePointer :: inline (this: *btSerializer, oldPtr: *void) -> *void { return this.vtable.getUniquePointer(this, oldPtr); }

btSerializer_startSerialization :: inline (this: *btSerializer) { this.vtable.startSerialization(this); }

btSerializer_finishSerialization :: inline (this: *btSerializer) { this.vtable.finishSerialization(this); }

btSerializer_findNameForPointer :: inline (this: *btSerializer, ptr: *void) -> *u8 { return this.vtable.findNameForPointer(this, ptr); }

btSerializer_registerNameForPointer :: inline (this: *btSerializer, ptr: *void, name: *u8) { this.vtable.registerNameForPointer(this, ptr, name); }

btSerializer_serializeName :: inline (this: *btSerializer, ptr: *u8) { this.vtable.serializeName(this, ptr); }

btSerializer_getSerializationFlags :: inline (this: *btSerializer) -> s32 { return this.vtable.getSerializationFlags(this); }

btSerializer_setSerializationFlags :: inline (this: *btSerializer, flags: s32) { this.vtable.setSerializationFlags(this, flags); }

btSerializer_getNumChunks :: inline (this: *btSerializer) -> s32 { return this.vtable.getNumChunks(this); }

btSerializer_getChunk :: inline (this: *btSerializer, chunkIndex: s32) -> *btChunk { return this.vtable.getChunk(this, chunkIndex); }



btPointerUid :: struct {
    union {
        m_ptr:       *void;
        m_uniqueIds: [2] s32;
    }
}

btBulletSerializedArrays :: struct {
    Constructor :: (this: *btBulletSerializedArrays) -> void #cpp_method #foreign bullet3 "??0btBulletSerializedArrays@@QEAA@XZ";

    m_bvhsDouble:                 btAlignedObjectArray(*btQuantizedBvhDoubleData);
    m_bvhsFloat:                  btAlignedObjectArray(*btQuantizedBvhFloatData);
    m_colShapeData:               btAlignedObjectArray(*btCollisionShapeData);
    m_dynamicWorldInfoDataDouble: btAlignedObjectArray(*btDynamicsWorldDoubleData);
    m_dynamicWorldInfoDataFloat:  btAlignedObjectArray(*btDynamicsWorldFloatData);
    m_rigidBodyDataDouble:        btAlignedObjectArray(*btRigidBodyDoubleData);
    m_rigidBodyDataFloat:         btAlignedObjectArray(*btRigidBodyFloatData);
    m_collisionObjectDataDouble:  btAlignedObjectArray(*btCollisionObjectDoubleData);
    m_collisionObjectDataFloat:   btAlignedObjectArray(*btCollisionObjectFloatData);
    m_constraintDataFloat:        btAlignedObjectArray(*btTypedConstraintFloatData);
    m_constraintDataDouble:       btAlignedObjectArray(*btTypedConstraintDoubleData);
    m_constraintData:             btAlignedObjectArray(*btTypedConstraintData); //for backwards compatibility
    m_softBodyFloatData:          btAlignedObjectArray(*btSoftBodyFloatData);
    btSoftBodyDoubleData :: struct {}
    m_softBodyDoubleData:         btAlignedObjectArray(*btSoftBodyDoubleData);
}

///The btDefaultSerializer is the main Bullet serialization class.
///The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
btDefaultSerializer :: struct {
    #as using btserializer: btSerializer;

    mTypes:               btAlignedObjectArray(*u8);
    mStructs:             btAlignedObjectArray(*s16);
    mTlens:               btAlignedObjectArray(s16);
    mStructReverse:       btHashMap(btHashInt, s32);
    mTypeLookup:          btHashMap(btHashString, s32);

    m_chunkP:             btHashMap(btHashPtr, *void);

    m_nameMap:            btHashMap(btHashPtr, *u8);

    m_uniquePointers:     btHashMap(btHashPtr, btPointerUid);
    m_uniqueIdGenerator:  s32;

    m_totalSize:          s32;
    m_buffer:             *u8;
    m_ownsBuffer:         bool;
    m_currentSize:        s32;
    m_dna:                *void;
    m_dnaLength:          s32;

    m_serializationFlags: s32;

    m_chunkPtrs:          btAlignedObjectArray(*btChunk);

    getReverseType :: (this: *btDefaultSerializer, type: *u8) -> s32 #cpp_method #foreign bullet3 "?getReverseType@btDefaultSerializer@@IEBAHPEBD@Z";

    initDNA :: (this: *btDefaultSerializer, bdnaOrg: *u8, dnalen: s32) -> void #cpp_method #foreign bullet3 "?initDNA@btDefaultSerializer@@IEAAXPEBDH@Z";

    m_skipPointers:       btHashMap(btHashPtr, *void);

    Constructor :: (this: *btDefaultSerializer, totalSize: s32 = 0, buffer: *u8 = null) -> void #cpp_method #foreign bullet3 "??0btDefaultSerializer@@QEAA@HPEAE@Z";

    getMemoryDnaSizeInBytes :: () -> s32 #foreign bullet3 "?getMemoryDnaSizeInBytes@btDefaultSerializer@@SAHXZ";

    getMemoryDna :: () -> *u8 #foreign bullet3 "?getMemoryDna@btDefaultSerializer@@SAPEBDXZ";

    insertHeader :: (this: *btDefaultSerializer) -> void #cpp_method #foreign bullet3 "?insertHeader@btDefaultSerializer@@QEAAXXZ";

    writeHeader :: (this: *btDefaultSerializer, buffer: *u8) -> void #cpp_method #foreign bullet3 "?writeHeader@btDefaultSerializer@@QEBAXPEAE@Z";
    #place btserializer; btdefaultserializer_vtable: *btDefaultSerializer_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_findPointer :: (this: *btDefaultSerializer, oldPtr: *void) -> *void #cpp_method #foreign bullet3 "?findPointer@btDefaultSerializer@@MEAAPEAXPEAX@Z";

    virtual_writeDNA :: (this: *btDefaultSerializer) -> void #cpp_method #foreign bullet3 "?writeDNA@btDefaultSerializer@@MEAAXXZ";

    virtual_Destructor :: (this: *btDefaultSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDefaultSerializer@@UEAA@XZ";

    virtual_startSerialization :: (this: *btDefaultSerializer) -> void #cpp_method #foreign bullet3 "?startSerialization@btDefaultSerializer@@UEAAXXZ";

    virtual_finishSerialization :: (this: *btDefaultSerializer) -> void #cpp_method #foreign bullet3 "?finishSerialization@btDefaultSerializer@@UEAAXXZ";

    virtual_getUniquePointer :: (this: *btDefaultSerializer, oldPtr: *void) -> *void #cpp_method #foreign bullet3 "?getUniquePointer@btDefaultSerializer@@UEAAPEAXPEAX@Z";

    virtual_getBufferPointer :: (this: *btDefaultSerializer) -> *u8 #cpp_method #foreign bullet3 "?getBufferPointer@btDefaultSerializer@@UEBAPEBEXZ";

    virtual_getCurrentBufferSize :: (this: *btDefaultSerializer) -> s32 #cpp_method #foreign bullet3 "?getCurrentBufferSize@btDefaultSerializer@@UEBAHXZ";

    virtual_finalizeChunk :: (this: *btDefaultSerializer, chunk: *btChunk, structType: *u8, chunkCode: s32, oldPtr: *void) -> void #cpp_method #foreign bullet3 "?finalizeChunk@btDefaultSerializer@@UEAAXPEAVbtChunk@@PEBDHPEAX@Z";

    virtual_internalAlloc :: (this: *btDefaultSerializer, size: size_t) -> *u8 #cpp_method #foreign bullet3 "?internalAlloc@btDefaultSerializer@@UEAAPEAE_K@Z";

    virtual_allocate :: (this: *btDefaultSerializer, size: size_t, numElements: s32) -> *btChunk #cpp_method #foreign bullet3 "?allocate@btDefaultSerializer@@UEAAPEAVbtChunk@@_KH@Z";

    virtual_findNameForPointer :: (this: *btDefaultSerializer, ptr: *void) -> *u8 #cpp_method #foreign bullet3 "?findNameForPointer@btDefaultSerializer@@UEBAPEBDPEBX@Z";

    virtual_registerNameForPointer :: (this: *btDefaultSerializer, ptr: *void, name: *u8) -> void #cpp_method #foreign bullet3 "?registerNameForPointer@btDefaultSerializer@@UEAAXPEBXPEBD@Z";

    virtual_serializeName :: (this: *btDefaultSerializer, name: *u8) -> void #cpp_method #foreign bullet3 "?serializeName@btDefaultSerializer@@UEAAXPEBD@Z";

    virtual_getSerializationFlags :: (this: *btDefaultSerializer) -> s32 #cpp_method #foreign bullet3 "?getSerializationFlags@btDefaultSerializer@@UEBAHXZ";

    virtual_setSerializationFlags :: (this: *btDefaultSerializer, flags: s32) -> void #cpp_method #foreign bullet3 "?setSerializationFlags@btDefaultSerializer@@UEAAXH@Z";

    virtual_getNumChunks :: (this: *btDefaultSerializer) -> s32 #cpp_method #foreign bullet3 "?getNumChunks@btDefaultSerializer@@UEBAHXZ";

    virtual_getChunk :: (this: *btDefaultSerializer, chunkIndex: s32) -> *btChunk #cpp_method #foreign bullet3 "?getChunk@btDefaultSerializer@@UEBAPEBVbtChunk@@H@Z";
}
btDefaultSerializer_VTable :: struct #type_info_none {
    using btserializer: btSerializer_VTable;
    writeDNA: (this: *btDefaultSerializer) -> void #cpp_method;

    internalAlloc: (this: *btDefaultSerializer, size: size_t) -> *u8 #cpp_method;
}

btDefaultSerializer_writeDNA :: inline (this: *btDefaultSerializer) { this.btdefaultserializer_vtable.writeDNA(this); }

btDefaultSerializer_internalAlloc :: inline (this: *btDefaultSerializer, size: size_t) -> *u8 { return this.btdefaultserializer_vtable.internalAlloc(this, size); }

vtable :: (obj: *btDefaultSerializer) -> *btDefaultSerializer_VTable { return obj.btdefaultserializer_vtable; }


///The btTriangleInfo structure stores information to adjust collision normals to avoid collisions against internal edges
///it can be generated using
btTriangleInfo :: struct {
    Constructor :: (this: *btTriangleInfo) -> void #cpp_method #foreign bullet3 "??0btTriangleInfo@@QEAA@XZ";

    m_flags:         s32;

    m_edgeV0V1Angle: btScalar;
    m_edgeV1V2Angle: btScalar;
    m_edgeV2V0Angle: btScalar;
}

btInternalTriangleInfoMap :: btHashMap(btHashInt, btTriangleInfo);

///The btTriangleInfoMap stores edge angle information for some triangles. You can compute this information yourself or using btGenerateInternalEdgeInfo.
btTriangleInfoMap :: struct {
    #as using btinternaltriangleinfomap: btInternalTriangleInfoMap;
    vtable: *btTriangleInfoMap_VTable;

    m_convexEpsilon:         btScalar;
    ///used to determine if an edge or contact normal is convex, using the dot product
    m_planarEpsilon:         btScalar;
    ///used to determine if a triangle edge is planar with zero angle
    m_equalVertexThreshold:  btScalar;
    ///used to compute connectivity: if the distance between two vertices is smaller than m_equalVertexThreshold, they are considered to be 'shared'
    m_edgeDistanceThreshold: btScalar;
    m_maxEdgeAngleThreshold: btScalar; //ignore edges that connect triangles at an angle larger than this m_maxEdgeAngleThreshold
    m_zeroAreaThreshold:     btScalar;

    ///used to determine if a triangle is degenerate (length squared of cross product of 2 triangle edges < threshold)
    Constructor :: (this: *btTriangleInfoMap) -> void #cpp_method #foreign bullet3 "??0btTriangleInfoMap@@QEAA@XZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    deSerialize :: (this: *btTriangleInfoMap, data: *btTriangleInfoMapData) -> void #cpp_method #foreign bullet3 "?deSerialize@btTriangleInfoMap@@QEAAXAEAUbtTriangleInfoMapData@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btTriangleInfoMap, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btTriangleInfoMap@@UEAA@XZ";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btTriangleInfoMap) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btTriangleInfoMap@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btTriangleInfoMap, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btTriangleInfoMap@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btTriangleInfoMap_VTable :: struct #type_info_none {
    Destructor: (this: *btTriangleInfoMap, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    calculateSerializeBufferSize: (this: *btTriangleInfoMap) -> s32 #cpp_method;

    serialize: (this: *btTriangleInfoMap, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;
}

btTriangleInfoMap_Destructor :: inline (this: *btTriangleInfoMap, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btTriangleInfoMap_calculateSerializeBufferSize :: inline (this: *btTriangleInfoMap) -> s32 { return this.vtable.calculateSerializeBufferSize(this); }

btTriangleInfoMap_serialize :: inline (this: *btTriangleInfoMap, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }



///those fields have to be float and not btScalar for the serialization to work properly
btTriangleInfoData :: struct {
    m_flags:         s32;
    m_edgeV0V1Angle: float;
    m_edgeV1V2Angle: float;
    m_edgeV2V0Angle: float;
}

btTriangleInfoMapData :: struct {
    m_hashTablePtr:          *s32;
    m_nextPtr:               *s32;
    m_valueArrayPtr:         *btTriangleInfoData;
    m_keyArrayPtr:           *s32;

    m_convexEpsilon:         float;
    m_planarEpsilon:         float;
    m_equalVertexThreshold:  float;
    m_edgeDistanceThreshold: float;
    m_zeroAreaThreshold:     float;

    m_nextSize:              s32;
    m_hashTableSize:         s32;
    m_numValues:             s32;
    m_numKeys:               s32;
    m_padding:               [4] u8;
}

///The btBvhTriangleMeshShape is a static-triangle mesh shape, it can only be used for fixed/non-moving objects.
///If you required moving concave triangle meshes, it is recommended to perform convex decomposition
///using HACD, see Bullet/Demos/ConvexDecompositionDemo.
///Alternatively, you can use btGimpactMeshShape for moving concave triangle meshes.
///btBvhTriangleMeshShape has several optimizations, such as bounding volume hierarchy and
///cache friendly traversal for PlayStation 3 Cell SPU.
///It is recommended to enable useQuantizedAabbCompression for better memory usage.
///It takes a triangle mesh as input, for example a btTriangleMesh or btTriangleIndexVertexArray. The btBvhTriangleMeshShape class allows for triangle mesh deformations by a refit or partialRefit method.
///Instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk.
///See Demos\ConcaveDemo\ConcavePhysicsDemo.cpp for an example.
btBvhTriangleMeshShape :: struct {
    #as using bttrianglemeshshape: btTriangleMeshShape;

    m_bvh:                         *btOptimizedBvh;
    m_triangleInfoMap:             *btTriangleInfoMap;

    m_useQuantizedAabbCompression: bool;
    m_ownsBvh:                     bool;

    m_pad:                         [11] bool;

    Constructor :: (this: *btBvhTriangleMeshShape, meshInterface: *btStridingMeshInterface, useQuantizedAabbCompression: bool, buildBvh := true) -> void #cpp_method #foreign bullet3 "??0btBvhTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_N1@Z";

    ///optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb
    Constructor :: (this: *btBvhTriangleMeshShape, meshInterface: *btStridingMeshInterface, useQuantizedAabbCompression: bool, bvhAabbMin: *btVector3, bvhAabbMax: *btVector3, buildBvh := true) -> void #cpp_method #foreign bullet3 "??0btBvhTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_NAEBVbtVector3@@21@Z";
    Constructor :: (this: *btBvhTriangleMeshShape, meshInterface: *btStridingMeshInterface, useQuantizedAabbCompression: bool, bvhAabbMin: btVector3, bvhAabbMax: btVector3, buildBvh := true) #no_context {
        Constructor(this, meshInterface, useQuantizedAabbCompression, *bvhAabbMin, *bvhAabbMax, buildBvh);
    }

    getOwnsBvh :: (this: *btBvhTriangleMeshShape) -> bool #cpp_method #foreign bullet3 "?getOwnsBvh@btBvhTriangleMeshShape@@QEBA_NXZ";

    performRaycast :: (this: *btBvhTriangleMeshShape, callback: *btTriangleCallback, raySource: *btVector3, rayTarget: *btVector3) -> void #cpp_method #foreign bullet3 "?performRaycast@btBvhTriangleMeshShape@@QEAAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
    performRaycast :: (this: *btBvhTriangleMeshShape, callback: *btTriangleCallback, raySource: btVector3, rayTarget: btVector3) #no_context {
        performRaycast(this, callback, *raySource, *rayTarget);
    }
    performConvexcast :: (this: *btBvhTriangleMeshShape, callback: *btTriangleCallback, boxSource: *btVector3, boxTarget: *btVector3, boxMin: *btVector3, boxMax: *btVector3) -> void #cpp_method #foreign bullet3 "?performConvexcast@btBvhTriangleMeshShape@@QEAAXPEAVbtTriangleCallback@@AEBVbtVector3@@111@Z";
    performConvexcast :: (this: *btBvhTriangleMeshShape, callback: *btTriangleCallback, boxSource: btVector3, boxTarget: btVector3, boxMin: btVector3, boxMax: btVector3) #no_context {
        performConvexcast(this, callback, *boxSource, *boxTarget, *boxMin, *boxMax);
    }

    refitTree :: (this: *btBvhTriangleMeshShape, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?refitTree@btBvhTriangleMeshShape@@QEAAXAEBVbtVector3@@0@Z";
    refitTree :: (this: *btBvhTriangleMeshShape, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        refitTree(this, *aabbMin, *aabbMax);
    }

    ///for a fast incremental refit of parts of the tree. Note: the entire AABB of the tree will become more conservative, it never shrinks
    partialRefitTree :: (this: *btBvhTriangleMeshShape, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?partialRefitTree@btBvhTriangleMeshShape@@QEAAXAEBVbtVector3@@0@Z";
    partialRefitTree :: (this: *btBvhTriangleMeshShape, aabbMin: btVector3, aabbMax: btVector3) #no_context {
        partialRefitTree(this, *aabbMin, *aabbMax);
    }

    getOptimizedBvh :: (this: *btBvhTriangleMeshShape) -> *btOptimizedBvh #cpp_method #foreign bullet3 "?getOptimizedBvh@btBvhTriangleMeshShape@@QEAAPEAVbtOptimizedBvh@@XZ";

    setOptimizedBvh :: (this: *btBvhTriangleMeshShape, bvh: *btOptimizedBvh, localScaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setOptimizedBvh@btBvhTriangleMeshShape@@QEAAXPEAVbtOptimizedBvh@@AEBVbtVector3@@@Z";
    setOptimizedBvh :: (this: *btBvhTriangleMeshShape, bvh: *btOptimizedBvh, localScaling: btVector3 = btVector3.{1, 1, 1}) #no_context {
        setOptimizedBvh(this, bvh, *localScaling);
    }

    buildOptimizedBvh :: (this: *btBvhTriangleMeshShape) -> void #cpp_method #foreign bullet3 "?buildOptimizedBvh@btBvhTriangleMeshShape@@QEAAXXZ";

    usesQuantizedAabbCompression :: (this: *btBvhTriangleMeshShape) -> bool #cpp_method #foreign bullet3 "?usesQuantizedAabbCompression@btBvhTriangleMeshShape@@QEBA_NXZ";

    setTriangleInfoMap :: (this: *btBvhTriangleMeshShape, triangleInfoMap: *btTriangleInfoMap) -> void #cpp_method #foreign bullet3 "?setTriangleInfoMap@btBvhTriangleMeshShape@@QEAAXPEAUbtTriangleInfoMap@@@Z";

    getTriangleInfoMap :: (this: /*const*/ *btBvhTriangleMeshShape) -> *btTriangleInfoMap #cpp_method #foreign bullet3 "?getTriangleInfoMap@btBvhTriangleMeshShape@@QEBAPEBUbtTriangleInfoMap@@XZ";

    getTriangleInfoMap_1 :: (this: *btBvhTriangleMeshShape) -> *btTriangleInfoMap #cpp_method #foreign bullet3 "?getTriangleInfoMap@btBvhTriangleMeshShape@@QEAAPEAUbtTriangleInfoMap@@XZ";
    #place bttrianglemeshshape; btbvhtrianglemeshshape_vtable: *btBvhTriangleMeshShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btBvhTriangleMeshShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBvhTriangleMeshShape@@UEAA@XZ";

    virtual_processAllTriangles :: (this: *btBvhTriangleMeshShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btBvhTriangleMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    //debugging
    virtual_getName :: (this: *btBvhTriangleMeshShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btBvhTriangleMeshShape@@UEBAPEBDXZ";

    virtual_setLocalScaling :: (this: *btBvhTriangleMeshShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btBvhTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btBvhTriangleMeshShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btBvhTriangleMeshShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btBvhTriangleMeshShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btBvhTriangleMeshShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";

    virtual_serializeSingleBvh :: (this: *btBvhTriangleMeshShape, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSingleBvh@btBvhTriangleMeshShape@@UEBAXPEAVbtSerializer@@@Z";

    virtual_serializeSingleTriangleInfoMap :: (this: *btBvhTriangleMeshShape, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSingleTriangleInfoMap@btBvhTriangleMeshShape@@UEBAXPEAVbtSerializer@@@Z";
}
btBvhTriangleMeshShape_VTable :: struct #type_info_none {
    using bttrianglemeshshape: btTriangleMeshShape_VTable;
    serializeSingleBvh: (this: *btBvhTriangleMeshShape, serializer: *btSerializer) -> void #cpp_method;

    serializeSingleTriangleInfoMap: (this: *btBvhTriangleMeshShape, serializer: *btSerializer) -> void #cpp_method;
}

btBvhTriangleMeshShape_serializeSingleBvh :: inline (this: *btBvhTriangleMeshShape, serializer: *btSerializer) { this.btbvhtrianglemeshshape_vtable.serializeSingleBvh(this, serializer); }

btBvhTriangleMeshShape_serializeSingleTriangleInfoMap :: inline (this: *btBvhTriangleMeshShape, serializer: *btSerializer) { this.btbvhtrianglemeshshape_vtable.serializeSingleTriangleInfoMap(this, serializer); }

vtable :: (obj: *btBvhTriangleMeshShape) -> *btBvhTriangleMeshShape_VTable { return obj.btbvhtrianglemeshshape_vtable; }



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btTriangleMeshShapeData :: struct {
    m_collisionShapeData: btCollisionShapeData;

    m_meshInterface:      btStridingMeshInterfaceData;

    m_quantizedFloatBvh:  *btQuantizedBvhFloatData;
    m_quantizedDoubleBvh: *btQuantizedBvhDoubleData;

    m_triangleInfoMap:    *btTriangleInfoMapData;

    m_collisionMargin:    float;

    m_pad3:               [4] u8;
}

///The btScaledBvhTriangleMeshShape allows to instance a scaled version of an existing btBvhTriangleMeshShape.
///Note that each btBvhTriangleMeshShape still can have its own local scaling, independent from this btScaledBvhTriangleMeshShape 'localScaling'
btScaledBvhTriangleMeshShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    m_localScaling:    btVector3;

    m_bvhTriMeshShape: *btBvhTriangleMeshShape;

    Constructor :: (this: *btScaledBvhTriangleMeshShape, childShape: *btBvhTriangleMeshShape, localScaling: *btVector3) -> void #cpp_method #foreign bullet3 "??0btScaledBvhTriangleMeshShape@@QEAA@PEAVbtBvhTriangleMeshShape@@AEBVbtVector3@@@Z";
    Constructor :: (this: *btScaledBvhTriangleMeshShape, childShape: *btBvhTriangleMeshShape, localScaling: btVector3) #no_context {
        Constructor(this, childShape, *localScaling);
    }

    getChildShape :: (this: *btScaledBvhTriangleMeshShape) -> *btBvhTriangleMeshShape #cpp_method #foreign bullet3 "?getChildShape@btScaledBvhTriangleMeshShape@@QEAAPEAVbtBvhTriangleMeshShape@@XZ";

    getChildShape_1 :: (this: /*const*/ *btScaledBvhTriangleMeshShape) -> *btBvhTriangleMeshShape #cpp_method #foreign bullet3 "?getChildShape@btScaledBvhTriangleMeshShape@@QEBAPEBVbtBvhTriangleMeshShape@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btScaledBvhTriangleMeshShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btScaledBvhTriangleMeshShape@@UEAA@XZ";

    virtual_getAabb :: (this: *btScaledBvhTriangleMeshShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btScaledBvhTriangleMeshShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";
    virtual_setLocalScaling :: (this: *btScaledBvhTriangleMeshShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btScaledBvhTriangleMeshShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btScaledBvhTriangleMeshShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btScaledBvhTriangleMeshShape@@UEBAAEBVbtVector3@@XZ";
    virtual_calculateLocalInertia :: (this: *btScaledBvhTriangleMeshShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btScaledBvhTriangleMeshShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_processAllTriangles :: (this: *btScaledBvhTriangleMeshShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btScaledBvhTriangleMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    //debugging
    virtual_getName :: (this: *btScaledBvhTriangleMeshShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btScaledBvhTriangleMeshShape@@UEBAPEBDXZ";

    virtual_calculateSerializeBufferSize :: (this: *btScaledBvhTriangleMeshShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btScaledBvhTriangleMeshShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btScaledBvhTriangleMeshShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btScaledBvhTriangleMeshShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btScaledTriangleMeshShapeData :: struct {
    m_trimeshShapeData: btTriangleMeshShapeData;

    m_localScaling:     btVector3FloatData;
}

btCompoundShapeChild :: struct {
    m_transform:      btTransform;
    m_childShape:     *btCollisionShape;
    m_childShapeType: s32;
    m_childMargin:    btScalar;
    m_node:           *btDbvtNode;
}


/// The btCompoundShape allows to store multiple other btCollisionShapes
/// This allows for moving concave collision objects. This is more general then the static concave btBvhTriangleMeshShape.
/// It has an (optional) dynamic aabb tree to accelerate early rejection tests.
/// @todo: This aabb tree can also be use to speed up ray tests on btCompoundShape, see http://code.google.com/p/bullet/issues/detail?id=25
/// Currently, removal of child shapes is only supported when disabling the aabb tree (pass 'false' in the constructor of btCompoundShape)
btCompoundShape :: struct {
    #as using btcollisionshape: btCollisionShape;

    m_children:        btAlignedObjectArray(btCompoundShapeChild);
    m_localAabbMin:    btVector3;
    m_localAabbMax:    btVector3;

    m_dynamicAabbTree: *btDbvt;

    ///increment m_updateRevision when adding/removing/replacing child shapes, so that some caches can be updated
    m_updateRevision:  s32;

    m_collisionMargin: btScalar;

    m_localScaling:    btVector3;

    Constructor :: (this: *btCompoundShape, enableDynamicAabbTree := true, initialChildCapacity: s32 = 0) -> void #cpp_method #foreign bullet3 "??0btCompoundShape@@QEAA@_NH@Z";

    addChildShape :: (this: *btCompoundShape, localTransform: *btTransform, shape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?addChildShape@btCompoundShape@@QEAAXAEBVbtTransform@@PEAVbtCollisionShape@@@Z";
    addChildShape :: (this: *btCompoundShape, localTransform: btTransform, shape: *btCollisionShape) #no_context {
        addChildShape(this, *localTransform, shape);
    }

    removeChildShapeByIndex :: (this: *btCompoundShape, childShapeindex: s32) -> void #cpp_method #foreign bullet3 "?removeChildShapeByIndex@btCompoundShape@@QEAAXH@Z";

    getNumChildShapes :: (this: *btCompoundShape) -> s32 #cpp_method #foreign bullet3 "?getNumChildShapes@btCompoundShape@@QEBAHXZ";

    getChildShape :: (this: *btCompoundShape, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btCompoundShape@@QEAAPEAVbtCollisionShape@@H@Z";

    getChildShape_1 :: (this: /*const*/ *btCompoundShape, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btCompoundShape@@QEBAPEBVbtCollisionShape@@H@Z";

    getChildTransform :: (this: *btCompoundShape, index: s32) -> *btTransform #cpp_method #foreign bullet3 "?getChildTransform@btCompoundShape@@QEAAAEAVbtTransform@@H@Z";

    getChildTransform_1 :: (this: /*const*/ *btCompoundShape, index: s32) -> *btTransform #cpp_method #foreign bullet3 "?getChildTransform@btCompoundShape@@QEBAAEBVbtTransform@@H@Z";

    ///set a new transform for a child, and update internal data structures (local aabb and dynamic tree)
    updateChildTransform :: (this: *btCompoundShape, childIndex: s32, newChildTransform: *btTransform, shouldRecalculateLocalAabb := true) -> void #cpp_method #foreign bullet3 "?updateChildTransform@btCompoundShape@@QEAAXHAEBVbtTransform@@_N@Z";
    updateChildTransform :: (this: *btCompoundShape, childIndex: s32, newChildTransform: btTransform, shouldRecalculateLocalAabb := true) #no_context {
        updateChildTransform(this, childIndex, *newChildTransform, shouldRecalculateLocalAabb);
    }

    getChildList :: (this: *btCompoundShape) -> *btCompoundShapeChild #cpp_method #foreign bullet3 "?getChildList@btCompoundShape@@QEAAPEAUbtCompoundShapeChild@@XZ";

    getDynamicAabbTree :: (this: /*const*/ *btCompoundShape) -> *btDbvt #cpp_method #foreign bullet3 "?getDynamicAabbTree@btCompoundShape@@QEBAPEBUbtDbvt@@XZ";

    getDynamicAabbTree_1 :: (this: *btCompoundShape) -> *btDbvt #cpp_method #foreign bullet3 "?getDynamicAabbTree@btCompoundShape@@QEAAPEAUbtDbvt@@XZ";

    createAabbTreeFromChildren :: (this: *btCompoundShape) -> void #cpp_method #foreign bullet3 "?createAabbTreeFromChildren@btCompoundShape@@QEAAXXZ";

    ///computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia
    ///and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. The resulting transform
    ///"principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound
    ///shape to be centered at the center of mass and to coincide with the principal axes. This also necessitates a correction of the world transform
    ///of the collision object by the principal transform.
    calculatePrincipalAxisTransform :: (this: *btCompoundShape, masses: *btScalar, principal: *btTransform, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculatePrincipalAxisTransform@btCompoundShape@@QEBAXPEBMAEAVbtTransform@@AEAVbtVector3@@@Z";

    getUpdateRevision :: (this: *btCompoundShape) -> s32 #cpp_method #foreign bullet3 "?getUpdateRevision@btCompoundShape@@QEBAHXZ";
    #place btcollisionshape; btcompoundshape_vtable: *btCompoundShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCompoundShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCompoundShape@@UEAA@XZ";

    /// Remove all children shapes that contain the specified shape
    virtual_removeChildShape :: (this: *btCompoundShape, shape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?removeChildShape@btCompoundShape@@UEAAXPEAVbtCollisionShape@@@Z";

    ///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    virtual_getAabb :: (this: *btCompoundShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btCompoundShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    /** Re-calculate the local Aabb. Is called at the end of removeChildShapes. 
    Use this yourself if you modify the children or their transforms. */
    virtual_recalculateLocalAabb :: (this: *btCompoundShape) -> void #cpp_method #foreign bullet3 "?recalculateLocalAabb@btCompoundShape@@UEAAXXZ";

    virtual_setLocalScaling :: (this: *btCompoundShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btCompoundShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getLocalScaling :: (this: *btCompoundShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btCompoundShape@@UEBAAEBVbtVector3@@XZ";

    virtual_calculateLocalInertia :: (this: *btCompoundShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btCompoundShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_setMargin :: (this: *btCompoundShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btCompoundShape@@UEAAXM@Z";

    virtual_getMargin :: (this: *btCompoundShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btCompoundShape@@UEBAMXZ";

    virtual_getName :: (this: *btCompoundShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btCompoundShape@@UEBAPEBDXZ";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btCompoundShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btCompoundShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btCompoundShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btCompoundShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btCompoundShape_VTable :: struct #type_info_none {
    using btcollisionshape: btCollisionShape_VTable;
    removeChildShape: (this: *btCompoundShape, shape: *btCollisionShape) -> void #cpp_method;

    recalculateLocalAabb: (this: *btCompoundShape) -> void #cpp_method;
}

btCompoundShape_removeChildShape :: inline (this: *btCompoundShape, shape: *btCollisionShape) { this.btcompoundshape_vtable.removeChildShape(this, shape); }

btCompoundShape_recalculateLocalAabb :: inline (this: *btCompoundShape) { this.btcompoundshape_vtable.recalculateLocalAabb(this); }

vtable :: (obj: *btCompoundShape) -> *btCompoundShape_VTable { return obj.btcompoundshape_vtable; }



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCompoundShapeChildData :: struct {
    m_transform:      btTransformFloatData;
    m_childShape:     *btCollisionShapeData;
    m_childShapeType: s32;
    m_childMargin:    float;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btCompoundShapeData :: struct {
    m_collisionShapeData: btCollisionShapeData;

    m_childShapePtr:      *btCompoundShapeChildData;

    m_numChildShapes:     s32;

    m_collisionMargin:    float;
}

///The btBU_Simplex1to4 implements tetrahedron, triangle, line, vertex collision shapes. In most cases it is better to use btConvexHullShape instead.
btBU_Simplex1to4 :: struct {
    #as using btpolyhedralconvexaabbcachingshape: btPolyhedralConvexAabbCachingShape;

    m_numVertices: s32;
    m_vertices:    [4] btVector3;

    Constructor :: (this: *btBU_Simplex1to4) -> void #cpp_method #foreign bullet3 "??0btBU_Simplex1to4@@QEAA@XZ";

    Constructor :: (this: *btBU_Simplex1to4, pt0: *btVector3) -> void #cpp_method #foreign bullet3 "??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btBU_Simplex1to4, pt0: btVector3) #no_context {
        Constructor(this, *pt0);
    }
    Constructor :: (this: *btBU_Simplex1to4, pt0: *btVector3, pt1: *btVector3) -> void #cpp_method #foreign bullet3 "??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@0@Z";
    Constructor :: (this: *btBU_Simplex1to4, pt0: btVector3, pt1: btVector3) #no_context {
        Constructor(this, *pt0, *pt1);
    }
    Constructor :: (this: *btBU_Simplex1to4, pt0: *btVector3, pt1: *btVector3, pt2: *btVector3) -> void #cpp_method #foreign bullet3 "??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@00@Z";
    Constructor :: (this: *btBU_Simplex1to4, pt0: btVector3, pt1: btVector3, pt2: btVector3) #no_context {
        Constructor(this, *pt0, *pt1, *pt2);
    }
    Constructor :: (this: *btBU_Simplex1to4, pt0: *btVector3, pt1: *btVector3, pt2: *btVector3, pt3: *btVector3) -> void #cpp_method #foreign bullet3 "??0btBU_Simplex1to4@@QEAA@AEBVbtVector3@@000@Z";
    Constructor :: (this: *btBU_Simplex1to4, pt0: btVector3, pt1: btVector3, pt2: btVector3, pt3: btVector3) #no_context {
        Constructor(this, *pt0, *pt1, *pt2, *pt3);
    }

    reset :: (this: *btBU_Simplex1to4) -> void #cpp_method #foreign bullet3 "?reset@btBU_Simplex1to4@@QEAAXXZ";

    addVertex :: (this: *btBU_Simplex1to4, pt: *btVector3) -> void #cpp_method #foreign bullet3 "?addVertex@btBU_Simplex1to4@@QEAAXAEBVbtVector3@@@Z";
    addVertex :: (this: *btBU_Simplex1to4, pt: btVector3) #no_context {
        addVertex(this, *pt);
    }
    #place btpolyhedralconvexaabbcachingshape; btbu_simplex1to4_vtable: *btBU_Simplex1to4_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getAabb :: (this: *btBU_Simplex1to4, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btBU_Simplex1to4@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    //PolyhedralConvexShape interface
    virtual_getNumVertices :: (this: *btBU_Simplex1to4) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btBU_Simplex1to4@@UEBAHXZ";

    virtual_getNumEdges :: (this: *btBU_Simplex1to4) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btBU_Simplex1to4@@UEBAHXZ";

    virtual_getEdge :: (this: *btBU_Simplex1to4, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btBU_Simplex1to4@@UEBAXHAEAVbtVector3@@0@Z";

    virtual_getVertex :: (this: *btBU_Simplex1to4, i: s32, vtx: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btBU_Simplex1to4@@UEBAXHAEAVbtVector3@@@Z";

    virtual_getNumPlanes :: (this: *btBU_Simplex1to4) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btBU_Simplex1to4@@UEBAHXZ";

    virtual_getPlane :: (this: *btBU_Simplex1to4, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btBU_Simplex1to4@@UEBAXAEAVbtVector3@@0H@Z";

    virtual_getIndex :: (this: *btBU_Simplex1to4, i: s32) -> s32 #cpp_method #foreign bullet3 "?getIndex@btBU_Simplex1to4@@UEBAHH@Z";

    virtual_isInside :: (this: *btBU_Simplex1to4, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btBU_Simplex1to4@@UEBA_NAEBVbtVector3@@M@Z";

    ///getName is for debugging
    virtual_getName :: (this: *btBU_Simplex1to4) -> *u8 #cpp_method #foreign bullet3 "?getName@btBU_Simplex1to4@@UEBAPEBDXZ";
}
btBU_Simplex1to4_VTable :: struct #type_info_none {
    using btpolyhedralconvexshape: btPolyhedralConvexShape_VTable;
    getIndex: (this: *btBU_Simplex1to4, i: s32) -> s32 #cpp_method;
}
btBU_Simplex1to4_getIndex :: inline (this: *btBU_Simplex1to4, i: s32) -> s32 { return this.btbu_simplex1to4_vtable.getIndex(this, i); }

vtable :: (obj: *btBU_Simplex1to4) -> *btBU_Simplex1to4_VTable { return obj.btbu_simplex1to4_vtable; }



/// The btEmptyShape is a collision shape without actual collision detection shape, so most users should ignore this class.
/// It can be replaced by another shape during runtime, but the inertia tensor should be recomputed.
btEmptyShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    Constructor :: (this: *btEmptyShape) -> void #cpp_method #foreign bullet3 "??0btEmptyShape@@QEAA@XZ";

    m_localScaling: btVector3;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btEmptyShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btEmptyShape@@UEAA@XZ";

    ///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    virtual_getAabb :: (this: *btEmptyShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btEmptyShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_setLocalScaling :: (this: *btEmptyShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btEmptyShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getLocalScaling :: (this: *btEmptyShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btEmptyShape@@UEBAAEBVbtVector3@@XZ";

    virtual_calculateLocalInertia :: (this: *btEmptyShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btEmptyShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btEmptyShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btEmptyShape@@UEBAPEBDXZ";

    virtual_processAllTriangles :: (this: *btEmptyShape, unknown0: *btTriangleCallback, unknown1: *btVector3, unknown2: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btEmptyShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
}


///The btMultiSphereShape represents the convex hull of a collection of spheres. You can create special capsules or other smooth volumes.
///It is possible to animate the spheres for deformation, but call 'recalcLocalAabb' after changing any sphere position/radius
btMultiSphereShape :: struct {
    #as using btconvexinternalaabbcachingshape: btConvexInternalAabbCachingShape;

    m_localPositionArray: btAlignedObjectArray(btVector3);
    m_radiArray:          btAlignedObjectArray(btScalar);

    Constructor :: (this: *btMultiSphereShape, positions: *btVector3, radi: *btScalar, numSpheres: s32) -> void #cpp_method #foreign bullet3 "??0btMultiSphereShape@@QEAA@PEBVbtVector3@@PEBMH@Z";

    getSphereCount :: (this: *btMultiSphereShape) -> s32 #cpp_method #foreign bullet3 "?getSphereCount@btMultiSphereShape@@QEBAHXZ";

    getSpherePosition :: (this: *btMultiSphereShape, index: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getSpherePosition@btMultiSphereShape@@QEBAAEBVbtVector3@@H@Z";

    getSphereRadius :: (this: *btMultiSphereShape, index: s32) -> btScalar #cpp_method #foreign bullet3 "?getSphereRadius@btMultiSphereShape@@QEBAMH@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    ///CollisionShape Interface
    virtual_calculateLocalInertia :: (this: *btMultiSphereShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btMultiSphereShape@@UEBAXMAEAVbtVector3@@@Z";

    /// btConvexShape Interface
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btMultiSphereShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btMultiSphereShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btMultiSphereShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btMultiSphereShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_getName :: (this: *btMultiSphereShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btMultiSphereShape@@UEBAPEBDXZ";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btMultiSphereShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btMultiSphereShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btMultiSphereShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btMultiSphereShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}


btPositionAndRadius :: struct {
    m_pos:    btVector3FloatData;
    m_radius: float;
}

// clang-format off
btMultiSphereShapeData :: struct {
    m_convexInternalShapeData: btConvexInternalShapeData;

    m_localPositionArrayPtr:   *btPositionAndRadius;
    m_localPositionArraySize:  s32;
    m_padding:                 [4] u8;
}

///The btUniformScalingShape allows to re-use uniform scaled instances of btConvexShape in a memory efficient way.
///Istead of using btUniformScalingShape, it is better to use the non-uniform setLocalScaling method on convex shapes that implement it.
btUniformScalingShape :: struct {
    #as using btconvexshape: btConvexShape;

    m_childConvexShape:     *btConvexShape;

    m_uniformScalingFactor: btScalar;

    Constructor :: (this: *btUniformScalingShape, convexChildShape: *btConvexShape, uniformScalingFactor: btScalar) -> void #cpp_method #foreign bullet3 "??0btUniformScalingShape@@QEAA@PEAVbtConvexShape@@M@Z";

    getUniformScalingFactor :: (this: *btUniformScalingShape) -> btScalar #cpp_method #foreign bullet3 "?getUniformScalingFactor@btUniformScalingShape@@QEBAMXZ";

    getChildShape :: (this: *btUniformScalingShape) -> *btConvexShape #cpp_method #foreign bullet3 "?getChildShape@btUniformScalingShape@@QEAAPEAVbtConvexShape@@XZ";

    getChildShape_1 :: (this: /*const*/ *btUniformScalingShape) -> *btConvexShape #cpp_method #foreign bullet3 "?getChildShape@btUniformScalingShape@@QEBAPEBVbtConvexShape@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btUniformScalingShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btUniformScalingShape@@UEAA@XZ";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btUniformScalingShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btUniformScalingShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_localGetSupportingVertex :: (this: *btUniformScalingShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btUniformScalingShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btUniformScalingShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btUniformScalingShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btUniformScalingShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btUniformScalingShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btUniformScalingShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btUniformScalingShape@@UEBAPEBDXZ";

    ///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    virtual_getAabb :: (this: *btUniformScalingShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btUniformScalingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_getAabbSlow :: (this: *btUniformScalingShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabbSlow@btUniformScalingShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_setLocalScaling :: (this: *btUniformScalingShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btUniformScalingShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btUniformScalingShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btUniformScalingShape@@UEBAAEBVbtVector3@@XZ";

    virtual_setMargin :: (this: *btUniformScalingShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btUniformScalingShape@@UEAAXM@Z";
    virtual_getMargin :: (this: *btUniformScalingShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btUniformScalingShape@@UEBAMXZ";

    virtual_getNumPreferredPenetrationDirections :: (this: *btUniformScalingShape) -> s32 #cpp_method #foreign bullet3 "?getNumPreferredPenetrationDirections@btUniformScalingShape@@UEBAHXZ";

    virtual_getPreferredPenetrationDirection :: (this: *btUniformScalingShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method #foreign bullet3 "?getPreferredPenetrationDirection@btUniformScalingShape@@UEBAXHAEAVbtVector3@@@Z";
}


btManifoldArray :: btAlignedObjectArray(*btPersistentManifold);

btCollisionAlgorithmConstructionInfo :: struct {
    Constructor :: (this: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btCollisionAlgorithmConstructionInfo@@QEAA@XZ";

    Constructor :: (this: *btCollisionAlgorithmConstructionInfo, dispatcher: *btDispatcher, temp: s32) -> void #cpp_method #foreign bullet3 "??0btCollisionAlgorithmConstructionInfo@@QEAA@PEAVbtDispatcher@@H@Z";

    m_dispatcher1: *btDispatcher;
    m_manifold:    *btPersistentManifold;
}

///btCollisionAlgorithm is an collision interface that is compatible with the Broadphase and btDispatcher.
///It is persistent over frames
btCollisionAlgorithm :: struct {
    vtable: *btCollisionAlgorithm_VTable;
    m_dispatcher: *btDispatcher;

    //	int	getDispatcherId();
    Constructor :: (this: *btCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "??0btCollisionAlgorithm@@QEAA@XZ";

    Constructor :: (this: *btCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionAlgorithm@@UEAA@XZ";
}
btCollisionAlgorithm_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    processCollision: (this: *btCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method;

    calculateTimeOfImpact: (this: *btCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method;

    getAllContactManifolds: (this: *btCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method;
}

btCollisionAlgorithm_Destructor :: inline (this: *btCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionAlgorithm_processCollision :: inline (this: *btCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) { this.vtable.processCollision(this, body0Wrap, body1Wrap, dispatchInfo, resultOut); }

btCollisionAlgorithm_calculateTimeOfImpact :: inline (this: *btCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar { return this.vtable.calculateTimeOfImpact(this, body0, body1, dispatchInfo, resultOut); }

btCollisionAlgorithm_getAllContactManifolds :: inline (this: *btCollisionAlgorithm, manifoldArray: *btManifoldArray) { this.vtable.getAllContactManifolds(this, manifoldArray); }



///This class is not enabled yet (work-in-progress) to more aggressively activate objects.
btActivatingCollisionAlgorithm :: struct {
    #as using btcollisionalgorithm: btCollisionAlgorithm;

    //	btCollisionObject* m_colObj0;
    //	btCollisionObject* m_colObj1;
    Constructor :: (this: *btActivatingCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btActivatingCollisionAlgorithm@@IEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btActivatingCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    Constructor :: (this: *btActivatingCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btActivatingCollisionAlgorithm@@IEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1@Z";
    Constructor :: (this: *btActivatingCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) #no_context {
        Constructor(this, *ci, body0Wrap, body1Wrap);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btActivatingCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btActivatingCollisionAlgorithm@@UEAA@XZ";
}

/// btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
/// Also provides the most basic sample for custom/user btCollisionAlgorithm
btSphereSphereCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_ownManifold: bool;
    m_manifoldPtr: *btPersistentManifold;

    Constructor :: (this: *btSphereSphereCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, col0Wrap: *btCollisionObjectWrapper, col1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btSphereSphereCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z";
    Constructor :: (this: *btSphereSphereCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, col0Wrap: *btCollisionObjectWrapper, col1Wrap: *btCollisionObjectWrapper) #no_context {
        Constructor(this, mf, *ci, col0Wrap, col1Wrap);
    }

    Constructor :: (this: *btSphereSphereCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btSphereSphereCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btSphereSphereCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processCollision :: (this: *btSphereSphereCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btSphereSphereCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btSphereSphereCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btSphereSphereCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btSphereSphereCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btSphereSphereCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";

    virtual_Destructor :: (this: *btSphereSphereCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSphereSphereCollisionAlgorithm@@UEAA@XZ";
}

///btCollisionConfiguration allows to configure Bullet collision detection
///stack allocator size, default collision algorithms and persistent manifold pool size
///@todo: describe the meaning
btCollisionConfiguration :: struct {
    vtable: *btCollisionConfiguration_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btCollisionConfiguration, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionConfiguration@@UEAA@XZ";
}
btCollisionConfiguration_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionConfiguration, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getPersistentManifoldPool: (this: *btCollisionConfiguration) -> *btPoolAllocator #cpp_method;

    getCollisionAlgorithmPool: (this: *btCollisionConfiguration) -> *btPoolAllocator #cpp_method;

    getCollisionAlgorithmCreateFunc: (this: *btCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc #cpp_method;

    getClosestPointsAlgorithmCreateFunc: (this: *btCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc #cpp_method;
}

btCollisionConfiguration_Destructor :: inline (this: *btCollisionConfiguration, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionConfiguration_getPersistentManifoldPool :: inline (this: *btCollisionConfiguration) -> *btPoolAllocator { return this.vtable.getPersistentManifoldPool(this); }

btCollisionConfiguration_getCollisionAlgorithmPool :: inline (this: *btCollisionConfiguration) -> *btPoolAllocator { return this.vtable.getCollisionAlgorithmPool(this); }

btCollisionConfiguration_getCollisionAlgorithmCreateFunc :: inline (this: *btCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc { return this.vtable.getCollisionAlgorithmCreateFunc(this, proxyType0, proxyType1); }

btCollisionConfiguration_getClosestPointsAlgorithmCreateFunc :: inline (this: *btCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc { return this.vtable.getClosestPointsAlgorithmCreateFunc(this, proxyType0, proxyType1); }



btDefaultCollisionConstructionInfo :: struct {
    m_persistentManifoldPool:                 *btPoolAllocator;
    m_collisionAlgorithmPool:                 *btPoolAllocator;
    m_defaultMaxPersistentManifoldPoolSize:   s32;
    m_defaultMaxCollisionAlgorithmPoolSize:   s32;
    m_customCollisionAlgorithmMaxElementSize: s32;
    m_useEpaPenetrationAlgorithm:             s32;

    Constructor :: (this: *btDefaultCollisionConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btDefaultCollisionConstructionInfo@@QEAA@XZ";
}

///btCollisionConfiguration allows to configure Bullet collision detection
///stack allocator, pool memory allocators
///@todo: describe the meaning
btDefaultCollisionConfiguration :: struct {
    #as using btcollisionconfiguration: btCollisionConfiguration;

    m_persistentManifoldPoolSize:     s32;

    m_persistentManifoldPool:         *btPoolAllocator;
    m_ownsPersistentManifoldPool:     bool;

    m_collisionAlgorithmPool:         *btPoolAllocator;
    m_ownsCollisionAlgorithmPool:     bool;

    //default penetration depth solver
    m_pdSolver:                       *btConvexPenetrationDepthSolver;

    //default CreationFunctions, filling the m_doubleDispatch table
    m_convexConvexCreateFunc:         *btCollisionAlgorithmCreateFunc;
    m_convexConcaveCreateFunc:        *btCollisionAlgorithmCreateFunc;
    m_swappedConvexConcaveCreateFunc: *btCollisionAlgorithmCreateFunc;
    m_compoundCreateFunc:             *btCollisionAlgorithmCreateFunc;
    m_compoundCompoundCreateFunc:     *btCollisionAlgorithmCreateFunc;

    m_swappedCompoundCreateFunc:      *btCollisionAlgorithmCreateFunc;
    m_emptyCreateFunc:                *btCollisionAlgorithmCreateFunc;
    m_sphereSphereCF:                 *btCollisionAlgorithmCreateFunc;
    m_sphereBoxCF:                    *btCollisionAlgorithmCreateFunc;
    m_boxSphereCF:                    *btCollisionAlgorithmCreateFunc;

    m_boxBoxCF:                       *btCollisionAlgorithmCreateFunc;
    m_sphereTriangleCF:               *btCollisionAlgorithmCreateFunc;
    m_triangleSphereCF:               *btCollisionAlgorithmCreateFunc;
    m_planeConvexCF:                  *btCollisionAlgorithmCreateFunc;
    m_convexPlaneCF:                  *btCollisionAlgorithmCreateFunc;

    Constructor :: (this: *btDefaultCollisionConfiguration, constructionInfo: *btDefaultCollisionConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btDefaultCollisionConfiguration@@QEAA@AEBUbtDefaultCollisionConstructionInfo@@@Z";
    Constructor :: (this: *btDefaultCollisionConfiguration, constructionInfo: btDefaultCollisionConstructionInfo = btDefaultCollisionConstructionInfo.{}) #no_context {
        Constructor(this, *constructionInfo);
    }

    ///Use this method to allow to generate multiple contact points between at once, between two objects using the generic convex-convex algorithm.
    ///By default, this feature is disabled for best performance.
    ///@param numPerturbationIterations controls the number of collision queries. Set it to zero to disable the feature.
    ///@param minimumPointsPerturbationThreshold is the minimum number of points in the contact cache, above which the feature is disabled
    ///3 is a good value for both params, if you want to enable the feature. This is because the default contact cache contains a maximum of 4 points, and one collision query at the unperturbed orientation is performed first.
    ///See Bullet/Demos/CollisionDemo for an example how this feature gathers multiple points.
    ///@todo we could add a per-object setting of those parameters, for level-of-detail collision detection.
    setConvexConvexMultipointIterations :: (this: *btDefaultCollisionConfiguration, numPerturbationIterations: s32 = 3, minimumPointsPerturbationThreshold: s32 = 3) -> void #cpp_method #foreign bullet3 "?setConvexConvexMultipointIterations@btDefaultCollisionConfiguration@@QEAAXHH@Z";

    setPlaneConvexMultipointIterations :: (this: *btDefaultCollisionConfiguration, numPerturbationIterations: s32 = 3, minimumPointsPerturbationThreshold: s32 = 3) -> void #cpp_method #foreign bullet3 "?setPlaneConvexMultipointIterations@btDefaultCollisionConfiguration@@QEAAXHH@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDefaultCollisionConfiguration, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDefaultCollisionConfiguration@@UEAA@XZ";

    ///memory pools
    virtual_getPersistentManifoldPool :: (this: *btDefaultCollisionConfiguration) -> *btPoolAllocator #cpp_method #foreign bullet3 "?getPersistentManifoldPool@btDefaultCollisionConfiguration@@UEAAPEAVbtPoolAllocator@@XZ";

    virtual_getCollisionAlgorithmPool :: (this: *btDefaultCollisionConfiguration) -> *btPoolAllocator #cpp_method #foreign bullet3 "?getCollisionAlgorithmPool@btDefaultCollisionConfiguration@@UEAAPEAVbtPoolAllocator@@XZ";

    virtual_getCollisionAlgorithmCreateFunc :: (this: *btDefaultCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc #cpp_method #foreign bullet3 "?getCollisionAlgorithmCreateFunc@btDefaultCollisionConfiguration@@UEAAPEAUbtCollisionAlgorithmCreateFunc@@HH@Z";

    virtual_getClosestPointsAlgorithmCreateFunc :: (this: *btDefaultCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc #cpp_method #foreign bullet3 "?getClosestPointsAlgorithmCreateFunc@btDefaultCollisionConfiguration@@UEAAPEAUbtCollisionAlgorithmCreateFunc@@HH@Z";
}

btSimpleBroadphaseProxy :: struct {
    #as using btbroadphaseproxy: btBroadphaseProxy;

    m_nextFree: s32;

    //	int			m_handleId;
    Constructor :: (this: *btSimpleBroadphaseProxy) -> void #cpp_method #foreign bullet3 "??0btSimpleBroadphaseProxy@@QEAA@XZ";

    Constructor :: (this: *btSimpleBroadphaseProxy, minpt: *btVector3, maxpt: *btVector3, shapeType: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> void #cpp_method #foreign bullet3 "??0btSimpleBroadphaseProxy@@QEAA@AEBVbtVector3@@0HPEAXHH@Z";
    Constructor :: (this: *btSimpleBroadphaseProxy, minpt: btVector3, maxpt: btVector3, shapeType: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) #no_context {
        Constructor(this, *minpt, *maxpt, shapeType, userPtr, collisionFilterGroup, collisionFilterMask);
    }

    SetNextFree :: (this: *btSimpleBroadphaseProxy, next: s32) -> void #cpp_method #foreign bullet3 "?SetNextFree@btSimpleBroadphaseProxy@@QEAAXH@Z";
    GetNextFree :: (this: *btSimpleBroadphaseProxy) -> s32 #cpp_method #foreign bullet3 "?GetNextFree@btSimpleBroadphaseProxy@@QEBAHXZ";
}

///The SimpleBroadphase is just a unit-test for btAxisSweep3, bt32BitAxisSweep3, or btDbvtBroadphase, so use those classes instead.
///It is a brute force aabb culling broadphase based on O(n^2) aabb checks
btSimpleBroadphase :: struct {
    #as using btbroadphaseinterface: btBroadphaseInterface;

    m_numHandles:      s32; // number of active handles
    m_maxHandles:      s32; // max number of handles
    m_LastHandleIndex: s32;

    m_pHandles:        *btSimpleBroadphaseProxy; // handles pool

    m_pHandlesRawPtr:  *void;
    m_firstFreeHandle: s32; // free handles list

    allocHandle :: (this: *btSimpleBroadphase) -> s32 #cpp_method #foreign bullet3 "?allocHandle@btSimpleBroadphase@@IEAAHXZ";

    freeHandle :: (this: *btSimpleBroadphase, proxy: *btSimpleBroadphaseProxy) -> void #cpp_method #foreign bullet3 "?freeHandle@btSimpleBroadphase@@IEAAXPEAUbtSimpleBroadphaseProxy@@@Z";

    m_pairCache:       *btOverlappingPairCache;
    m_ownsPairCache:   bool;

    m_invalidPair:     s32;

    getSimpleProxyFromProxy :: (this: *btSimpleBroadphase, proxy: *btBroadphaseProxy) -> *btSimpleBroadphaseProxy #cpp_method #foreign bullet3 "?getSimpleProxyFromProxy@btSimpleBroadphase@@IEAAPEAUbtSimpleBroadphaseProxy@@PEAUbtBroadphaseProxy@@@Z";

    getSimpleProxyFromProxy_1 :: (this: /*const*/ *btSimpleBroadphase, proxy: *btBroadphaseProxy) -> *btSimpleBroadphaseProxy #cpp_method #foreign bullet3 "?getSimpleProxyFromProxy@btSimpleBroadphase@@IEBAPEBUbtSimpleBroadphaseProxy@@PEAUbtBroadphaseProxy@@@Z";

    validate :: (this: *btSimpleBroadphase) -> void #cpp_method #foreign bullet3 "?validate@btSimpleBroadphase@@IEAAXXZ";

    Constructor :: (this: *btSimpleBroadphase, maxProxies: s32 = 16384, overlappingPairCache: *btOverlappingPairCache = null) -> void #cpp_method #foreign bullet3 "??0btSimpleBroadphase@@QEAA@HPEAVbtOverlappingPairCache@@@Z";

    aabbOverlap :: (proxy0: *btSimpleBroadphaseProxy, proxy1: *btSimpleBroadphaseProxy) -> bool #foreign bullet3 "?aabbOverlap@btSimpleBroadphase@@SA_NPEAUbtSimpleBroadphaseProxy@@0@Z";

    testAabbOverlap :: (this: *btSimpleBroadphase, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> bool #cpp_method #foreign bullet3 "?testAabbOverlap@btSimpleBroadphase@@QEAA_NPEAUbtBroadphaseProxy@@0@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    ///reset broadphase internal structures, to ensure determinism/reproducability
    virtual_resetPool :: (this: *btSimpleBroadphase, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?resetPool@btSimpleBroadphase@@MEAAXPEAVbtDispatcher@@@Z";

    virtual_Destructor :: (this: *btSimpleBroadphase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSimpleBroadphase@@UEAA@XZ";

    virtual_createProxy :: (this: *btSimpleBroadphase, aabbMin: *btVector3, aabbMax: *btVector3, shapeType: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32, dispatcher: *btDispatcher) -> *btBroadphaseProxy #cpp_method #foreign bullet3 "?createProxy@btSimpleBroadphase@@UEAAPEAUbtBroadphaseProxy@@AEBVbtVector3@@0HPEAXHHPEAVbtDispatcher@@@Z";

    virtual_calculateOverlappingPairs :: (this: *btSimpleBroadphase, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?calculateOverlappingPairs@btSimpleBroadphase@@UEAAXPEAVbtDispatcher@@@Z";

    virtual_destroyProxy :: (this: *btSimpleBroadphase, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?destroyProxy@btSimpleBroadphase@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";
    virtual_setAabb :: (this: *btSimpleBroadphase, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?setAabb@btSimpleBroadphase@@UEAAXPEAUbtBroadphaseProxy@@AEBVbtVector3@@1PEAVbtDispatcher@@@Z";
    virtual_getAabb :: (this: *btSimpleBroadphase, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btSimpleBroadphase@@UEBAXPEAUbtBroadphaseProxy@@AEAVbtVector3@@1@Z";

    virtual_rayTest :: (this: *btSimpleBroadphase, rayFrom: *btVector3, rayTo: *btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?rayTest@btSimpleBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseRayCallback@@00@Z";
    rayTest :: (this: *btSimpleBroadphase, rayFrom: btVector3, rayTo: btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: btVector3 = btVector3.{0, 0, 0}, aabbMax: btVector3 = btVector3.{0, 0, 0}) #no_context {
        rayTest(this, *rayFrom, *rayTo, rayCallback, *aabbMin, *aabbMax);
    }
    virtual_aabbTest :: (this: *btSimpleBroadphase, aabbMin: *btVector3, aabbMax: *btVector3, callback: *btBroadphaseAabbCallback) -> void #cpp_method #foreign bullet3 "?aabbTest@btSimpleBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseAabbCallback@@@Z";

    virtual_getOverlappingPairCache :: (this: *btSimpleBroadphase) -> *btOverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@btSimpleBroadphase@@UEAAPEAVbtOverlappingPairCache@@XZ";

    virtual_getOverlappingPairCache_1 :: (this: /*const*/ *btSimpleBroadphase) -> *btOverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@btSimpleBroadphase@@UEBAPEBVbtOverlappingPairCache@@XZ";

    ///getAabb returns the axis aligned bounding box in the 'global' coordinate frame
    ///will add some transform later
    virtual_getBroadphaseAabb :: (this: *btSimpleBroadphase, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getBroadphaseAabb@btSimpleBroadphase@@UEBAXAEAVbtVector3@@0@Z";

    virtual_printStats :: (this: *btSimpleBroadphase) -> void #cpp_method #foreign bullet3 "?printStats@btSimpleBroadphase@@UEAAXXZ";
}

/* btDbvtAabbMm			*/
btDbvtAabbMm :: struct {
    Constructor :: (this: *btDbvtAabbMm) -> void #cpp_method #foreign bullet3 "??0btDbvtAabbMm@@QEAA@XZ";
    Center :: (this: *btDbvtAabbMm) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?Center@btDbvtAabbMm@@QEBA?AVbtVector3@@XZ";
    Lengths :: (this: *btDbvtAabbMm) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?Lengths@btDbvtAabbMm@@QEBA?AVbtVector3@@XZ";
    Extents :: (this: *btDbvtAabbMm) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?Extents@btDbvtAabbMm@@QEBA?AVbtVector3@@XZ";
    Mins :: (this: *btDbvtAabbMm) -> *btVector3 #cpp_method #foreign bullet3 "?Mins@btDbvtAabbMm@@QEBAAEBVbtVector3@@XZ";
    Maxs :: (this: *btDbvtAabbMm) -> *btVector3 #cpp_method #foreign bullet3 "?Maxs@btDbvtAabbMm@@QEBAAEBVbtVector3@@XZ";

    //
    FromCE :: (c: *btVector3, e: *btVector3) -> btDbvtAabbMm #cpp_return_type_is_non_pod #foreign bullet3 "?FromCE@btDbvtAabbMm@@SA?AU1@AEBVbtVector3@@0@Z";
    FromCE :: (c: btVector3, e: btVector3) -> btDbvtAabbMm #no_context {
        return FromCE(*c, *e);
    }

    //
    FromCR :: (c: *btVector3, r: btScalar) -> btDbvtAabbMm #cpp_return_type_is_non_pod #foreign bullet3 "?FromCR@btDbvtAabbMm@@SA?AU1@AEBVbtVector3@@M@Z";
    FromCR :: (c: btVector3, r: btScalar) -> btDbvtAabbMm #no_context {
        return FromCR(*c, r);
    }

    //
    FromMM :: (mi: *btVector3, mx: *btVector3) -> btDbvtAabbMm #cpp_return_type_is_non_pod #foreign bullet3 "?FromMM@btDbvtAabbMm@@SA?AU1@AEBVbtVector3@@0@Z";
    FromMM :: (mi: btVector3, mx: btVector3) -> btDbvtAabbMm #no_context {
        return FromMM(*mi, *mx);
    }

    //
    FromPoints :: (pts: *btVector3, n: s32) -> btDbvtAabbMm #cpp_return_type_is_non_pod #foreign bullet3 "?FromPoints@btDbvtAabbMm@@SA?AU1@PEBVbtVector3@@H@Z";

    //
    FromPoints :: (ppts: **btVector3, n: s32) -> btDbvtAabbMm #cpp_return_type_is_non_pod #foreign bullet3 "?FromPoints@btDbvtAabbMm@@SA?AU1@PEAPEBVbtVector3@@H@Z";

    //
    Expand :: (this: *btDbvtAabbMm, e: *btVector3) -> void #cpp_method #foreign bullet3 "?Expand@btDbvtAabbMm@@QEAAXAEBVbtVector3@@@Z";
    Expand :: (this: *btDbvtAabbMm, e: btVector3) #no_context {
        Expand(this, *e);
    }

    //
    SignedExpand :: (this: *btDbvtAabbMm, e: *btVector3) -> void #cpp_method #foreign bullet3 "?SignedExpand@btDbvtAabbMm@@QEAAXAEBVbtVector3@@@Z";
    SignedExpand :: (this: *btDbvtAabbMm, e: btVector3) #no_context {
        SignedExpand(this, *e);
    }

    //
    Contain :: (this: *btDbvtAabbMm, a: *btDbvtAabbMm) -> bool #cpp_method #foreign bullet3 "?Contain@btDbvtAabbMm@@QEBA_NAEBU1@@Z";
    Contain :: (this: *btDbvtAabbMm, a: btDbvtAabbMm) -> bool #no_context {
        return Contain(this, *a);
    }

    //
    Classify :: (this: *btDbvtAabbMm, n: *btVector3, o: btScalar, s: s32) -> s32 #cpp_method #foreign bullet3 "?Classify@btDbvtAabbMm@@QEBAHAEBVbtVector3@@MH@Z";
    Classify :: (this: *btDbvtAabbMm, n: btVector3, o: btScalar, s: s32) -> s32 #no_context {
        return Classify(this, *n, o, s);
    }

    //
    ProjectMinimum :: (this: *btDbvtAabbMm, v: *btVector3, signs: u32) -> btScalar #cpp_method #foreign bullet3 "?ProjectMinimum@btDbvtAabbMm@@QEBAMAEBVbtVector3@@I@Z";
    ProjectMinimum :: (this: *btDbvtAabbMm, v: btVector3, signs: u32) -> btScalar #no_context {
        return ProjectMinimum(this, *v, signs);
    }

    tMins :: (this: *btDbvtAabbMm) -> *btVector3 #cpp_method #foreign bullet3 "?tMins@btDbvtAabbMm@@QEAAAEAVbtVector3@@XZ";
    tMaxs :: (this: *btDbvtAabbMm) -> *btVector3 #cpp_method #foreign bullet3 "?tMaxs@btDbvtAabbMm@@QEAAAEAVbtVector3@@XZ";

    //
    AddSpan :: (this: *btDbvtAabbMm, d: *btVector3, smi: *btScalar, smx: *btScalar) -> void #cpp_method #foreign bullet3 "?AddSpan@btDbvtAabbMm@@AEBAXAEBVbtVector3@@AEAM1@Z";
    AddSpan :: (this: *btDbvtAabbMm, d: btVector3, smi: *btScalar, smx: *btScalar) #no_context {
        AddSpan(this, *d, smi, smx);
    }

    mi: btVector3;
    mx: btVector3;
}

// Types
btDbvtVolume :: btDbvtAabbMm;

/* btDbvtNode				*/
btDbvtNode :: struct {
    volume: btDbvtVolume;
    parent: *btDbvtNode;
    isleaf :: (this: *btDbvtNode) -> bool #cpp_method #foreign bullet3 "?isleaf@btDbvtNode@@QEBA_NXZ";
    isinternal :: (this: *btDbvtNode) -> bool #cpp_method #foreign bullet3 "?isinternal@btDbvtNode@@QEBA_NXZ";
    union {
        childs:    [2] *btDbvtNode;
        data:      *void;
        dataAsInt: s32;
    }
}

/* btDbv(normal)tNode                */
btDbvntNode :: struct {
    volume: btDbvtVolume;
    normal: btVector3;
    angle:  btScalar;
    isleaf :: (this: *btDbvntNode) -> bool #cpp_method #foreign bullet3 "?isleaf@btDbvntNode@@QEBA_NXZ";
    isinternal :: (this: *btDbvntNode) -> bool #cpp_method #foreign bullet3 "?isinternal@btDbvntNode@@QEBA_NXZ";
    childs: [2] *btDbvntNode;
    data:   *void;

    Constructor :: (this: *btDbvntNode, n: *btDbvtNode) -> void #cpp_method #foreign bullet3 "??0btDbvntNode@@QEAA@PEBUbtDbvtNode@@@Z";

    Destructor :: (this: *btDbvntNode) -> void #cpp_method #foreign bullet3 "??1btDbvntNode@@QEAA@XZ";
}

btNodeStack :: btAlignedObjectArray(*btDbvtNode);

//class btOptimizedBvh;
btDbvt :: struct {
    /* Stack element	*/
    sStkNN :: struct {
        a: *btDbvtNode;
        b: *btDbvtNode;
        Constructor :: (this: *sStkNN) -> void #cpp_method #foreign bullet3 "??0sStkNN@btDbvt@@QEAA@XZ";
        Constructor :: (this: *sStkNN, na: *btDbvtNode, nb: *btDbvtNode) -> void #cpp_method #foreign bullet3 "??0sStkNN@btDbvt@@QEAA@PEBUbtDbvtNode@@0@Z";
    }

    sStkNP :: struct {
        node: *btDbvtNode;
        mask: s32;
        Constructor :: (this: *sStkNP, n: *btDbvtNode, m: u32) -> void #cpp_method #foreign bullet3 "??0sStkNP@btDbvt@@QEAA@PEBUbtDbvtNode@@I@Z";
    }

    sStkNPS :: struct {
        node:  *btDbvtNode;
        mask:  s32;
        value: btScalar;
        Constructor :: (this: *sStkNPS) -> void #cpp_method #foreign bullet3 "??0sStkNPS@btDbvt@@QEAA@XZ";
        Constructor :: (this: *sStkNPS, n: *btDbvtNode, m: u32, v: btScalar) -> void #cpp_method #foreign bullet3 "??0sStkNPS@btDbvt@@QEAA@PEBUbtDbvtNode@@IM@Z";
    }

    sStkCLN :: struct {
        node:   *btDbvtNode;
        parent: *btDbvtNode;
        Constructor :: (this: *sStkCLN, n: *btDbvtNode, p: *btDbvtNode) -> void #cpp_method #foreign bullet3 "??0sStkCLN@btDbvt@@QEAA@PEBUbtDbvtNode@@PEAU2@@Z";
    }

    sStknNN :: struct {
        a: *btDbvntNode;
        b: *btDbvntNode;
        Constructor :: (this: *sStknNN) -> void #cpp_method #foreign bullet3 "??0sStknNN@btDbvt@@QEAA@XZ";
        Constructor :: (this: *sStknNN, na: *btDbvntNode, nb: *btDbvntNode) -> void #cpp_method #foreign bullet3 "??0sStknNN@btDbvt@@QEAA@PEBUbtDbvntNode@@0@Z";
    }

    /* ICollide	*/
    ICollide :: struct {
        Process :: (this: *ICollide, unknown0: *btDbvtNode, unknown1: *btDbvtNode) -> void #cpp_method #foreign bullet3 "?Process@ICollide@btDbvt@@QEAAXPEBUbtDbvtNode@@0@Z";
        Process :: (this: *ICollide, unknown0: *btDbvtNode) -> void #cpp_method #foreign bullet3 "?Process@ICollide@btDbvt@@QEAAXPEBUbtDbvtNode@@@Z";
        Process :: (this: *ICollide, n: *btDbvtNode, unknown0: btScalar) -> void #cpp_method #foreign bullet3 "?Process@ICollide@btDbvt@@QEAAXPEBUbtDbvtNode@@M@Z";
        Process :: (this: *ICollide, unknown0: *btDbvntNode, unknown1: *btDbvntNode) -> void #cpp_method #foreign bullet3 "?Process@ICollide@btDbvt@@QEAAXPEBUbtDbvntNode@@0@Z";
        Descent :: (this: *ICollide, unknown0: *btDbvtNode) -> bool #cpp_method #foreign bullet3 "?Descent@ICollide@btDbvt@@QEAA_NPEBUbtDbvtNode@@@Z";
        AllLeaves :: (this: *ICollide, unknown0: *btDbvtNode) -> bool #cpp_method #foreign bullet3 "?AllLeaves@ICollide@btDbvt@@QEAA_NPEBUbtDbvtNode@@@Z";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /* IWriter	*/
    IWriter :: struct {
        vtable: *IWriter_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *IWriter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1IWriter@btDbvt@@UEAA@XZ";
    }
    IWriter_VTable :: struct #type_info_none {
        Destructor: (this: *IWriter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        Prepare: (this: *IWriter, root: *btDbvtNode, numnodes: s32) -> void #cpp_method;
        WriteNode: (this: *IWriter, unknown0: *btDbvtNode, index: s32, parent: s32, child0: s32, child1: s32) -> void #cpp_method;
        WriteLeaf: (this: *IWriter, unknown0: *btDbvtNode, index: s32, parent: s32) -> void #cpp_method;
    }

    IWriter_Destructor :: inline (this: *IWriter, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    IWriter_Prepare :: inline (this: *IWriter, root: *btDbvtNode, numnodes: s32) { this.vtable.Prepare(this, root, numnodes); }
    IWriter_WriteNode :: inline (this: *IWriter, unknown0: *btDbvtNode, index: s32, parent: s32, child0: s32, child1: s32) { this.vtable.WriteNode(this, unknown0, index, parent, child0, child1); }
    IWriter_WriteLeaf :: inline (this: *IWriter, unknown0: *btDbvtNode, index: s32, parent: s32) { this.vtable.WriteLeaf(this, unknown0, index, parent); }



    /* IClone	*/
    IClone :: struct {
        vtable: *IClone_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *IClone, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1IClone@btDbvt@@UEAA@XZ";
        virtual_CloneLeaf :: (this: *IClone, unknown0: *btDbvtNode) -> void #cpp_method #foreign bullet3 "?CloneLeaf@IClone@btDbvt@@UEAAXPEAUbtDbvtNode@@@Z";
    }
    IClone_VTable :: struct #type_info_none {
        Destructor: (this: *IClone, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        CloneLeaf: (this: *IClone, unknown0: *btDbvtNode) -> void #cpp_method;
    }

    IClone_Destructor :: inline (this: *IClone, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    IClone_CloneLeaf :: inline (this: *IClone, unknown0: *btDbvtNode) { this.vtable.CloneLeaf(this, unknown0); }



    // Constants
    anon_enum_1 :: enum s32 {
        SIMPLE_STACKSIZE :: 64;
        DOUBLE_STACKSIZE :: 128;
    }

    // Fields
    m_root:     *btDbvtNode;
    m_free:     *btDbvtNode;
    m_lkhd:     s32;
    m_leaves:   s32;
    m_opath:    u32;

    m_stkStack: btAlignedObjectArray(sStkNN);

    // Methods
    Constructor :: (this: *btDbvt) -> void #cpp_method #foreign bullet3 "??0btDbvt@@QEAA@XZ";
    Destructor :: (this: *btDbvt) -> void #cpp_method #foreign bullet3 "??1btDbvt@@QEAA@XZ";
    clear :: (this: *btDbvt) -> void #cpp_method #foreign bullet3 "?clear@btDbvt@@QEAAXXZ";
    empty :: (this: *btDbvt) -> bool #cpp_method #foreign bullet3 "?empty@btDbvt@@QEBA_NXZ";
    optimizeBottomUp :: (this: *btDbvt) -> void #cpp_method #foreign bullet3 "?optimizeBottomUp@btDbvt@@QEAAXXZ";
    optimizeTopDown :: (this: *btDbvt, bu_treshold: s32 = 128) -> void #cpp_method #foreign bullet3 "?optimizeTopDown@btDbvt@@QEAAXH@Z";
    optimizeIncremental :: (this: *btDbvt, passes: s32) -> void #cpp_method #foreign bullet3 "?optimizeIncremental@btDbvt@@QEAAXH@Z";
    insert :: (this: *btDbvt, box: *btDbvtVolume, data: *void) -> *btDbvtNode #cpp_method #foreign bullet3 "?insert@btDbvt@@QEAAPEAUbtDbvtNode@@AEBUbtDbvtAabbMm@@PEAX@Z";
    insert :: (this: *btDbvt, box: btDbvtVolume, data: *void) -> *btDbvtNode #no_context {
        return insert(this, *box, data);
    }
    update :: (this: *btDbvt, leaf: *btDbvtNode, lookahead: s32 = -1) -> void #cpp_method #foreign bullet3 "?update@btDbvt@@QEAAXPEAUbtDbvtNode@@H@Z";
    update :: (this: *btDbvt, leaf: *btDbvtNode, volume: *btDbvtVolume) -> void #cpp_method #foreign bullet3 "?update@btDbvt@@QEAAXPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@@Z";
    update :: (this: *btDbvt, leaf: *btDbvtNode, volume: *btDbvtVolume, velocity: *btVector3, margin: btScalar) -> bool #cpp_method #foreign bullet3 "?update@btDbvt@@QEAA_NPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@AEBVbtVector3@@M@Z";
    update :: (this: *btDbvt, leaf: *btDbvtNode, volume: *btDbvtVolume, velocity: btVector3, margin: btScalar) -> bool #no_context {
        return update(this, leaf, volume, *velocity, margin);
    }
    update :: (this: *btDbvt, leaf: *btDbvtNode, volume: *btDbvtVolume, velocity: *btVector3) -> bool #cpp_method #foreign bullet3 "?update@btDbvt@@QEAA_NPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@AEBVbtVector3@@@Z";
    update :: (this: *btDbvt, leaf: *btDbvtNode, volume: *btDbvtVolume, velocity: btVector3) -> bool #no_context {
        return update(this, leaf, volume, *velocity);
    }
    update :: (this: *btDbvt, leaf: *btDbvtNode, volume: *btDbvtVolume, margin: btScalar) -> bool #cpp_method #foreign bullet3 "?update@btDbvt@@QEAA_NPEAUbtDbvtNode@@AEAUbtDbvtAabbMm@@M@Z";
    _remove :: (this: *btDbvt, leaf: *btDbvtNode) -> void #cpp_method #foreign bullet3 "?remove@btDbvt@@QEAAXPEAUbtDbvtNode@@@Z";
    write :: (this: *btDbvt, iwriter: *IWriter) -> void #cpp_method #foreign bullet3 "?write@btDbvt@@QEBAXPEAUIWriter@1@@Z";
    clone :: (this: *btDbvt, dest: *btDbvt, iclone: *IClone = null) -> void #cpp_method #foreign bullet3 "?clone@btDbvt@@QEBAXAEAU1@PEAUIClone@1@@Z";
    maxdepth :: (node: *btDbvtNode) -> s32 #foreign bullet3 "?maxdepth@btDbvt@@SAHPEBUbtDbvtNode@@@Z";
    countLeaves :: (node: *btDbvtNode) -> s32 #foreign bullet3 "?countLeaves@btDbvt@@SAHPEBUbtDbvtNode@@@Z";
    extractLeaves :: (node: *btDbvtNode, leaves: *btAlignedObjectArray(*btDbvtNode)) -> void #foreign bullet3 "?extractLeaves@btDbvt@@SAXPEBUbtDbvtNode@@AEAV?$btAlignedObjectArray@PEBUbtDbvtNode@@@@@Z";

    benchmark :: () -> void #foreign bullet3 "?benchmark@btDbvt@@SAXXZ";

    // Helpers
    nearest :: (i: *s32, a: *sStkNPS, v: btScalar, l: s32, h: s32) -> s32 #foreign bullet3 "?nearest@btDbvt@@SAHPEBHPEBUsStkNPS@1@MHH@Z";

    allocate :: (ifree: *btAlignedObjectArray(s32), stock: *btAlignedObjectArray(sStkNPS), value: *sStkNPS) -> s32 #foreign bullet3 "?allocate@btDbvt@@SAHAEAV?$btAlignedObjectArray@H@@AEAV?$btAlignedObjectArray@UsStkNPS@btDbvt@@@@AEBUsStkNPS@1@@Z";
    allocate :: (ifree: *btAlignedObjectArray(s32), stock: *btAlignedObjectArray(sStkNPS), value: sStkNPS) -> s32 #no_context {
        return allocate(ifree, stock, *value);
    }

    //
    CopyConstructor :: (this: *btDbvt, unknown0: *btDbvt) -> void #cpp_method #foreign bullet3 "??0btDbvt@@AEAA@AEBU0@@Z";
    CopyConstructor :: (this: *btDbvt, unknown0: btDbvt) #no_context {
        CopyConstructor(this, *unknown0);
    }
}

//
// btDbvtProxy
//
btDbvtProxy :: struct {
    #as using btbroadphaseproxy: btBroadphaseProxy;

    /* Fields		*/
    //btDbvtAabbMm	aabb;
    leaf:  *btDbvtNode;
    links: [2] *btDbvtProxy;
    stage: s32;

    /* ctor			*/
    Constructor :: (this: *btDbvtProxy, aabbMin: *btVector3, aabbMax: *btVector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> void #cpp_method #foreign bullet3 "??0btDbvtProxy@@QEAA@AEBVbtVector3@@0PEAXHH@Z";
    Constructor :: (this: *btDbvtProxy, aabbMin: btVector3, aabbMax: btVector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) #no_context {
        Constructor(this, *aabbMin, *aabbMax, userPtr, collisionFilterGroup, collisionFilterMask);
    }
}

btDbvtProxyArray :: btAlignedObjectArray(*btDbvtProxy);

///The btDbvtBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see btDbvt).
///One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
///This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases btAxisSweep3 and bt32BitAxisSweep3.
btDbvtBroadphase :: struct {
    #as using btbroadphaseinterface: btBroadphaseInterface;

    /* Config		*/
    anon_enum_2 :: enum s32 {
        DYNAMIC_SET :: 0;
        FIXED_SET   :: 1;
        STAGECOUNT  :: 2;
    }

    m_sets:             [2] btDbvt; // Dbvt sets
    m_stageRoots:       [3] *btDbvtProxy; // Stages list
    m_paircache:        *btOverlappingPairCache; // Pair cache
    m_prediction:       btScalar; // Velocity prediction
    m_stageCurrent:     s32; // Current stage
    m_fupdates:         s32; // % of fixed updates per frame
    m_dupdates:         s32; // % of dynamic updates per frame
    m_cupdates:         s32; // % of cleanup updates per frame
    m_newpairs:         s32; // Number of pairs created
    m_fixedleft:        s32; // Fixed optimization left
    m_updates_call:     u32; // Number of updates call
    m_updates_done:     u32; // Number of updates done
    m_updates_ratio:    btScalar; // m_updates_done/m_updates_call
    m_pid:              s32; // Parse id
    m_cid:              s32; // Cleanup index
    m_gid:              s32; // Gen id
    m_releasepaircache: bool; // Release pair cache on delete
    m_deferedcollide:   bool; // Defere dynamic/static collision to collide call
    m_needcleanup:      bool; // Need to run cleanup?
    m_rayTestStacks:    btAlignedObjectArray(btAlignedObjectArray(*btDbvtNode));

    /* Methods		*/
    Constructor :: (this: *btDbvtBroadphase, paircache: *btOverlappingPairCache = null) -> void #cpp_method #foreign bullet3 "??0btDbvtBroadphase@@QEAA@PEAVbtOverlappingPairCache@@@Z";

    collide :: (this: *btDbvtBroadphase, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?collide@btDbvtBroadphase@@QEAAXPEAVbtDispatcher@@@Z";
    optimize :: (this: *btDbvtBroadphase) -> void #cpp_method #foreign bullet3 "?optimize@btDbvtBroadphase@@QEAAXXZ";

    performDeferredRemoval :: (this: *btDbvtBroadphase, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?performDeferredRemoval@btDbvtBroadphase@@QEAAXPEAVbtDispatcher@@@Z";

    setVelocityPrediction :: (this: *btDbvtBroadphase, prediction: btScalar) -> void #cpp_method #foreign bullet3 "?setVelocityPrediction@btDbvtBroadphase@@QEAAXM@Z";

    getVelocityPrediction :: (this: *btDbvtBroadphase) -> btScalar #cpp_method #foreign bullet3 "?getVelocityPrediction@btDbvtBroadphase@@QEBAMXZ";

    ///this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
    ///it is not part of the btBroadphaseInterface but specific to btDbvtBroadphase.
    ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
    ///http://code.google.com/p/bullet/issues/detail?id=223
    setAabbForceUpdate :: (this: *btDbvtBroadphase, absproxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3, unknown0: *btDispatcher) -> void #cpp_method #foreign bullet3 "?setAabbForceUpdate@btDbvtBroadphase@@QEAAXPEAUbtBroadphaseProxy@@AEBVbtVector3@@1PEAVbtDispatcher@@@Z";
    setAabbForceUpdate :: (this: *btDbvtBroadphase, absproxy: *btBroadphaseProxy, aabbMin: btVector3, aabbMax: btVector3, unknown0: *btDispatcher) #no_context {
        setAabbForceUpdate(this, absproxy, *aabbMin, *aabbMax, unknown0);
    }

    benchmark :: (unknown0: *btBroadphaseInterface) -> void #foreign bullet3 "?benchmark@btDbvtBroadphase@@SAXPEAVbtBroadphaseInterface@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDbvtBroadphase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDbvtBroadphase@@UEAA@XZ";

    /* btBroadphaseInterface Implementation	*/
    virtual_createProxy :: (this: *btDbvtBroadphase, aabbMin: *btVector3, aabbMax: *btVector3, shapeType: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32, dispatcher: *btDispatcher) -> *btBroadphaseProxy #cpp_method #foreign bullet3 "?createProxy@btDbvtBroadphase@@UEAAPEAUbtBroadphaseProxy@@AEBVbtVector3@@0HPEAXHHPEAVbtDispatcher@@@Z";
    virtual_destroyProxy :: (this: *btDbvtBroadphase, proxy: *btBroadphaseProxy, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?destroyProxy@btDbvtBroadphase@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";
    virtual_setAabb :: (this: *btDbvtBroadphase, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?setAabb@btDbvtBroadphase@@UEAAXPEAUbtBroadphaseProxy@@AEBVbtVector3@@1PEAVbtDispatcher@@@Z";
    virtual_rayTest :: (this: *btDbvtBroadphase, rayFrom: *btVector3, rayTo: *btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?rayTest@btDbvtBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseRayCallback@@00@Z";
    rayTest :: (this: *btDbvtBroadphase, rayFrom: btVector3, rayTo: btVector3, rayCallback: *btBroadphaseRayCallback, aabbMin: btVector3 = btVector3.{0, 0, 0}, aabbMax: btVector3 = btVector3.{0, 0, 0}) #no_context {
        rayTest(this, *rayFrom, *rayTo, rayCallback, *aabbMin, *aabbMax);
    }
    virtual_aabbTest :: (this: *btDbvtBroadphase, aabbMin: *btVector3, aabbMax: *btVector3, callback: *btBroadphaseAabbCallback) -> void #cpp_method #foreign bullet3 "?aabbTest@btDbvtBroadphase@@UEAAXAEBVbtVector3@@0AEAUbtBroadphaseAabbCallback@@@Z";

    virtual_getAabb :: (this: *btDbvtBroadphase, proxy: *btBroadphaseProxy, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btDbvtBroadphase@@UEBAXPEAUbtBroadphaseProxy@@AEAVbtVector3@@1@Z";
    virtual_calculateOverlappingPairs :: (this: *btDbvtBroadphase, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?calculateOverlappingPairs@btDbvtBroadphase@@UEAAXPEAVbtDispatcher@@@Z";
    virtual_getOverlappingPairCache :: (this: *btDbvtBroadphase) -> *btOverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@btDbvtBroadphase@@UEAAPEAVbtOverlappingPairCache@@XZ";
    virtual_getOverlappingPairCache_1 :: (this: /*const*/ *btDbvtBroadphase) -> *btOverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@btDbvtBroadphase@@UEBAPEBVbtOverlappingPairCache@@XZ";
    virtual_getBroadphaseAabb :: (this: *btDbvtBroadphase, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getBroadphaseAabb@btDbvtBroadphase@@UEBAXAEAVbtVector3@@0@Z";
    virtual_printStats :: (this: *btDbvtBroadphase) -> void #cpp_method #foreign bullet3 "?printStats@btDbvtBroadphase@@UEAAXXZ";

    ///reset broadphase internal structures, to ensure determinism/reproducability
    virtual_resetPool :: (this: *btDbvtBroadphase, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?resetPool@btDbvtBroadphase@@UEAAXPEAVbtDispatcher@@@Z";
}

/// The internal templace class btAxisSweep3Internal implements the sweep and prune broadphase.
/// It uses quantized integers to represent the begin and end points for each of the 3 axis.
/// Dont use this class directly, use btAxisSweep3 or bt32BitAxisSweep3 instead.
btAxisSweep3Internal :: struct(BP_FP_INT_TYPE: Type) {
    #as btbroadphaseinterface: btBroadphaseInterface; // jai: no "using" to avoid name-clashes

    m_bpHandleMask:       BP_FP_INT_TYPE;
    m_handleSentinel:     BP_FP_INT_TYPE;

    Edge :: struct {
        m_pos:    BP_FP_INT_TYPE; // low bit is min/max
        m_handle: BP_FP_INT_TYPE;
    }

    Handle :: struct {
        #as using btbroadphaseproxy: btBroadphaseProxy;

        m_minEdges:  [3] BP_FP_INT_TYPE; // 6 * 2 = 12
        m_maxEdges:  [3] BP_FP_INT_TYPE; // 6 * 2 = 12

        m_dbvtProxy: *btBroadphaseProxy; //for faster raycast
    }

    m_worldAabbMin:       btVector3; // overall system bounds
    m_worldAabbMax:       btVector3; // overall system bounds

    m_quantize:           btVector3; // scaling factor for quantization

    m_numHandles:         BP_FP_INT_TYPE; // number of active handles
    m_maxHandles:         BP_FP_INT_TYPE; // max number of handles
    m_pHandles:           *Handle; // handles pool

    m_firstFreeHandle:    BP_FP_INT_TYPE; // free handles list

    m_pEdges:             [3] *Edge; // edge arrays for the 3 axes (each array has m_maxHandles * 2 + 2 sentinel entries)
    m_pEdgesRawPtr:       [3] *void;

    m_pairCache:          *btOverlappingPairCache;

    ///btOverlappingPairCallback is an additional optional user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
    m_userPairCallback:   *btOverlappingPairCallback;

    m_ownsPairCache:      bool;

    m_invalidPair:        s32;

    ///additional dynamic aabb structure, used to accelerate ray cast queries.
    ///can be disabled using a optional argument in the constructor
    m_raycastAccelerator: *btDbvtBroadphase;
    m_nullPairCache:      *btOverlappingPairCache;
}

/// The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
/// It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
/// For large worlds and many objects, use bt32BitAxisSweep3 or btDbvtBroadphase instead. bt32BitAxisSweep3 has higher precision and allows more then 16384 objects at the cost of more memory and bit of performance.
btAxisSweep3 :: struct {
    #as using btaxissweep3internal: btAxisSweep3Internal(u16);

    Constructor :: (this: *btAxisSweep3, worldAabbMin: *btVector3, worldAabbMax: *btVector3, maxHandles: u16 = 16384, pairCache: *btOverlappingPairCache = null, disableRaycastAccelerator := false) -> void #cpp_method #foreign bullet3 "??0btAxisSweep3@@QEAA@AEBVbtVector3@@0GPEAVbtOverlappingPairCache@@_N@Z";
    Constructor :: (this: *btAxisSweep3, worldAabbMin: btVector3, worldAabbMax: btVector3, maxHandles: u16 = 16384, pairCache: *btOverlappingPairCache = null, disableRaycastAccelerator := false) #no_context {
        Constructor(this, *worldAabbMin, *worldAabbMax, maxHandles, pairCache, disableRaycastAccelerator);
    }
}

/// The bt32BitAxisSweep3 allows higher precision quantization and more objects compared to the btAxisSweep3 sweep and prune.
/// This comes at the cost of more memory per handle, and a bit slower performance.
/// It uses arrays rather then lists for storage of the 3 axis.
bt32BitAxisSweep3 :: struct {
    #as using btaxissweep3internal: btAxisSweep3Internal(u32);

    Constructor :: (this: *bt32BitAxisSweep3, worldAabbMin: *btVector3, worldAabbMax: *btVector3, maxHandles: u32 = 1500000, pairCache: *btOverlappingPairCache = null, disableRaycastAccelerator := false) -> void #cpp_method #foreign bullet3 "??0bt32BitAxisSweep3@@QEAA@AEBVbtVector3@@0IPEAVbtOverlappingPairCache@@_N@Z";
    Constructor :: (this: *bt32BitAxisSweep3, worldAabbMin: btVector3, worldAabbMax: btVector3, maxHandles: u32 = 1500000, pairCache: *btOverlappingPairCache = null, disableRaycastAccelerator := false) #no_context {
        Constructor(this, *worldAabbMin, *worldAabbMax, maxHandles, pairCache, disableRaycastAccelerator);
    }
}

///The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.
btDefaultMotionState :: struct {
    #as using btmotionstate: btMotionState;

    m_graphicsWorldTrans: btTransform;
    m_centerOfMassOffset: btTransform;
    m_startWorldTrans:    btTransform;
    m_userPointer:        *void;

    Constructor :: (this: *btDefaultMotionState, startTrans: *btTransform, centerOfMassOffset: *btTransform) -> void #cpp_method #foreign bullet3 "??0btDefaultMotionState@@QEAA@AEBVbtTransform@@0@Z";
    Constructor :: (this: *btDefaultMotionState, startTrans: btTransform, centerOfMassOffset: btTransform) #no_context {
        Constructor(this, *startTrans, *centerOfMassOffset);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    ///synchronizes world transform from user to physics
    virtual_getWorldTransform :: (this: *btDefaultMotionState, centerOfMassWorldTrans: *btTransform) -> void #cpp_method #foreign bullet3 "?getWorldTransform@btDefaultMotionState@@UEBAXAEAVbtTransform@@@Z";

    ///synchronizes world transform from physics to user
    ///Bullet only calls the update of worldtransform for active objects
    virtual_setWorldTransform :: (this: *btDefaultMotionState, centerOfMassWorldTrans: *btTransform) -> void #cpp_method #foreign bullet3 "?setWorldTransform@btDefaultMotionState@@UEAAXAEBVbtTransform@@@Z";
}


///The btClock is a portable basic clock that measures accurate time in seconds, use for profiling.
btClock :: struct {
    Constructor :: (this: *btClock) -> void #cpp_method #foreign bullet3 "??0btClock@@QEAA@XZ";

    CopyConstructor :: (this: *btClock, other: *btClock) -> void #cpp_method #foreign bullet3 "??0btClock@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btClock, other: btClock) #no_context {
        CopyConstructor(this, *other);
    }

    Destructor :: (this: *btClock) -> void #cpp_method #foreign bullet3 "??1btClock@@QEAA@XZ";

    /// Resets the initial reference time.
    reset :: (this: *btClock) -> void #cpp_method #foreign bullet3 "?reset@btClock@@QEAAXXZ";

    /// Returns the time in ms since the last call to reset or since
    /// the btClock was created.
    getTimeMilliseconds :: (this: *btClock) -> u64 #cpp_method #foreign bullet3 "?getTimeMilliseconds@btClock@@QEAA_KXZ";

    /// Returns the time in us since the last call to reset or since
    /// the Clock was created.
    getTimeMicroseconds :: (this: *btClock) -> u64 #cpp_method #foreign bullet3 "?getTimeMicroseconds@btClock@@QEAA_KXZ";

    getTimeNanoseconds :: (this: *btClock) -> u64 #cpp_method #foreign bullet3 "?getTimeNanoseconds@btClock@@QEAA_KXZ";

    /// Returns the time in s since the last call to reset or since
    /// the Clock was created.
    getTimeSeconds :: (this: *btClock) -> btScalar #cpp_method #foreign bullet3 "?getTimeSeconds@btClock@@QEAAMXZ";

    btClockData :: struct {}
    m_data: *btClockData;
}

operator_assign :: (this: *btClock, other: *btClock) -> *btClock #cpp_method #foreign bullet3 "??4btClock@@QEAAAEAV0@AEBV0@@Z";
operator_assign :: (this: *btClock, other: btClock) -> *btClock #no_context {
    return operator_assign(this, *other);
}

btEnterProfileZoneFunc :: #type (msg: *u8) -> void #c_call;
btLeaveProfileZoneFunc :: #type () -> void #c_call;

///ProfileSampleClass is a simple way to profile a function's scope
///Use the BT_PROFILE macro at the start of scope to time
CProfileSample :: struct {
    Constructor :: (this: *CProfileSample, name: *u8) -> void #cpp_method #foreign bullet3 "??0CProfileSample@@QEAA@PEBD@Z";

    Destructor :: (this: *CProfileSample) -> void #cpp_method #foreign bullet3 "??1CProfileSample@@QEAA@XZ";
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///The btIDebugDraw interface class allows hooking up a debug renderer to visually debug simulations.
///Typical use case: create a debug drawer object, and assign it to a btCollisionWorld or btDynamicsWorld using setDebugDrawer and call debugDrawWorld.
///A class that implements the btIDebugDraw interface will need to provide non-empty implementations of the the drawLine and getDebugMode methods at a minimum.
///For color arguments the X,Y,Z components refer to Red, Green and Blue each in the range [0..1]
btIDebugDraw :: struct {
    vtable: *btIDebugDraw_VTable;
    DefaultColors :: struct {
        m_activeObject:               btVector3;
        m_deactivatedObject:          btVector3;
        m_wantsDeactivationObject:    btVector3;
        m_disabledDeactivationObject: btVector3;
        m_disabledSimulationObject:   btVector3;
        m_aabb:                       btVector3;
        m_contactPoint:               btVector3;
    }

    DebugDrawModes :: enum s32 {
        NoDebug              :: 0;
        DrawWireframe        :: 1;
        DrawAabb             :: 2;
        DrawFeaturesText     :: 4;
        DrawContactPoints    :: 8;
        NoDeactivation       :: 16;
        NoHelpText           :: 32;
        DrawText             :: 64;
        ProfileTimings       :: 128;
        EnableSatComparison  :: 256;
        DisableBulletLCP     :: 512;
        EnableCCD            :: 1024;
        DrawConstraints      :: 2048;
        DrawConstraintLimits :: 4096;
        FastWireframe        :: 8192;
        DrawNormals          :: 16384;
        DrawFrames           :: 32768;
        MAX_DEBUG_DRAW_MODE  :: 32769;

        DBG_NoDebug              :: NoDebug;
        DBG_DrawWireframe        :: DrawWireframe;
        DBG_DrawAabb             :: DrawAabb;
        DBG_DrawFeaturesText     :: DrawFeaturesText;
        DBG_DrawContactPoints    :: DrawContactPoints;
        DBG_NoDeactivation       :: NoDeactivation;
        DBG_NoHelpText           :: NoHelpText;
        DBG_DrawText             :: DrawText;
        DBG_ProfileTimings       :: ProfileTimings;
        DBG_EnableSatComparison  :: EnableSatComparison;
        DBG_DisableBulletLCP     :: DisableBulletLCP;
        DBG_EnableCCD            :: EnableCCD;
        DBG_DrawConstraints      :: DrawConstraints;
        DBG_DrawConstraintLimits :: DrawConstraintLimits;
        DBG_FastWireframe        :: FastWireframe;
        DBG_DrawNormals          :: DrawNormals;
        DBG_DrawFrames           :: DrawFrames;
        DBG_MAX_DEBUG_DRAW_MODE  :: MAX_DEBUG_DRAW_MODE;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btIDebugDraw, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btIDebugDraw@@UEAA@XZ";

    virtual_getDefaultColors :: (this: *btIDebugDraw) -> DefaultColors #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDefaultColors@btIDebugDraw@@UEBA?AUDefaultColors@1@XZ";

    ///the default implementation for setDefaultColors has no effect. A derived class can implement it and store the colors.
    virtual_setDefaultColors :: (this: *btIDebugDraw, unknown0: *DefaultColors) -> void #cpp_method #foreign bullet3 "?setDefaultColors@btIDebugDraw@@UEAAXAEBUDefaultColors@1@@Z";

    virtual_drawLine :: (this: *btIDebugDraw, from: *btVector3, to: *btVector3, fromColor: *btVector3, toColor: *btVector3) -> void #cpp_method #foreign bullet3 "?drawLine@btIDebugDraw@@UEAAXAEBVbtVector3@@000@Z";

    virtual_drawSphere :: (this: *btIDebugDraw, radius: btScalar, transform: *btTransform, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawSphere@btIDebugDraw@@UEAAXMAEBVbtTransform@@AEBVbtVector3@@@Z";

    virtual_drawSphere :: (this: *btIDebugDraw, p: *btVector3, radius: btScalar, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawSphere@btIDebugDraw@@UEAAXAEBVbtVector3@@M0@Z";

    virtual_drawTriangle :: (this: *btIDebugDraw, v0: *btVector3, v1: *btVector3, v2: *btVector3, unknown0: *btVector3, unknown1: *btVector3, unknown2: *btVector3, color: *btVector3, alpha: btScalar) -> void #cpp_method #foreign bullet3 "?drawTriangle@btIDebugDraw@@UEAAXAEBVbtVector3@@000000M@Z";

    virtual_drawTriangle :: (this: *btIDebugDraw, v0: *btVector3, v1: *btVector3, v2: *btVector3, color: *btVector3, unknown0: btScalar) -> void #cpp_method #foreign bullet3 "?drawTriangle@btIDebugDraw@@UEAAXAEBVbtVector3@@000M@Z";

    virtual_drawAabb :: (this: *btIDebugDraw, from: *btVector3, to: *btVector3, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawAabb@btIDebugDraw@@UEAAXAEBVbtVector3@@00@Z";

    virtual_drawTransform :: (this: *btIDebugDraw, transform: *btTransform, orthoLen: btScalar) -> void #cpp_method #foreign bullet3 "?drawTransform@btIDebugDraw@@UEAAXAEBVbtTransform@@M@Z";

    virtual_drawArc :: (this: *btIDebugDraw, center: *btVector3, normal: *btVector3, axis: *btVector3, radiusA: btScalar, radiusB: btScalar, minAngle: btScalar, maxAngle: btScalar, color: *btVector3, drawSect: bool, stepDegrees: btScalar) -> void #cpp_method #foreign bullet3 "?drawArc@btIDebugDraw@@UEAAXAEBVbtVector3@@00MMMM0_NM@Z";

    virtual_drawSpherePatch :: (this: *btIDebugDraw, center: *btVector3, up: *btVector3, axis: *btVector3, radius: btScalar, minTh: btScalar, maxTh: btScalar, minPs: btScalar, maxPs: btScalar, color: *btVector3, stepDegrees: btScalar, drawCenter := true) -> void #cpp_method #foreign bullet3 "?drawSpherePatch@btIDebugDraw@@UEAAXAEBVbtVector3@@00MMMMM0M_N@Z";

    virtual_drawBox :: (this: *btIDebugDraw, bbMin: *btVector3, bbMax: *btVector3, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawBox@btIDebugDraw@@UEAAXAEBVbtVector3@@00@Z";

    virtual_drawBox :: (this: *btIDebugDraw, bbMin: *btVector3, bbMax: *btVector3, trans: *btTransform, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawBox@btIDebugDraw@@UEAAXAEBVbtVector3@@0AEBVbtTransform@@0@Z";

    virtual_drawCapsule :: (this: *btIDebugDraw, radius: btScalar, halfHeight: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawCapsule@btIDebugDraw@@UEAAXMMHAEBVbtTransform@@AEBVbtVector3@@@Z";

    virtual_drawCylinder :: (this: *btIDebugDraw, radius: btScalar, halfHeight: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawCylinder@btIDebugDraw@@UEAAXMMHAEBVbtTransform@@AEBVbtVector3@@@Z";

    virtual_drawCone :: (this: *btIDebugDraw, radius: btScalar, height: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawCone@btIDebugDraw@@UEAAXMMHAEBVbtTransform@@AEBVbtVector3@@@Z";

    virtual_drawPlane :: (this: *btIDebugDraw, planeNormal: *btVector3, planeConst: btScalar, transform: *btTransform, color: *btVector3) -> void #cpp_method #foreign bullet3 "?drawPlane@btIDebugDraw@@UEAAXAEBVbtVector3@@MAEBVbtTransform@@0@Z";

    virtual_clearLines :: (this: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?clearLines@btIDebugDraw@@UEAAXXZ";

    virtual_flushLines :: (this: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?flushLines@btIDebugDraw@@UEAAXXZ";
}
btIDebugDraw_VTable :: struct #type_info_none {
    Destructor: (this: *btIDebugDraw, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getDefaultColors: (this: *btIDebugDraw) -> btIDebugDraw.DefaultColors #cpp_method #cpp_return_type_is_non_pod;

    setDefaultColors: (this: *btIDebugDraw, unknown0: *btIDebugDraw.DefaultColors) -> void #cpp_method;

    drawLine: (this: *btIDebugDraw, from: *btVector3, to: *btVector3, fromColor: *btVector3, toColor: *btVector3) -> void #cpp_method;

    drawLine_1: (this: *btIDebugDraw, from: /*const reference*/ *btVector3, to: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3) -> void #cpp_method;

    drawSphere: (this: *btIDebugDraw, p: *btVector3, radius: btScalar, color: *btVector3) -> void #cpp_method;

    drawSphere_1: (this: *btIDebugDraw, radius: btScalar, transform: /*const reference*/ *btTransform, color: /*const reference*/ *btVector3) -> void #cpp_method;

    drawTriangle: (this: *btIDebugDraw, v0: *btVector3, v1: *btVector3, v2: *btVector3, color: *btVector3, unknown0: btScalar) -> void #cpp_method;

    drawTriangle_1: (this: *btIDebugDraw, v0: /*const reference*/ *btVector3, v1: /*const reference*/ *btVector3, v2: /*const reference*/ *btVector3, unknown0: /*const reference*/ *btVector3, unknown1: /*const reference*/ *btVector3, unknown2: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3, alpha: btScalar) -> void #cpp_method;

    drawContactPoint: (this: *btIDebugDraw, PointOnB: *btVector3, normalOnB: *btVector3, distance: btScalar, lifeTime: s32, color: *btVector3) -> void #cpp_method;

    reportErrorWarning: (this: *btIDebugDraw, warningString: *u8) -> void #cpp_method;

    draw3dText: (this: *btIDebugDraw, location: *btVector3, textString: *u8) -> void #cpp_method;

    setDebugMode: (this: *btIDebugDraw, debugMode: s32) -> void #cpp_method;

    getDebugMode: (this: *btIDebugDraw) -> s32 #cpp_method;

    drawAabb: (this: *btIDebugDraw, from: *btVector3, to: *btVector3, color: *btVector3) -> void #cpp_method;

    drawTransform: (this: *btIDebugDraw, transform: *btTransform, orthoLen: btScalar) -> void #cpp_method;

    drawArc: (this: *btIDebugDraw, center: *btVector3, normal: *btVector3, axis: *btVector3, radiusA: btScalar, radiusB: btScalar, minAngle: btScalar, maxAngle: btScalar, color: *btVector3, drawSect: bool, stepDegrees: btScalar) -> void #cpp_method;

    drawSpherePatch: (this: *btIDebugDraw, center: *btVector3, up: *btVector3, axis: *btVector3, radius: btScalar, minTh: btScalar, maxTh: btScalar, minPs: btScalar, maxPs: btScalar, color: *btVector3, stepDegrees: btScalar, drawCenter := true) -> void #cpp_method;

    drawBox: (this: *btIDebugDraw, bbMin: *btVector3, bbMax: *btVector3, trans: *btTransform, color: *btVector3) -> void #cpp_method;

    drawBox_1: (this: *btIDebugDraw, bbMin: /*const reference*/ *btVector3, bbMax: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3) -> void #cpp_method;

    drawCapsule: (this: *btIDebugDraw, radius: btScalar, halfHeight: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) -> void #cpp_method;

    drawCylinder: (this: *btIDebugDraw, radius: btScalar, halfHeight: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) -> void #cpp_method;

    drawCone: (this: *btIDebugDraw, radius: btScalar, height: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) -> void #cpp_method;

    drawPlane: (this: *btIDebugDraw, planeNormal: *btVector3, planeConst: btScalar, transform: *btTransform, color: *btVector3) -> void #cpp_method;

    clearLines: (this: *btIDebugDraw) -> void #cpp_method;

    flushLines: (this: *btIDebugDraw) -> void #cpp_method;
}

btIDebugDraw_Destructor :: inline (this: *btIDebugDraw, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btIDebugDraw_getDefaultColors :: inline (this: *btIDebugDraw) -> btIDebugDraw.DefaultColors { return this.vtable.getDefaultColors(this); }

btIDebugDraw_setDefaultColors :: inline (this: *btIDebugDraw, unknown0: *btIDebugDraw.DefaultColors) { this.vtable.setDefaultColors(this, unknown0); }

btIDebugDraw_drawLine :: inline (this: *btIDebugDraw, from: /*const reference*/ *btVector3, to: /*const reference*/ *btVector3, fromColor: /*const reference*/ *btVector3, toColor: /*const reference*/ *btVector3) { this.vtable.drawLine(this, from, to, fromColor, toColor); }

btIDebugDraw_drawLine_1 :: inline (this: *btIDebugDraw, from: /*const reference*/ *btVector3, to: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3) { this.vtable.drawLine_1(this, from, to, color); }

btIDebugDraw_drawSphere :: inline (this: *btIDebugDraw, p: /*const reference*/ *btVector3, radius: btScalar, color: /*const reference*/ *btVector3) { this.vtable.drawSphere(this, p, radius, color); }

btIDebugDraw_drawSphere_1 :: inline (this: *btIDebugDraw, radius: btScalar, transform: /*const reference*/ *btTransform, color: /*const reference*/ *btVector3) { this.vtable.drawSphere_1(this, radius, transform, color); }

btIDebugDraw_drawTriangle :: inline (this: *btIDebugDraw, v0: /*const reference*/ *btVector3, v1: /*const reference*/ *btVector3, v2: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3, unknown0: btScalar) { this.vtable.drawTriangle(this, v0, v1, v2, color, unknown0); }

btIDebugDraw_drawTriangle_1 :: inline (this: *btIDebugDraw, v0: /*const reference*/ *btVector3, v1: /*const reference*/ *btVector3, v2: /*const reference*/ *btVector3, unknown0: /*const reference*/ *btVector3, unknown1: /*const reference*/ *btVector3, unknown2: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3, alpha: btScalar) { this.vtable.drawTriangle_1(this, v0, v1, v2, unknown0, unknown1, unknown2, color, alpha); }

btIDebugDraw_drawContactPoint :: inline (this: *btIDebugDraw, PointOnB: *btVector3, normalOnB: *btVector3, distance: btScalar, lifeTime: s32, color: *btVector3) { this.vtable.drawContactPoint(this, PointOnB, normalOnB, distance, lifeTime, color); }

btIDebugDraw_reportErrorWarning :: inline (this: *btIDebugDraw, warningString: *u8) { this.vtable.reportErrorWarning(this, warningString); }

btIDebugDraw_draw3dText :: inline (this: *btIDebugDraw, location: *btVector3, textString: *u8) { this.vtable.draw3dText(this, location, textString); }

btIDebugDraw_setDebugMode :: inline (this: *btIDebugDraw, debugMode: s32) { this.vtable.setDebugMode(this, debugMode); }

btIDebugDraw_getDebugMode :: inline (this: *btIDebugDraw) -> s32 { return this.vtable.getDebugMode(this); }

btIDebugDraw_drawAabb :: inline (this: *btIDebugDraw, from: *btVector3, to: *btVector3, color: *btVector3) { this.vtable.drawAabb(this, from, to, color); }

btIDebugDraw_drawTransform :: inline (this: *btIDebugDraw, transform: *btTransform, orthoLen: btScalar) { this.vtable.drawTransform(this, transform, orthoLen); }

btIDebugDraw_drawArc :: inline (this: *btIDebugDraw, center: *btVector3, normal: *btVector3, axis: *btVector3, radiusA: btScalar, radiusB: btScalar, minAngle: btScalar, maxAngle: btScalar, color: *btVector3, drawSect: bool, stepDegrees: btScalar) { this.vtable.drawArc(this, center, normal, axis, radiusA, radiusB, minAngle, maxAngle, color, drawSect, stepDegrees); }

btIDebugDraw_drawSpherePatch :: inline (this: *btIDebugDraw, center: *btVector3, up: *btVector3, axis: *btVector3, radius: btScalar, minTh: btScalar, maxTh: btScalar, minPs: btScalar, maxPs: btScalar, color: *btVector3, stepDegrees: btScalar, drawCenter := true) { this.vtable.drawSpherePatch(this, center, up, axis, radius, minTh, maxTh, minPs, maxPs, color, stepDegrees, drawCenter); }

btIDebugDraw_drawBox :: inline (this: *btIDebugDraw, bbMin: /*const reference*/ *btVector3, bbMax: /*const reference*/ *btVector3, trans: /*const reference*/ *btTransform, color: /*const reference*/ *btVector3) { this.vtable.drawBox(this, bbMin, bbMax, trans, color); }

btIDebugDraw_drawBox_1 :: inline (this: *btIDebugDraw, bbMin: /*const reference*/ *btVector3, bbMax: /*const reference*/ *btVector3, color: /*const reference*/ *btVector3) { this.vtable.drawBox_1(this, bbMin, bbMax, color); }

btIDebugDraw_drawCapsule :: inline (this: *btIDebugDraw, radius: btScalar, halfHeight: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) { this.vtable.drawCapsule(this, radius, halfHeight, upAxis, transform, color); }

btIDebugDraw_drawCylinder :: inline (this: *btIDebugDraw, radius: btScalar, halfHeight: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) { this.vtable.drawCylinder(this, radius, halfHeight, upAxis, transform, color); }

btIDebugDraw_drawCone :: inline (this: *btIDebugDraw, radius: btScalar, height: btScalar, upAxis: s32, transform: *btTransform, color: *btVector3) { this.vtable.drawCone(this, radius, height, upAxis, transform, color); }

btIDebugDraw_drawPlane :: inline (this: *btIDebugDraw, planeNormal: *btVector3, planeConst: btScalar, transform: *btTransform, color: *btVector3) { this.vtable.drawPlane(this, planeNormal, planeConst, transform, color); }

btIDebugDraw_clearLines :: inline (this: *btIDebugDraw) { this.vtable.clearLines(this); }

btIDebugDraw_flushLines :: inline (this: *btIDebugDraw) { this.vtable.flushLines(this); }



btSolverMode :: enum s32 {
    RANDMIZE_ORDER                                :: 1;
    FRICTION_SEPARATE                             :: 2;
    USE_WARMSTARTING                              :: 4;
    USE_2_FRICTION_DIRECTIONS                     :: 16;
    ENABLE_FRICTION_DIRECTION_CACHING             :: 32;
    DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION :: 64;
    CACHE_FRIENDLY                                :: 128;
    SIMD                                          :: 256;
    INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS   :: 512;
    ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS         :: 1024;
    DISABLE_IMPLICIT_CONE_FRICTION                :: 2048;
    USE_ARTICULATED_WARMSTARTING                  :: 4096;

    SOLVER_RANDMIZE_ORDER                                :: RANDMIZE_ORDER;
    SOLVER_FRICTION_SEPARATE                             :: FRICTION_SEPARATE;
    SOLVER_USE_WARMSTARTING                              :: USE_WARMSTARTING;
    SOLVER_USE_2_FRICTION_DIRECTIONS                     :: USE_2_FRICTION_DIRECTIONS;
    SOLVER_ENABLE_FRICTION_DIRECTION_CACHING             :: ENABLE_FRICTION_DIRECTION_CACHING;
    SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION :: DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
    SOLVER_CACHE_FRIENDLY                                :: CACHE_FRIENDLY;
    SOLVER_SIMD                                          :: SIMD;
    SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS   :: INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
    SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS         :: ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
    SOLVER_DISABLE_IMPLICIT_CONE_FRICTION                :: DISABLE_IMPLICIT_CONE_FRICTION;
    SOLVER_USE_ARTICULATED_WARMSTARTING                  :: USE_ARTICULATED_WARMSTARTING;
}

btContactSolverInfoData :: struct {
    m_tau:                                btScalar;
    m_damping:                            btScalar; //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
    m_friction:                           btScalar;
    m_timeStep:                           btScalar;
    m_restitution:                        btScalar;
    m_numIterations:                      s32;
    m_maxErrorReduction:                  btScalar;
    m_sor:                                btScalar; //successive over-relaxation term
    m_erp:                                btScalar; //error reduction for non-contact constraints
    m_erp2:                               btScalar; //error reduction for contact constraints
    m_deformable_erp:                     btScalar; //error reduction for deformable constraints
    m_deformable_cfm:                     btScalar; //constraint force mixing for deformable constraints
    m_deformable_maxErrorReduction:       btScalar; // maxErrorReduction for deformable contact
    m_globalCfm:                          btScalar; //constraint force mixing for contacts and non-contacts
    m_frictionERP:                        btScalar; //error reduction for friction constraints
    m_frictionCFM:                        btScalar; //constraint force mixing for friction constraints

    m_splitImpulse:                       s32;
    m_splitImpulsePenetrationThreshold:   btScalar;
    m_splitImpulseTurnErp:                btScalar;
    m_linearSlop:                         btScalar;
    m_warmstartingFactor:                 btScalar;
    m_articulatedWarmstartingFactor:      btScalar;
    m_solverMode:                         s32;
    m_restingContactRestitutionThreshold: s32;
    m_minimumSolverBatchSize:             s32;
    m_maxGyroscopicForce:                 btScalar;
    m_singleAxisRollingFrictionThreshold: btScalar;
    m_leastSquaresResidualThreshold:      btScalar;
    m_restitutionVelocityThreshold:       btScalar;
    m_jointFeedbackInWorldSpace:          bool;
    m_jointFeedbackInJointFrame:          bool;
    m_reportSolverAnalytics:              s32;
    m_numNonContactInnerIterations:       s32;
}

btContactSolverInfo :: struct {
    #as using btcontactsolverinfodata: btContactSolverInfoData;

    Constructor :: (this: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btContactSolverInfo@@QEAA@XZ";
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btContactSolverInfoDoubleData :: struct {
    m_tau:                                float64;
    m_damping:                            float64; //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
    m_friction:                           float64;
    m_timeStep:                           float64;
    m_restitution:                        float64;
    m_maxErrorReduction:                  float64;
    m_sor:                                float64;
    m_erp:                                float64; //used as Baumgarte factor
    m_erp2:                               float64; //used in Split Impulse
    m_globalCfm:                          float64; //constraint force mixing
    m_splitImpulsePenetrationThreshold:   float64;
    m_splitImpulseTurnErp:                float64;
    m_linearSlop:                         float64;
    m_warmstartingFactor:                 float64;
    m_articulatedWarmstartingFactor:      float64;
    m_maxGyroscopicForce:                 float64;
    ///it is only used for 'explicit' version of gyroscopic force
    m_singleAxisRollingFrictionThreshold: float64;

    m_numIterations:                      s32;
    m_solverMode:                         s32;
    m_restingContactRestitutionThreshold: s32;
    m_minimumSolverBatchSize:             s32;
    m_splitImpulse:                       s32;
    m_padding:                            [4] u8;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btContactSolverInfoFloatData :: struct {
    m_tau:                                float;
    m_damping:                            float; //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
    m_friction:                           float;
    m_timeStep:                           float;

    m_restitution:                        float;
    m_maxErrorReduction:                  float;
    m_sor:                                float;
    m_erp:                                float; //used as Baumgarte factor

    m_erp2:                               float; //used in Split Impulse
    m_globalCfm:                          float; //constraint force mixing
    m_splitImpulsePenetrationThreshold:   float;
    m_splitImpulseTurnErp:                float;

    m_linearSlop:                         float;
    m_warmstartingFactor:                 float;
    m_articulatedWarmstartingFactor:      float;
    m_maxGyroscopicForce:                 float;

    m_singleAxisRollingFrictionThreshold: float;
    m_numIterations:                      s32;
    m_solverMode:                         s32;
    m_restingContactRestitutionThreshold: s32;

    m_minimumSolverBatchSize:             s32;
    m_splitImpulse:                       s32;
}

/// Type for the callback for each tick
btInternalTickCallback :: #type (world: *btDynamicsWorld, timeStep: btScalar) -> void #c_call;

btDynamicsWorldType :: enum s32 {
    SIMPLE_DYNAMICS_WORLD               :: 1;
    DISCRETE_DYNAMICS_WORLD             :: 2;
    CONTINUOUS_DYNAMICS_WORLD           :: 3;
    SOFT_RIGID_DYNAMICS_WORLD           :: 4;
    GPU_DYNAMICS_WORLD                  :: 5;
    SOFT_MULTIBODY_DYNAMICS_WORLD       :: 6;
    DEFORMABLE_MULTIBODY_DYNAMICS_WORLD :: 7;

    BT_SIMPLE_DYNAMICS_WORLD               :: SIMPLE_DYNAMICS_WORLD;
    BT_DISCRETE_DYNAMICS_WORLD             :: DISCRETE_DYNAMICS_WORLD;
    BT_CONTINUOUS_DYNAMICS_WORLD           :: CONTINUOUS_DYNAMICS_WORLD;
    BT_SOFT_RIGID_DYNAMICS_WORLD           :: SOFT_RIGID_DYNAMICS_WORLD;
    BT_GPU_DYNAMICS_WORLD                  :: GPU_DYNAMICS_WORLD;
    BT_SOFT_MULTIBODY_DYNAMICS_WORLD       :: SOFT_MULTIBODY_DYNAMICS_WORLD;
    BT_DEFORMABLE_MULTIBODY_DYNAMICS_WORLD :: DEFORMABLE_MULTIBODY_DYNAMICS_WORLD;
}

///The btDynamicsWorld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc.
btDynamicsWorld :: struct {
    #as using btcollisionworld: btCollisionWorld;

    m_internalTickCallback:    btInternalTickCallback;
    m_internalPreTickCallback: btInternalTickCallback;
    m_worldUserInfo:           *void;

    m_solverInfo:              btContactSolverInfo;

    Constructor :: (this: *btDynamicsWorld, dispatcher: *btDispatcher, broadphase: *btBroadphaseInterface, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtCollisionConfiguration@@@Z";

    /// Set the callback for when an internal tick (simulation substep) happens, optional user info
    setInternalTickCallback :: (this: *btDynamicsWorld, cb: btInternalTickCallback, worldUserInfo: *void = null, isPreTick := false) -> void #cpp_method #foreign bullet3 "?setInternalTickCallback@btDynamicsWorld@@QEAAXP6AXPEAV1@M@ZPEAX_N@Z";

    setWorldUserInfo :: (this: *btDynamicsWorld, worldUserInfo: *void) -> void #cpp_method #foreign bullet3 "?setWorldUserInfo@btDynamicsWorld@@QEAAXPEAX@Z";

    getWorldUserInfo :: (this: *btDynamicsWorld) -> *void #cpp_method #foreign bullet3 "?getWorldUserInfo@btDynamicsWorld@@QEBAPEAXXZ";

    getSolverInfo :: (this: *btDynamicsWorld) -> *btContactSolverInfo #cpp_method #foreign bullet3 "?getSolverInfo@btDynamicsWorld@@QEAAAEAUbtContactSolverInfo@@XZ";

    getSolverInfo_1 :: (this: /*const*/ *btDynamicsWorld) -> *btContactSolverInfo #cpp_method #foreign bullet3 "?getSolverInfo@btDynamicsWorld@@QEBAAEBUbtContactSolverInfo@@XZ";
    #place btcollisionworld; btdynamicsworld_vtable: *btDynamicsWorld_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDynamicsWorld@@UEAA@XZ";

    virtual_addConstraint :: (this: *btDynamicsWorld, constraint: *btTypedConstraint, disableCollisionsBetweenLinkedBodies := false) -> void #cpp_method #foreign bullet3 "?addConstraint@btDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@_N@Z";

    virtual_removeConstraint :: (this: *btDynamicsWorld, constraint: *btTypedConstraint) -> void #cpp_method #foreign bullet3 "?removeConstraint@btDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@@Z";

    virtual_getNumConstraints :: (this: *btDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getNumConstraints@btDynamicsWorld@@UEBAHXZ";

    virtual_getConstraint :: (this: *btDynamicsWorld, index: s32) -> *btTypedConstraint #cpp_method #foreign bullet3 "?getConstraint@btDynamicsWorld@@UEAAPEAVbtTypedConstraint@@H@Z";

    virtual_getConstraint_1 :: (this: /*const*/ *btDynamicsWorld, index: s32) -> *btTypedConstraint #cpp_method #foreign bullet3 "?getConstraint@btDynamicsWorld@@UEBAPEBVbtTypedConstraint@@H@Z";

    ///obsolete, use addAction instead.
    virtual_addVehicle :: (this: *btDynamicsWorld, vehicle: *btActionInterface) -> void #cpp_method #foreign bullet3 "?addVehicle@btDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///obsolete, use removeAction instead
    virtual_removeVehicle :: (this: *btDynamicsWorld, vehicle: *btActionInterface) -> void #cpp_method #foreign bullet3 "?removeVehicle@btDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///obsolete, use addAction instead.
    virtual_addCharacter :: (this: *btDynamicsWorld, character: *btActionInterface) -> void #cpp_method #foreign bullet3 "?addCharacter@btDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///obsolete, use removeAction instead
    virtual_removeCharacter :: (this: *btDynamicsWorld, character: *btActionInterface) -> void #cpp_method #foreign bullet3 "?removeCharacter@btDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";
}
btDynamicsWorld_VTable :: struct #type_info_none {
    using btcollisionworld: btCollisionWorld_VTable;
    stepSimulation: (this: *btDynamicsWorld, timeStep: btScalar, maxSubSteps: s32 = 1, fixedTimeStep: btScalar) -> s32 #cpp_method;

    addConstraint: (this: *btDynamicsWorld, constraint: *btTypedConstraint, disableCollisionsBetweenLinkedBodies := false) -> void #cpp_method;

    removeConstraint: (this: *btDynamicsWorld, constraint: *btTypedConstraint) -> void #cpp_method;

    addAction: (this: *btDynamicsWorld, action: *btActionInterface) -> void #cpp_method;

    removeAction: (this: *btDynamicsWorld, action: *btActionInterface) -> void #cpp_method;

    setGravity: (this: *btDynamicsWorld, gravity: *btVector3) -> void #cpp_method;
    getGravity: (this: *btDynamicsWorld) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    synchronizeMotionStates: (this: *btDynamicsWorld) -> void #cpp_method;

    addRigidBody: (this: *btDynamicsWorld, body: *btRigidBody, group: s32, mask: s32) -> void #cpp_method;

    addRigidBody_1: (this: *btDynamicsWorld, body: *btRigidBody) -> void #cpp_method;

    removeRigidBody: (this: *btDynamicsWorld, body: *btRigidBody) -> void #cpp_method;

    setConstraintSolver: (this: *btDynamicsWorld, solver: *btConstraintSolver) -> void #cpp_method;

    getConstraintSolver: (this: *btDynamicsWorld) -> *btConstraintSolver #cpp_method;

    getNumConstraints: (this: *btDynamicsWorld) -> s32 #cpp_method;

    getConstraint_1: (this: /*const*/ *btDynamicsWorld, index: s32) -> *btTypedConstraint #cpp_method;

    getConstraint: (this: *btDynamicsWorld, index: s32) -> *btTypedConstraint #cpp_method;

    getWorldType: (this: *btDynamicsWorld) -> btDynamicsWorldType #cpp_method;

    clearForces: (this: *btDynamicsWorld) -> void #cpp_method;

    addVehicle: (this: *btDynamicsWorld, vehicle: *btActionInterface) -> void #cpp_method;

    removeVehicle: (this: *btDynamicsWorld, vehicle: *btActionInterface) -> void #cpp_method;

    addCharacter: (this: *btDynamicsWorld, character: *btActionInterface) -> void #cpp_method;

    removeCharacter: (this: *btDynamicsWorld, character: *btActionInterface) -> void #cpp_method;
}

btDynamicsWorld_stepSimulation :: inline (this: *btDynamicsWorld, timeStep: btScalar, maxSubSteps: s32 = 1, fixedTimeStep: btScalar) -> s32 { return this.btdynamicsworld_vtable.stepSimulation(this, timeStep, maxSubSteps, fixedTimeStep); }

btDynamicsWorld_addConstraint :: inline (this: *btDynamicsWorld, constraint: *btTypedConstraint, disableCollisionsBetweenLinkedBodies := false) { this.btdynamicsworld_vtable.addConstraint(this, constraint, disableCollisionsBetweenLinkedBodies); }

btDynamicsWorld_removeConstraint :: inline (this: *btDynamicsWorld, constraint: *btTypedConstraint) { this.btdynamicsworld_vtable.removeConstraint(this, constraint); }

btDynamicsWorld_addAction :: inline (this: *btDynamicsWorld, action: *btActionInterface) { this.btdynamicsworld_vtable.addAction(this, action); }

btDynamicsWorld_removeAction :: inline (this: *btDynamicsWorld, action: *btActionInterface) { this.btdynamicsworld_vtable.removeAction(this, action); }

btDynamicsWorld_setGravity :: inline (this: *btDynamicsWorld, gravity: *btVector3) { this.btdynamicsworld_vtable.setGravity(this, gravity); }
btDynamicsWorld_getGravity :: inline (this: *btDynamicsWorld) -> btVector3 { return this.btdynamicsworld_vtable.getGravity(this); }

btDynamicsWorld_synchronizeMotionStates :: inline (this: *btDynamicsWorld) { this.btdynamicsworld_vtable.synchronizeMotionStates(this); }

btDynamicsWorld_addRigidBody :: inline (this: *btDynamicsWorld, body: *btRigidBody, group: s32, mask: s32) { this.btdynamicsworld_vtable.addRigidBody(this, body, group, mask); }

btDynamicsWorld_addRigidBody_1 :: inline (this: *btDynamicsWorld, body: *btRigidBody) { this.btdynamicsworld_vtable.addRigidBody_1(this, body); }

btDynamicsWorld_removeRigidBody :: inline (this: *btDynamicsWorld, body: *btRigidBody) { this.btdynamicsworld_vtable.removeRigidBody(this, body); }

btDynamicsWorld_setConstraintSolver :: inline (this: *btDynamicsWorld, solver: *btConstraintSolver) { this.btdynamicsworld_vtable.setConstraintSolver(this, solver); }

btDynamicsWorld_getConstraintSolver :: inline (this: *btDynamicsWorld) -> *btConstraintSolver { return this.btdynamicsworld_vtable.getConstraintSolver(this); }

btDynamicsWorld_getNumConstraints :: inline (this: *btDynamicsWorld) -> s32 { return this.btdynamicsworld_vtable.getNumConstraints(this); }

btDynamicsWorld_getConstraint_1 :: inline (this: /*const*/ *btDynamicsWorld, index: s32) -> *btTypedConstraint { return this.btdynamicsworld_vtable.getConstraint_1(this, index); }

btDynamicsWorld_getConstraint :: inline (this: *btDynamicsWorld, index: s32) -> *btTypedConstraint { return this.btdynamicsworld_vtable.getConstraint(this, index); }

btDynamicsWorld_getWorldType :: inline (this: *btDynamicsWorld) -> btDynamicsWorldType { return this.btdynamicsworld_vtable.getWorldType(this); }

btDynamicsWorld_clearForces :: inline (this: *btDynamicsWorld) { this.btdynamicsworld_vtable.clearForces(this); }

btDynamicsWorld_addVehicle :: inline (this: *btDynamicsWorld, vehicle: *btActionInterface) { this.btdynamicsworld_vtable.addVehicle(this, vehicle); }

btDynamicsWorld_removeVehicle :: inline (this: *btDynamicsWorld, vehicle: *btActionInterface) { this.btdynamicsworld_vtable.removeVehicle(this, vehicle); }

btDynamicsWorld_addCharacter :: inline (this: *btDynamicsWorld, character: *btActionInterface) { this.btdynamicsworld_vtable.addCharacter(this, character); }

btDynamicsWorld_removeCharacter :: inline (this: *btDynamicsWorld, character: *btActionInterface) { this.btdynamicsworld_vtable.removeCharacter(this, character); }

vtable :: (obj: *btDynamicsWorld) -> *btDynamicsWorld_VTable { return obj.btdynamicsworld_vtable; }


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btDynamicsWorldDoubleData :: struct {
    m_solverInfo: btContactSolverInfoDoubleData;
    m_gravity:    btVector3DoubleData;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btDynamicsWorldFloatData :: struct {
    m_solverInfo: btContactSolverInfoFloatData;
    m_gravity:    btVector3FloatData;
}

InplaceSolverIslandCallback :: struct {}

///
/// btSpinMutex -- lightweight spin-mutex implemented with atomic ops, never puts
///               a thread to sleep because it is designed to be used with a task scheduler
///               which has one thread per core and the threads don't sleep until they
///               run out of tasks. Not good for general purpose use.
///
btSpinMutex :: struct {
    mLock: s32;

    Constructor :: (this: *btSpinMutex) -> void #cpp_method #foreign bullet3 "??0btSpinMutex@@QEAA@XZ";

    lock :: (this: *btSpinMutex) -> void #cpp_method #foreign bullet3 "?lock@btSpinMutex@@QEAAXXZ";
    unlock :: (this: *btSpinMutex) -> void #cpp_method #foreign bullet3 "?unlock@btSpinMutex@@QEAAXXZ";
    tryLock :: (this: *btSpinMutex) -> bool #cpp_method #foreign bullet3 "?tryLock@btSpinMutex@@QEAA_NXZ";
}

//
// btIParallelForBody -- subclass this to express work that can be done in parallel
//
btIParallelForBody :: struct {
    vtable: *btIParallelForBody_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btIParallelForBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btIParallelForBody@@UEAA@XZ";
}
btIParallelForBody_VTable :: struct #type_info_none {
    Destructor: (this: *btIParallelForBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    forLoop: (this: *btIParallelForBody, iBegin: s32, iEnd: s32) -> void #cpp_method;
}

btIParallelForBody_Destructor :: inline (this: *btIParallelForBody, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
btIParallelForBody_forLoop :: inline (this: *btIParallelForBody, iBegin: s32, iEnd: s32) { this.vtable.forLoop(this, iBegin, iEnd); }



//
// btIParallelSumBody -- subclass this to express work that can be done in parallel
//                       and produces a sum over all loop elements
//
btIParallelSumBody :: struct {
    vtable: *btIParallelSumBody_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btIParallelSumBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btIParallelSumBody@@UEAA@XZ";
}
btIParallelSumBody_VTable :: struct #type_info_none {
    Destructor: (this: *btIParallelSumBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    sumLoop: (this: *btIParallelSumBody, iBegin: s32, iEnd: s32) -> btScalar #cpp_method;
}

btIParallelSumBody_Destructor :: inline (this: *btIParallelSumBody, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
btIParallelSumBody_sumLoop :: inline (this: *btIParallelSumBody, iBegin: s32, iEnd: s32) -> btScalar { return this.vtable.sumLoop(this, iBegin, iEnd); }



//
// btITaskScheduler -- subclass this to implement a task scheduler that can dispatch work to
//                     worker threads
//
btITaskScheduler :: struct {
    vtable: *btITaskScheduler_VTable;
    Constructor :: (this: *btITaskScheduler, name: *u8) -> void #cpp_method #foreign bullet3 "??0btITaskScheduler@@QEAA@PEBD@Z";

    getName :: (this: *btITaskScheduler) -> *u8 #cpp_method #foreign bullet3 "?getName@btITaskScheduler@@QEBAPEBDXZ";

    m_name:               *u8;
    m_savedThreadCounter: u32;
    m_isActive:           bool;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btITaskScheduler, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btITaskScheduler@@UEAA@XZ";

    virtual_sleepWorkerThreadsHint :: (this: *btITaskScheduler) -> void #cpp_method #foreign bullet3 "?sleepWorkerThreadsHint@btITaskScheduler@@UEAAXXZ";

    // internal use only
    virtual_activate :: (this: *btITaskScheduler) -> void #cpp_method #foreign bullet3 "?activate@btITaskScheduler@@UEAAXXZ";
    virtual_deactivate :: (this: *btITaskScheduler) -> void #cpp_method #foreign bullet3 "?deactivate@btITaskScheduler@@UEAAXXZ";
}
btITaskScheduler_VTable :: struct #type_info_none {
    Destructor: (this: *btITaskScheduler, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getMaxNumThreads: (this: *btITaskScheduler) -> s32 #cpp_method;
    getNumThreads: (this: *btITaskScheduler) -> s32 #cpp_method;
    setNumThreads: (this: *btITaskScheduler, numThreads: s32) -> void #cpp_method;
    parallelFor: (this: *btITaskScheduler, iBegin: s32, iEnd: s32, grainSize: s32, body: *btIParallelForBody) -> void #cpp_method;
    parallelSum: (this: *btITaskScheduler, iBegin: s32, iEnd: s32, grainSize: s32, body: *btIParallelSumBody) -> btScalar #cpp_method;
    sleepWorkerThreadsHint: (this: *btITaskScheduler) -> void #cpp_method;

    activate: (this: *btITaskScheduler) -> void #cpp_method;
    deactivate: (this: *btITaskScheduler) -> void #cpp_method;
}

btITaskScheduler_Destructor :: inline (this: *btITaskScheduler, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btITaskScheduler_getMaxNumThreads :: inline (this: *btITaskScheduler) -> s32 { return this.vtable.getMaxNumThreads(this); }
btITaskScheduler_getNumThreads :: inline (this: *btITaskScheduler) -> s32 { return this.vtable.getNumThreads(this); }
btITaskScheduler_setNumThreads :: inline (this: *btITaskScheduler, numThreads: s32) { this.vtable.setNumThreads(this, numThreads); }
btITaskScheduler_parallelFor :: inline (this: *btITaskScheduler, iBegin: s32, iEnd: s32, grainSize: s32, body: *btIParallelForBody) { this.vtable.parallelFor(this, iBegin, iEnd, grainSize, body); }
btITaskScheduler_parallelSum :: inline (this: *btITaskScheduler, iBegin: s32, iEnd: s32, grainSize: s32, body: *btIParallelSumBody) -> btScalar { return this.vtable.parallelSum(this, iBegin, iEnd, grainSize, body); }
btITaskScheduler_sleepWorkerThreadsHint :: inline (this: *btITaskScheduler) { this.vtable.sleepWorkerThreadsHint(this); }

btITaskScheduler_activate :: inline (this: *btITaskScheduler) { this.vtable.activate(this); }
btITaskScheduler_deactivate :: inline (this: *btITaskScheduler) { this.vtable.deactivate(this); }



///btDiscreteDynamicsWorld provides discrete rigid body simulation
///those classes replace the obsolete CcdPhysicsEnvironment/CcdPhysicsController
btDiscreteDynamicsWorld :: struct {
    #as using btdynamicsworld: btDynamicsWorld;

    m_sortedConstraints:                  btAlignedObjectArray(*btTypedConstraint);
    m_solverIslandCallback:               *InplaceSolverIslandCallback;

    m_constraintSolver:                   *btConstraintSolver;

    m_islandManager:                      *btSimulationIslandManager;

    m_constraints:                        btAlignedObjectArray(*btTypedConstraint);

    m_nonStaticRigidBodies:               btAlignedObjectArray(*btRigidBody);

    m_gravity:                            btVector3;

    //for variable timesteps
    m_localTime:                          btScalar;
    m_fixedTimeStep:                      btScalar;

    //for variable timesteps
    m_ownsIslandManager:                  bool;
    m_ownsConstraintSolver:               bool;
    m_synchronizeAllMotionStates:         bool;
    m_applySpeculativeContactRestitution: bool;

    m_actions:                            btAlignedObjectArray(*btActionInterface);

    m_profileTimings:                     s32;

    m_latencyMotionStateInterpolation:    bool;

    m_predictiveManifolds:                btAlignedObjectArray(*btPersistentManifold);
    m_predictiveManifoldsMutex:           btSpinMutex; // used to synchronize threads creating predictive contacts

    integrateTransformsInternal :: (this: *btDiscreteDynamicsWorld, bodies: **btRigidBody, numBodies: s32, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateTransformsInternal@btDiscreteDynamicsWorld@@IEAAXPEAPEAVbtRigidBody@@HM@Z";

    updateActions :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateActions@btDiscreteDynamicsWorld@@IEAAXM@Z";

    startProfiling :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?startProfiling@btDiscreteDynamicsWorld@@IEAAXM@Z";

    releasePredictiveContacts :: (this: *btDiscreteDynamicsWorld) -> void #cpp_method #foreign bullet3 "?releasePredictiveContacts@btDiscreteDynamicsWorld@@IEAAXXZ";
    createPredictiveContactsInternal :: (this: *btDiscreteDynamicsWorld, bodies: **btRigidBody, numBodies: s32, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?createPredictiveContactsInternal@btDiscreteDynamicsWorld@@IEAAXPEAPEAVbtRigidBody@@HM@Z";

    serializeRigidBodies :: (this: *btDiscreteDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeRigidBodies@btDiscreteDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z";

    serializeDynamicsWorldInfo :: (this: *btDiscreteDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeDynamicsWorldInfo@btDiscreteDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z";

    ///this btDiscreteDynamicsWorld constructor gets created objects from the user, and will not delete those
    Constructor :: (this: *btDiscreteDynamicsWorld, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, constraintSolver: *btConstraintSolver, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btDiscreteDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@@Z";

    ///this can be useful to synchronize a single rigid body -> graphics object
    synchronizeSingleMotionState :: (this: *btDiscreteDynamicsWorld, body: *btRigidBody) -> void #cpp_method #foreign bullet3 "?synchronizeSingleMotionState@btDiscreteDynamicsWorld@@QEAAXPEAVbtRigidBody@@@Z";

    getSimulationIslandManager :: (this: *btDiscreteDynamicsWorld) -> *btSimulationIslandManager #cpp_method #foreign bullet3 "?getSimulationIslandManager@btDiscreteDynamicsWorld@@QEAAPEAVbtSimulationIslandManager@@XZ";

    getSimulationIslandManager_1 :: (this: /*const*/ *btDiscreteDynamicsWorld) -> *btSimulationIslandManager #cpp_method #foreign bullet3 "?getSimulationIslandManager@btDiscreteDynamicsWorld@@QEBAPEBVbtSimulationIslandManager@@XZ";

    getCollisionWorld :: (this: *btDiscreteDynamicsWorld) -> *btCollisionWorld #cpp_method #foreign bullet3 "?getCollisionWorld@btDiscreteDynamicsWorld@@QEAAPEAVbtCollisionWorld@@XZ";

    setSynchronizeAllMotionStates :: (this: *btDiscreteDynamicsWorld, synchronizeAll: bool) -> void #cpp_method #foreign bullet3 "?setSynchronizeAllMotionStates@btDiscreteDynamicsWorld@@QEAAX_N@Z";

    getSynchronizeAllMotionStates :: (this: *btDiscreteDynamicsWorld) -> bool #cpp_method #foreign bullet3 "?getSynchronizeAllMotionStates@btDiscreteDynamicsWorld@@QEBA_NXZ";

    setApplySpeculativeContactRestitution :: (this: *btDiscreteDynamicsWorld, enable: bool) -> void #cpp_method #foreign bullet3 "?setApplySpeculativeContactRestitution@btDiscreteDynamicsWorld@@QEAAX_N@Z";

    getApplySpeculativeContactRestitution :: (this: *btDiscreteDynamicsWorld) -> bool #cpp_method #foreign bullet3 "?getApplySpeculativeContactRestitution@btDiscreteDynamicsWorld@@QEBA_NXZ";

    ///Interpolate motion state between previous and current transform, instead of current and next transform.
    ///This can relieve discontinuities in the rendering, due to penetrations
    setLatencyMotionStateInterpolation :: (this: *btDiscreteDynamicsWorld, latencyInterpolation: bool) -> void #cpp_method #foreign bullet3 "?setLatencyMotionStateInterpolation@btDiscreteDynamicsWorld@@QEAAX_N@Z";

    getLatencyMotionStateInterpolation :: (this: *btDiscreteDynamicsWorld) -> bool #cpp_method #foreign bullet3 "?getLatencyMotionStateInterpolation@btDiscreteDynamicsWorld@@QEBA_NXZ";

    getNonStaticRigidBodies :: (this: *btDiscreteDynamicsWorld) -> *btAlignedObjectArray(*btRigidBody) #cpp_method #foreign bullet3 "?getNonStaticRigidBodies@btDiscreteDynamicsWorld@@QEAAAEAV?$btAlignedObjectArray@PEAVbtRigidBody@@@@XZ";

    getNonStaticRigidBodies_1 :: (this: /*const*/ *btDiscreteDynamicsWorld) -> *btAlignedObjectArray(*btRigidBody) #cpp_method #foreign bullet3 "?getNonStaticRigidBodies@btDiscreteDynamicsWorld@@QEBAAEBV?$btAlignedObjectArray@PEAVbtRigidBody@@@@XZ";
    #place btdynamicsworld; btdiscretedynamicsworld_vtable: *btDiscreteDynamicsWorld_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_predictUnconstraintMotion :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btDiscreteDynamicsWorld@@MEAAXM@Z";

    virtual_integrateTransforms :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateTransforms@btDiscreteDynamicsWorld@@MEAAXM@Z";

    virtual_calculateSimulationIslands :: (this: *btDiscreteDynamicsWorld) -> void #cpp_method #foreign bullet3 "?calculateSimulationIslands@btDiscreteDynamicsWorld@@MEAAXXZ";

    virtual_updateActivationState :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateActivationState@btDiscreteDynamicsWorld@@MEAAXM@Z";

    virtual_internalSingleStepSimulation :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?internalSingleStepSimulation@btDiscreteDynamicsWorld@@MEAAXM@Z";

    virtual_createPredictiveContacts :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?createPredictiveContacts@btDiscreteDynamicsWorld@@MEAAXM@Z";

    virtual_saveKinematicState :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?saveKinematicState@btDiscreteDynamicsWorld@@MEAAXM@Z";

    virtual_Destructor :: (this: *btDiscreteDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDiscreteDynamicsWorld@@UEAA@XZ";

    ///if maxSubSteps > 0, it will interpolate motion between fixedTimeStep's
    virtual_stepSimulation :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar, maxSubSteps: s32 = 1, fixedTimeStep: btScalar) -> s32 #cpp_method #foreign bullet3 "?stepSimulation@btDiscreteDynamicsWorld@@UEAAHMHM@Z";

    virtual_solveConstraints :: (this: *btDiscreteDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solveConstraints@btDiscreteDynamicsWorld@@UEAAXAEAUbtContactSolverInfo@@@Z";

    virtual_synchronizeMotionStates :: (this: *btDiscreteDynamicsWorld) -> void #cpp_method #foreign bullet3 "?synchronizeMotionStates@btDiscreteDynamicsWorld@@UEAAXXZ";

    virtual_addConstraint :: (this: *btDiscreteDynamicsWorld, constraint: *btTypedConstraint, disableCollisionsBetweenLinkedBodies := false) -> void #cpp_method #foreign bullet3 "?addConstraint@btDiscreteDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@_N@Z";

    virtual_removeConstraint :: (this: *btDiscreteDynamicsWorld, constraint: *btTypedConstraint) -> void #cpp_method #foreign bullet3 "?removeConstraint@btDiscreteDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@@Z";

    virtual_addAction :: (this: *btDiscreteDynamicsWorld, unknown0: *btActionInterface) -> void #cpp_method #foreign bullet3 "?addAction@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    virtual_removeAction :: (this: *btDiscreteDynamicsWorld, unknown0: *btActionInterface) -> void #cpp_method #foreign bullet3 "?removeAction@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    virtual_setGravity :: (this: *btDiscreteDynamicsWorld, gravity: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btDiscreteDynamicsWorld@@UEAAXAEBVbtVector3@@@Z";

    virtual_getGravity :: (this: *btDiscreteDynamicsWorld) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getGravity@btDiscreteDynamicsWorld@@UEBA?AVbtVector3@@XZ";

    virtual_addCollisionObject :: (this: *btDiscreteDynamicsWorld, collisionObject: *btCollisionObject, collisionFilterGroup: s32 = xx CollisionFilterGroups.StaticFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter ^ xx CollisionFilterGroups.StaticFilter) -> void #cpp_method #foreign bullet3 "?addCollisionObject@btDiscreteDynamicsWorld@@UEAAXPEAVbtCollisionObject@@HH@Z";

    virtual_addRigidBody :: (this: *btDiscreteDynamicsWorld, body: *btRigidBody) -> void #cpp_method #foreign bullet3 "?addRigidBody@btDiscreteDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z";

    virtual_addRigidBody :: (this: *btDiscreteDynamicsWorld, body: *btRigidBody, group: s32, mask: s32) -> void #cpp_method #foreign bullet3 "?addRigidBody@btDiscreteDynamicsWorld@@UEAAXPEAVbtRigidBody@@HH@Z";

    virtual_removeRigidBody :: (this: *btDiscreteDynamicsWorld, body: *btRigidBody) -> void #cpp_method #foreign bullet3 "?removeRigidBody@btDiscreteDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z";

    ///removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
    virtual_removeCollisionObject :: (this: *btDiscreteDynamicsWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCollisionObject@btDiscreteDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_debugDrawConstraint :: (this: *btDiscreteDynamicsWorld, constraint: *btTypedConstraint) -> void #cpp_method #foreign bullet3 "?debugDrawConstraint@btDiscreteDynamicsWorld@@UEAAXPEAVbtTypedConstraint@@@Z";

    virtual_debugDrawWorld :: (this: *btDiscreteDynamicsWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btDiscreteDynamicsWorld@@UEAAXXZ";

    virtual_setConstraintSolver :: (this: *btDiscreteDynamicsWorld, solver: *btConstraintSolver) -> void #cpp_method #foreign bullet3 "?setConstraintSolver@btDiscreteDynamicsWorld@@UEAAXPEAVbtConstraintSolver@@@Z";

    virtual_getConstraintSolver :: (this: *btDiscreteDynamicsWorld) -> *btConstraintSolver #cpp_method #foreign bullet3 "?getConstraintSolver@btDiscreteDynamicsWorld@@UEAAPEAVbtConstraintSolver@@XZ";

    virtual_getNumConstraints :: (this: *btDiscreteDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getNumConstraints@btDiscreteDynamicsWorld@@UEBAHXZ";

    virtual_getConstraint :: (this: *btDiscreteDynamicsWorld, index: s32) -> *btTypedConstraint #cpp_method #foreign bullet3 "?getConstraint@btDiscreteDynamicsWorld@@UEAAPEAVbtTypedConstraint@@H@Z";

    virtual_getConstraint_1 :: (this: /*const*/ *btDiscreteDynamicsWorld, index: s32) -> *btTypedConstraint #cpp_method #foreign bullet3 "?getConstraint@btDiscreteDynamicsWorld@@UEBAPEBVbtTypedConstraint@@H@Z";

    virtual_getWorldType :: (this: *btDiscreteDynamicsWorld) -> btDynamicsWorldType #cpp_method #foreign bullet3 "?getWorldType@btDiscreteDynamicsWorld@@UEBA?AW4btDynamicsWorldType@@XZ";

    ///the forces on each rigidbody is accumulating together with gravity. clear this after each timestep.
    virtual_clearForces :: (this: *btDiscreteDynamicsWorld) -> void #cpp_method #foreign bullet3 "?clearForces@btDiscreteDynamicsWorld@@UEAAXXZ";

    ///apply gravity, call this once per timestep
    virtual_applyGravity :: (this: *btDiscreteDynamicsWorld) -> void #cpp_method #foreign bullet3 "?applyGravity@btDiscreteDynamicsWorld@@UEAAXXZ";

    virtual_setNumTasks :: (this: *btDiscreteDynamicsWorld, numTasks: s32) -> void #cpp_method #foreign bullet3 "?setNumTasks@btDiscreteDynamicsWorld@@UEAAXH@Z";

    ///obsolete, use updateActions instead
    virtual_updateVehicles :: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateVehicles@btDiscreteDynamicsWorld@@UEAAXM@Z";

    ///obsolete, use addAction instead
    virtual_addVehicle :: (this: *btDiscreteDynamicsWorld, vehicle: *btActionInterface) -> void #cpp_method #foreign bullet3 "?addVehicle@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///obsolete, use removeAction instead
    virtual_removeVehicle :: (this: *btDiscreteDynamicsWorld, vehicle: *btActionInterface) -> void #cpp_method #foreign bullet3 "?removeVehicle@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///obsolete, use addAction instead
    virtual_addCharacter :: (this: *btDiscreteDynamicsWorld, character: *btActionInterface) -> void #cpp_method #foreign bullet3 "?addCharacter@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///obsolete, use removeAction instead
    virtual_removeCharacter :: (this: *btDiscreteDynamicsWorld, character: *btActionInterface) -> void #cpp_method #foreign bullet3 "?removeCharacter@btDiscreteDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///Preliminary serialization test for Bullet 2.76. Loading those files requires a separate parser (see Bullet/Demos/SerializeDemo)
    virtual_serialize :: (this: *btDiscreteDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serialize@btDiscreteDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z";
}
btDiscreteDynamicsWorld_VTable :: struct #type_info_none {
    using btdynamicsworld: btDynamicsWorld_VTable;
    predictUnconstraintMotion: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;

    integrateTransforms: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;

    calculateSimulationIslands: (this: *btDiscreteDynamicsWorld) -> void #cpp_method;

    updateActivationState: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;

    internalSingleStepSimulation: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;

    createPredictiveContacts: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;

    saveKinematicState: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;

    solveConstraints: (this: *btDiscreteDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method;

    debugDrawConstraint: (this: *btDiscreteDynamicsWorld, constraint: *btTypedConstraint) -> void #cpp_method;

    applyGravity: (this: *btDiscreteDynamicsWorld) -> void #cpp_method;

    setNumTasks: (this: *btDiscreteDynamicsWorld, numTasks: s32) -> void #cpp_method;

    updateVehicles: (this: *btDiscreteDynamicsWorld, timeStep: btScalar) -> void #cpp_method;
}

btDiscreteDynamicsWorld_predictUnconstraintMotion :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.predictUnconstraintMotion(this, timeStep); }

btDiscreteDynamicsWorld_integrateTransforms :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.integrateTransforms(this, timeStep); }

btDiscreteDynamicsWorld_calculateSimulationIslands :: inline (this: *btDiscreteDynamicsWorld) { this.btdiscretedynamicsworld_vtable.calculateSimulationIslands(this); }

btDiscreteDynamicsWorld_updateActivationState :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.updateActivationState(this, timeStep); }

btDiscreteDynamicsWorld_internalSingleStepSimulation :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.internalSingleStepSimulation(this, timeStep); }

btDiscreteDynamicsWorld_createPredictiveContacts :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.createPredictiveContacts(this, timeStep); }

btDiscreteDynamicsWorld_saveKinematicState :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.saveKinematicState(this, timeStep); }

btDiscreteDynamicsWorld_solveConstraints :: inline (this: *btDiscreteDynamicsWorld, solverInfo: *btContactSolverInfo) { this.btdiscretedynamicsworld_vtable.solveConstraints(this, solverInfo); }

btDiscreteDynamicsWorld_debugDrawConstraint :: inline (this: *btDiscreteDynamicsWorld, constraint: *btTypedConstraint) { this.btdiscretedynamicsworld_vtable.debugDrawConstraint(this, constraint); }

btDiscreteDynamicsWorld_applyGravity :: inline (this: *btDiscreteDynamicsWorld) { this.btdiscretedynamicsworld_vtable.applyGravity(this); }

btDiscreteDynamicsWorld_setNumTasks :: inline (this: *btDiscreteDynamicsWorld, numTasks: s32) { this.btdiscretedynamicsworld_vtable.setNumTasks(this, numTasks); }

btDiscreteDynamicsWorld_updateVehicles :: inline (this: *btDiscreteDynamicsWorld, timeStep: btScalar) { this.btdiscretedynamicsworld_vtable.updateVehicles(this, timeStep); }

vtable :: (obj: *btDiscreteDynamicsWorld) -> *btDiscreteDynamicsWorld_VTable { return obj.btdiscretedynamicsworld_vtable; }



///The btSimpleDynamicsWorld serves as unit-test and to verify more complicated and optimized dynamics worlds.
///Please use btDiscreteDynamicsWorld instead
btSimpleDynamicsWorld :: struct {
    #as using btdynamicsworld: btDynamicsWorld;

    m_constraintSolver:     *btConstraintSolver;

    m_ownsConstraintSolver: bool;

    predictUnconstraintMotion :: (this: *btSimpleDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btSimpleDynamicsWorld@@IEAAXM@Z";

    integrateTransforms :: (this: *btSimpleDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateTransforms@btSimpleDynamicsWorld@@IEAAXM@Z";

    m_gravity:              btVector3;

    ///this btSimpleDynamicsWorld constructor creates dispatcher, broadphase pairCache and constraintSolver
    Constructor :: (this: *btSimpleDynamicsWorld, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, constraintSolver: *btConstraintSolver, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btSimpleDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSimpleDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSimpleDynamicsWorld@@UEAA@XZ";

    ///maxSubSteps/fixedTimeStep for interpolation is currently ignored for btSimpleDynamicsWorld, use btDiscreteDynamicsWorld instead
    virtual_stepSimulation :: (this: *btSimpleDynamicsWorld, timeStep: btScalar, maxSubSteps: s32 = 1, fixedTimeStep: btScalar) -> s32 #cpp_method #foreign bullet3 "?stepSimulation@btSimpleDynamicsWorld@@UEAAHMHM@Z";

    virtual_setGravity :: (this: *btSimpleDynamicsWorld, gravity: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btSimpleDynamicsWorld@@UEAAXAEBVbtVector3@@@Z";

    virtual_getGravity :: (this: *btSimpleDynamicsWorld) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getGravity@btSimpleDynamicsWorld@@UEBA?AVbtVector3@@XZ";

    virtual_addRigidBody :: (this: *btSimpleDynamicsWorld, body: *btRigidBody) -> void #cpp_method #foreign bullet3 "?addRigidBody@btSimpleDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z";

    virtual_addRigidBody :: (this: *btSimpleDynamicsWorld, body: *btRigidBody, group: s32, mask: s32) -> void #cpp_method #foreign bullet3 "?addRigidBody@btSimpleDynamicsWorld@@UEAAXPEAVbtRigidBody@@HH@Z";

    virtual_removeRigidBody :: (this: *btSimpleDynamicsWorld, body: *btRigidBody) -> void #cpp_method #foreign bullet3 "?removeRigidBody@btSimpleDynamicsWorld@@UEAAXPEAVbtRigidBody@@@Z";

    virtual_debugDrawWorld :: (this: *btSimpleDynamicsWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btSimpleDynamicsWorld@@UEAAXXZ";

    virtual_addAction :: (this: *btSimpleDynamicsWorld, action: *btActionInterface) -> void #cpp_method #foreign bullet3 "?addAction@btSimpleDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    virtual_removeAction :: (this: *btSimpleDynamicsWorld, action: *btActionInterface) -> void #cpp_method #foreign bullet3 "?removeAction@btSimpleDynamicsWorld@@UEAAXPEAVbtActionInterface@@@Z";

    ///removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btCollisionWorld::removeCollisionObject
    virtual_removeCollisionObject :: (this: *btSimpleDynamicsWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCollisionObject@btSimpleDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_updateAabbs :: (this: *btSimpleDynamicsWorld) -> void #cpp_method #foreign bullet3 "?updateAabbs@btSimpleDynamicsWorld@@UEAAXXZ";

    virtual_synchronizeMotionStates :: (this: *btSimpleDynamicsWorld) -> void #cpp_method #foreign bullet3 "?synchronizeMotionStates@btSimpleDynamicsWorld@@UEAAXXZ";

    virtual_setConstraintSolver :: (this: *btSimpleDynamicsWorld, solver: *btConstraintSolver) -> void #cpp_method #foreign bullet3 "?setConstraintSolver@btSimpleDynamicsWorld@@UEAAXPEAVbtConstraintSolver@@@Z";

    virtual_getConstraintSolver :: (this: *btSimpleDynamicsWorld) -> *btConstraintSolver #cpp_method #foreign bullet3 "?getConstraintSolver@btSimpleDynamicsWorld@@UEAAPEAVbtConstraintSolver@@XZ";

    virtual_getWorldType :: (this: *btSimpleDynamicsWorld) -> btDynamicsWorldType #cpp_method #foreign bullet3 "?getWorldType@btSimpleDynamicsWorld@@UEBA?AW4btDynamicsWorldType@@XZ";

    virtual_clearForces :: (this: *btSimpleDynamicsWorld) -> void #cpp_method #foreign bullet3 "?clearForces@btSimpleDynamicsWorld@@UEAAXXZ";
}

btRigidBodyFlags :: enum s32 {
    DISABLE_WORLD_GRAVITY                  :: 1;

    ENABLE_GYROSCOPIC_FORCE_EXPLICIT       :: 2;
    ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD :: 4;
    ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY  :: 8;
    ENABLE_GYROPSCOPIC_FORCE               :: 8;

    BT_DISABLE_WORLD_GRAVITY                  :: DISABLE_WORLD_GRAVITY;

    BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT       :: ENABLE_GYROSCOPIC_FORCE_EXPLICIT;
    BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD :: ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD;
    BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY  :: ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
    BT_ENABLE_GYROPSCOPIC_FORCE               :: ENABLE_GYROPSCOPIC_FORCE;
}

///The btRigidBody is the main class for rigid body objects. It is derived from btCollisionObject, so it keeps a pointer to a btCollisionShape.
///It is recommended for performance and memory use to share btCollisionShape objects whenever possible.
///There are 3 types of rigid bodies:
///- A) Dynamic rigid bodies, with positive mass. Motion is controlled by rigid body dynamics.
///- B) Fixed objects with zero mass. They are not moving (basically collision objects)
///- C) Kinematic objects, which are objects without mass, but the user can move them. There is one-way interaction, and Bullet calculates a velocity based on the timestep and previous and current world transform.
///Bullet automatically deactivates dynamic rigid bodies, when the velocity is below a threshold for a given time.
///Deactivated (sleeping) rigid bodies don't take any processing time, except a minor broadphase collision detection impact (to allow active objects to activate/wake up sleeping objects)
btRigidBody :: struct {
    #as using btcollisionobject: btCollisionObject;

    m_invInertiaTensorWorld:                btMatrix3x3;
    m_linearVelocity:                       btVector3;
    m_angularVelocity:                      btVector3;
    m_inverseMass:                          btScalar;
    m_linearFactor:                         btVector3;

    m_gravity:                              btVector3;
    m_gravity_acceleration:                 btVector3;
    m_invInertiaLocal:                      btVector3;
    m_totalForce:                           btVector3;
    m_totalTorque:                          btVector3;

    m_linearDamping:                        btScalar;
    m_angularDamping:                       btScalar;

    m_additionalDamping:                    bool;
    m_additionalDampingFactor:              btScalar;
    m_additionalLinearDampingThresholdSqr:  btScalar;
    m_additionalAngularDampingThresholdSqr: btScalar;
    m_additionalAngularDampingFactor:       btScalar;

    m_linearSleepingThreshold:              btScalar;
    m_angularSleepingThreshold:             btScalar;

    //m_optionalMotionState allows to automatic synchronize the world transform for active objects
    m_optionalMotionState:                  *btMotionState;

    //keep track of typed constraints referencing this rigid body, to disable collision between linked bodies
    m_constraintRefs:                       btAlignedObjectArray(*btTypedConstraint);

    m_rigidbodyFlags:                       s32;

    m_debugBodyId:                          s32;

    m_deltaLinearVelocity:                  btVector3;
    m_deltaAngularVelocity:                 btVector3;
    m_angularFactor:                        btVector3;
    m_invMass:                              btVector3;
    m_pushVelocity:                         btVector3;
    m_turnVelocity:                         btVector3;

    ///The btRigidBodyConstructionInfo structure provides information to create a rigid body. Setting mass to zero creates a fixed (non-dynamic) rigid body.
    ///For dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument)
    ///You can use the motion state to synchronize the world transform between physics and graphics objects.
    ///And if the motion state is provided, the rigid body will initialize its initial world transform from the motion state,
    ///m_startWorldTransform is only used when you don't provide a motion state.
    btRigidBodyConstructionInfo :: struct {
        m_mass:                                 btScalar;

        ///When a motionState is provided, the rigid body will initialize its world transform from the motion state
        ///In this case, m_startWorldTransform is ignored.
        m_motionState:                          *btMotionState;
        m_startWorldTransform:                  btTransform;

        m_collisionShape:                       *btCollisionShape;
        m_localInertia:                         btVector3;
        m_linearDamping:                        btScalar;
        m_angularDamping:                       btScalar;

        ///best simulation results when friction is non-zero
        m_friction:                             btScalar;

        ///the m_rollingFriction prevents rounded shapes, such as spheres, cylinders and capsules from rolling forever.
        ///See Bullet/Demos/RollingFrictionDemo for usage
        m_rollingFriction:                      btScalar;
        m_spinningFriction:                     btScalar; //torsional friction around contact normal

        ///best simulation results using zero restitution.
        m_restitution:                          btScalar;

        m_linearSleepingThreshold:              btScalar;
        m_angularSleepingThreshold:             btScalar;

        //Additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc.
        //Such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete
        m_additionalDamping:                    bool;
        m_additionalDampingFactor:              btScalar;
        m_additionalLinearDampingThresholdSqr:  btScalar;
        m_additionalAngularDampingThresholdSqr: btScalar;
        m_additionalAngularDampingFactor:       btScalar;

        Constructor :: (this: *btRigidBodyConstructionInfo, mass: btScalar, motionState: *btMotionState, collisionShape: *btCollisionShape, localInertia: *btVector3) -> void #cpp_method #foreign bullet3 "??0btRigidBodyConstructionInfo@btRigidBody@@QEAA@MPEAVbtMotionState@@PEAVbtCollisionShape@@AEBVbtVector3@@@Z";
        Constructor :: (this: *btRigidBodyConstructionInfo, mass: btScalar, motionState: *btMotionState, collisionShape: *btCollisionShape, localInertia: btVector3 = btVector3.{0, 0, 0}) #no_context {
            Constructor(this, mass, motionState, collisionShape, *localInertia);
        }
    }

    ///btRigidBody constructor using construction info
    Constructor :: (this: *btRigidBody, constructionInfo: *btRigidBodyConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btRigidBody@@QEAA@AEBUbtRigidBodyConstructionInfo@0@@Z";
    Constructor :: (this: *btRigidBody, constructionInfo: btRigidBodyConstructionInfo) #no_context {
        Constructor(this, *constructionInfo);
    }

    ///btRigidBody constructor for backwards compatibility.
    ///To specify friction (etc) during rigid body construction, please use the other constructor (using btRigidBodyConstructionInfo)
    Constructor :: (this: *btRigidBody, mass: btScalar, motionState: *btMotionState, collisionShape: *btCollisionShape, localInertia: *btVector3) -> void #cpp_method #foreign bullet3 "??0btRigidBody@@QEAA@MPEAVbtMotionState@@PEAVbtCollisionShape@@AEBVbtVector3@@@Z";
    Constructor :: (this: *btRigidBody, mass: btScalar, motionState: *btMotionState, collisionShape: *btCollisionShape, localInertia: btVector3 = btVector3.{0, 0, 0}) #no_context {
        Constructor(this, mass, motionState, collisionShape, *localInertia);
    }

    ///setupRigidBody is only used internally by the constructor
    setupRigidBody :: (this: *btRigidBody, constructionInfo: *btRigidBodyConstructionInfo) -> void #cpp_method #foreign bullet3 "?setupRigidBody@btRigidBody@@IEAAXAEBUbtRigidBodyConstructionInfo@1@@Z";
    setupRigidBody :: (this: *btRigidBody, constructionInfo: btRigidBodyConstructionInfo) #no_context {
        setupRigidBody(this, *constructionInfo);
    }

    proceedToTransform :: (this: *btRigidBody, newTrans: *btTransform) -> void #cpp_method #foreign bullet3 "?proceedToTransform@btRigidBody@@QEAAXAEBVbtTransform@@@Z";
    proceedToTransform :: (this: *btRigidBody, newTrans: btTransform) #no_context {
        proceedToTransform(this, *newTrans);
    }

    ///to keep collision detection and dynamics separate we don't store a rigidbody pointer
    ///but a rigidbody is derived from btCollisionObject, so we can safely perform an upcast
    upcast :: (colObj: /*const*/ *btCollisionObject) -> *btRigidBody #foreign bullet3 "?upcast@btRigidBody@@SAPEBV1@PEBVbtCollisionObject@@@Z";

    upcast_1 :: (colObj: *btCollisionObject) -> *btRigidBody #foreign bullet3 "?upcast@btRigidBody@@SAPEAV1@PEAVbtCollisionObject@@@Z";

    /// continuous collision detection needs prediction
    predictIntegratedTransform :: (this: *btRigidBody, step: btScalar, predictedTransform: *btTransform) -> void #cpp_method #foreign bullet3 "?predictIntegratedTransform@btRigidBody@@QEAAXMAEAVbtTransform@@@Z";

    saveKinematicState :: (this: *btRigidBody, step: btScalar) -> void #cpp_method #foreign bullet3 "?saveKinematicState@btRigidBody@@QEAAXM@Z";

    applyGravity :: (this: *btRigidBody) -> void #cpp_method #foreign bullet3 "?applyGravity@btRigidBody@@QEAAXXZ";

    clearGravity :: (this: *btRigidBody) -> void #cpp_method #foreign bullet3 "?clearGravity@btRigidBody@@QEAAXXZ";

    setGravity :: (this: *btRigidBody, acceleration: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setGravity :: (this: *btRigidBody, acceleration: btVector3) #no_context {
        setGravity(this, *acceleration);
    }

    getGravity :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getGravity@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    setDamping :: (this: *btRigidBody, lin_damping: btScalar, ang_damping: btScalar) -> void #cpp_method #foreign bullet3 "?setDamping@btRigidBody@@QEAAXMM@Z";

    getLinearDamping :: (this: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?getLinearDamping@btRigidBody@@QEBAMXZ";

    getAngularDamping :: (this: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?getAngularDamping@btRigidBody@@QEBAMXZ";

    getLinearSleepingThreshold :: (this: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?getLinearSleepingThreshold@btRigidBody@@QEBAMXZ";

    getAngularSleepingThreshold :: (this: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?getAngularSleepingThreshold@btRigidBody@@QEBAMXZ";

    applyDamping :: (this: *btRigidBody, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?applyDamping@btRigidBody@@QEAAXM@Z";

    getCollisionShape :: (this: /*const*/ *btRigidBody) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShape@btRigidBody@@QEBAPEBVbtCollisionShape@@XZ";

    getCollisionShape_1 :: (this: *btRigidBody) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShape@btRigidBody@@QEAAPEAVbtCollisionShape@@XZ";

    setMassProps :: (this: *btRigidBody, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?setMassProps@btRigidBody@@QEAAXMAEBVbtVector3@@@Z";
    setMassProps :: (this: *btRigidBody, mass: btScalar, inertia: btVector3) #no_context {
        setMassProps(this, mass, *inertia);
    }

    getLinearFactor :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getLinearFactor@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    setLinearFactor :: (this: *btRigidBody, linearFactor: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearFactor@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setLinearFactor :: (this: *btRigidBody, linearFactor: btVector3) #no_context {
        setLinearFactor(this, *linearFactor);
    }

    getInvMass :: (this: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?getInvMass@btRigidBody@@QEBAMXZ";
    getMass :: (this: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?getMass@btRigidBody@@QEBAMXZ";
    getInvInertiaTensorWorld :: (this: *btRigidBody) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getInvInertiaTensorWorld@btRigidBody@@QEBAAEBVbtMatrix3x3@@XZ";

    integrateVelocities :: (this: *btRigidBody, step: btScalar) -> void #cpp_method #foreign bullet3 "?integrateVelocities@btRigidBody@@QEAAXM@Z";

    setCenterOfMassTransform :: (this: *btRigidBody, xform: *btTransform) -> void #cpp_method #foreign bullet3 "?setCenterOfMassTransform@btRigidBody@@QEAAXAEBVbtTransform@@@Z";
    setCenterOfMassTransform :: (this: *btRigidBody, xform: btTransform) #no_context {
        setCenterOfMassTransform(this, *xform);
    }

    applyCentralForce :: (this: *btRigidBody, force: *btVector3) -> void #cpp_method #foreign bullet3 "?applyCentralForce@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    applyCentralForce :: (this: *btRigidBody, force: btVector3) #no_context {
        applyCentralForce(this, *force);
    }

    getTotalForce :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getTotalForce@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    getTotalTorque :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getTotalTorque@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    getInvInertiaDiagLocal :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getInvInertiaDiagLocal@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    setInvInertiaDiagLocal :: (this: *btRigidBody, diagInvInertia: *btVector3) -> void #cpp_method #foreign bullet3 "?setInvInertiaDiagLocal@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setInvInertiaDiagLocal :: (this: *btRigidBody, diagInvInertia: btVector3) #no_context {
        setInvInertiaDiagLocal(this, *diagInvInertia);
    }

    setSleepingThresholds :: (this: *btRigidBody, linear: btScalar, angular: btScalar) -> void #cpp_method #foreign bullet3 "?setSleepingThresholds@btRigidBody@@QEAAXMM@Z";

    applyTorque :: (this: *btRigidBody, torque: *btVector3) -> void #cpp_method #foreign bullet3 "?applyTorque@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    applyTorque :: (this: *btRigidBody, torque: btVector3) #no_context {
        applyTorque(this, *torque);
    }

    applyForce :: (this: *btRigidBody, force: *btVector3, rel_pos: *btVector3) -> void #cpp_method #foreign bullet3 "?applyForce@btRigidBody@@QEAAXAEBVbtVector3@@0@Z";
    applyForce :: (this: *btRigidBody, force: btVector3, rel_pos: btVector3) #no_context {
        applyForce(this, *force, *rel_pos);
    }

    applyCentralImpulse :: (this: *btRigidBody, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyCentralImpulse@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    applyCentralImpulse :: (this: *btRigidBody, impulse: btVector3) #no_context {
        applyCentralImpulse(this, *impulse);
    }

    applyTorqueImpulse :: (this: *btRigidBody, torque: *btVector3) -> void #cpp_method #foreign bullet3 "?applyTorqueImpulse@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    applyTorqueImpulse :: (this: *btRigidBody, torque: btVector3) #no_context {
        applyTorqueImpulse(this, *torque);
    }

    applyImpulse :: (this: *btRigidBody, impulse: *btVector3, rel_pos: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btRigidBody@@QEAAXAEBVbtVector3@@0@Z";
    applyImpulse :: (this: *btRigidBody, impulse: btVector3, rel_pos: btVector3) #no_context {
        applyImpulse(this, *impulse, *rel_pos);
    }

    applyPushImpulse :: (this: *btRigidBody, impulse: *btVector3, rel_pos: *btVector3) -> void #cpp_method #foreign bullet3 "?applyPushImpulse@btRigidBody@@QEAAXAEBVbtVector3@@0@Z";
    applyPushImpulse :: (this: *btRigidBody, impulse: btVector3, rel_pos: btVector3) #no_context {
        applyPushImpulse(this, *impulse, *rel_pos);
    }

    getPushVelocity :: (this: *btRigidBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getPushVelocity@btRigidBody@@QEBA?AVbtVector3@@XZ";

    getTurnVelocity :: (this: *btRigidBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getTurnVelocity@btRigidBody@@QEBA?AVbtVector3@@XZ";

    setPushVelocity :: (this: *btRigidBody, v: *btVector3) -> void #cpp_method #foreign bullet3 "?setPushVelocity@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setPushVelocity :: (this: *btRigidBody, v: btVector3) #no_context {
        setPushVelocity(this, *v);
    }

    setTurnVelocity :: (this: *btRigidBody, v: *btVector3) -> void #cpp_method #foreign bullet3 "?setTurnVelocity@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setTurnVelocity :: (this: *btRigidBody, v: btVector3) #no_context {
        setTurnVelocity(this, *v);
    }

    applyCentralPushImpulse :: (this: *btRigidBody, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyCentralPushImpulse@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    applyCentralPushImpulse :: (this: *btRigidBody, impulse: btVector3) #no_context {
        applyCentralPushImpulse(this, *impulse);
    }

    applyTorqueTurnImpulse :: (this: *btRigidBody, torque: *btVector3) -> void #cpp_method #foreign bullet3 "?applyTorqueTurnImpulse@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    applyTorqueTurnImpulse :: (this: *btRigidBody, torque: btVector3) #no_context {
        applyTorqueTurnImpulse(this, *torque);
    }

    clearForces :: (this: *btRigidBody) -> void #cpp_method #foreign bullet3 "?clearForces@btRigidBody@@QEAAXXZ";

    updateInertiaTensor :: (this: *btRigidBody) -> void #cpp_method #foreign bullet3 "?updateInertiaTensor@btRigidBody@@QEAAXXZ";

    getCenterOfMassPosition :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getCenterOfMassPosition@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    getOrientation :: (this: *btRigidBody) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getOrientation@btRigidBody@@QEBA?AVbtQuaternion@@XZ";

    getCenterOfMassTransform :: (this: *btRigidBody) -> *btTransform #cpp_method #foreign bullet3 "?getCenterOfMassTransform@btRigidBody@@QEBAAEBVbtTransform@@XZ";

    getLinearVelocity :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getLinearVelocity@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    getAngularVelocity :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getAngularVelocity@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    setLinearVelocity :: (this: *btRigidBody, lin_vel: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearVelocity@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setLinearVelocity :: (this: *btRigidBody, lin_vel: btVector3) #no_context {
        setLinearVelocity(this, *lin_vel);
    }

    setAngularVelocity :: (this: *btRigidBody, ang_vel: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularVelocity@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setAngularVelocity :: (this: *btRigidBody, ang_vel: btVector3) #no_context {
        setAngularVelocity(this, *ang_vel);
    }

    getVelocityInLocalPoint :: (this: *btRigidBody, rel_pos: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVelocityInLocalPoint@btRigidBody@@QEBA?AVbtVector3@@AEBV2@@Z";
    getVelocityInLocalPoint :: (this: *btRigidBody, rel_pos: btVector3) -> btVector3 #no_context {
        return getVelocityInLocalPoint(this, *rel_pos);
    }

    getPushVelocityInLocalPoint :: (this: *btRigidBody, rel_pos: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getPushVelocityInLocalPoint@btRigidBody@@QEBA?AVbtVector3@@AEBV2@@Z";
    getPushVelocityInLocalPoint :: (this: *btRigidBody, rel_pos: btVector3) -> btVector3 #no_context {
        return getPushVelocityInLocalPoint(this, *rel_pos);
    }

    translate :: (this: *btRigidBody, v: *btVector3) -> void #cpp_method #foreign bullet3 "?translate@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    translate :: (this: *btRigidBody, v: btVector3) #no_context {
        translate(this, *v);
    }

    getAabb :: (this: *btRigidBody, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btRigidBody@@QEBAXAEAVbtVector3@@0@Z";

    computeImpulseDenominator :: (this: *btRigidBody, pos: *btVector3, normal: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?computeImpulseDenominator@btRigidBody@@QEBAMAEBVbtVector3@@0@Z";
    computeImpulseDenominator :: (this: *btRigidBody, pos: btVector3, normal: btVector3) -> btScalar #no_context {
        return computeImpulseDenominator(this, *pos, *normal);
    }

    computeAngularImpulseDenominator :: (this: *btRigidBody, axis: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?computeAngularImpulseDenominator@btRigidBody@@QEBAMAEBVbtVector3@@@Z";
    computeAngularImpulseDenominator :: (this: *btRigidBody, axis: btVector3) -> btScalar #no_context {
        return computeAngularImpulseDenominator(this, *axis);
    }

    updateDeactivation :: (this: *btRigidBody, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateDeactivation@btRigidBody@@QEAAXM@Z";

    wantsSleeping :: (this: *btRigidBody) -> bool #cpp_method #foreign bullet3 "?wantsSleeping@btRigidBody@@QEAA_NXZ";

    getBroadphaseProxy :: (this: /*const*/ *btRigidBody) -> *btBroadphaseProxy #cpp_method #foreign bullet3 "?getBroadphaseProxy@btRigidBody@@QEBAPEBUbtBroadphaseProxy@@XZ";

    getBroadphaseProxy_1 :: (this: *btRigidBody) -> *btBroadphaseProxy #cpp_method #foreign bullet3 "?getBroadphaseProxy@btRigidBody@@QEAAPEAUbtBroadphaseProxy@@XZ";

    setNewBroadphaseProxy :: (this: *btRigidBody, broadphaseProxy: *btBroadphaseProxy) -> void #cpp_method #foreign bullet3 "?setNewBroadphaseProxy@btRigidBody@@QEAAXPEAUbtBroadphaseProxy@@@Z";

    //btMotionState allows to automatic synchronize the world transform for active objects
    getMotionState :: (this: *btRigidBody) -> *btMotionState #cpp_method #foreign bullet3 "?getMotionState@btRigidBody@@QEAAPEAVbtMotionState@@XZ";

    getMotionState_1 :: (this: /*const*/ *btRigidBody) -> *btMotionState #cpp_method #foreign bullet3 "?getMotionState@btRigidBody@@QEBAPEBVbtMotionState@@XZ";

    setMotionState :: (this: *btRigidBody, motionState: *btMotionState) -> void #cpp_method #foreign bullet3 "?setMotionState@btRigidBody@@QEAAXPEAVbtMotionState@@@Z";

    //for experimental overriding of friction/contact solver func
    m_contactSolverType:                    s32;
    m_frictionSolverType:                   s32;

    setAngularFactor :: (this: *btRigidBody, angFac: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularFactor@btRigidBody@@QEAAXAEBVbtVector3@@@Z";
    setAngularFactor :: (this: *btRigidBody, angFac: btVector3) #no_context {
        setAngularFactor(this, *angFac);
    }

    setAngularFactor :: (this: *btRigidBody, angFac: btScalar) -> void #cpp_method #foreign bullet3 "?setAngularFactor@btRigidBody@@QEAAXM@Z";

    getAngularFactor :: (this: *btRigidBody) -> *btVector3 #cpp_method #foreign bullet3 "?getAngularFactor@btRigidBody@@QEBAAEBVbtVector3@@XZ";

    //is this rigidbody added to a btCollisionWorld/btDynamicsWorld/btBroadphase?
    isInWorld :: (this: *btRigidBody) -> bool #cpp_method #foreign bullet3 "?isInWorld@btRigidBody@@QEBA_NXZ";

    addConstraintRef :: (this: *btRigidBody, c: *btTypedConstraint) -> void #cpp_method #foreign bullet3 "?addConstraintRef@btRigidBody@@QEAAXPEAVbtTypedConstraint@@@Z";
    removeConstraintRef :: (this: *btRigidBody, c: *btTypedConstraint) -> void #cpp_method #foreign bullet3 "?removeConstraintRef@btRigidBody@@QEAAXPEAVbtTypedConstraint@@@Z";

    getConstraintRef :: (this: *btRigidBody, index: s32) -> *btTypedConstraint #cpp_method #foreign bullet3 "?getConstraintRef@btRigidBody@@QEAAPEAVbtTypedConstraint@@H@Z";

    getNumConstraintRefs :: (this: *btRigidBody) -> s32 #cpp_method #foreign bullet3 "?getNumConstraintRefs@btRigidBody@@QEBAHXZ";

    setFlags :: (this: *btRigidBody, flags: s32) -> void #cpp_method #foreign bullet3 "?setFlags@btRigidBody@@QEAAXH@Z";

    getFlags :: (this: *btRigidBody) -> s32 #cpp_method #foreign bullet3 "?getFlags@btRigidBody@@QEBAHXZ";

    ///perform implicit force computation in world space
    computeGyroscopicImpulseImplicit_World :: (this: *btRigidBody, dt: btScalar) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?computeGyroscopicImpulseImplicit_World@btRigidBody@@QEBA?AVbtVector3@@M@Z";

    ///perform implicit force computation in body space (inertial frame)
    computeGyroscopicImpulseImplicit_Body :: (this: *btRigidBody, step: btScalar) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?computeGyroscopicImpulseImplicit_Body@btRigidBody@@QEBA?AVbtVector3@@M@Z";

    ///explicit version is best avoided, it gains energy
    computeGyroscopicForceExplicit :: (this: *btRigidBody, maxGyroscopicForce: btScalar) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?computeGyroscopicForceExplicit@btRigidBody@@QEBA?AVbtVector3@@M@Z";
    getLocalInertia :: (this: *btRigidBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getLocalInertia@btRigidBody@@QEBA?AVbtVector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btRigidBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btRigidBody@@UEAA@XZ";

    ///////////////////////////////////////////////
    virtual_calculateSerializeBufferSize :: (this: *btRigidBody) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btRigidBody@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btRigidBody, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btRigidBody@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";

    virtual_serializeSingleObject :: (this: *btRigidBody, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSingleObject@btRigidBody@@UEBAXPEAVbtSerializer@@@Z";
}

//@todo add m_optionalMotionState and m_constraintRefs to btRigidBodyData
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btRigidBodyFloatData :: struct {
    m_collisionObjectData:                  btCollisionObjectFloatData;
    m_invInertiaTensorWorld:                btMatrix3x3FloatData;
    m_linearVelocity:                       btVector3FloatData;
    m_angularVelocity:                      btVector3FloatData;
    m_angularFactor:                        btVector3FloatData;
    m_linearFactor:                         btVector3FloatData;
    m_gravity:                              btVector3FloatData;
    m_gravity_acceleration:                 btVector3FloatData;
    m_invInertiaLocal:                      btVector3FloatData;
    m_totalForce:                           btVector3FloatData;
    m_totalTorque:                          btVector3FloatData;
    m_inverseMass:                          float;
    m_linearDamping:                        float;
    m_angularDamping:                       float;
    m_additionalDampingFactor:              float;
    m_additionalLinearDampingThresholdSqr:  float;
    m_additionalAngularDampingThresholdSqr: float;
    m_additionalAngularDampingFactor:       float;
    m_linearSleepingThreshold:              float;
    m_angularSleepingThreshold:             float;
    m_additionalDamping:                    s32;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btRigidBodyDoubleData :: struct {
    m_collisionObjectData:                  btCollisionObjectDoubleData;
    m_invInertiaTensorWorld:                btMatrix3x3DoubleData;
    m_linearVelocity:                       btVector3DoubleData;
    m_angularVelocity:                      btVector3DoubleData;
    m_angularFactor:                        btVector3DoubleData;
    m_linearFactor:                         btVector3DoubleData;
    m_gravity:                              btVector3DoubleData;
    m_gravity_acceleration:                 btVector3DoubleData;
    m_invInertiaLocal:                      btVector3DoubleData;
    m_totalForce:                           btVector3DoubleData;
    m_totalTorque:                          btVector3DoubleData;
    m_inverseMass:                          float64;
    m_linearDamping:                        float64;
    m_angularDamping:                       float64;
    m_additionalDampingFactor:              float64;
    m_additionalLinearDampingThresholdSqr:  float64;
    m_additionalAngularDampingThresholdSqr: float64;
    m_additionalAngularDampingFactor:       float64;
    m_linearSleepingThreshold:              float64;
    m_angularSleepingThreshold:             float64;
    m_additionalDamping:                    s32;
    m_padding:                              [4] u8;
}

/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
btJacobianEntry :: struct {
    Constructor :: (this: *btJacobianEntry) -> void #cpp_method #foreign bullet3 "??0btJacobianEntry@@QEAA@XZ";

    //constraint between two different rigidbodies
    Constructor :: (this: *btJacobianEntry, world2A: *btMatrix3x3, world2B: *btMatrix3x3, rel_pos1: *btVector3, rel_pos2: *btVector3, jointAxis: *btVector3, inertiaInvA: *btVector3, massInvA: btScalar, inertiaInvB: *btVector3, massInvB: btScalar) -> void #cpp_method #foreign bullet3 "??0btJacobianEntry@@QEAA@AEBVbtMatrix3x3@@0AEBVbtVector3@@111M1M@Z";
    Constructor :: (this: *btJacobianEntry, world2A: btMatrix3x3, world2B: btMatrix3x3, rel_pos1: btVector3, rel_pos2: btVector3, jointAxis: btVector3, inertiaInvA: btVector3, massInvA: btScalar, inertiaInvB: btVector3, massInvB: btScalar) #no_context {
        Constructor(this, *world2A, *world2B, *rel_pos1, *rel_pos2, *jointAxis, *inertiaInvA, massInvA, *inertiaInvB, massInvB);
    }

    //angular constraint between two different rigidbodies
    Constructor :: (this: *btJacobianEntry, jointAxis: *btVector3, world2A: *btMatrix3x3, world2B: *btMatrix3x3, inertiaInvA: *btVector3, inertiaInvB: *btVector3) -> void #cpp_method #foreign bullet3 "??0btJacobianEntry@@QEAA@AEBVbtVector3@@AEBVbtMatrix3x3@@100@Z";
    Constructor :: (this: *btJacobianEntry, jointAxis: btVector3, world2A: btMatrix3x3, world2B: btMatrix3x3, inertiaInvA: btVector3, inertiaInvB: btVector3) #no_context {
        Constructor(this, *jointAxis, *world2A, *world2B, *inertiaInvA, *inertiaInvB);
    }

    //angular constraint between two different rigidbodies
    Constructor :: (this: *btJacobianEntry, axisInA: *btVector3, axisInB: *btVector3, inertiaInvA: *btVector3, inertiaInvB: *btVector3) -> void #cpp_method #foreign bullet3 "??0btJacobianEntry@@QEAA@AEBVbtVector3@@000@Z";
    Constructor :: (this: *btJacobianEntry, axisInA: btVector3, axisInB: btVector3, inertiaInvA: btVector3, inertiaInvB: btVector3) #no_context {
        Constructor(this, *axisInA, *axisInB, *inertiaInvA, *inertiaInvB);
    }

    //constraint on one rigidbody
    Constructor :: (this: *btJacobianEntry, world2A: *btMatrix3x3, rel_pos1: *btVector3, rel_pos2: *btVector3, jointAxis: *btVector3, inertiaInvA: *btVector3, massInvA: btScalar) -> void #cpp_method #foreign bullet3 "??0btJacobianEntry@@QEAA@AEBVbtMatrix3x3@@AEBVbtVector3@@111M@Z";
    Constructor :: (this: *btJacobianEntry, world2A: btMatrix3x3, rel_pos1: btVector3, rel_pos2: btVector3, jointAxis: btVector3, inertiaInvA: btVector3, massInvA: btScalar) #no_context {
        Constructor(this, *world2A, *rel_pos1, *rel_pos2, *jointAxis, *inertiaInvA, massInvA);
    }

    getDiagonal :: (this: *btJacobianEntry) -> btScalar #cpp_method #foreign bullet3 "?getDiagonal@btJacobianEntry@@QEBAMXZ";

    // for two constraints on the same rigidbody (for example vehicle friction)
    getNonDiagonal :: (this: *btJacobianEntry, jacB: *btJacobianEntry, massInvA: btScalar) -> btScalar #cpp_method #foreign bullet3 "?getNonDiagonal@btJacobianEntry@@QEBAMAEBV1@M@Z";
    getNonDiagonal :: (this: *btJacobianEntry, jacB: btJacobianEntry, massInvA: btScalar) -> btScalar #no_context {
        return getNonDiagonal(this, *jacB, massInvA);
    }

    // for two constraints on sharing two same rigidbodies (for example two contact points between two rigidbodies)
    getNonDiagonal :: (this: *btJacobianEntry, jacB: *btJacobianEntry, massInvA: btScalar, massInvB: btScalar) -> btScalar #cpp_method #foreign bullet3 "?getNonDiagonal@btJacobianEntry@@QEBAMAEBV1@MM@Z";
    getNonDiagonal :: (this: *btJacobianEntry, jacB: btJacobianEntry, massInvA: btScalar, massInvB: btScalar) -> btScalar #no_context {
        return getNonDiagonal(this, *jacB, massInvA, massInvB);
    }

    getRelativeVelocity :: (this: *btJacobianEntry, linvelA: *btVector3, angvelA: *btVector3, linvelB: *btVector3, angvelB: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?getRelativeVelocity@btJacobianEntry@@QEAAMAEBVbtVector3@@000@Z";
    getRelativeVelocity :: (this: *btJacobianEntry, linvelA: btVector3, angvelA: btVector3, linvelB: btVector3, angvelB: btVector3) -> btScalar #no_context {
        return getRelativeVelocity(this, *linvelA, *angvelA, *linvelB, *angvelB);
    }

    //private:
    m_linearJointAxis: btVector3;
    m_aJ:              btVector3;
    m_bJ:              btVector3;
    m_0MinvJt:         btVector3;
    m_1MinvJt:         btVector3;

    //Optimization: can be stored in the w/last component of one of the vectors
    m_Adiag:           btScalar;
}

///The btSolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
btSolverBody :: struct {
    m_worldTransform:        btTransform;
    m_deltaLinearVelocity:   btVector3;
    m_deltaAngularVelocity:  btVector3;
    m_angularFactor:         btVector3;
    m_linearFactor:          btVector3;
    m_invMass:               btVector3;
    m_pushVelocity:          btVector3;
    m_turnVelocity:          btVector3;
    m_linearVelocity:        btVector3;
    m_angularVelocity:       btVector3;
    m_externalForceImpulse:  btVector3;
    m_externalTorqueImpulse: btVector3;

    m_originalBody:          *btRigidBody;
    setWorldTransform :: (this: *btSolverBody, worldTransform: *btTransform) -> void #cpp_method #foreign bullet3 "?setWorldTransform@btSolverBody@@QEAAXAEBVbtTransform@@@Z";
    setWorldTransform :: (this: *btSolverBody, worldTransform: btTransform) #no_context {
        setWorldTransform(this, *worldTransform);
    }

    getWorldTransform :: (this: *btSolverBody) -> *btTransform #cpp_method #foreign bullet3 "?getWorldTransform@btSolverBody@@QEBAAEBVbtTransform@@XZ";

    getVelocityInLocalPointNoDelta :: (this: *btSolverBody, rel_pos: *btVector3, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?getVelocityInLocalPointNoDelta@btSolverBody@@QEBAXAEBVbtVector3@@AEAV2@@Z";
    getVelocityInLocalPointNoDelta :: (this: *btSolverBody, rel_pos: btVector3, velocity: *btVector3) #no_context {
        getVelocityInLocalPointNoDelta(this, *rel_pos, velocity);
    }

    getVelocityInLocalPointObsolete :: (this: *btSolverBody, rel_pos: *btVector3, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?getVelocityInLocalPointObsolete@btSolverBody@@QEBAXAEBVbtVector3@@AEAV2@@Z";
    getVelocityInLocalPointObsolete :: (this: *btSolverBody, rel_pos: btVector3, velocity: *btVector3) #no_context {
        getVelocityInLocalPointObsolete(this, *rel_pos, velocity);
    }

    getAngularVelocity :: (this: *btSolverBody, angVel: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularVelocity@btSolverBody@@QEBAXAEAVbtVector3@@@Z";

    //Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
    applyImpulse :: (this: *btSolverBody, linearComponent: *btVector3, angularComponent: *btVector3, impulseMagnitude: btScalar) -> void #cpp_method #foreign bullet3 "?applyImpulse@btSolverBody@@QEAAXAEBVbtVector3@@0M@Z";
    applyImpulse :: (this: *btSolverBody, linearComponent: btVector3, angularComponent: btVector3, impulseMagnitude: btScalar) #no_context {
        applyImpulse(this, *linearComponent, *angularComponent, impulseMagnitude);
    }

    internalApplyPushImpulse :: (this: *btSolverBody, linearComponent: *btVector3, angularComponent: *btVector3, impulseMagnitude: btScalar) -> void #cpp_method #foreign bullet3 "?internalApplyPushImpulse@btSolverBody@@QEAAXAEBVbtVector3@@0M@Z";
    internalApplyPushImpulse :: (this: *btSolverBody, linearComponent: btVector3, angularComponent: btVector3, impulseMagnitude: btScalar) #no_context {
        internalApplyPushImpulse(this, *linearComponent, *angularComponent, impulseMagnitude);
    }

    getDeltaLinearVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?getDeltaLinearVelocity@btSolverBody@@QEBAAEBVbtVector3@@XZ";

    getDeltaAngularVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?getDeltaAngularVelocity@btSolverBody@@QEBAAEBVbtVector3@@XZ";

    getPushVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?getPushVelocity@btSolverBody@@QEBAAEBVbtVector3@@XZ";

    getTurnVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?getTurnVelocity@btSolverBody@@QEBAAEBVbtVector3@@XZ";

    ////////////////////////////////////////////////
    ///some internal methods, don't use them
    internalGetDeltaLinearVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?internalGetDeltaLinearVelocity@btSolverBody@@QEAAAEAVbtVector3@@XZ";

    internalGetDeltaAngularVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?internalGetDeltaAngularVelocity@btSolverBody@@QEAAAEAVbtVector3@@XZ";

    internalGetAngularFactor :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?internalGetAngularFactor@btSolverBody@@QEBAAEBVbtVector3@@XZ";

    internalGetInvMass :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?internalGetInvMass@btSolverBody@@QEBAAEBVbtVector3@@XZ";

    internalSetInvMass :: (this: *btSolverBody, invMass: *btVector3) -> void #cpp_method #foreign bullet3 "?internalSetInvMass@btSolverBody@@QEAAXAEBVbtVector3@@@Z";
    internalSetInvMass :: (this: *btSolverBody, invMass: btVector3) #no_context {
        internalSetInvMass(this, *invMass);
    }

    internalGetPushVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?internalGetPushVelocity@btSolverBody@@QEAAAEAVbtVector3@@XZ";

    internalGetTurnVelocity :: (this: *btSolverBody) -> *btVector3 #cpp_method #foreign bullet3 "?internalGetTurnVelocity@btSolverBody@@QEAAAEAVbtVector3@@XZ";

    internalGetVelocityInLocalPointObsolete :: (this: *btSolverBody, rel_pos: *btVector3, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?internalGetVelocityInLocalPointObsolete@btSolverBody@@QEBAXAEBVbtVector3@@AEAV2@@Z";
    internalGetVelocityInLocalPointObsolete :: (this: *btSolverBody, rel_pos: btVector3, velocity: *btVector3) #no_context {
        internalGetVelocityInLocalPointObsolete(this, *rel_pos, velocity);
    }

    internalGetAngularVelocity :: (this: *btSolverBody, angVel: *btVector3) -> void #cpp_method #foreign bullet3 "?internalGetAngularVelocity@btSolverBody@@QEBAXAEAVbtVector3@@@Z";

    //Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
    internalApplyImpulse :: (this: *btSolverBody, linearComponent: *btVector3, angularComponent: *btVector3, impulseMagnitude: btScalar) -> void #cpp_method #foreign bullet3 "?internalApplyImpulse@btSolverBody@@QEAAXAEBVbtVector3@@0M@Z";
    internalApplyImpulse :: (this: *btSolverBody, linearComponent: btVector3, angularComponent: btVector3, impulseMagnitude: btScalar) #no_context {
        internalApplyImpulse(this, *linearComponent, *angularComponent, impulseMagnitude);
    }

    writebackVelocity :: (this: *btSolverBody) -> void #cpp_method #foreign bullet3 "?writebackVelocity@btSolverBody@@QEAAXXZ";

    writebackVelocityAndTransform :: (this: *btSolverBody, timeStep: btScalar, splitImpulseTurnErp: btScalar) -> void #cpp_method #foreign bullet3 "?writebackVelocityAndTransform@btSolverBody@@QEAAXMM@Z";
}


///1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
btSolverConstraint :: struct {
    m_relpos1CrossNormal:          btVector3;
    m_contactNormal1:              btVector3;

    m_relpos2CrossNormal:          btVector3;
    m_contactNormal2:              btVector3; //usually m_contactNormal2 == -m_contactNormal1, but not always

    m_angularComponentA:           btVector3;
    m_angularComponentB:           btVector3;

    m_appliedPushImpulse:          btScalar;
    m_appliedImpulse:              btScalar;

    m_friction:                    btScalar;
    m_jacDiagABInv:                btScalar;
    m_rhs:                         btScalar;
    m_cfm:                         btScalar;

    m_lowerLimit:                  btScalar;
    m_upperLimit:                  btScalar;
    m_rhsPenetration:              btScalar;
    union {
        m_originalContactPoint:           *void;
        m_unusedPadding4:                 btScalar;
        m_numRowsForNonContactConstraint: s32;
    }

    m_overrideNumSolverIterations: s32;
    m_frictionIndex:               s32;
    m_solverBodyIdA:               s32;
    m_solverBodyIdB:               s32;

    btSolverConstraintType :: enum s32 {
        CONTACT_1D  :: 0;
        FRICTION_1D :: 1;

        BT_SOLVER_CONTACT_1D  :: CONTACT_1D;
        BT_SOLVER_FRICTION_1D :: FRICTION_1D;
    }
}


btConstraintArray :: btAlignedObjectArray(btSolverConstraint);

//Don't change any of the existing enum values, so add enum types at the end for serialization compatibility
btTypedConstraintType :: enum s32 {
    POINT2POINT_CONSTRAINT_TYPE :: 3;
    HINGE_CONSTRAINT_TYPE       :: 4;
    CONETWIST_CONSTRAINT_TYPE   :: 5;
    D6_CONSTRAINT_TYPE          :: 6;
    SLIDER_CONSTRAINT_TYPE      :: 7;
    CONTACT_CONSTRAINT_TYPE     :: 8;
    D6_SPRING_CONSTRAINT_TYPE   :: 9;
    GEAR_CONSTRAINT_TYPE        :: 10;
    FIXED_CONSTRAINT_TYPE       :: 11;
    D6_SPRING_2_CONSTRAINT_TYPE :: 12;
    MAX_CONSTRAINT_TYPE         :: 13;
}

btConstraintParams :: enum s32 {
    ERP      :: 1;
    STOP_ERP :: 2;
    CFM      :: 3;
    STOP_CFM :: 4;

    BT_CONSTRAINT_ERP      :: ERP;
    BT_CONSTRAINT_STOP_ERP :: STOP_ERP;
    BT_CONSTRAINT_CFM      :: CFM;
    BT_CONSTRAINT_STOP_CFM :: STOP_CFM;
}

btJointFeedback :: struct {
    m_appliedForceBodyA:  btVector3;
    m_appliedTorqueBodyA: btVector3;
    m_appliedForceBodyB:  btVector3;
    m_appliedTorqueBodyB: btVector3;
}


///TypedConstraint is the baseclass for Bullet constraints and vehicles
btTypedConstraint :: struct {
    #as using bttypedobject: btTypedObject;
    vtable: *btTypedConstraint_VTable;

    m_userConstraintType:          s32;

    union {
        m_userConstraintId:  s32;
        m_userConstraintPtr: *void;
    }

    m_breakingImpulseThreshold:    btScalar;
    m_isEnabled:                   bool;
    m_needsFeedback:               bool;
    m_overrideNumSolverIterations: s32;

    m_rbA:                         *btRigidBody;
    m_rbB:                         *btRigidBody;
    m_appliedImpulse:              btScalar;
    m_dbgDrawSize:                 btScalar;
    m_jointFeedback:               *btJointFeedback;

    ///internal method used by the constraint solver, don't use them directly
    getMotorFactor :: (this: *btTypedConstraint, pos: btScalar, lowLim: btScalar, uppLim: btScalar, vel: btScalar, timeFact: btScalar) -> btScalar #cpp_method #foreign bullet3 "?getMotorFactor@btTypedConstraint@@IEAAMMMMMM@Z";

    Constructor :: (this: *btTypedConstraint, type: btTypedConstraintType, rbA: *btRigidBody) -> void #cpp_method #foreign bullet3 "??0btTypedConstraint@@QEAA@W4btTypedConstraintType@@AEAVbtRigidBody@@@Z";
    Constructor :: (this: *btTypedConstraint, type: btTypedConstraintType, rbA: *btRigidBody, rbB: *btRigidBody) -> void #cpp_method #foreign bullet3 "??0btTypedConstraint@@QEAA@W4btTypedConstraintType@@AEAVbtRigidBody@@1@Z";

    btConstraintInfo1 :: struct {
        m_numConstraintRows: s32;
        nub:                 s32;
    }

    getFixedBody :: () -> *btRigidBody #foreign bullet3 "?getFixedBody@btTypedConstraint@@SAAEAVbtRigidBody@@XZ";

    btConstraintInfo2 :: struct {
        // integrator parameters: frames per second (1/stepsize), default error
        // reduction parameter (0..1).
        fps:               btScalar;
        // integrator parameters: frames per second (1/stepsize), default error
        // reduction parameter (0..1).
        erp:               btScalar;

        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J1linearAxis:    *btScalar;
        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J1angularAxis:   *btScalar;
        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J2linearAxis:    *btScalar;
        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J2angularAxis:   *btScalar;

        // elements to jump from one row to the next in J's
        rowskip:           s32;

        // right hand sides of the equation J*v = c + cfm * lambda. cfm is the
        // "constraint force mixing" vector. c is set to zero on entry, cfm is
        // set to a constant value (typically very small or zero) value on entry.
        m_constraintError: *btScalar;
        // right hand sides of the equation J*v = c + cfm * lambda. cfm is the
        // "constraint force mixing" vector. c is set to zero on entry, cfm is
        // set to a constant value (typically very small or zero) value on entry.
        cfm:               *btScalar;

        // lo and hi limits for variables (set to -/+ infinity on entry).
        m_lowerLimit:      *btScalar;
        // lo and hi limits for variables (set to -/+ infinity on entry).
        m_upperLimit:      *btScalar;

        // number of solver iterations
        m_numIterations:   s32;

        //damping of the velocity
        m_damping:         btScalar;
    }

    getOverrideNumSolverIterations :: (this: *btTypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getOverrideNumSolverIterations@btTypedConstraint@@QEBAHXZ";

    ///override the number of constraint solver iterations used to solve this constraint
    ///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
    setOverrideNumSolverIterations :: (this: *btTypedConstraint, overideNumIterations: s32) -> void #cpp_method #foreign bullet3 "?setOverrideNumSolverIterations@btTypedConstraint@@QEAAXH@Z";

    ///internal method used by the constraint solver, don't use them directly
    internalSetAppliedImpulse :: (this: *btTypedConstraint, appliedImpulse: btScalar) -> void #cpp_method #foreign bullet3 "?internalSetAppliedImpulse@btTypedConstraint@@QEAAXM@Z";

    ///internal method used by the constraint solver, don't use them directly
    internalGetAppliedImpulse :: (this: *btTypedConstraint) -> btScalar #cpp_method #foreign bullet3 "?internalGetAppliedImpulse@btTypedConstraint@@QEAAMXZ";

    getBreakingImpulseThreshold :: (this: *btTypedConstraint) -> btScalar #cpp_method #foreign bullet3 "?getBreakingImpulseThreshold@btTypedConstraint@@QEBAMXZ";

    setBreakingImpulseThreshold :: (this: *btTypedConstraint, threshold: btScalar) -> void #cpp_method #foreign bullet3 "?setBreakingImpulseThreshold@btTypedConstraint@@QEAAXM@Z";

    isEnabled :: (this: *btTypedConstraint) -> bool #cpp_method #foreign bullet3 "?isEnabled@btTypedConstraint@@QEBA_NXZ";

    setEnabled :: (this: *btTypedConstraint, enabled: bool) -> void #cpp_method #foreign bullet3 "?setEnabled@btTypedConstraint@@QEAAX_N@Z";

    getRigidBodyA :: (this: /*const*/ *btTypedConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyA@btTypedConstraint@@QEBAAEBVbtRigidBody@@XZ";

    getRigidBodyB :: (this: /*const*/ *btTypedConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyB@btTypedConstraint@@QEBAAEBVbtRigidBody@@XZ";

    getRigidBodyA_1 :: (this: *btTypedConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyA@btTypedConstraint@@QEAAAEAVbtRigidBody@@XZ";

    getRigidBodyB_1 :: (this: *btTypedConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyB@btTypedConstraint@@QEAAAEAVbtRigidBody@@XZ";

    getUserConstraintType :: (this: *btTypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getUserConstraintType@btTypedConstraint@@QEBAHXZ";

    setUserConstraintType :: (this: *btTypedConstraint, userConstraintType: s32) -> void #cpp_method #foreign bullet3 "?setUserConstraintType@btTypedConstraint@@QEAAXH@Z";

    setUserConstraintId :: (this: *btTypedConstraint, uid: s32) -> void #cpp_method #foreign bullet3 "?setUserConstraintId@btTypedConstraint@@QEAAXH@Z";

    getUserConstraintId :: (this: *btTypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getUserConstraintId@btTypedConstraint@@QEBAHXZ";

    setUserConstraintPtr :: (this: *btTypedConstraint, ptr: *void) -> void #cpp_method #foreign bullet3 "?setUserConstraintPtr@btTypedConstraint@@QEAAXPEAX@Z";

    getUserConstraintPtr :: (this: *btTypedConstraint) -> *void #cpp_method #foreign bullet3 "?getUserConstraintPtr@btTypedConstraint@@QEAAPEAXXZ";

    setJointFeedback :: (this: *btTypedConstraint, jointFeedback: *btJointFeedback) -> void #cpp_method #foreign bullet3 "?setJointFeedback@btTypedConstraint@@QEAAXPEAUbtJointFeedback@@@Z";

    getJointFeedback :: (this: /*const*/ *btTypedConstraint) -> *btJointFeedback #cpp_method #foreign bullet3 "?getJointFeedback@btTypedConstraint@@QEBAPEBUbtJointFeedback@@XZ";

    getJointFeedback_1 :: (this: *btTypedConstraint) -> *btJointFeedback #cpp_method #foreign bullet3 "?getJointFeedback@btTypedConstraint@@QEAAPEAUbtJointFeedback@@XZ";

    getUid :: (this: *btTypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getUid@btTypedConstraint@@QEBAHXZ";

    needsFeedback :: (this: *btTypedConstraint) -> bool #cpp_method #foreign bullet3 "?needsFeedback@btTypedConstraint@@QEBA_NXZ";

    ///enableFeedback will allow to read the applied linear and angular impulse
    ///use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information
    enableFeedback :: (this: *btTypedConstraint, needsFeedback: bool) -> void #cpp_method #foreign bullet3 "?enableFeedback@btTypedConstraint@@QEAAX_N@Z";

    ///getAppliedImpulse is an estimated total applied impulse.
    ///This feedback could be used to determine breaking constraints or playing sounds.
    getAppliedImpulse :: (this: *btTypedConstraint) -> btScalar #cpp_method #foreign bullet3 "?getAppliedImpulse@btTypedConstraint@@QEBAMXZ";

    getConstraintType :: (this: *btTypedConstraint) -> btTypedConstraintType #cpp_method #foreign bullet3 "?getConstraintType@btTypedConstraint@@QEBA?AW4btTypedConstraintType@@XZ";

    setDbgDrawSize :: (this: *btTypedConstraint, dbgDrawSize: btScalar) -> void #cpp_method #foreign bullet3 "?setDbgDrawSize@btTypedConstraint@@QEAAXM@Z";

    getDbgDrawSize :: (this: *btTypedConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDbgDrawSize@btTypedConstraint@@QEAAMXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btTypedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btTypedConstraint@@UEAA@XZ";

    ///internal method used by the constraint solver, don't use them directly
    virtual_buildJacobian :: (this: *btTypedConstraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btTypedConstraint@@UEAAXXZ";

    ///internal method used by the constraint solver, don't use them directly
    virtual_setupSolverConstraint :: (this: *btTypedConstraint, ca: *btConstraintArray, solverBodyA: s32, solverBodyB: s32, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?setupSolverConstraint@btTypedConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtSolverConstraint@@@@HHM@Z";

    ///internal method used by the constraint solver, don't use them directly
    virtual_solveConstraintObsolete :: (this: *btTypedConstraint, unknown0: *btSolverBody, unknown1: *btSolverBody, unknown2: btScalar) -> void #cpp_method #foreign bullet3 "?solveConstraintObsolete@btTypedConstraint@@UEAAXAEAUbtSolverBody@@0M@Z";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btTypedConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btTypedConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btTypedConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btTypedConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btTypedConstraint_VTable :: struct #type_info_none {
    Destructor: (this: *btTypedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    buildJacobian: (this: *btTypedConstraint) -> void #cpp_method;

    setupSolverConstraint: (this: *btTypedConstraint, ca: *btConstraintArray, solverBodyA: s32, solverBodyB: s32, timeStep: btScalar) -> void #cpp_method;

    getInfo1: (this: *btTypedConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method;

    getInfo2: (this: *btTypedConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method;

    solveConstraintObsolete: (this: *btTypedConstraint, unknown0: *btSolverBody, unknown1: *btSolverBody, unknown2: btScalar) -> void #cpp_method;

    setParam: (this: *btTypedConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method;

    getParam: (this: *btTypedConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method;

    calculateSerializeBufferSize: (this: *btTypedConstraint) -> s32 #cpp_method;

    serialize: (this: *btTypedConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;
}

btTypedConstraint_Destructor :: inline (this: *btTypedConstraint, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btTypedConstraint_buildJacobian :: inline (this: *btTypedConstraint) { this.vtable.buildJacobian(this); }

btTypedConstraint_setupSolverConstraint :: inline (this: *btTypedConstraint, ca: *btConstraintArray, solverBodyA: s32, solverBodyB: s32, timeStep: btScalar) { this.vtable.setupSolverConstraint(this, ca, solverBodyA, solverBodyB, timeStep); }

btTypedConstraint_getInfo1 :: inline (this: *btTypedConstraint, info: *btTypedConstraint.btConstraintInfo1) { this.vtable.getInfo1(this, info); }

btTypedConstraint_getInfo2 :: inline (this: *btTypedConstraint, info: *btTypedConstraint.btConstraintInfo2) { this.vtable.getInfo2(this, info); }

btTypedConstraint_solveConstraintObsolete :: inline (this: *btTypedConstraint, unknown0: *btSolverBody, unknown1: *btSolverBody, unknown2: btScalar) { this.vtable.solveConstraintObsolete(this, unknown0, unknown1, unknown2); }

btTypedConstraint_setParam :: inline (this: *btTypedConstraint, num: s32, value: btScalar, axis: s32 = -1) { this.vtable.setParam(this, num, value, axis); }

btTypedConstraint_getParam :: inline (this: *btTypedConstraint, num: s32, axis: s32 = -1) -> btScalar { return this.vtable.getParam(this, num, axis); }

btTypedConstraint_calculateSerializeBufferSize :: inline (this: *btTypedConstraint) -> s32 { return this.vtable.calculateSerializeBufferSize(this); }

btTypedConstraint_serialize :: inline (this: *btTypedConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }



operator_assign :: (this: *btTypedConstraint, other: *btTypedConstraint) -> *btTypedConstraint #cpp_method #foreign bullet3 "??4btTypedConstraint@@AEAAAEAV0@AEAV0@@Z";


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btTypedConstraintFloatData :: struct {
    m_rbA:                                  *btRigidBodyFloatData;
    m_rbB:                                  *btRigidBodyFloatData;
    m_name:                                 *u8;

    m_objectType:                           s32;
    m_userConstraintType:                   s32;
    m_userConstraintId:                     s32;
    m_needsFeedback:                        s32;

    m_appliedImpulse:                       float;
    m_dbgDrawSize:                          float;

    m_disableCollisionsBetweenLinkedBodies: s32;
    m_overrideNumSolverIterations:          s32;

    m_breakingImpulseThreshold:             float;
    m_isEnabled:                            s32;
}

///this structure is not used, except for loading pre-2.82 .bullet files
btTypedConstraintData :: struct {
    m_rbA:                                  *btRigidBodyFloatData;
    m_rbB:                                  *btRigidBodyFloatData;
    m_name:                                 *u8;

    m_objectType:                           s32;
    m_userConstraintType:                   s32;
    m_userConstraintId:                     s32;
    m_needsFeedback:                        s32;

    m_appliedImpulse:                       float;
    m_dbgDrawSize:                          float;

    m_disableCollisionsBetweenLinkedBodies: s32;
    m_overrideNumSolverIterations:          s32;

    m_breakingImpulseThreshold:             float;
    m_isEnabled:                            s32;
}

btTypedConstraintDoubleData :: struct {
    m_rbA:                                  *btRigidBodyDoubleData;
    m_rbB:                                  *btRigidBodyDoubleData;
    m_name:                                 *u8;

    m_objectType:                           s32;
    m_userConstraintType:                   s32;
    m_userConstraintId:                     s32;
    m_needsFeedback:                        s32;

    m_appliedImpulse:                       float64;
    m_dbgDrawSize:                          float64;

    m_disableCollisionsBetweenLinkedBodies: s32;
    m_overrideNumSolverIterations:          s32;

    m_breakingImpulseThreshold:             float64;
    m_isEnabled:                            s32;
    padding:                                [4] u8;
}

btAngularLimit :: struct {
    m_center:           btScalar;
    m_halfRange:        btScalar;
    m_softness:         btScalar;
    m_biasFactor:       btScalar;
    m_relaxationFactor: btScalar;
    m_correction:       btScalar;
    m_sign:             btScalar;

    m_solveLimit:       bool;

    /// Default constructor initializes limit as inactive, allowing free constraint movement
    Constructor :: (this: *btAngularLimit) -> void #cpp_method #foreign bullet3 "??0btAngularLimit@@QEAA@XZ";

    /// Sets all limit's parameters.
    /// When low > high limit becomes inactive.
    /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
    set :: (this: *btAngularLimit, low: btScalar, high: btScalar, _softness: btScalar = 0.9, _biasFactor: btScalar = 0.3, _relaxationFactor: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?set@btAngularLimit@@QEAAXMMMMM@Z";

    /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
    /// correction is calculated.
    test :: (this: *btAngularLimit, angle: btScalar) -> void #cpp_method #foreign bullet3 "?test@btAngularLimit@@QEAAXM@Z";

    /// Returns limit's softness
    getSoftness :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getSoftness@btAngularLimit@@QEBAMXZ";

    /// Returns limit's bias factor
    getBiasFactor :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getBiasFactor@btAngularLimit@@QEBAMXZ";

    /// Returns limit's relaxation factor
    getRelaxationFactor :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getRelaxationFactor@btAngularLimit@@QEBAMXZ";

    /// Returns correction value evaluated when test() was invoked
    getCorrection :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getCorrection@btAngularLimit@@QEBAMXZ";

    /// Returns sign value evaluated when test() was invoked
    getSign :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getSign@btAngularLimit@@QEBAMXZ";

    /// Gives half of the distance between min and max limit angle
    getHalfRange :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getHalfRange@btAngularLimit@@QEBAMXZ";

    /// Returns true when the last test() invocation recognized limit violation
    isLimit :: (this: *btAngularLimit) -> bool #cpp_method #foreign bullet3 "?isLimit@btAngularLimit@@QEBA_NXZ";

    /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
    /// returned is modified so it equals to the limit closest to given angle.
    fit :: (this: *btAngularLimit, angle: *btScalar) -> void #cpp_method #foreign bullet3 "?fit@btAngularLimit@@QEBAXAEAM@Z";

    /// Returns correction value multiplied by sign value
    getError :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getError@btAngularLimit@@QEBAMXZ";

    getLow :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getLow@btAngularLimit@@QEBAMXZ";

    getHigh :: (this: *btAngularLimit) -> btScalar #cpp_method #foreign bullet3 "?getHigh@btAngularLimit@@QEBAMXZ";
}

btConstraintSetting :: struct {
    Constructor :: (this: *btConstraintSetting) -> void #cpp_method #foreign bullet3 "??0btConstraintSetting@@QEAA@XZ";

    m_tau:          btScalar;
    m_damping:      btScalar;
    m_impulseClamp: btScalar;
}

btPoint2PointFlags :: enum s32 {
    ERP :: 1;
    CFM :: 2;

    BT_P2P_FLAGS_ERP :: ERP;
    BT_P2P_FLAGS_CFM :: CFM;
}

/// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
btPoint2PointConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_jac:                        [3] btJacobianEntry; //3 orthogonal linear constraints

    m_pivotInA:                   btVector3;
    m_pivotInB:                   btVector3;

    m_flags:                      s32;
    m_erp:                        btScalar;
    m_cfm:                        btScalar;

    ///for backwards compatibility during the transition to 'getInfo/getInfo2'
    m_useSolveConstraintObsolete: bool;

    m_setting:                    btConstraintSetting;

    Constructor :: (this: *btPoint2PointConstraint, rbA: *btRigidBody, rbB: *btRigidBody, pivotInA: *btVector3, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "??0btPoint2PointConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@1@Z";
    Constructor :: (this: *btPoint2PointConstraint, rbA: *btRigidBody, rbB: *btRigidBody, pivotInA: btVector3, pivotInB: btVector3) #no_context {
        Constructor(this, rbA, rbB, *pivotInA, *pivotInB);
    }

    Constructor :: (this: *btPoint2PointConstraint, rbA: *btRigidBody, pivotInA: *btVector3) -> void #cpp_method #foreign bullet3 "??0btPoint2PointConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtVector3@@@Z";
    Constructor :: (this: *btPoint2PointConstraint, rbA: *btRigidBody, pivotInA: btVector3) #no_context {
        Constructor(this, rbA, *pivotInA);
    }

    getInfo1NonVirtual :: (this: *btPoint2PointConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@btPoint2PointConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    getInfo2NonVirtual :: (this: *btPoint2PointConstraint, info: *btTypedConstraint.btConstraintInfo2, body0_trans: *btTransform, body1_trans: *btTransform) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@btPoint2PointConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1@Z";
    getInfo2NonVirtual :: (this: *btPoint2PointConstraint, info: *btTypedConstraint.btConstraintInfo2, body0_trans: btTransform, body1_trans: btTransform) #no_context {
        getInfo2NonVirtual(this, info, *body0_trans, *body1_trans);
    }

    updateRHS :: (this: *btPoint2PointConstraint, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateRHS@btPoint2PointConstraint@@QEAAXM@Z";

    setPivotA :: (this: *btPoint2PointConstraint, pivotA: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotA@btPoint2PointConstraint@@QEAAXAEBVbtVector3@@@Z";
    setPivotA :: (this: *btPoint2PointConstraint, pivotA: btVector3) #no_context {
        setPivotA(this, *pivotA);
    }

    setPivotB :: (this: *btPoint2PointConstraint, pivotB: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotB@btPoint2PointConstraint@@QEAAXAEBVbtVector3@@@Z";
    setPivotB :: (this: *btPoint2PointConstraint, pivotB: btVector3) #no_context {
        setPivotB(this, *pivotB);
    }

    getPivotInA :: (this: *btPoint2PointConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInA@btPoint2PointConstraint@@QEBAAEBVbtVector3@@XZ";

    getPivotInB :: (this: *btPoint2PointConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInB@btPoint2PointConstraint@@QEBAAEBVbtVector3@@XZ";
    #place bttypedconstraint; btpoint2pointconstraint_vtable: *btPoint2PointConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_buildJacobian :: (this: *btPoint2PointConstraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btPoint2PointConstraint@@UEAAXXZ";

    virtual_getInfo1 :: (this: *btPoint2PointConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btPoint2PointConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    virtual_getInfo2 :: (this: *btPoint2PointConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btPoint2PointConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *btPoint2PointConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btPoint2PointConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *btPoint2PointConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btPoint2PointConstraint@@UEBAMHH@Z";

    virtual_getFlags :: (this: *btPoint2PointConstraint) -> s32 #cpp_method #foreign bullet3 "?getFlags@btPoint2PointConstraint@@UEBAHXZ";

    virtual_calculateSerializeBufferSize :: (this: *btPoint2PointConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btPoint2PointConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btPoint2PointConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btPoint2PointConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btPoint2PointConstraint_VTable :: struct #type_info_none {
    using bttypedconstraint: btTypedConstraint_VTable;
    getFlags: (this: *btPoint2PointConstraint) -> s32 #cpp_method;
}
btPoint2PointConstraint_getFlags :: inline (this: *btPoint2PointConstraint) -> s32 { return this.btpoint2pointconstraint_vtable.getFlags(this); }

vtable :: (obj: *btPoint2PointConstraint) -> *btPoint2PointConstraint_VTable { return obj.btpoint2pointconstraint_vtable; }



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btPoint2PointConstraintFloatData :: struct {
    m_typeConstraintData: btTypedConstraintData;
    m_pivotInA:           btVector3FloatData;
    m_pivotInB:           btVector3FloatData;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btPoint2PointConstraintDoubleData2 :: struct {
    m_typeConstraintData: btTypedConstraintDoubleData;
    m_pivotInA:           btVector3DoubleData;
    m_pivotInB:           btVector3DoubleData;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
///this structure is not used, except for loading pre-2.82 .bullet files
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btPoint2PointConstraintDoubleData :: struct {
    m_typeConstraintData: btTypedConstraintData;
    m_pivotInA:           btVector3DoubleData;
    m_pivotInB:           btVector3DoubleData;
}

btHingeFlags :: enum s32 {
    CFM_STOP :: 1;
    ERP_STOP :: 2;
    CFM_NORM :: 4;
    ERP_NORM :: 8;

    BT_HINGE_FLAGS_CFM_STOP :: CFM_STOP;
    BT_HINGE_FLAGS_ERP_STOP :: ERP_STOP;
    BT_HINGE_FLAGS_CFM_NORM :: CFM_NORM;
    BT_HINGE_FLAGS_ERP_NORM :: ERP_NORM;
}

/// hinge constraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/// axis defines the orientation of the hinge axis
btHingeConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_jac:                         [3] btJacobianEntry; //3 orthogonal linear constraints
    m_jacAng:                      [3] btJacobianEntry; //2 orthogonal angular constraints+ 1 for limit/motor

    m_rbAFrame:                    btTransform; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:                    btTransform;

    m_motorTargetVelocity:         btScalar;
    m_maxMotorImpulse:             btScalar;

    m_limit:                       btAngularLimit;

    m_kHinge:                      btScalar;

    m_accLimitImpulse:             btScalar;
    m_hingeAngle:                  btScalar;
    m_referenceSign:               btScalar;

    m_angularOnly:                 bool;
    m_enableAngularMotor:          bool;
    m_useSolveConstraintObsolete:  bool;
    m_useOffsetForConstraintFrame: bool;
    m_useReferenceFrameA:          bool;

    m_accMotorImpulse:             btScalar;

    m_flags:                       s32;
    m_normalCFM:                   btScalar;
    m_normalERP:                   btScalar;
    m_stopCFM:                     btScalar;
    m_stopERP:                     btScalar;

    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, rbB: *btRigidBody, pivotInA: *btVector3, pivotInB: *btVector3, axisInA: *btVector3, axisInB: *btVector3, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@111_N@Z";
    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, rbB: *btRigidBody, pivotInA: btVector3, pivotInB: btVector3, axisInA: btVector3, axisInB: btVector3, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, rbB, *pivotInA, *pivotInB, *axisInA, *axisInB, useReferenceFrameA);
    }

    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, pivotInA: *btVector3, axisInA: *btVector3, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtVector3@@1_N@Z";
    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, pivotInA: btVector3, axisInA: btVector3, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, *pivotInA, *axisInA, useReferenceFrameA);
    }

    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, rbB: *btRigidBody, rbAFrame: *btTransform, rbBFrame: *btTransform, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z";
    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, rbB: *btRigidBody, rbAFrame: btTransform, rbBFrame: btTransform, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, rbB, *rbAFrame, *rbBFrame, useReferenceFrameA);
    }

    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, rbAFrame: *btTransform, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z";
    Constructor :: (this: *btHingeConstraint, rbA: *btRigidBody, rbAFrame: btTransform, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, *rbAFrame, useReferenceFrameA);
    }

    getInfo1NonVirtual :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@btHingeConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    getInfo2NonVirtual :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: *btTransform, transB: *btTransform, angVelA: *btVector3, angVelB: *btVector3) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@btHingeConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2@Z";
    getInfo2NonVirtual :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: btTransform, transB: btTransform, angVelA: btVector3, angVelB: btVector3) #no_context {
        getInfo2NonVirtual(this, info, *transA, *transB, *angVelA, *angVelB);
    }

    getInfo2Internal :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: *btTransform, transB: *btTransform, angVelA: *btVector3, angVelB: *btVector3) -> void #cpp_method #foreign bullet3 "?getInfo2Internal@btHingeConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2@Z";
    getInfo2Internal :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: btTransform, transB: btTransform, angVelA: btVector3, angVelB: btVector3) #no_context {
        getInfo2Internal(this, info, *transA, *transB, *angVelA, *angVelB);
    }
    getInfo2InternalUsingFrameOffset :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: *btTransform, transB: *btTransform, angVelA: *btVector3, angVelB: *btVector3) -> void #cpp_method #foreign bullet3 "?getInfo2InternalUsingFrameOffset@btHingeConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2@Z";
    getInfo2InternalUsingFrameOffset :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: btTransform, transB: btTransform, angVelA: btVector3, angVelB: btVector3) #no_context {
        getInfo2InternalUsingFrameOffset(this, info, *transA, *transB, *angVelA, *angVelB);
    }

    updateRHS :: (this: *btHingeConstraint, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateRHS@btHingeConstraint@@QEAAXM@Z";

    getRigidBodyA :: (this: /*const*/ *btHingeConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyA@btHingeConstraint@@QEBAAEBVbtRigidBody@@XZ";

    getRigidBodyB :: (this: /*const*/ *btHingeConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyB@btHingeConstraint@@QEBAAEBVbtRigidBody@@XZ";

    getRigidBodyA_1 :: (this: *btHingeConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyA@btHingeConstraint@@QEAAAEAVbtRigidBody@@XZ";

    getRigidBodyB_1 :: (this: *btHingeConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyB@btHingeConstraint@@QEAAAEAVbtRigidBody@@XZ";

    getFrameOffsetA :: (this: *btHingeConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btHingeConstraint@@QEAAAEAVbtTransform@@XZ";

    getFrameOffsetB :: (this: *btHingeConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btHingeConstraint@@QEAAAEAVbtTransform@@XZ";

    setFrames :: (this: *btHingeConstraint, frameA: *btTransform, frameB: *btTransform) -> void #cpp_method #foreign bullet3 "?setFrames@btHingeConstraint@@QEAAXAEBVbtTransform@@0@Z";
    setFrames :: (this: *btHingeConstraint, frameA: btTransform, frameB: btTransform) #no_context {
        setFrames(this, *frameA, *frameB);
    }

    setAngularOnly :: (this: *btHingeConstraint, angularOnly: bool) -> void #cpp_method #foreign bullet3 "?setAngularOnly@btHingeConstraint@@QEAAX_N@Z";

    enableAngularMotor :: (this: *btHingeConstraint, enableMotor: bool, targetVelocity: btScalar, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "?enableAngularMotor@btHingeConstraint@@QEAAX_NMM@Z";

    // extra motor API, including ability to set a target rotation (as opposed to angular velocity)
    // note: setMotorTarget sets angular velocity under the hood, so you must call it every tick to
    //       maintain a given angular target.
    enableMotor :: (this: *btHingeConstraint, enableMotor: bool) -> void #cpp_method #foreign bullet3 "?enableMotor@btHingeConstraint@@QEAAX_N@Z";
    setMaxMotorImpulse :: (this: *btHingeConstraint, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxMotorImpulse@btHingeConstraint@@QEAAXM@Z";
    setMotorTargetVelocity :: (this: *btHingeConstraint, motorTargetVelocity: btScalar) -> void #cpp_method #foreign bullet3 "?setMotorTargetVelocity@btHingeConstraint@@QEAAXM@Z";
    setMotorTarget :: (this: *btHingeConstraint, qAinB: *btQuaternion, dt: btScalar) -> void #cpp_method #foreign bullet3 "?setMotorTarget@btHingeConstraint@@QEAAXAEBVbtQuaternion@@M@Z";
    setMotorTarget :: (this: *btHingeConstraint, qAinB: btQuaternion, dt: btScalar) #no_context {
        setMotorTarget(this, *qAinB, dt);
    }
    setMotorTarget :: (this: *btHingeConstraint, targetAngle: btScalar, dt: btScalar) -> void #cpp_method #foreign bullet3 "?setMotorTarget@btHingeConstraint@@QEAAXMM@Z";

    setLimit :: (this: *btHingeConstraint, low: btScalar, high: btScalar, _softness: btScalar = 0.9, _biasFactor: btScalar = 0.3, _relaxationFactor: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setLimit@btHingeConstraint@@QEAAXMMMMM@Z";

    getLimitSoftness :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLimitSoftness@btHingeConstraint@@QEBAMXZ";

    getLimitBiasFactor :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLimitBiasFactor@btHingeConstraint@@QEBAMXZ";

    getLimitRelaxationFactor :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLimitRelaxationFactor@btHingeConstraint@@QEBAMXZ";

    setAxis :: (this: *btHingeConstraint, axisInA: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxis@btHingeConstraint@@QEAAXAEAVbtVector3@@@Z";

    hasLimit :: (this: *btHingeConstraint) -> bool #cpp_method #foreign bullet3 "?hasLimit@btHingeConstraint@@QEBA_NXZ";

    getLowerLimit :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLowerLimit@btHingeConstraint@@QEBAMXZ";

    getUpperLimit :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getUpperLimit@btHingeConstraint@@QEBAMXZ";

    ///The getHingeAngle gives the hinge angle in range [-PI,PI]
    getHingeAngle :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getHingeAngle@btHingeConstraint@@QEAAMXZ";

    getHingeAngle :: (this: *btHingeConstraint, transA: *btTransform, transB: *btTransform) -> btScalar #cpp_method #foreign bullet3 "?getHingeAngle@btHingeConstraint@@QEAAMAEBVbtTransform@@0@Z";
    getHingeAngle :: (this: *btHingeConstraint, transA: btTransform, transB: btTransform) -> btScalar #no_context {
        return getHingeAngle(this, *transA, *transB);
    }

    testLimit :: (this: *btHingeConstraint, transA: *btTransform, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?testLimit@btHingeConstraint@@QEAAXAEBVbtTransform@@0@Z";
    testLimit :: (this: *btHingeConstraint, transA: btTransform, transB: btTransform) #no_context {
        testLimit(this, *transA, *transB);
    }

    getAFrame :: (this: /*const*/ *btHingeConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getAFrame@btHingeConstraint@@QEBAAEBVbtTransform@@XZ";
    getBFrame :: (this: /*const*/ *btHingeConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getBFrame@btHingeConstraint@@QEBAAEBVbtTransform@@XZ";

    getAFrame_1 :: (this: *btHingeConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getAFrame@btHingeConstraint@@QEAAAEAVbtTransform@@XZ";
    getBFrame_1 :: (this: *btHingeConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getBFrame@btHingeConstraint@@QEAAAEAVbtTransform@@XZ";

    getSolveLimit :: (this: *btHingeConstraint) -> s32 #cpp_method #foreign bullet3 "?getSolveLimit@btHingeConstraint@@QEAAHXZ";

    getLimitSign :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLimitSign@btHingeConstraint@@QEAAMXZ";

    getAngularOnly :: (this: *btHingeConstraint) -> bool #cpp_method #foreign bullet3 "?getAngularOnly@btHingeConstraint@@QEAA_NXZ";

    getEnableAngularMotor :: (this: *btHingeConstraint) -> bool #cpp_method #foreign bullet3 "?getEnableAngularMotor@btHingeConstraint@@QEAA_NXZ";

    getMotorTargetVelocity :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getMotorTargetVelocity@btHingeConstraint@@QEAAMXZ";

    getMaxMotorImpulse :: (this: *btHingeConstraint) -> btScalar #cpp_method #foreign bullet3 "?getMaxMotorImpulse@btHingeConstraint@@QEAAMXZ";

    // access for UseFrameOffset
    getUseFrameOffset :: (this: *btHingeConstraint) -> bool #cpp_method #foreign bullet3 "?getUseFrameOffset@btHingeConstraint@@QEAA_NXZ";
    setUseFrameOffset :: (this: *btHingeConstraint, frameOffsetOnOff: bool) -> void #cpp_method #foreign bullet3 "?setUseFrameOffset@btHingeConstraint@@QEAAX_N@Z";

    // access for UseReferenceFrameA
    getUseReferenceFrameA :: (this: *btHingeConstraint) -> bool #cpp_method #foreign bullet3 "?getUseReferenceFrameA@btHingeConstraint@@QEBA_NXZ";
    setUseReferenceFrameA :: (this: *btHingeConstraint, useReferenceFrameA: bool) -> void #cpp_method #foreign bullet3 "?setUseReferenceFrameA@btHingeConstraint@@QEAAX_N@Z";
    #place bttypedconstraint; bthingeconstraint_vtable: *btHingeConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_buildJacobian :: (this: *btHingeConstraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btHingeConstraint@@UEAAXXZ";

    virtual_getInfo1 :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btHingeConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    virtual_getInfo2 :: (this: *btHingeConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btHingeConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *btHingeConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btHingeConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *btHingeConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btHingeConstraint@@UEBAMHH@Z";

    virtual_getFlags :: (this: *btHingeConstraint) -> s32 #cpp_method #foreign bullet3 "?getFlags@btHingeConstraint@@UEBAHXZ";

    virtual_calculateSerializeBufferSize :: (this: *btHingeConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btHingeConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btHingeConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btHingeConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btHingeConstraint_VTable :: struct #type_info_none {
    using bttypedconstraint: btTypedConstraint_VTable;
    getFlags: (this: *btHingeConstraint) -> s32 #cpp_method;
}
btHingeConstraint_getFlags :: inline (this: *btHingeConstraint) -> s32 { return this.bthingeconstraint_vtable.getFlags(this); }

vtable :: (obj: *btHingeConstraint) -> *btHingeConstraint_VTable { return obj.bthingeconstraint_vtable; }



///this structure is not used, except for loading pre-2.82 .bullet files
btHingeConstraintDoubleData :: struct {
    m_typeConstraintData:  btTypedConstraintData;
    m_rbAFrame:            btTransformDoubleData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:            btTransformDoubleData;
    m_useReferenceFrameA:  s32;
    m_angularOnly:         s32;
    m_enableAngularMotor:  s32;
    m_motorTargetVelocity: float;
    m_maxMotorImpulse:     float;

    m_lowerLimit:          float;
    m_upperLimit:          float;
    m_limitSoftness:       float;
    m_biasFactor:          float;
    m_relaxationFactor:    float;
}

///The getAccumulatedHingeAngle returns the accumulated hinge angle, taking rotation across the -PI/PI boundary into account
btHingeAccumulatedAngleConstraint :: struct {
    #as using bthingeconstraint: btHingeConstraint;

    m_accumulatedAngle: btScalar;

    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, rbB: *btRigidBody, pivotInA: *btVector3, pivotInB: *btVector3, axisInA: *btVector3, axisInB: *btVector3, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeAccumulatedAngleConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@111_N@Z";
    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, rbB: *btRigidBody, pivotInA: btVector3, pivotInB: btVector3, axisInA: btVector3, axisInB: btVector3, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, rbB, *pivotInA, *pivotInB, *axisInA, *axisInB, useReferenceFrameA);
    }

    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, pivotInA: *btVector3, axisInA: *btVector3, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeAccumulatedAngleConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtVector3@@1_N@Z";
    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, pivotInA: btVector3, axisInA: btVector3, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, *pivotInA, *axisInA, useReferenceFrameA);
    }

    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, rbB: *btRigidBody, rbAFrame: *btTransform, rbBFrame: *btTransform, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeAccumulatedAngleConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z";
    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, rbB: *btRigidBody, rbAFrame: btTransform, rbBFrame: btTransform, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, rbB, *rbAFrame, *rbBFrame, useReferenceFrameA);
    }

    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, rbAFrame: *btTransform, useReferenceFrameA := false) -> void #cpp_method #foreign bullet3 "??0btHingeAccumulatedAngleConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z";
    Constructor :: (this: *btHingeAccumulatedAngleConstraint, rbA: *btRigidBody, rbAFrame: btTransform, useReferenceFrameA := false) #no_context {
        Constructor(this, rbA, *rbAFrame, useReferenceFrameA);
    }

    getAccumulatedHingeAngle :: (this: *btHingeAccumulatedAngleConstraint) -> btScalar #cpp_method #foreign bullet3 "?getAccumulatedHingeAngle@btHingeAccumulatedAngleConstraint@@QEAAMXZ";
    setAccumulatedHingeAngle :: (this: *btHingeAccumulatedAngleConstraint, accAngle: btScalar) -> void #cpp_method #foreign bullet3 "?setAccumulatedHingeAngle@btHingeAccumulatedAngleConstraint@@QEAAXM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_getInfo1 :: (this: *btHingeAccumulatedAngleConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btHingeAccumulatedAngleConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";
}


btHingeConstraintFloatData :: struct {
    m_typeConstraintData:  btTypedConstraintData;
    m_rbAFrame:            btTransformFloatData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:            btTransformFloatData;
    m_useReferenceFrameA:  s32;
    m_angularOnly:         s32;

    m_enableAngularMotor:  s32;
    m_motorTargetVelocity: float;
    m_maxMotorImpulse:     float;

    m_lowerLimit:          float;
    m_upperLimit:          float;
    m_limitSoftness:       float;
    m_biasFactor:          float;
    m_relaxationFactor:    float;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btHingeConstraintDoubleData2 :: struct {
    m_typeConstraintData:  btTypedConstraintDoubleData;
    m_rbAFrame:            btTransformDoubleData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:            btTransformDoubleData;
    m_useReferenceFrameA:  s32;
    m_angularOnly:         s32;
    m_enableAngularMotor:  s32;
    m_motorTargetVelocity: float64;
    m_maxMotorImpulse:     float64;

    m_lowerLimit:          float64;
    m_upperLimit:          float64;
    m_limitSoftness:       float64;
    m_biasFactor:          float64;
    m_relaxationFactor:    float64;
    m_padding1:            [4] u8;
}

btConeTwistFlags :: enum s32 {
    LIN_CFM :: 1;
    LIN_ERP :: 2;
    ANG_CFM :: 4;

    BT_CONETWIST_FLAGS_LIN_CFM :: LIN_CFM;
    BT_CONETWIST_FLAGS_LIN_ERP :: LIN_ERP;
    BT_CONETWIST_FLAGS_ANG_CFM :: ANG_CFM;
}

///btConeTwistConstraint can be used to simulate ragdoll joints (upper arm, leg etc)
btConeTwistConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_jac:                        [3] btJacobianEntry; //3 orthogonal linear constraints

    m_rbAFrame:                   btTransform;
    m_rbBFrame:                   btTransform;

    m_limitSoftness:              btScalar;
    m_biasFactor:                 btScalar;
    m_relaxationFactor:           btScalar;

    m_damping:                    btScalar;

    m_swingSpan1:                 btScalar;
    m_swingSpan2:                 btScalar;
    m_twistSpan:                  btScalar;

    m_fixThresh:                  btScalar;

    m_swingAxis:                  btVector3;
    m_twistAxis:                  btVector3;

    m_kSwing:                     btScalar;
    m_kTwist:                     btScalar;

    m_twistLimitSign:             btScalar;
    m_swingCorrection:            btScalar;
    m_twistCorrection:            btScalar;

    m_twistAngle:                 btScalar;

    m_accSwingLimitImpulse:       btScalar;
    m_accTwistLimitImpulse:       btScalar;

    m_angularOnly:                bool;
    m_solveTwistLimit:            bool;
    m_solveSwingLimit:            bool;

    m_useSolveConstraintObsolete: bool;

    // not yet used...
    m_swingLimitRatio:            btScalar;
    m_twistLimitRatio:            btScalar;
    m_twistAxisA:                 btVector3 #align 8;

    // motor
    m_bMotorEnabled:              bool;
    m_bNormalizedMotorStrength:   bool;
    m_qTarget:                    btQuaternion;
    m_maxMotorImpulse:            btScalar;
    m_accMotorImpulse:            btVector3;

    // parameters
    m_flags:                      s32;
    m_linCFM:                     btScalar;
    m_linERP:                     btScalar;
    m_angCFM:                     btScalar;

    init :: (this: *btConeTwistConstraint) -> void #cpp_method #foreign bullet3 "?init@btConeTwistConstraint@@IEAAXXZ";

    computeConeLimitInfo :: (this: *btConeTwistConstraint, qCone: *btQuaternion, swingAngle: *btScalar, vSwingAxis: *btVector3, swingLimit: *btScalar) -> void #cpp_method #foreign bullet3 "?computeConeLimitInfo@btConeTwistConstraint@@IEAAXAEBVbtQuaternion@@AEAMAEAVbtVector3@@1@Z";
    computeConeLimitInfo :: (this: *btConeTwistConstraint, qCone: btQuaternion, swingAngle: *btScalar, vSwingAxis: *btVector3, swingLimit: *btScalar) #no_context {
        computeConeLimitInfo(this, *qCone, swingAngle, vSwingAxis, swingLimit);
    }

    computeTwistLimitInfo :: (this: *btConeTwistConstraint, qTwist: *btQuaternion, twistAngle: *btScalar, vTwistAxis: *btVector3) -> void #cpp_method #foreign bullet3 "?computeTwistLimitInfo@btConeTwistConstraint@@IEAAXAEBVbtQuaternion@@AEAMAEAVbtVector3@@@Z";
    computeTwistLimitInfo :: (this: *btConeTwistConstraint, qTwist: btQuaternion, twistAngle: *btScalar, vTwistAxis: *btVector3) #no_context {
        computeTwistLimitInfo(this, *qTwist, twistAngle, vTwistAxis);
    }

    adjustSwingAxisToUseEllipseNormal :: (this: *btConeTwistConstraint, vSwingAxis: *btVector3) -> void #cpp_method #foreign bullet3 "?adjustSwingAxisToUseEllipseNormal@btConeTwistConstraint@@IEBAXAEAVbtVector3@@@Z";

    Constructor :: (this: *btConeTwistConstraint, rbA: *btRigidBody, rbB: *btRigidBody, rbAFrame: *btTransform, rbBFrame: *btTransform) -> void #cpp_method #foreign bullet3 "??0btConeTwistConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1@Z";
    Constructor :: (this: *btConeTwistConstraint, rbA: *btRigidBody, rbB: *btRigidBody, rbAFrame: btTransform, rbBFrame: btTransform) #no_context {
        Constructor(this, rbA, rbB, *rbAFrame, *rbBFrame);
    }

    Constructor :: (this: *btConeTwistConstraint, rbA: *btRigidBody, rbAFrame: *btTransform) -> void #cpp_method #foreign bullet3 "??0btConeTwistConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@@Z";
    Constructor :: (this: *btConeTwistConstraint, rbA: *btRigidBody, rbAFrame: btTransform) #no_context {
        Constructor(this, rbA, *rbAFrame);
    }

    getInfo1NonVirtual :: (this: *btConeTwistConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@btConeTwistConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    getInfo2NonVirtual :: (this: *btConeTwistConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: *btTransform, transB: *btTransform, invInertiaWorldA: *btMatrix3x3, invInertiaWorldB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@btConeTwistConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtMatrix3x3@@2@Z";
    getInfo2NonVirtual :: (this: *btConeTwistConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: btTransform, transB: btTransform, invInertiaWorldA: btMatrix3x3, invInertiaWorldB: btMatrix3x3) #no_context {
        getInfo2NonVirtual(this, info, *transA, *transB, *invInertiaWorldA, *invInertiaWorldB);
    }

    updateRHS :: (this: *btConeTwistConstraint, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateRHS@btConeTwistConstraint@@QEAAXM@Z";

    getRigidBodyA :: (this: *btConeTwistConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyA@btConeTwistConstraint@@QEBAAEBVbtRigidBody@@XZ";

    getRigidBodyB :: (this: *btConeTwistConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyB@btConeTwistConstraint@@QEBAAEBVbtRigidBody@@XZ";

    setAngularOnly :: (this: *btConeTwistConstraint, angularOnly: bool) -> void #cpp_method #foreign bullet3 "?setAngularOnly@btConeTwistConstraint@@QEAAX_N@Z";

    getAngularOnly :: (this: *btConeTwistConstraint) -> bool #cpp_method #foreign bullet3 "?getAngularOnly@btConeTwistConstraint@@QEBA_NXZ";

    setLimit :: (this: *btConeTwistConstraint, limitIndex: s32, limitValue: btScalar) -> void #cpp_method #foreign bullet3 "?setLimit@btConeTwistConstraint@@QEAAXHM@Z";

    getLimit :: (this: *btConeTwistConstraint, limitIndex: s32) -> btScalar #cpp_method #foreign bullet3 "?getLimit@btConeTwistConstraint@@QEBAMH@Z";

    // setLimit(), a few notes:
    // _softness:
    //		0->1, recommend ~0.8->1.
    //		describes % of limits where movement is free.
    //		beyond this softness %, the limit is gradually enforced until the "hard" (1.0) limit is reached.
    // _biasFactor:
    //		0->1?, recommend 0.3 +/-0.3 or so.
    //		strength with which constraint resists zeroth order (angular, not angular velocity) limit violation.
    // __relaxationFactor:
    //		0->1, recommend to stay near 1.
    //		the lower the value, the less the constraint will fight velocities which violate the angular limits.
    setLimit :: (this: *btConeTwistConstraint, _swingSpan1: btScalar, _swingSpan2: btScalar, _twistSpan: btScalar, _softness: btScalar = 1.0, _biasFactor: btScalar = 0.3, _relaxationFactor: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setLimit@btConeTwistConstraint@@QEAAXMMMMMM@Z";

    getAFrame :: (this: *btConeTwistConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getAFrame@btConeTwistConstraint@@QEBAAEBVbtTransform@@XZ";
    getBFrame :: (this: *btConeTwistConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getBFrame@btConeTwistConstraint@@QEBAAEBVbtTransform@@XZ";

    getSolveTwistLimit :: (this: *btConeTwistConstraint) -> s32 #cpp_method #foreign bullet3 "?getSolveTwistLimit@btConeTwistConstraint@@QEAAHXZ";

    getSolveSwingLimit :: (this: *btConeTwistConstraint) -> s32 #cpp_method #foreign bullet3 "?getSolveSwingLimit@btConeTwistConstraint@@QEAAHXZ";

    getTwistLimitSign :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getTwistLimitSign@btConeTwistConstraint@@QEAAMXZ";

    calcAngleInfo :: (this: *btConeTwistConstraint) -> void #cpp_method #foreign bullet3 "?calcAngleInfo@btConeTwistConstraint@@QEAAXXZ";
    calcAngleInfo2 :: (this: *btConeTwistConstraint, transA: *btTransform, transB: *btTransform, invInertiaWorldA: *btMatrix3x3, invInertiaWorldB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?calcAngleInfo2@btConeTwistConstraint@@QEAAXAEBVbtTransform@@0AEBVbtMatrix3x3@@1@Z";
    calcAngleInfo2 :: (this: *btConeTwistConstraint, transA: btTransform, transB: btTransform, invInertiaWorldA: btMatrix3x3, invInertiaWorldB: btMatrix3x3) #no_context {
        calcAngleInfo2(this, *transA, *transB, *invInertiaWorldA, *invInertiaWorldB);
    }

    getSwingSpan1 :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSwingSpan1@btConeTwistConstraint@@QEBAMXZ";

    getSwingSpan2 :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSwingSpan2@btConeTwistConstraint@@QEBAMXZ";

    getTwistSpan :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getTwistSpan@btConeTwistConstraint@@QEBAMXZ";

    getLimitSoftness :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLimitSoftness@btConeTwistConstraint@@QEBAMXZ";

    getBiasFactor :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getBiasFactor@btConeTwistConstraint@@QEBAMXZ";

    getRelaxationFactor :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRelaxationFactor@btConeTwistConstraint@@QEBAMXZ";

    getTwistAngle :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getTwistAngle@btConeTwistConstraint@@QEBAMXZ";

    isPastSwingLimit :: (this: *btConeTwistConstraint) -> bool #cpp_method #foreign bullet3 "?isPastSwingLimit@btConeTwistConstraint@@QEAA_NXZ";

    getDamping :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDamping@btConeTwistConstraint@@QEBAMXZ";
    setDamping :: (this: *btConeTwistConstraint, damping: btScalar) -> void #cpp_method #foreign bullet3 "?setDamping@btConeTwistConstraint@@QEAAXM@Z";

    enableMotor :: (this: *btConeTwistConstraint, b: bool) -> void #cpp_method #foreign bullet3 "?enableMotor@btConeTwistConstraint@@QEAAX_N@Z";
    isMotorEnabled :: (this: *btConeTwistConstraint) -> bool #cpp_method #foreign bullet3 "?isMotorEnabled@btConeTwistConstraint@@QEBA_NXZ";
    getMaxMotorImpulse :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getMaxMotorImpulse@btConeTwistConstraint@@QEBAMXZ";
    isMaxMotorImpulseNormalized :: (this: *btConeTwistConstraint) -> bool #cpp_method #foreign bullet3 "?isMaxMotorImpulseNormalized@btConeTwistConstraint@@QEBA_NXZ";
    setMaxMotorImpulse :: (this: *btConeTwistConstraint, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxMotorImpulse@btConeTwistConstraint@@QEAAXM@Z";

    setMaxMotorImpulseNormalized :: (this: *btConeTwistConstraint, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxMotorImpulseNormalized@btConeTwistConstraint@@QEAAXM@Z";

    getFixThresh :: (this: *btConeTwistConstraint) -> btScalar #cpp_method #foreign bullet3 "?getFixThresh@btConeTwistConstraint@@QEAAMXZ";
    setFixThresh :: (this: *btConeTwistConstraint, fixThresh: btScalar) -> void #cpp_method #foreign bullet3 "?setFixThresh@btConeTwistConstraint@@QEAAXM@Z";

    // setMotorTarget:
    // q: the desired rotation of bodyA wrt bodyB.
    // note: if q violates the joint limits, the internal target is clamped to avoid conflicting impulses (very bad for stability)
    // note: don't forget to enableMotor()
    setMotorTarget :: (this: *btConeTwistConstraint, q: *btQuaternion) -> void #cpp_method #foreign bullet3 "?setMotorTarget@btConeTwistConstraint@@QEAAXAEBVbtQuaternion@@@Z";
    setMotorTarget :: (this: *btConeTwistConstraint, q: btQuaternion) #no_context {
        setMotorTarget(this, *q);
    }
    getMotorTarget :: (this: *btConeTwistConstraint) -> *btQuaternion #cpp_method #foreign bullet3 "?getMotorTarget@btConeTwistConstraint@@QEBAAEBVbtQuaternion@@XZ";

    // same as above, but q is the desired rotation of frameA wrt frameB in constraint space
    setMotorTargetInConstraintSpace :: (this: *btConeTwistConstraint, q: *btQuaternion) -> void #cpp_method #foreign bullet3 "?setMotorTargetInConstraintSpace@btConeTwistConstraint@@QEAAXAEBVbtQuaternion@@@Z";
    setMotorTargetInConstraintSpace :: (this: *btConeTwistConstraint, q: btQuaternion) #no_context {
        setMotorTargetInConstraintSpace(this, *q);
    }

    GetPointForAngle :: (this: *btConeTwistConstraint, fAngleInRadians: btScalar, fLength: btScalar) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?GetPointForAngle@btConeTwistConstraint@@QEBA?AVbtVector3@@MM@Z";

    getFrameOffsetA :: (this: *btConeTwistConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btConeTwistConstraint@@QEBAAEBVbtTransform@@XZ";

    getFrameOffsetB :: (this: *btConeTwistConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btConeTwistConstraint@@QEBAAEBVbtTransform@@XZ";

    getFlags :: (this: *btConeTwistConstraint) -> s32 #cpp_method #foreign bullet3 "?getFlags@btConeTwistConstraint@@QEBAHXZ";
    #place bttypedconstraint; btconetwistconstraint_vtable: *btConeTwistConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_buildJacobian :: (this: *btConeTwistConstraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btConeTwistConstraint@@UEAAXXZ";

    virtual_getInfo1 :: (this: *btConeTwistConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btConeTwistConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    virtual_getInfo2 :: (this: *btConeTwistConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btConeTwistConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    virtual_solveConstraintObsolete :: (this: *btConeTwistConstraint, bodyA: *btSolverBody, bodyB: *btSolverBody, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?solveConstraintObsolete@btConeTwistConstraint@@UEAAXAEAUbtSolverBody@@0M@Z";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *btConeTwistConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btConeTwistConstraint@@UEAAXHMH@Z";

    virtual_setFrames :: (this: *btConeTwistConstraint, frameA: *btTransform, frameB: *btTransform) -> void #cpp_method #foreign bullet3 "?setFrames@btConeTwistConstraint@@UEAAXAEBVbtTransform@@0@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *btConeTwistConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btConeTwistConstraint@@UEBAMHH@Z";

    //
    virtual_calculateSerializeBufferSize :: (this: *btConeTwistConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btConeTwistConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btConeTwistConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btConeTwistConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btConeTwistConstraint_VTable :: struct #type_info_none {
    using bttypedconstraint: btTypedConstraint_VTable;
    setFrames: (this: *btConeTwistConstraint, frameA: *btTransform, frameB: *btTransform) -> void #cpp_method;
}
btConeTwistConstraint_setFrames :: inline (this: *btConeTwistConstraint, frameA: *btTransform, frameB: *btTransform) { this.btconetwistconstraint_vtable.setFrames(this, frameA, frameB); }

vtable :: (obj: *btConeTwistConstraint) -> *btConeTwistConstraint_VTable { return obj.btconetwistconstraint_vtable; }



btConeTwistConstraintDoubleData :: struct {
    m_typeConstraintData: btTypedConstraintDoubleData;
    m_rbAFrame:           btTransformDoubleData;
    m_rbBFrame:           btTransformDoubleData;

    //limits
    m_swingSpan1:         float64;
    m_swingSpan2:         float64;
    m_twistSpan:          float64;
    m_limitSoftness:      float64;
    m_biasFactor:         float64;
    m_relaxationFactor:   float64;

    m_damping:            float64;
}

///this structure is not used, except for loading pre-2.82 .bullet files
btConeTwistConstraintData :: struct {
    m_typeConstraintData: btTypedConstraintData;
    m_rbAFrame:           btTransformFloatData;
    m_rbBFrame:           btTransformFloatData;

    //limits
    m_swingSpan1:         float;
    m_swingSpan2:         float;
    m_twistSpan:          float;
    m_limitSoftness:      float;
    m_biasFactor:         float;
    m_relaxationFactor:   float;

    m_damping:            float;

    m_pad:                [4] u8;
}

//! Rotation Limit structure for generic joints
btRotationalLimitMotor :: struct {
    m_loLimit:            btScalar; //!< joint limit
    m_hiLimit:            btScalar; //!< joint limit
    m_targetVelocity:     btScalar; //!< target motor velocity
    m_maxMotorForce:      btScalar; //!< max force on motor
    m_maxLimitForce:      btScalar; //!< max force on limit
    m_damping:            btScalar; //!< Damping.
    m_limitSoftness:      btScalar;
    m_normalCFM:          btScalar; //!< Constraint force mixing factor
    m_stopERP:            btScalar; //!< Error tolerance factor when joint is at limit
    m_stopCFM:            btScalar; //!< Constraint force mixing factor when joint is at limit
    m_bounce:             btScalar; //!< restitution factor
    m_enableMotor:        bool;

    //! temp_variables
    //!@{
    m_currentLimitError:  btScalar;
    //!  How much is violated this limit
    m_currentPosition:    btScalar;
    m_currentLimit:       s32; //!< 0=free, 1=at lo limit, 2=at hi limit
    m_accumulatedImpulse: btScalar;

    //!@}
    Constructor :: (this: *btRotationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0btRotationalLimitMotor@@QEAA@XZ";

    CopyConstructor :: (this: *btRotationalLimitMotor, limot: *btRotationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0btRotationalLimitMotor@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btRotationalLimitMotor, limot: btRotationalLimitMotor) #no_context {
        CopyConstructor(this, *limot);
    }

    //! Is limited
    isLimited :: (this: *btRotationalLimitMotor) -> bool #cpp_method #foreign bullet3 "?isLimited@btRotationalLimitMotor@@QEBA_NXZ";

    //! Need apply correction
    needApplyTorques :: (this: *btRotationalLimitMotor) -> bool #cpp_method #foreign bullet3 "?needApplyTorques@btRotationalLimitMotor@@QEBA_NXZ";

    //! calculates  error
    /*!
    calculates m_currentLimit and m_currentLimitError.
    */
    testLimitValue :: (this: *btRotationalLimitMotor, test_value: btScalar) -> s32 #cpp_method #foreign bullet3 "?testLimitValue@btRotationalLimitMotor@@QEAAHM@Z";

    //! apply the correction impulses for two bodies
    solveAngularLimits :: (this: *btRotationalLimitMotor, timeStep: btScalar, axis: *btVector3, jacDiagABInv: btScalar, body0: *btRigidBody, body1: *btRigidBody) -> btScalar #cpp_method #foreign bullet3 "?solveAngularLimits@btRotationalLimitMotor@@QEAAMMAEAVbtVector3@@MPEAVbtRigidBody@@1@Z";
}

btTranslationalLimitMotor :: struct {
    m_lowerLimit:         btVector3; //!< the constraint lower limits
    m_upperLimit:         btVector3; //!< the constraint upper limits
    m_accumulatedImpulse: btVector3;

    m_limitSoftness:      btScalar; //!< Softness for linear limit
    m_damping:            btScalar; //!< Damping for linear limit
    m_restitution:        btScalar;
    m_normalCFM:          btVector3 #align 8; //!< Constraint force mixing factor
    m_stopERP:            btVector3; //!< Error tolerance factor when joint is at limit
    m_stopCFM:            btVector3; //!< Constraint force mixing factor when joint is at limit

    //!@}
    m_enableMotor:        [3] bool;
    m_targetVelocity:     btVector3; //!< target motor velocity
    m_maxMotorForce:      btVector3; //!< max force on motor
    m_currentLimitError:  btVector3;
    //!  How much is violated this limit
    m_currentLinearDiff:  btVector3;
    m_currentLimit:       [3] s32; //!< 0=free, 1=at lower limit, 2=at upper limit

    Constructor :: (this: *btTranslationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0btTranslationalLimitMotor@@QEAA@XZ";

    CopyConstructor :: (this: *btTranslationalLimitMotor, other: *btTranslationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0btTranslationalLimitMotor@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btTranslationalLimitMotor, other: btTranslationalLimitMotor) #no_context {
        CopyConstructor(this, *other);
    }

    //! Test limit
    /*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
    isLimited :: (this: *btTranslationalLimitMotor, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?isLimited@btTranslationalLimitMotor@@QEBA_NH@Z";

    needApplyForce :: (this: *btTranslationalLimitMotor, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?needApplyForce@btTranslationalLimitMotor@@QEBA_NH@Z";

    testLimitValue :: (this: *btTranslationalLimitMotor, limitIndex: s32, test_value: btScalar) -> s32 #cpp_method #foreign bullet3 "?testLimitValue@btTranslationalLimitMotor@@QEAAHHM@Z";

    solveLinearAxis :: (this: *btTranslationalLimitMotor, timeStep: btScalar, jacDiagABInv: btScalar, body1: *btRigidBody, pointInA: *btVector3, body2: *btRigidBody, pointInB: *btVector3, limit_index: s32, axis_normal_on_a: *btVector3, anchorPos: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?solveLinearAxis@btTranslationalLimitMotor@@QEAAMMMAEAVbtRigidBody@@AEBVbtVector3@@01H11@Z";
    solveLinearAxis :: (this: *btTranslationalLimitMotor, timeStep: btScalar, jacDiagABInv: btScalar, body1: *btRigidBody, pointInA: btVector3, body2: *btRigidBody, pointInB: btVector3, limit_index: s32, axis_normal_on_a: btVector3, anchorPos: btVector3) -> btScalar #no_context {
        return solveLinearAxis(this, timeStep, jacDiagABInv, body1, *pointInA, body2, *pointInB, limit_index, *axis_normal_on_a, *anchorPos);
    }
}

bt6DofFlags :: enum s32 {
    CFM_NORM :: 1;
    CFM_STOP :: 2;
    ERP_STOP :: 4;

    BT_6DOF_FLAGS_CFM_NORM :: CFM_NORM;
    BT_6DOF_FLAGS_CFM_STOP :: CFM_STOP;
    BT_6DOF_FLAGS_ERP_STOP :: ERP_STOP;
}

/// btGeneric6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/*!
btGeneric6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
currently this limit supports rotational motors<br>
<ul>
<li> For Linear limits, use btGeneric6DofConstraint.setLinearUpperLimit, btGeneric6DofConstraint.setLinearLowerLimit. You can set the parameters with the btTranslationalLimitMotor structure accsesible through the btGeneric6DofConstraint.getTranslationalLimitMotor method.
At this moment translational motors are not supported. May be in the future. </li>

<li> For Angular limits, use the btRotationalLimitMotor structure for configuring the limit.
This is accessible through btGeneric6DofConstraint.getLimitMotor method,
This brings support for limit parameters and motors. </li>

<li> Angulars limits have these possible ranges:
<table border=1 >
<tr>
<td><b>AXIS</b></td>
<td><b>MIN ANGLE</b></td>
<td><b>MAX ANGLE</b></td>
</tr><tr>
<td>X</td>
<td>-PI</td>
<td>PI</td>
</tr><tr>
<td>Y</td>
<td>-PI/2</td>
<td>PI/2</td>
</tr><tr>
<td>Z</td>
<td>-PI</td>
<td>PI</td>
</tr>
</table>
</li>
</ul>

*/
btGeneric6DofConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_frameInA:                    btTransform; //!< the constraint space w.r.t body A
    m_frameInB:                    btTransform; //!< the constraint space w.r.t body B

    m_jacLinear:                   [3] btJacobianEntry; //!< 3 orthogonal linear constraints
    m_jacAng:                      [3] btJacobianEntry; //!< 3 orthogonal angular constraints

    //! Linear_Limit_parameters
    //!@{
    m_linearLimits:                btTranslationalLimitMotor;

    //! hinge_parameters
    //!@{
    m_angularLimits:               [3] btRotationalLimitMotor;

    //! temporal variables
    //!@{
    m_timeStep:                    btScalar;
    m_calculatedTransformA:        btTransform;
    m_calculatedTransformB:        btTransform;
    m_calculatedAxisAngleDiff:     btVector3;
    m_calculatedAxis:              [3] btVector3;
    m_calculatedLinearDiff:        btVector3;
    m_factA:                       btScalar;
    m_factB:                       btScalar;
    m_hasStaticBody:               bool;

    m_AnchorPos:                   btVector3 #align 8; // point betwen pivots of bodies A and B to solve linear axes

    m_useLinearReferenceFrameA:    bool;
    m_useOffsetForConstraintFrame: bool;

    m_flags:                       s32;

    setAngularLimits :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2, row_offset: s32, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3) -> s32 #cpp_method #foreign bullet3 "?setAngularLimits@btGeneric6DofConstraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z";
    setAngularLimits :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2, row_offset: s32, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3) -> s32 #no_context {
        return setAngularLimits(this, info, row_offset, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }

    setLinearLimits :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2, row: s32, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3) -> s32 #cpp_method #foreign bullet3 "?setLinearLimits@btGeneric6DofConstraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z";
    setLinearLimits :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2, row: s32, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3) -> s32 #no_context {
        return setLinearLimits(this, info, row, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }

    buildLinearJacobian :: (this: *btGeneric6DofConstraint, jacLinear: *btJacobianEntry, normalWorld: *btVector3, pivotAInW: *btVector3, pivotBInW: *btVector3) -> void #cpp_method #foreign bullet3 "?buildLinearJacobian@btGeneric6DofConstraint@@IEAAXAEAVbtJacobianEntry@@AEBVbtVector3@@11@Z";
    buildLinearJacobian :: (this: *btGeneric6DofConstraint, jacLinear: *btJacobianEntry, normalWorld: btVector3, pivotAInW: btVector3, pivotBInW: btVector3) #no_context {
        buildLinearJacobian(this, jacLinear, *normalWorld, *pivotAInW, *pivotBInW);
    }

    buildAngularJacobian :: (this: *btGeneric6DofConstraint, jacAngular: *btJacobianEntry, jointAxisW: *btVector3) -> void #cpp_method #foreign bullet3 "?buildAngularJacobian@btGeneric6DofConstraint@@IEAAXAEAVbtJacobianEntry@@AEBVbtVector3@@@Z";
    buildAngularJacobian :: (this: *btGeneric6DofConstraint, jacAngular: *btJacobianEntry, jointAxisW: btVector3) #no_context {
        buildAngularJacobian(this, jacAngular, *jointAxisW);
    }

    // tests linear limits
    calculateLinearInfo :: (this: *btGeneric6DofConstraint) -> void #cpp_method #foreign bullet3 "?calculateLinearInfo@btGeneric6DofConstraint@@IEAAXXZ";

    //! calcs the euler angles between the two bodies.
    calculateAngleInfo :: (this: *btGeneric6DofConstraint) -> void #cpp_method #foreign bullet3 "?calculateAngleInfo@btGeneric6DofConstraint@@IEAAXXZ";

    ///for backwards compatibility during the transition to 'getInfo/getInfo2'
    m_useSolveConstraintObsolete:  bool;

    Constructor :: (this: *btGeneric6DofConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: *btTransform, frameInB: *btTransform, useLinearReferenceFrameA: bool) -> void #cpp_method #foreign bullet3 "??0btGeneric6DofConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z";
    Constructor :: (this: *btGeneric6DofConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: btTransform, frameInB: btTransform, useLinearReferenceFrameA: bool) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB, useLinearReferenceFrameA);
    }
    Constructor :: (this: *btGeneric6DofConstraint, rbB: *btRigidBody, frameInB: *btTransform, useLinearReferenceFrameB: bool) -> void #cpp_method #foreign bullet3 "??0btGeneric6DofConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z";
    Constructor :: (this: *btGeneric6DofConstraint, rbB: *btRigidBody, frameInB: btTransform, useLinearReferenceFrameB: bool) #no_context {
        Constructor(this, rbB, *frameInB, useLinearReferenceFrameB);
    }

    //! Calcs global transform of the offsets
    /*!
    Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
    \sa btGeneric6DofConstraint.getCalculatedTransformA , btGeneric6DofConstraint.getCalculatedTransformB, btGeneric6DofConstraint.calculateAngleInfo
    */
    calculateTransforms :: (this: *btGeneric6DofConstraint, transA: *btTransform, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?calculateTransforms@btGeneric6DofConstraint@@QEAAXAEBVbtTransform@@0@Z";
    calculateTransforms :: (this: *btGeneric6DofConstraint, transA: btTransform, transB: btTransform) #no_context {
        calculateTransforms(this, *transA, *transB);
    }

    calculateTransforms :: (this: *btGeneric6DofConstraint) -> void #cpp_method #foreign bullet3 "?calculateTransforms@btGeneric6DofConstraint@@QEAAXXZ";

    //! Gets the global transform of the offset for body A
    /*!
    \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
    getCalculatedTransformA :: (this: *btGeneric6DofConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getCalculatedTransformA@btGeneric6DofConstraint@@QEBAAEBVbtTransform@@XZ";

    //! Gets the global transform of the offset for body B
    /*!
    \sa btGeneric6DofConstraint.getFrameOffsetA, btGeneric6DofConstraint.getFrameOffsetB, btGeneric6DofConstraint.calculateAngleInfo.
    */
    getCalculatedTransformB :: (this: *btGeneric6DofConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getCalculatedTransformB@btGeneric6DofConstraint@@QEBAAEBVbtTransform@@XZ";

    getFrameOffsetA :: (this: /*const*/ *btGeneric6DofConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btGeneric6DofConstraint@@QEBAAEBVbtTransform@@XZ";

    getFrameOffsetB :: (this: /*const*/ *btGeneric6DofConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btGeneric6DofConstraint@@QEBAAEBVbtTransform@@XZ";

    getFrameOffsetA_1 :: (this: *btGeneric6DofConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btGeneric6DofConstraint@@QEAAAEAVbtTransform@@XZ";

    getFrameOffsetB_1 :: (this: *btGeneric6DofConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btGeneric6DofConstraint@@QEAAAEAVbtTransform@@XZ";

    getInfo1NonVirtual :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@btGeneric6DofConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    getInfo2NonVirtual :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@btGeneric6DofConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@222@Z";
    getInfo2NonVirtual :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3) #no_context {
        getInfo2NonVirtual(this, info, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }

    updateRHS :: (this: *btGeneric6DofConstraint, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateRHS@btGeneric6DofConstraint@@QEAAXM@Z";

    //! Get the rotation axis in global coordinates
    /*!
    \pre btGeneric6DofConstraint.buildJacobian must be called previously.
    */
    getAxis :: (this: *btGeneric6DofConstraint, axis_index: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAxis@btGeneric6DofConstraint@@QEBA?AVbtVector3@@H@Z";

    //! Get the relative Euler angle
    /*!
    \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    */
    getAngle :: (this: *btGeneric6DofConstraint, axis_index: s32) -> btScalar #cpp_method #foreign bullet3 "?getAngle@btGeneric6DofConstraint@@QEBAMH@Z";

    //! Get the relative position of the constraint pivot
    /*!
    \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    */
    getRelativePivotPosition :: (this: *btGeneric6DofConstraint, axis_index: s32) -> btScalar #cpp_method #foreign bullet3 "?getRelativePivotPosition@btGeneric6DofConstraint@@QEBAMH@Z";

    setFrames :: (this: *btGeneric6DofConstraint, frameA: *btTransform, frameB: *btTransform) -> void #cpp_method #foreign bullet3 "?setFrames@btGeneric6DofConstraint@@QEAAXAEBVbtTransform@@0@Z";
    setFrames :: (this: *btGeneric6DofConstraint, frameA: btTransform, frameB: btTransform) #no_context {
        setFrames(this, *frameA, *frameB);
    }

    //! Test angular limit.
    /*!
    Calculates angular correction and returns true if limit needs to be corrected.
    \pre btGeneric6DofConstraint::calculateTransforms() must be called previously.
    */
    testAngularLimitMotor :: (this: *btGeneric6DofConstraint, axis_index: s32) -> bool #cpp_method #foreign bullet3 "?testAngularLimitMotor@btGeneric6DofConstraint@@QEAA_NH@Z";

    setLinearLowerLimit :: (this: *btGeneric6DofConstraint, linearLower: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearLowerLimit@btGeneric6DofConstraint@@QEAAXAEBVbtVector3@@@Z";
    setLinearLowerLimit :: (this: *btGeneric6DofConstraint, linearLower: btVector3) #no_context {
        setLinearLowerLimit(this, *linearLower);
    }

    getLinearLowerLimit :: (this: *btGeneric6DofConstraint, linearLower: *btVector3) -> void #cpp_method #foreign bullet3 "?getLinearLowerLimit@btGeneric6DofConstraint@@QEBAXAEAVbtVector3@@@Z";

    setLinearUpperLimit :: (this: *btGeneric6DofConstraint, linearUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearUpperLimit@btGeneric6DofConstraint@@QEAAXAEBVbtVector3@@@Z";
    setLinearUpperLimit :: (this: *btGeneric6DofConstraint, linearUpper: btVector3) #no_context {
        setLinearUpperLimit(this, *linearUpper);
    }

    getLinearUpperLimit :: (this: *btGeneric6DofConstraint, linearUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?getLinearUpperLimit@btGeneric6DofConstraint@@QEBAXAEAVbtVector3@@@Z";

    setAngularLowerLimit :: (this: *btGeneric6DofConstraint, angularLower: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularLowerLimit@btGeneric6DofConstraint@@QEAAXAEBVbtVector3@@@Z";
    setAngularLowerLimit :: (this: *btGeneric6DofConstraint, angularLower: btVector3) #no_context {
        setAngularLowerLimit(this, *angularLower);
    }

    getAngularLowerLimit :: (this: *btGeneric6DofConstraint, angularLower: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularLowerLimit@btGeneric6DofConstraint@@QEBAXAEAVbtVector3@@@Z";

    setAngularUpperLimit :: (this: *btGeneric6DofConstraint, angularUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularUpperLimit@btGeneric6DofConstraint@@QEAAXAEBVbtVector3@@@Z";
    setAngularUpperLimit :: (this: *btGeneric6DofConstraint, angularUpper: btVector3) #no_context {
        setAngularUpperLimit(this, *angularUpper);
    }

    getAngularUpperLimit :: (this: *btGeneric6DofConstraint, angularUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularUpperLimit@btGeneric6DofConstraint@@QEBAXAEAVbtVector3@@@Z";

    //! Retrieves the angular limit informacion
    getRotationalLimitMotor :: (this: *btGeneric6DofConstraint, index: s32) -> *btRotationalLimitMotor #cpp_method #foreign bullet3 "?getRotationalLimitMotor@btGeneric6DofConstraint@@QEAAPEAVbtRotationalLimitMotor@@H@Z";

    //! Retrieves the  limit informacion
    getTranslationalLimitMotor :: (this: *btGeneric6DofConstraint) -> *btTranslationalLimitMotor #cpp_method #foreign bullet3 "?getTranslationalLimitMotor@btGeneric6DofConstraint@@QEAAPEAVbtTranslationalLimitMotor@@XZ";

    //first 3 are linear, next 3 are angular
    setLimit :: (this: *btGeneric6DofConstraint, axis: s32, lo: btScalar, hi: btScalar) -> void #cpp_method #foreign bullet3 "?setLimit@btGeneric6DofConstraint@@QEAAXHMM@Z";

    //! Test limit
    /*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
    isLimited :: (this: *btGeneric6DofConstraint, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?isLimited@btGeneric6DofConstraint@@QEBA_NH@Z";

    get_limit_motor_info2 :: (this: *btGeneric6DofConstraint, limot: *btRotationalLimitMotor, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3, info: *btTypedConstraint.btConstraintInfo2, row: s32, ax1: *btVector3, rotational: s32, rotAllowed: s32 = 0) -> s32 #cpp_method #foreign bullet3 "?get_limit_motor_info2@btGeneric6DofConstraint@@QEAAHPEAVbtRotationalLimitMotor@@AEBVbtTransform@@1AEBVbtVector3@@222PEAUbtConstraintInfo2@btTypedConstraint@@HAEAV4@HH@Z";
    get_limit_motor_info2 :: (this: *btGeneric6DofConstraint, limot: *btRotationalLimitMotor, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3, info: *btTypedConstraint.btConstraintInfo2, row: s32, ax1: *btVector3, rotational: s32, rotAllowed: s32 = 0) -> s32 #no_context {
        return get_limit_motor_info2(this, limot, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB, info, row, ax1, rotational, rotAllowed);
    }

    // access for UseFrameOffset
    getUseFrameOffset :: (this: *btGeneric6DofConstraint) -> bool #cpp_method #foreign bullet3 "?getUseFrameOffset@btGeneric6DofConstraint@@QEBA_NXZ";
    setUseFrameOffset :: (this: *btGeneric6DofConstraint, frameOffsetOnOff: bool) -> void #cpp_method #foreign bullet3 "?setUseFrameOffset@btGeneric6DofConstraint@@QEAAX_N@Z";

    getUseLinearReferenceFrameA :: (this: *btGeneric6DofConstraint) -> bool #cpp_method #foreign bullet3 "?getUseLinearReferenceFrameA@btGeneric6DofConstraint@@QEBA_NXZ";
    setUseLinearReferenceFrameA :: (this: *btGeneric6DofConstraint, linearReferenceFrameA: bool) -> void #cpp_method #foreign bullet3 "?setUseLinearReferenceFrameA@btGeneric6DofConstraint@@QEAAX_N@Z";

    setAxis :: (this: *btGeneric6DofConstraint, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxis@btGeneric6DofConstraint@@QEAAXAEBVbtVector3@@0@Z";
    setAxis :: (this: *btGeneric6DofConstraint, axis1: btVector3, axis2: btVector3) #no_context {
        setAxis(this, *axis1, *axis2);
    }
    #place bttypedconstraint; btgeneric6dofconstraint_vtable: *btGeneric6DofConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //! performs Jacobian calculation, and also calculates angle differences and axis
    virtual_buildJacobian :: (this: *btGeneric6DofConstraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btGeneric6DofConstraint@@UEAAXXZ";

    virtual_getInfo1 :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btGeneric6DofConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    virtual_getInfo2 :: (this: *btGeneric6DofConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btGeneric6DofConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    virtual_calcAnchorPos :: (this: *btGeneric6DofConstraint) -> void #cpp_method #foreign bullet3 "?calcAnchorPos@btGeneric6DofConstraint@@UEAAXXZ";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *btGeneric6DofConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btGeneric6DofConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *btGeneric6DofConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btGeneric6DofConstraint@@UEBAMHH@Z";

    virtual_getFlags :: (this: *btGeneric6DofConstraint) -> s32 #cpp_method #foreign bullet3 "?getFlags@btGeneric6DofConstraint@@UEBAHXZ";

    virtual_calculateSerializeBufferSize :: (this: *btGeneric6DofConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btGeneric6DofConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btGeneric6DofConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btGeneric6DofConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btGeneric6DofConstraint_VTable :: struct #type_info_none {
    using bttypedconstraint: btTypedConstraint_VTable;
    calcAnchorPos: (this: *btGeneric6DofConstraint) -> void #cpp_method;

    getFlags: (this: *btGeneric6DofConstraint) -> s32 #cpp_method;
}

btGeneric6DofConstraint_calcAnchorPos :: inline (this: *btGeneric6DofConstraint) { this.btgeneric6dofconstraint_vtable.calcAnchorPos(this); }

btGeneric6DofConstraint_getFlags :: inline (this: *btGeneric6DofConstraint) -> s32 { return this.btgeneric6dofconstraint_vtable.getFlags(this); }

vtable :: (obj: *btGeneric6DofConstraint) -> *btGeneric6DofConstraint_VTable { return obj.btgeneric6dofconstraint_vtable; }


//!@}
operator_assign :: (this: *btGeneric6DofConstraint, other: *btGeneric6DofConstraint) -> *btGeneric6DofConstraint #cpp_method #foreign bullet3 "??4btGeneric6DofConstraint@@IEAAAEAV0@AEAV0@@Z";


btGeneric6DofConstraintData :: struct {
    m_typeConstraintData:          btTypedConstraintData;
    m_rbAFrame:                    btTransformFloatData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:                    btTransformFloatData;

    m_linearUpperLimit:            btVector3FloatData;
    m_linearLowerLimit:            btVector3FloatData;

    m_angularUpperLimit:           btVector3FloatData;
    m_angularLowerLimit:           btVector3FloatData;

    m_useLinearReferenceFrameA:    s32;
    m_useOffsetForConstraintFrame: s32;
}

btGeneric6DofConstraintDoubleData2 :: struct {
    m_typeConstraintData:          btTypedConstraintDoubleData;
    m_rbAFrame:                    btTransformDoubleData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:                    btTransformDoubleData;

    m_linearUpperLimit:            btVector3DoubleData;
    m_linearLowerLimit:            btVector3DoubleData;

    m_angularUpperLimit:           btVector3DoubleData;
    m_angularLowerLimit:           btVector3DoubleData;

    m_useLinearReferenceFrameA:    s32;
    m_useOffsetForConstraintFrame: s32;
}

btSliderFlags :: enum s32 {
    CFM_DIRLIN :: 1;
    ERP_DIRLIN :: 2;
    CFM_DIRANG :: 4;
    ERP_DIRANG :: 8;
    CFM_ORTLIN :: 16;
    ERP_ORTLIN :: 32;
    CFM_ORTANG :: 64;
    ERP_ORTANG :: 128;
    CFM_LIMLIN :: 256;
    ERP_LIMLIN :: 512;
    CFM_LIMANG :: 1024;
    ERP_LIMANG :: 2048;

    BT_SLIDER_FLAGS_CFM_DIRLIN :: CFM_DIRLIN;
    BT_SLIDER_FLAGS_ERP_DIRLIN :: ERP_DIRLIN;
    BT_SLIDER_FLAGS_CFM_DIRANG :: CFM_DIRANG;
    BT_SLIDER_FLAGS_ERP_DIRANG :: ERP_DIRANG;
    BT_SLIDER_FLAGS_CFM_ORTLIN :: CFM_ORTLIN;
    BT_SLIDER_FLAGS_ERP_ORTLIN :: ERP_ORTLIN;
    BT_SLIDER_FLAGS_CFM_ORTANG :: CFM_ORTANG;
    BT_SLIDER_FLAGS_ERP_ORTANG :: ERP_ORTANG;
    BT_SLIDER_FLAGS_CFM_LIMLIN :: CFM_LIMLIN;
    BT_SLIDER_FLAGS_ERP_LIMLIN :: ERP_LIMLIN;
    BT_SLIDER_FLAGS_CFM_LIMANG :: CFM_LIMANG;
    BT_SLIDER_FLAGS_ERP_LIMANG :: ERP_LIMANG;
}

btSliderConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    ///for backwards compatibility during the transition to 'getInfo/getInfo2'
    m_useSolveConstraintObsolete:  bool;
    m_useOffsetForConstraintFrame: bool;
    m_frameInA:                    btTransform #align 8;
    m_frameInB:                    btTransform;

    // use frameA fo define limits, if true
    m_useLinearReferenceFrameA:    bool;

    // linear limits
    m_lowerLinLimit:               btScalar;
    m_upperLinLimit:               btScalar;

    // angular limits
    m_lowerAngLimit:               btScalar;
    m_upperAngLimit:               btScalar;

    // softness, restitution and damping for different cases
    // DirLin - moving inside linear limits
    // LimLin - hitting linear limit
    // DirAng - moving inside angular limits
    // LimAng - hitting angular limit
    // OrthoLin, OrthoAng - against constraint axis
    m_softnessDirLin:              btScalar;
    m_restitutionDirLin:           btScalar;
    m_dampingDirLin:               btScalar;
    m_cfmDirLin:                   btScalar;

    m_softnessDirAng:              btScalar;
    m_restitutionDirAng:           btScalar;
    m_dampingDirAng:               btScalar;
    m_cfmDirAng:                   btScalar;

    m_softnessLimLin:              btScalar;
    m_restitutionLimLin:           btScalar;
    m_dampingLimLin:               btScalar;
    m_cfmLimLin:                   btScalar;

    m_softnessLimAng:              btScalar;
    m_restitutionLimAng:           btScalar;
    m_dampingLimAng:               btScalar;
    m_cfmLimAng:                   btScalar;

    m_softnessOrthoLin:            btScalar;
    m_restitutionOrthoLin:         btScalar;
    m_dampingOrthoLin:             btScalar;
    m_cfmOrthoLin:                 btScalar;

    m_softnessOrthoAng:            btScalar;
    m_restitutionOrthoAng:         btScalar;
    m_dampingOrthoAng:             btScalar;
    m_cfmOrthoAng:                 btScalar;

    // for interlal use
    m_solveLinLim:                 bool;
    m_solveAngLim:                 bool;

    m_flags:                       s32;

    m_jacLin:                      [3] btJacobianEntry #align 8;
    m_jacLinDiagABInv:             [3] btScalar;

    m_jacAng:                      [3] btJacobianEntry #align 8;

    m_timeStep:                    btScalar;
    m_calculatedTransformA:        btTransform;
    m_calculatedTransformB:        btTransform;

    m_sliderAxis:                  btVector3;
    m_realPivotAInW:               btVector3;
    m_realPivotBInW:               btVector3;
    m_projPivotInW:                btVector3;
    m_delta:                       btVector3;
    m_depth:                       btVector3;
    m_relPosA:                     btVector3;
    m_relPosB:                     btVector3;

    m_linPos:                      btScalar;
    m_angPos:                      btScalar;

    m_angDepth:                    btScalar;
    m_kAngle:                      btScalar;

    m_poweredLinMotor:             bool;
    m_targetLinMotorVelocity:      btScalar;
    m_maxLinMotorForce:            btScalar;
    m_accumulatedLinMotorImpulse:  btScalar;

    m_poweredAngMotor:             bool;
    m_targetAngMotorVelocity:      btScalar;
    m_maxAngMotorForce:            btScalar;
    m_accumulatedAngMotorImpulse:  btScalar;

    //------------------------
    initParams :: (this: *btSliderConstraint) -> void #cpp_method #foreign bullet3 "?initParams@btSliderConstraint@@IEAAXXZ";

    // constructors
    Constructor :: (this: *btSliderConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: *btTransform, frameInB: *btTransform, useLinearReferenceFrameA: bool) -> void #cpp_method #foreign bullet3 "??0btSliderConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z";
    Constructor :: (this: *btSliderConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: btTransform, frameInB: btTransform, useLinearReferenceFrameA: bool) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB, useLinearReferenceFrameA);
    }
    Constructor :: (this: *btSliderConstraint, rbB: *btRigidBody, frameInB: *btTransform, useLinearReferenceFrameA: bool) -> void #cpp_method #foreign bullet3 "??0btSliderConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z";
    Constructor :: (this: *btSliderConstraint, rbB: *btRigidBody, frameInB: btTransform, useLinearReferenceFrameA: bool) #no_context {
        Constructor(this, rbB, *frameInB, useLinearReferenceFrameA);
    }

    getInfo1NonVirtual :: (this: *btSliderConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@btSliderConstraint@@QEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    getInfo2NonVirtual :: (this: *btSliderConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, rbAinvMass: btScalar, rbBinvMass: btScalar) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@btSliderConstraint@@QEAAXPEAUbtConstraintInfo2@btTypedConstraint@@AEBVbtTransform@@1AEBVbtVector3@@2MM@Z";
    getInfo2NonVirtual :: (this: *btSliderConstraint, info: *btTypedConstraint.btConstraintInfo2, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, rbAinvMass: btScalar, rbBinvMass: btScalar) #no_context {
        getInfo2NonVirtual(this, info, *transA, *transB, *linVelA, *linVelB, rbAinvMass, rbBinvMass);
    }

    // access
    getRigidBodyA :: (this: *btSliderConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyA@btSliderConstraint@@QEBAAEBVbtRigidBody@@XZ";
    getRigidBodyB :: (this: *btSliderConstraint) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBodyB@btSliderConstraint@@QEBAAEBVbtRigidBody@@XZ";
    getCalculatedTransformA :: (this: *btSliderConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getCalculatedTransformA@btSliderConstraint@@QEBAAEBVbtTransform@@XZ";
    getCalculatedTransformB :: (this: *btSliderConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getCalculatedTransformB@btSliderConstraint@@QEBAAEBVbtTransform@@XZ";
    getFrameOffsetA :: (this: /*const*/ *btSliderConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btSliderConstraint@@QEBAAEBVbtTransform@@XZ";
    getFrameOffsetB :: (this: /*const*/ *btSliderConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btSliderConstraint@@QEBAAEBVbtTransform@@XZ";
    getFrameOffsetA_1 :: (this: *btSliderConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btSliderConstraint@@QEAAAEAVbtTransform@@XZ";
    getFrameOffsetB_1 :: (this: *btSliderConstraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btSliderConstraint@@QEAAAEAVbtTransform@@XZ";
    getLowerLinLimit :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLowerLinLimit@btSliderConstraint@@QEAAMXZ";
    setLowerLinLimit :: (this: *btSliderConstraint, lowerLimit: btScalar) -> void #cpp_method #foreign bullet3 "?setLowerLinLimit@btSliderConstraint@@QEAAXM@Z";
    getUpperLinLimit :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getUpperLinLimit@btSliderConstraint@@QEAAMXZ";
    setUpperLinLimit :: (this: *btSliderConstraint, upperLimit: btScalar) -> void #cpp_method #foreign bullet3 "?setUpperLinLimit@btSliderConstraint@@QEAAXM@Z";
    getLowerAngLimit :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLowerAngLimit@btSliderConstraint@@QEAAMXZ";
    setLowerAngLimit :: (this: *btSliderConstraint, lowerLimit: btScalar) -> void #cpp_method #foreign bullet3 "?setLowerAngLimit@btSliderConstraint@@QEAAXM@Z";
    getUpperAngLimit :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getUpperAngLimit@btSliderConstraint@@QEAAMXZ";
    setUpperAngLimit :: (this: *btSliderConstraint, upperLimit: btScalar) -> void #cpp_method #foreign bullet3 "?setUpperAngLimit@btSliderConstraint@@QEAAXM@Z";
    getUseLinearReferenceFrameA :: (this: *btSliderConstraint) -> bool #cpp_method #foreign bullet3 "?getUseLinearReferenceFrameA@btSliderConstraint@@QEAA_NXZ";
    getSoftnessDirLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSoftnessDirLin@btSliderConstraint@@QEAAMXZ";
    getRestitutionDirLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRestitutionDirLin@btSliderConstraint@@QEAAMXZ";
    getDampingDirLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDampingDirLin@btSliderConstraint@@QEAAMXZ";
    getSoftnessDirAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSoftnessDirAng@btSliderConstraint@@QEAAMXZ";
    getRestitutionDirAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRestitutionDirAng@btSliderConstraint@@QEAAMXZ";
    getDampingDirAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDampingDirAng@btSliderConstraint@@QEAAMXZ";
    getSoftnessLimLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSoftnessLimLin@btSliderConstraint@@QEAAMXZ";
    getRestitutionLimLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRestitutionLimLin@btSliderConstraint@@QEAAMXZ";
    getDampingLimLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDampingLimLin@btSliderConstraint@@QEAAMXZ";
    getSoftnessLimAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSoftnessLimAng@btSliderConstraint@@QEAAMXZ";
    getRestitutionLimAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRestitutionLimAng@btSliderConstraint@@QEAAMXZ";
    getDampingLimAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDampingLimAng@btSliderConstraint@@QEAAMXZ";
    getSoftnessOrthoLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSoftnessOrthoLin@btSliderConstraint@@QEAAMXZ";
    getRestitutionOrthoLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRestitutionOrthoLin@btSliderConstraint@@QEAAMXZ";
    getDampingOrthoLin :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDampingOrthoLin@btSliderConstraint@@QEAAMXZ";
    getSoftnessOrthoAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getSoftnessOrthoAng@btSliderConstraint@@QEAAMXZ";
    getRestitutionOrthoAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRestitutionOrthoAng@btSliderConstraint@@QEAAMXZ";
    getDampingOrthoAng :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getDampingOrthoAng@btSliderConstraint@@QEAAMXZ";
    setSoftnessDirLin :: (this: *btSliderConstraint, softnessDirLin: btScalar) -> void #cpp_method #foreign bullet3 "?setSoftnessDirLin@btSliderConstraint@@QEAAXM@Z";
    setRestitutionDirLin :: (this: *btSliderConstraint, restitutionDirLin: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitutionDirLin@btSliderConstraint@@QEAAXM@Z";
    setDampingDirLin :: (this: *btSliderConstraint, dampingDirLin: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingDirLin@btSliderConstraint@@QEAAXM@Z";
    setSoftnessDirAng :: (this: *btSliderConstraint, softnessDirAng: btScalar) -> void #cpp_method #foreign bullet3 "?setSoftnessDirAng@btSliderConstraint@@QEAAXM@Z";
    setRestitutionDirAng :: (this: *btSliderConstraint, restitutionDirAng: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitutionDirAng@btSliderConstraint@@QEAAXM@Z";
    setDampingDirAng :: (this: *btSliderConstraint, dampingDirAng: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingDirAng@btSliderConstraint@@QEAAXM@Z";
    setSoftnessLimLin :: (this: *btSliderConstraint, softnessLimLin: btScalar) -> void #cpp_method #foreign bullet3 "?setSoftnessLimLin@btSliderConstraint@@QEAAXM@Z";
    setRestitutionLimLin :: (this: *btSliderConstraint, restitutionLimLin: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitutionLimLin@btSliderConstraint@@QEAAXM@Z";
    setDampingLimLin :: (this: *btSliderConstraint, dampingLimLin: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingLimLin@btSliderConstraint@@QEAAXM@Z";
    setSoftnessLimAng :: (this: *btSliderConstraint, softnessLimAng: btScalar) -> void #cpp_method #foreign bullet3 "?setSoftnessLimAng@btSliderConstraint@@QEAAXM@Z";
    setRestitutionLimAng :: (this: *btSliderConstraint, restitutionLimAng: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitutionLimAng@btSliderConstraint@@QEAAXM@Z";
    setDampingLimAng :: (this: *btSliderConstraint, dampingLimAng: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingLimAng@btSliderConstraint@@QEAAXM@Z";
    setSoftnessOrthoLin :: (this: *btSliderConstraint, softnessOrthoLin: btScalar) -> void #cpp_method #foreign bullet3 "?setSoftnessOrthoLin@btSliderConstraint@@QEAAXM@Z";
    setRestitutionOrthoLin :: (this: *btSliderConstraint, restitutionOrthoLin: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitutionOrthoLin@btSliderConstraint@@QEAAXM@Z";
    setDampingOrthoLin :: (this: *btSliderConstraint, dampingOrthoLin: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingOrthoLin@btSliderConstraint@@QEAAXM@Z";
    setSoftnessOrthoAng :: (this: *btSliderConstraint, softnessOrthoAng: btScalar) -> void #cpp_method #foreign bullet3 "?setSoftnessOrthoAng@btSliderConstraint@@QEAAXM@Z";
    setRestitutionOrthoAng :: (this: *btSliderConstraint, restitutionOrthoAng: btScalar) -> void #cpp_method #foreign bullet3 "?setRestitutionOrthoAng@btSliderConstraint@@QEAAXM@Z";
    setDampingOrthoAng :: (this: *btSliderConstraint, dampingOrthoAng: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingOrthoAng@btSliderConstraint@@QEAAXM@Z";
    setPoweredLinMotor :: (this: *btSliderConstraint, onOff: bool) -> void #cpp_method #foreign bullet3 "?setPoweredLinMotor@btSliderConstraint@@QEAAX_N@Z";
    getPoweredLinMotor :: (this: *btSliderConstraint) -> bool #cpp_method #foreign bullet3 "?getPoweredLinMotor@btSliderConstraint@@QEAA_NXZ";
    setTargetLinMotorVelocity :: (this: *btSliderConstraint, targetLinMotorVelocity: btScalar) -> void #cpp_method #foreign bullet3 "?setTargetLinMotorVelocity@btSliderConstraint@@QEAAXM@Z";
    getTargetLinMotorVelocity :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getTargetLinMotorVelocity@btSliderConstraint@@QEAAMXZ";
    setMaxLinMotorForce :: (this: *btSliderConstraint, maxLinMotorForce: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxLinMotorForce@btSliderConstraint@@QEAAXM@Z";
    getMaxLinMotorForce :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getMaxLinMotorForce@btSliderConstraint@@QEAAMXZ";
    setPoweredAngMotor :: (this: *btSliderConstraint, onOff: bool) -> void #cpp_method #foreign bullet3 "?setPoweredAngMotor@btSliderConstraint@@QEAAX_N@Z";
    getPoweredAngMotor :: (this: *btSliderConstraint) -> bool #cpp_method #foreign bullet3 "?getPoweredAngMotor@btSliderConstraint@@QEAA_NXZ";
    setTargetAngMotorVelocity :: (this: *btSliderConstraint, targetAngMotorVelocity: btScalar) -> void #cpp_method #foreign bullet3 "?setTargetAngMotorVelocity@btSliderConstraint@@QEAAXM@Z";
    getTargetAngMotorVelocity :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getTargetAngMotorVelocity@btSliderConstraint@@QEAAMXZ";
    setMaxAngMotorForce :: (this: *btSliderConstraint, maxAngMotorForce: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxAngMotorForce@btSliderConstraint@@QEAAXM@Z";
    getMaxAngMotorForce :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getMaxAngMotorForce@btSliderConstraint@@QEAAMXZ";

    getLinearPos :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLinearPos@btSliderConstraint@@QEBAMXZ";
    getAngularPos :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getAngularPos@btSliderConstraint@@QEBAMXZ";

    // access for ODE solver
    getSolveLinLimit :: (this: *btSliderConstraint) -> bool #cpp_method #foreign bullet3 "?getSolveLinLimit@btSliderConstraint@@QEAA_NXZ";
    getLinDepth :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLinDepth@btSliderConstraint@@QEAAMXZ";
    getSolveAngLimit :: (this: *btSliderConstraint) -> bool #cpp_method #foreign bullet3 "?getSolveAngLimit@btSliderConstraint@@QEAA_NXZ";
    getAngDepth :: (this: *btSliderConstraint) -> btScalar #cpp_method #foreign bullet3 "?getAngDepth@btSliderConstraint@@QEAAMXZ";

    // shared code used by ODE solver
    calculateTransforms :: (this: *btSliderConstraint, transA: *btTransform, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?calculateTransforms@btSliderConstraint@@QEAAXAEBVbtTransform@@0@Z";
    calculateTransforms :: (this: *btSliderConstraint, transA: btTransform, transB: btTransform) #no_context {
        calculateTransforms(this, *transA, *transB);
    }
    testLinLimits :: (this: *btSliderConstraint) -> void #cpp_method #foreign bullet3 "?testLinLimits@btSliderConstraint@@QEAAXXZ";
    testAngLimits :: (this: *btSliderConstraint) -> void #cpp_method #foreign bullet3 "?testAngLimits@btSliderConstraint@@QEAAXXZ";

    // access for PE Solver
    getAncorInA :: (this: *btSliderConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAncorInA@btSliderConstraint@@QEAA?AVbtVector3@@XZ";
    getAncorInB :: (this: *btSliderConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAncorInB@btSliderConstraint@@QEAA?AVbtVector3@@XZ";

    // access for UseFrameOffset
    getUseFrameOffset :: (this: *btSliderConstraint) -> bool #cpp_method #foreign bullet3 "?getUseFrameOffset@btSliderConstraint@@QEAA_NXZ";
    setUseFrameOffset :: (this: *btSliderConstraint, frameOffsetOnOff: bool) -> void #cpp_method #foreign bullet3 "?setUseFrameOffset@btSliderConstraint@@QEAAX_N@Z";

    setFrames :: (this: *btSliderConstraint, frameA: *btTransform, frameB: *btTransform) -> void #cpp_method #foreign bullet3 "?setFrames@btSliderConstraint@@QEAAXAEBVbtTransform@@0@Z";
    setFrames :: (this: *btSliderConstraint, frameA: btTransform, frameB: btTransform) #no_context {
        setFrames(this, *frameA, *frameB);
    }
    #place bttypedconstraint; btsliderconstraint_vtable: *btSliderConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    // overrides
    virtual_getInfo1 :: (this: *btSliderConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btSliderConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    virtual_getInfo2 :: (this: *btSliderConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btSliderConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *btSliderConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btSliderConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *btSliderConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btSliderConstraint@@UEBAMHH@Z";

    virtual_getFlags :: (this: *btSliderConstraint) -> s32 #cpp_method #foreign bullet3 "?getFlags@btSliderConstraint@@UEBAHXZ";

    virtual_calculateSerializeBufferSize :: (this: *btSliderConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btSliderConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btSliderConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btSliderConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btSliderConstraint_VTable :: struct #type_info_none {
    using bttypedconstraint: btTypedConstraint_VTable;
    getFlags: (this: *btSliderConstraint) -> s32 #cpp_method;
}
btSliderConstraint_getFlags :: inline (this: *btSliderConstraint) -> s32 { return this.btsliderconstraint_vtable.getFlags(this); }

vtable :: (obj: *btSliderConstraint) -> *btSliderConstraint_VTable { return obj.btsliderconstraint_vtable; }



///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btSliderConstraintData :: struct {
    m_typeConstraintData:          btTypedConstraintData;
    m_rbAFrame:                    btTransformFloatData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:                    btTransformFloatData;

    m_linearUpperLimit:            float;
    m_linearLowerLimit:            float;

    m_angularUpperLimit:           float;
    m_angularLowerLimit:           float;

    m_useLinearReferenceFrameA:    s32;
    m_useOffsetForConstraintFrame: s32;
}

btSliderConstraintDoubleData :: struct {
    m_typeConstraintData:          btTypedConstraintDoubleData;
    m_rbAFrame:                    btTransformDoubleData; // constraint axii. Assumes z is hinge axis.
    m_rbBFrame:                    btTransformDoubleData;

    m_linearUpperLimit:            float64;
    m_linearLowerLimit:            float64;

    m_angularUpperLimit:           float64;
    m_angularLowerLimit:           float64;

    m_useLinearReferenceFrameA:    s32;
    m_useOffsetForConstraintFrame: s32;
}

/// DOF index used in enableSpring() and setStiffness() means:
/// 0 : translation X
/// 1 : translation Y
/// 2 : translation Z
/// 3 : rotation X (3rd Euler rotational around new position of X axis, range [-PI+epsilon, PI-epsilon] )
/// 4 : rotation Y (2nd Euler rotational around new position of Y axis, range [-PI/2+epsilon, PI/2-epsilon] )
/// 5 : rotation Z (1st Euler rotational around Z axis, range [-PI+epsilon, PI-epsilon] )
btGeneric6DofSpringConstraint :: struct {
    #as using btgeneric6dofconstraint: btGeneric6DofConstraint;

    m_springEnabled:    [6] bool;
    m_equilibriumPoint: [6] btScalar;
    m_springStiffness:  [6] btScalar;
    m_springDamping:    [6] btScalar; // between 0 and 1 (1 == no damping)
    init :: (this: *btGeneric6DofSpringConstraint) -> void #cpp_method #foreign bullet3 "?init@btGeneric6DofSpringConstraint@@IEAAXXZ";
    internalUpdateSprings :: (this: *btGeneric6DofSpringConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?internalUpdateSprings@btGeneric6DofSpringConstraint@@IEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    Constructor :: (this: *btGeneric6DofSpringConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: *btTransform, frameInB: *btTransform, useLinearReferenceFrameA: bool) -> void #cpp_method #foreign bullet3 "??0btGeneric6DofSpringConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1_N@Z";
    Constructor :: (this: *btGeneric6DofSpringConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: btTransform, frameInB: btTransform, useLinearReferenceFrameA: bool) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB, useLinearReferenceFrameA);
    }
    Constructor :: (this: *btGeneric6DofSpringConstraint, rbB: *btRigidBody, frameInB: *btTransform, useLinearReferenceFrameB: bool) -> void #cpp_method #foreign bullet3 "??0btGeneric6DofSpringConstraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@_N@Z";
    Constructor :: (this: *btGeneric6DofSpringConstraint, rbB: *btRigidBody, frameInB: btTransform, useLinearReferenceFrameB: bool) #no_context {
        Constructor(this, rbB, *frameInB, useLinearReferenceFrameB);
    }
    enableSpring :: (this: *btGeneric6DofSpringConstraint, index: s32, onOff: bool) -> void #cpp_method #foreign bullet3 "?enableSpring@btGeneric6DofSpringConstraint@@QEAAXH_N@Z";
    setStiffness :: (this: *btGeneric6DofSpringConstraint, index: s32, stiffness: btScalar) -> void #cpp_method #foreign bullet3 "?setStiffness@btGeneric6DofSpringConstraint@@QEAAXHM@Z";
    setDamping :: (this: *btGeneric6DofSpringConstraint, index: s32, damping: btScalar) -> void #cpp_method #foreign bullet3 "?setDamping@btGeneric6DofSpringConstraint@@QEAAXHM@Z";
    setEquilibriumPoint :: (this: *btGeneric6DofSpringConstraint) -> void #cpp_method #foreign bullet3 "?setEquilibriumPoint@btGeneric6DofSpringConstraint@@QEAAXXZ";
    setEquilibriumPoint :: (this: *btGeneric6DofSpringConstraint, index: s32) -> void #cpp_method #foreign bullet3 "?setEquilibriumPoint@btGeneric6DofSpringConstraint@@QEAAXH@Z";
    setEquilibriumPoint :: (this: *btGeneric6DofSpringConstraint, index: s32, val: btScalar) -> void #cpp_method #foreign bullet3 "?setEquilibriumPoint@btGeneric6DofSpringConstraint@@QEAAXHM@Z";

    isSpringEnabled :: (this: *btGeneric6DofSpringConstraint, index: s32) -> bool #cpp_method #foreign bullet3 "?isSpringEnabled@btGeneric6DofSpringConstraint@@QEBA_NH@Z";

    getStiffness :: (this: *btGeneric6DofSpringConstraint, index: s32) -> btScalar #cpp_method #foreign bullet3 "?getStiffness@btGeneric6DofSpringConstraint@@QEBAMH@Z";

    getDamping :: (this: *btGeneric6DofSpringConstraint, index: s32) -> btScalar #cpp_method #foreign bullet3 "?getDamping@btGeneric6DofSpringConstraint@@QEBAMH@Z";

    getEquilibriumPoint :: (this: *btGeneric6DofSpringConstraint, index: s32) -> btScalar #cpp_method #foreign bullet3 "?getEquilibriumPoint@btGeneric6DofSpringConstraint@@QEBAMH@Z";
    #place btgeneric6dofconstraint; btgeneric6dofspringconstraint_vtable: *btGeneric6DofSpringConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_setAxis :: (this: *btGeneric6DofSpringConstraint, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxis@btGeneric6DofSpringConstraint@@UEAAXAEBVbtVector3@@0@Z";

    virtual_getInfo2 :: (this: *btGeneric6DofSpringConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btGeneric6DofSpringConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    virtual_calculateSerializeBufferSize :: (this: *btGeneric6DofSpringConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btGeneric6DofSpringConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btGeneric6DofSpringConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btGeneric6DofSpringConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btGeneric6DofSpringConstraint_VTable :: struct #type_info_none {
    using btgeneric6dofconstraint: btGeneric6DofConstraint_VTable;
    setAxis: (this: *btGeneric6DofSpringConstraint, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method;
}
btGeneric6DofSpringConstraint_setAxis :: inline (this: *btGeneric6DofSpringConstraint, axis1: *btVector3, axis2: *btVector3) { this.btgeneric6dofspringconstraint_vtable.setAxis(this, axis1, axis2); }

vtable :: (obj: *btGeneric6DofSpringConstraint) -> *btGeneric6DofSpringConstraint_VTable { return obj.btgeneric6dofspringconstraint_vtable; }



btGeneric6DofSpringConstraintData :: struct {
    m_6dofData:         btGeneric6DofConstraintData;

    m_springEnabled:    [6] s32;
    m_equilibriumPoint: [6] float;
    m_springStiffness:  [6] float;
    m_springDamping:    [6] float;
}

btGeneric6DofSpringConstraintDoubleData2 :: struct {
    m_6dofData:         btGeneric6DofConstraintDoubleData2;

    m_springEnabled:    [6] s32;
    m_equilibriumPoint: [6] float64;
    m_springStiffness:  [6] float64;
    m_springDamping:    [6] float64;
}

/// Constraint similar to ODE Universal Joint
/// has 2 rotatioonal degrees of freedom, similar to Euler rotations around Z (axis 1)
/// and Y (axis 2)
/// Description from ODE manual :
/// "Given axis 1 on body 1, and axis 2 on body 2 that is perpendicular to axis 1, it keeps them perpendicular.
/// In other words, rotation of the two bodies about the direction perpendicular to the two axes will be equal."
btUniversalConstraint :: struct {
    #as using btgeneric6dofconstraint: btGeneric6DofConstraint;

    m_anchor: btVector3;
    m_axis1:  btVector3;
    m_axis2:  btVector3;

    // constructor
    // anchor, axis1 and axis2 are in world coordinate system
    // axis1 must be orthogonal to axis2
    Constructor :: (this: *btUniversalConstraint, rbA: *btRigidBody, rbB: *btRigidBody, anchor: *btVector3, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method #foreign bullet3 "??0btUniversalConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@11@Z";
    Constructor :: (this: *btUniversalConstraint, rbA: *btRigidBody, rbB: *btRigidBody, anchor: btVector3, axis1: btVector3, axis2: btVector3) #no_context {
        Constructor(this, rbA, rbB, *anchor, *axis1, *axis2);
    }

    // access
    getAnchor :: (this: *btUniversalConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAnchor@btUniversalConstraint@@QEAAAEBVbtVector3@@XZ";
    getAnchor2 :: (this: *btUniversalConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAnchor2@btUniversalConstraint@@QEAAAEBVbtVector3@@XZ";
    getAxis1 :: (this: *btUniversalConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAxis1@btUniversalConstraint@@QEAAAEBVbtVector3@@XZ";
    getAxis2 :: (this: *btUniversalConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAxis2@btUniversalConstraint@@QEAAAEBVbtVector3@@XZ";
    getAngle1 :: (this: *btUniversalConstraint) -> btScalar #cpp_method #foreign bullet3 "?getAngle1@btUniversalConstraint@@QEAAMXZ";
    getAngle2 :: (this: *btUniversalConstraint) -> btScalar #cpp_method #foreign bullet3 "?getAngle2@btUniversalConstraint@@QEAAMXZ";

    // limits
    setUpperLimit :: (this: *btUniversalConstraint, ang1max: btScalar, ang2max: btScalar) -> void #cpp_method #foreign bullet3 "?setUpperLimit@btUniversalConstraint@@QEAAXMM@Z";
    setLowerLimit :: (this: *btUniversalConstraint, ang1min: btScalar, ang2min: btScalar) -> void #cpp_method #foreign bullet3 "?setLowerLimit@btUniversalConstraint@@QEAAXMM@Z";

    setAxis :: (this: *btUniversalConstraint, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxis@btUniversalConstraint@@QEAAXAEBVbtVector3@@0@Z";
    setAxis :: (this: *btUniversalConstraint, axis1: btVector3, axis2: btVector3) #no_context {
        setAxis(this, *axis1, *axis2);
    }
}


RotateOrder :: enum s32 {
    XYZ :: 0;
    XZY :: 1;
    YXZ :: 2;
    YZX :: 3;
    ZXY :: 4;
    ZYX :: 5;

    RO_XYZ :: XYZ;
    RO_XZY :: XZY;
    RO_YXZ :: YXZ;
    RO_YZX :: YZX;
    RO_ZXY :: ZXY;
    RO_ZYX :: ZYX;
}

btRotationalLimitMotor2 :: struct {
    // upper < lower means free
    // upper == lower means locked
    // upper > lower means limited
    m_loLimit:                btScalar;
    m_hiLimit:                btScalar;
    m_bounce:                 btScalar;
    m_stopERP:                btScalar;
    m_stopCFM:                btScalar;
    m_motorERP:               btScalar;
    m_motorCFM:               btScalar;
    m_enableMotor:            bool;
    m_targetVelocity:         btScalar;
    m_maxMotorForce:          btScalar;
    m_servoMotor:             bool;
    m_servoTarget:            btScalar;
    m_enableSpring:           bool;
    m_springStiffness:        btScalar;
    m_springStiffnessLimited: bool;
    m_springDamping:          btScalar;
    m_springDampingLimited:   bool;
    m_equilibriumPoint:       btScalar;

    m_currentLimitError:      btScalar;
    m_currentLimitErrorHi:    btScalar;
    m_currentPosition:        btScalar;
    m_currentLimit:           s32;

    Constructor :: (this: *btRotationalLimitMotor2) -> void #cpp_method #foreign bullet3 "??0btRotationalLimitMotor2@@QEAA@XZ";

    CopyConstructor :: (this: *btRotationalLimitMotor2, limot: *btRotationalLimitMotor2) -> void #cpp_method #foreign bullet3 "??0btRotationalLimitMotor2@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btRotationalLimitMotor2, limot: btRotationalLimitMotor2) #no_context {
        CopyConstructor(this, *limot);
    }

    isLimited :: (this: *btRotationalLimitMotor2) -> bool #cpp_method #foreign bullet3 "?isLimited@btRotationalLimitMotor2@@QEAA_NXZ";

    testLimitValue :: (this: *btRotationalLimitMotor2, test_value: btScalar) -> void #cpp_method #foreign bullet3 "?testLimitValue@btRotationalLimitMotor2@@QEAAXM@Z";
}

btTranslationalLimitMotor2 :: struct {
    // upper < lower means free
    // upper == lower means locked
    // upper > lower means limited
    m_lowerLimit:             btVector3;
    m_upperLimit:             btVector3;
    m_bounce:                 btVector3;
    m_stopERP:                btVector3;
    m_stopCFM:                btVector3;
    m_motorERP:               btVector3;
    m_motorCFM:               btVector3;
    m_enableMotor:            [3] bool;
    m_servoMotor:             [3] bool;
    m_enableSpring:           [3] bool;
    m_servoTarget:            btVector3 #align 8;
    m_springStiffness:        btVector3;
    m_springStiffnessLimited: [3] bool;
    m_springDamping:          btVector3;
    m_springDampingLimited:   [3] bool;
    m_equilibriumPoint:       btVector3;
    m_targetVelocity:         btVector3;
    m_maxMotorForce:          btVector3;

    m_currentLimitError:      btVector3;
    m_currentLimitErrorHi:    btVector3;
    m_currentLinearDiff:      btVector3;
    m_currentLimit:           [3] s32;

    Constructor :: (this: *btTranslationalLimitMotor2) -> void #cpp_method #foreign bullet3 "??0btTranslationalLimitMotor2@@QEAA@XZ";

    CopyConstructor :: (this: *btTranslationalLimitMotor2, other: *btTranslationalLimitMotor2) -> void #cpp_method #foreign bullet3 "??0btTranslationalLimitMotor2@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btTranslationalLimitMotor2, other: btTranslationalLimitMotor2) #no_context {
        CopyConstructor(this, *other);
    }

    isLimited :: (this: *btTranslationalLimitMotor2, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?isLimited@btTranslationalLimitMotor2@@QEAA_NH@Z";

    testLimitValue :: (this: *btTranslationalLimitMotor2, limitIndex: s32, test_value: btScalar) -> void #cpp_method #foreign bullet3 "?testLimitValue@btTranslationalLimitMotor2@@QEAAXHM@Z";
}

bt6DofFlags2 :: enum s32 {
    CFM_STOP2          :: 1;
    ERP_STOP2          :: 2;
    CFM_MOTO2          :: 4;
    ERP_MOTO2          :: 8;
    USE_INFINITE_ERROR :: 65536;

    BT_6DOF_FLAGS_CFM_STOP2          :: CFM_STOP2;
    BT_6DOF_FLAGS_ERP_STOP2          :: ERP_STOP2;
    BT_6DOF_FLAGS_CFM_MOTO2          :: CFM_MOTO2;
    BT_6DOF_FLAGS_ERP_MOTO2          :: ERP_MOTO2;
    BT_6DOF_FLAGS_USE_INFINITE_ERROR :: USE_INFINITE_ERROR;
}

btGeneric6DofSpring2Constraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_frameInA:                btTransform;
    m_frameInB:                btTransform;

    m_jacLinear:               [3] btJacobianEntry;
    m_jacAng:                  [3] btJacobianEntry;

    m_linearLimits:            btTranslationalLimitMotor2;
    m_angularLimits:           [3] btRotationalLimitMotor2;

    m_rotateOrder:             RotateOrder;

    m_calculatedTransformA:    btTransform #align 8;
    m_calculatedTransformB:    btTransform;
    m_calculatedAxisAngleDiff: btVector3;
    m_calculatedAxis:          [3] btVector3;
    m_calculatedLinearDiff:    btVector3;
    m_factA:                   btScalar;
    m_factB:                   btScalar;
    m_hasStaticBody:           bool;
    m_flags:                   s32;

    setAngularLimits :: (this: *btGeneric6DofSpring2Constraint, info: *btTypedConstraint.btConstraintInfo2, row_offset: s32, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3) -> s32 #cpp_method #foreign bullet3 "?setAngularLimits@btGeneric6DofSpring2Constraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z";
    setAngularLimits :: (this: *btGeneric6DofSpring2Constraint, info: *btTypedConstraint.btConstraintInfo2, row_offset: s32, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3) -> s32 #no_context {
        return setAngularLimits(this, info, row_offset, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }
    setLinearLimits :: (this: *btGeneric6DofSpring2Constraint, info: *btTypedConstraint.btConstraintInfo2, row: s32, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3) -> s32 #cpp_method #foreign bullet3 "?setLinearLimits@btGeneric6DofSpring2Constraint@@IEAAHPEAUbtConstraintInfo2@btTypedConstraint@@HAEBVbtTransform@@1AEBVbtVector3@@222@Z";
    setLinearLimits :: (this: *btGeneric6DofSpring2Constraint, info: *btTypedConstraint.btConstraintInfo2, row: s32, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3) -> s32 #no_context {
        return setLinearLimits(this, info, row, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }

    calculateLinearInfo :: (this: *btGeneric6DofSpring2Constraint) -> void #cpp_method #foreign bullet3 "?calculateLinearInfo@btGeneric6DofSpring2Constraint@@IEAAXXZ";
    calculateAngleInfo :: (this: *btGeneric6DofSpring2Constraint) -> void #cpp_method #foreign bullet3 "?calculateAngleInfo@btGeneric6DofSpring2Constraint@@IEAAXXZ";
    testAngularLimitMotor :: (this: *btGeneric6DofSpring2Constraint, axis_index: s32) -> void #cpp_method #foreign bullet3 "?testAngularLimitMotor@btGeneric6DofSpring2Constraint@@IEAAXH@Z";

    calculateJacobi :: (this: *btGeneric6DofSpring2Constraint, limot: *btRotationalLimitMotor2, transA: *btTransform, transB: *btTransform, info: *btTypedConstraint.btConstraintInfo2, srow: s32, ax1: *btVector3, rotational: s32, rotAllowed: s32) -> void #cpp_method #foreign bullet3 "?calculateJacobi@btGeneric6DofSpring2Constraint@@IEAAXPEAVbtRotationalLimitMotor2@@AEBVbtTransform@@1PEAUbtConstraintInfo2@btTypedConstraint@@HAEAVbtVector3@@HH@Z";
    calculateJacobi :: (this: *btGeneric6DofSpring2Constraint, limot: *btRotationalLimitMotor2, transA: btTransform, transB: btTransform, info: *btTypedConstraint.btConstraintInfo2, srow: s32, ax1: *btVector3, rotational: s32, rotAllowed: s32) #no_context {
        calculateJacobi(this, limot, *transA, *transB, info, srow, ax1, rotational, rotAllowed);
    }
    get_limit_motor_info2 :: (this: *btGeneric6DofSpring2Constraint, limot: *btRotationalLimitMotor2, transA: *btTransform, transB: *btTransform, linVelA: *btVector3, linVelB: *btVector3, angVelA: *btVector3, angVelB: *btVector3, info: *btTypedConstraint.btConstraintInfo2, row: s32, ax1: *btVector3, rotational: s32, rotAllowed: s32 = 0) -> s32 #cpp_method #foreign bullet3 "?get_limit_motor_info2@btGeneric6DofSpring2Constraint@@IEAAHPEAVbtRotationalLimitMotor2@@AEBVbtTransform@@1AEBVbtVector3@@222PEAUbtConstraintInfo2@btTypedConstraint@@HAEAV4@HH@Z";
    get_limit_motor_info2 :: (this: *btGeneric6DofSpring2Constraint, limot: *btRotationalLimitMotor2, transA: btTransform, transB: btTransform, linVelA: btVector3, linVelB: btVector3, angVelA: btVector3, angVelB: btVector3, info: *btTypedConstraint.btConstraintInfo2, row: s32, ax1: *btVector3, rotational: s32, rotAllowed: s32 = 0) -> s32 #no_context {
        return get_limit_motor_info2(this, limot, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB, info, row, ax1, rotational, rotAllowed);
    }

    Constructor :: (this: *btGeneric6DofSpring2Constraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: *btTransform, frameInB: *btTransform, rotOrder: RotateOrder = .XYZ) -> void #cpp_method #foreign bullet3 "??0btGeneric6DofSpring2Constraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1W4RotateOrder@@@Z";
    Constructor :: (this: *btGeneric6DofSpring2Constraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: btTransform, frameInB: btTransform, rotOrder: RotateOrder = .XYZ) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB, rotOrder);
    }
    Constructor :: (this: *btGeneric6DofSpring2Constraint, rbB: *btRigidBody, frameInB: *btTransform, rotOrder: RotateOrder = .XYZ) -> void #cpp_method #foreign bullet3 "??0btGeneric6DofSpring2Constraint@@QEAA@AEAVbtRigidBody@@AEBVbtTransform@@W4RotateOrder@@@Z";
    Constructor :: (this: *btGeneric6DofSpring2Constraint, rbB: *btRigidBody, frameInB: btTransform, rotOrder: RotateOrder = .XYZ) #no_context {
        Constructor(this, rbB, *frameInB, rotOrder);
    }

    getRotationalLimitMotor :: (this: *btGeneric6DofSpring2Constraint, index: s32) -> *btRotationalLimitMotor2 #cpp_method #foreign bullet3 "?getRotationalLimitMotor@btGeneric6DofSpring2Constraint@@QEAAPEAVbtRotationalLimitMotor2@@H@Z";
    getTranslationalLimitMotor :: (this: *btGeneric6DofSpring2Constraint) -> *btTranslationalLimitMotor2 #cpp_method #foreign bullet3 "?getTranslationalLimitMotor@btGeneric6DofSpring2Constraint@@QEAAPEAVbtTranslationalLimitMotor2@@XZ";

    // Calculates the global transform for the joint offset for body A an B, and also calculates the angle differences between the bodies.
    calculateTransforms :: (this: *btGeneric6DofSpring2Constraint, transA: *btTransform, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?calculateTransforms@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtTransform@@0@Z";
    calculateTransforms :: (this: *btGeneric6DofSpring2Constraint, transA: btTransform, transB: btTransform) #no_context {
        calculateTransforms(this, *transA, *transB);
    }
    calculateTransforms :: (this: *btGeneric6DofSpring2Constraint) -> void #cpp_method #foreign bullet3 "?calculateTransforms@btGeneric6DofSpring2Constraint@@QEAAXXZ";

    // Gets the global transform of the offset for body A
    getCalculatedTransformA :: (this: *btGeneric6DofSpring2Constraint) -> *btTransform #cpp_method #foreign bullet3 "?getCalculatedTransformA@btGeneric6DofSpring2Constraint@@QEBAAEBVbtTransform@@XZ";

    // Gets the global transform of the offset for body B
    getCalculatedTransformB :: (this: *btGeneric6DofSpring2Constraint) -> *btTransform #cpp_method #foreign bullet3 "?getCalculatedTransformB@btGeneric6DofSpring2Constraint@@QEBAAEBVbtTransform@@XZ";

    getFrameOffsetA :: (this: /*const*/ *btGeneric6DofSpring2Constraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btGeneric6DofSpring2Constraint@@QEBAAEBVbtTransform@@XZ";
    getFrameOffsetB :: (this: /*const*/ *btGeneric6DofSpring2Constraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btGeneric6DofSpring2Constraint@@QEBAAEBVbtTransform@@XZ";

    getFrameOffsetA_1 :: (this: *btGeneric6DofSpring2Constraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetA@btGeneric6DofSpring2Constraint@@QEAAAEAVbtTransform@@XZ";
    getFrameOffsetB_1 :: (this: *btGeneric6DofSpring2Constraint) -> *btTransform #cpp_method #foreign bullet3 "?getFrameOffsetB@btGeneric6DofSpring2Constraint@@QEAAAEAVbtTransform@@XZ";

    // Get the rotation axis in global coordinates ( btGeneric6DofSpring2Constraint::calculateTransforms() must be called previously )
    getAxis :: (this: *btGeneric6DofSpring2Constraint, axis_index: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getAxis@btGeneric6DofSpring2Constraint@@QEBA?AVbtVector3@@H@Z";

    // Get the relative Euler angle ( btGeneric6DofSpring2Constraint::calculateTransforms() must be called previously )
    getAngle :: (this: *btGeneric6DofSpring2Constraint, axis_index: s32) -> btScalar #cpp_method #foreign bullet3 "?getAngle@btGeneric6DofSpring2Constraint@@QEBAMH@Z";

    // Get the relative position of the constraint pivot ( btGeneric6DofSpring2Constraint::calculateTransforms() must be called previously )
    getRelativePivotPosition :: (this: *btGeneric6DofSpring2Constraint, axis_index: s32) -> btScalar #cpp_method #foreign bullet3 "?getRelativePivotPosition@btGeneric6DofSpring2Constraint@@QEBAMH@Z";

    setFrames :: (this: *btGeneric6DofSpring2Constraint, frameA: *btTransform, frameB: *btTransform) -> void #cpp_method #foreign bullet3 "?setFrames@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtTransform@@0@Z";
    setFrames :: (this: *btGeneric6DofSpring2Constraint, frameA: btTransform, frameB: btTransform) #no_context {
        setFrames(this, *frameA, *frameB);
    }

    setLinearLowerLimit :: (this: *btGeneric6DofSpring2Constraint, linearLower: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearLowerLimit@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@@Z";
    setLinearLowerLimit :: (this: *btGeneric6DofSpring2Constraint, linearLower: btVector3) #no_context {
        setLinearLowerLimit(this, *linearLower);
    }
    getLinearLowerLimit :: (this: *btGeneric6DofSpring2Constraint, linearLower: *btVector3) -> void #cpp_method #foreign bullet3 "?getLinearLowerLimit@btGeneric6DofSpring2Constraint@@QEAAXAEAVbtVector3@@@Z";
    setLinearUpperLimit :: (this: *btGeneric6DofSpring2Constraint, linearUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearUpperLimit@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@@Z";
    setLinearUpperLimit :: (this: *btGeneric6DofSpring2Constraint, linearUpper: btVector3) #no_context {
        setLinearUpperLimit(this, *linearUpper);
    }
    getLinearUpperLimit :: (this: *btGeneric6DofSpring2Constraint, linearUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?getLinearUpperLimit@btGeneric6DofSpring2Constraint@@QEAAXAEAVbtVector3@@@Z";

    setAngularLowerLimit :: (this: *btGeneric6DofSpring2Constraint, angularLower: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularLowerLimit@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@@Z";
    setAngularLowerLimit :: (this: *btGeneric6DofSpring2Constraint, angularLower: btVector3) #no_context {
        setAngularLowerLimit(this, *angularLower);
    }

    setAngularLowerLimitReversed :: (this: *btGeneric6DofSpring2Constraint, angularLower: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularLowerLimitReversed@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@@Z";
    setAngularLowerLimitReversed :: (this: *btGeneric6DofSpring2Constraint, angularLower: btVector3) #no_context {
        setAngularLowerLimitReversed(this, *angularLower);
    }

    getAngularLowerLimit :: (this: *btGeneric6DofSpring2Constraint, angularLower: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularLowerLimit@btGeneric6DofSpring2Constraint@@QEAAXAEAVbtVector3@@@Z";

    getAngularLowerLimitReversed :: (this: *btGeneric6DofSpring2Constraint, angularLower: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularLowerLimitReversed@btGeneric6DofSpring2Constraint@@QEAAXAEAVbtVector3@@@Z";

    setAngularUpperLimit :: (this: *btGeneric6DofSpring2Constraint, angularUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularUpperLimit@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@@Z";
    setAngularUpperLimit :: (this: *btGeneric6DofSpring2Constraint, angularUpper: btVector3) #no_context {
        setAngularUpperLimit(this, *angularUpper);
    }

    setAngularUpperLimitReversed :: (this: *btGeneric6DofSpring2Constraint, angularUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularUpperLimitReversed@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@@Z";
    setAngularUpperLimitReversed :: (this: *btGeneric6DofSpring2Constraint, angularUpper: btVector3) #no_context {
        setAngularUpperLimitReversed(this, *angularUpper);
    }

    getAngularUpperLimit :: (this: *btGeneric6DofSpring2Constraint, angularUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularUpperLimit@btGeneric6DofSpring2Constraint@@QEAAXAEAVbtVector3@@@Z";

    getAngularUpperLimitReversed :: (this: *btGeneric6DofSpring2Constraint, angularUpper: *btVector3) -> void #cpp_method #foreign bullet3 "?getAngularUpperLimitReversed@btGeneric6DofSpring2Constraint@@QEAAXAEAVbtVector3@@@Z";

    //first 3 are linear, next 3 are angular
    setLimit :: (this: *btGeneric6DofSpring2Constraint, axis: s32, lo: btScalar, hi: btScalar) -> void #cpp_method #foreign bullet3 "?setLimit@btGeneric6DofSpring2Constraint@@QEAAXHMM@Z";

    setLimitReversed :: (this: *btGeneric6DofSpring2Constraint, axis: s32, lo: btScalar, hi: btScalar) -> void #cpp_method #foreign bullet3 "?setLimitReversed@btGeneric6DofSpring2Constraint@@QEAAXHMM@Z";

    isLimited :: (this: *btGeneric6DofSpring2Constraint, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?isLimited@btGeneric6DofSpring2Constraint@@QEAA_NH@Z";

    setRotationOrder :: (this: *btGeneric6DofSpring2Constraint, order: RotateOrder) -> void #cpp_method #foreign bullet3 "?setRotationOrder@btGeneric6DofSpring2Constraint@@QEAAXW4RotateOrder@@@Z";
    getRotationOrder :: (this: *btGeneric6DofSpring2Constraint) -> RotateOrder #cpp_method #foreign bullet3 "?getRotationOrder@btGeneric6DofSpring2Constraint@@QEAA?AW4RotateOrder@@XZ";

    setAxis :: (this: *btGeneric6DofSpring2Constraint, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxis@btGeneric6DofSpring2Constraint@@QEAAXAEBVbtVector3@@0@Z";
    setAxis :: (this: *btGeneric6DofSpring2Constraint, axis1: btVector3, axis2: btVector3) #no_context {
        setAxis(this, *axis1, *axis2);
    }

    setBounce :: (this: *btGeneric6DofSpring2Constraint, index: s32, bounce: btScalar) -> void #cpp_method #foreign bullet3 "?setBounce@btGeneric6DofSpring2Constraint@@QEAAXHM@Z";

    enableMotor :: (this: *btGeneric6DofSpring2Constraint, index: s32, onOff: bool) -> void #cpp_method #foreign bullet3 "?enableMotor@btGeneric6DofSpring2Constraint@@QEAAXH_N@Z";
    setServo :: (this: *btGeneric6DofSpring2Constraint, index: s32, onOff: bool) -> void #cpp_method #foreign bullet3 "?setServo@btGeneric6DofSpring2Constraint@@QEAAXH_N@Z";
    setTargetVelocity :: (this: *btGeneric6DofSpring2Constraint, index: s32, velocity: btScalar) -> void #cpp_method #foreign bullet3 "?setTargetVelocity@btGeneric6DofSpring2Constraint@@QEAAXHM@Z";
    setServoTarget :: (this: *btGeneric6DofSpring2Constraint, index: s32, target: btScalar) -> void #cpp_method #foreign bullet3 "?setServoTarget@btGeneric6DofSpring2Constraint@@QEAAXHM@Z";
    setMaxMotorForce :: (this: *btGeneric6DofSpring2Constraint, index: s32, force: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxMotorForce@btGeneric6DofSpring2Constraint@@QEAAXHM@Z";

    enableSpring :: (this: *btGeneric6DofSpring2Constraint, index: s32, onOff: bool) -> void #cpp_method #foreign bullet3 "?enableSpring@btGeneric6DofSpring2Constraint@@QEAAXH_N@Z";
    setStiffness :: (this: *btGeneric6DofSpring2Constraint, index: s32, stiffness: btScalar, limitIfNeeded := true) -> void #cpp_method #foreign bullet3 "?setStiffness@btGeneric6DofSpring2Constraint@@QEAAXHM_N@Z";
    setDamping :: (this: *btGeneric6DofSpring2Constraint, index: s32, damping: btScalar, limitIfNeeded := true) -> void #cpp_method #foreign bullet3 "?setDamping@btGeneric6DofSpring2Constraint@@QEAAXHM_N@Z";
    setEquilibriumPoint :: (this: *btGeneric6DofSpring2Constraint) -> void #cpp_method #foreign bullet3 "?setEquilibriumPoint@btGeneric6DofSpring2Constraint@@QEAAXXZ";
    setEquilibriumPoint :: (this: *btGeneric6DofSpring2Constraint, index: s32) -> void #cpp_method #foreign bullet3 "?setEquilibriumPoint@btGeneric6DofSpring2Constraint@@QEAAXH@Z";
    setEquilibriumPoint :: (this: *btGeneric6DofSpring2Constraint, index: s32, val: btScalar) -> void #cpp_method #foreign bullet3 "?setEquilibriumPoint@btGeneric6DofSpring2Constraint@@QEAAXHM@Z";

    btGetMatrixElem :: (mat: *btMatrix3x3, index: s32) -> btScalar #foreign bullet3 "?btGetMatrixElem@btGeneric6DofSpring2Constraint@@SAMAEBVbtMatrix3x3@@H@Z";
    btGetMatrixElem :: (mat: btMatrix3x3, index: s32) -> btScalar #no_context {
        return btGetMatrixElem(*mat, index);
    }
    matrixToEulerXYZ :: (mat: *btMatrix3x3, xyz: *btVector3) -> bool #foreign bullet3 "?matrixToEulerXYZ@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z";
    matrixToEulerXYZ :: (mat: btMatrix3x3, xyz: *btVector3) -> bool #no_context {
        return matrixToEulerXYZ(*mat, xyz);
    }
    matrixToEulerXZY :: (mat: *btMatrix3x3, xyz: *btVector3) -> bool #foreign bullet3 "?matrixToEulerXZY@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z";
    matrixToEulerXZY :: (mat: btMatrix3x3, xyz: *btVector3) -> bool #no_context {
        return matrixToEulerXZY(*mat, xyz);
    }
    matrixToEulerYXZ :: (mat: *btMatrix3x3, xyz: *btVector3) -> bool #foreign bullet3 "?matrixToEulerYXZ@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z";
    matrixToEulerYXZ :: (mat: btMatrix3x3, xyz: *btVector3) -> bool #no_context {
        return matrixToEulerYXZ(*mat, xyz);
    }
    matrixToEulerYZX :: (mat: *btMatrix3x3, xyz: *btVector3) -> bool #foreign bullet3 "?matrixToEulerYZX@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z";
    matrixToEulerYZX :: (mat: btMatrix3x3, xyz: *btVector3) -> bool #no_context {
        return matrixToEulerYZX(*mat, xyz);
    }
    matrixToEulerZXY :: (mat: *btMatrix3x3, xyz: *btVector3) -> bool #foreign bullet3 "?matrixToEulerZXY@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z";
    matrixToEulerZXY :: (mat: btMatrix3x3, xyz: *btVector3) -> bool #no_context {
        return matrixToEulerZXY(*mat, xyz);
    }
    matrixToEulerZYX :: (mat: *btMatrix3x3, xyz: *btVector3) -> bool #foreign bullet3 "?matrixToEulerZYX@btGeneric6DofSpring2Constraint@@SA_NAEBVbtMatrix3x3@@AEAVbtVector3@@@Z";
    matrixToEulerZYX :: (mat: btMatrix3x3, xyz: *btVector3) -> bool #no_context {
        return matrixToEulerZYX(*mat, xyz);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_buildJacobian :: (this: *btGeneric6DofSpring2Constraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btGeneric6DofSpring2Constraint@@UEAAXXZ";
    virtual_getInfo1 :: (this: *btGeneric6DofSpring2Constraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btGeneric6DofSpring2Constraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";
    virtual_getInfo2 :: (this: *btGeneric6DofSpring2Constraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btGeneric6DofSpring2Constraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    virtual_calculateSerializeBufferSize :: (this: *btGeneric6DofSpring2Constraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btGeneric6DofSpring2Constraint@@UEBAHXZ";

    virtual_serialize :: (this: *btGeneric6DofSpring2Constraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btGeneric6DofSpring2Constraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";

    //override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    //If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *btGeneric6DofSpring2Constraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btGeneric6DofSpring2Constraint@@UEAAXHMH@Z";
    virtual_getParam :: (this: *btGeneric6DofSpring2Constraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btGeneric6DofSpring2Constraint@@UEBAMHH@Z";
}

operator_assign :: (this: *btGeneric6DofSpring2Constraint, unknown0: *btGeneric6DofSpring2Constraint) -> *btGeneric6DofSpring2Constraint #cpp_method #foreign bullet3 "??4btGeneric6DofSpring2Constraint@@IEAAAEAV0@AEBV0@@Z";
operator_assign :: (this: *btGeneric6DofSpring2Constraint, unknown0: btGeneric6DofSpring2Constraint) -> *btGeneric6DofSpring2Constraint #no_context {
    return operator_assign(this, *unknown0);
}


btGeneric6DofSpring2ConstraintData :: struct {
    m_typeConstraintData:            btTypedConstraintData;
    m_rbAFrame:                      btTransformFloatData;
    m_rbBFrame:                      btTransformFloatData;

    m_linearUpperLimit:              btVector3FloatData;
    m_linearLowerLimit:              btVector3FloatData;
    m_linearBounce:                  btVector3FloatData;
    m_linearStopERP:                 btVector3FloatData;
    m_linearStopCFM:                 btVector3FloatData;
    m_linearMotorERP:                btVector3FloatData;
    m_linearMotorCFM:                btVector3FloatData;
    m_linearTargetVelocity:          btVector3FloatData;
    m_linearMaxMotorForce:           btVector3FloatData;
    m_linearServoTarget:             btVector3FloatData;
    m_linearSpringStiffness:         btVector3FloatData;
    m_linearSpringDamping:           btVector3FloatData;
    m_linearEquilibriumPoint:        btVector3FloatData;
    m_linearEnableMotor:             [4] u8;
    m_linearServoMotor:              [4] u8;
    m_linearEnableSpring:            [4] u8;
    m_linearSpringStiffnessLimited:  [4] u8;
    m_linearSpringDampingLimited:    [4] u8;
    m_padding1:                      [4] u8;

    m_angularUpperLimit:             btVector3FloatData;
    m_angularLowerLimit:             btVector3FloatData;
    m_angularBounce:                 btVector3FloatData;
    m_angularStopERP:                btVector3FloatData;
    m_angularStopCFM:                btVector3FloatData;
    m_angularMotorERP:               btVector3FloatData;
    m_angularMotorCFM:               btVector3FloatData;
    m_angularTargetVelocity:         btVector3FloatData;
    m_angularMaxMotorForce:          btVector3FloatData;
    m_angularServoTarget:            btVector3FloatData;
    m_angularSpringStiffness:        btVector3FloatData;
    m_angularSpringDamping:          btVector3FloatData;
    m_angularEquilibriumPoint:       btVector3FloatData;
    m_angularEnableMotor:            [4] u8;
    m_angularServoMotor:             [4] u8;
    m_angularEnableSpring:           [4] u8;
    m_angularSpringStiffnessLimited: [4] u8;
    m_angularSpringDampingLimited:   [4] u8;

    m_rotateOrder:                   s32;
}

btGeneric6DofSpring2ConstraintDoubleData2 :: struct {
    m_typeConstraintData:            btTypedConstraintDoubleData;
    m_rbAFrame:                      btTransformDoubleData;
    m_rbBFrame:                      btTransformDoubleData;

    m_linearUpperLimit:              btVector3DoubleData;
    m_linearLowerLimit:              btVector3DoubleData;
    m_linearBounce:                  btVector3DoubleData;
    m_linearStopERP:                 btVector3DoubleData;
    m_linearStopCFM:                 btVector3DoubleData;
    m_linearMotorERP:                btVector3DoubleData;
    m_linearMotorCFM:                btVector3DoubleData;
    m_linearTargetVelocity:          btVector3DoubleData;
    m_linearMaxMotorForce:           btVector3DoubleData;
    m_linearServoTarget:             btVector3DoubleData;
    m_linearSpringStiffness:         btVector3DoubleData;
    m_linearSpringDamping:           btVector3DoubleData;
    m_linearEquilibriumPoint:        btVector3DoubleData;
    m_linearEnableMotor:             [4] u8;
    m_linearServoMotor:              [4] u8;
    m_linearEnableSpring:            [4] u8;
    m_linearSpringStiffnessLimited:  [4] u8;
    m_linearSpringDampingLimited:    [4] u8;
    m_padding1:                      [4] u8;

    m_angularUpperLimit:             btVector3DoubleData;
    m_angularLowerLimit:             btVector3DoubleData;
    m_angularBounce:                 btVector3DoubleData;
    m_angularStopERP:                btVector3DoubleData;
    m_angularStopCFM:                btVector3DoubleData;
    m_angularMotorERP:               btVector3DoubleData;
    m_angularMotorCFM:               btVector3DoubleData;
    m_angularTargetVelocity:         btVector3DoubleData;
    m_angularMaxMotorForce:          btVector3DoubleData;
    m_angularServoTarget:            btVector3DoubleData;
    m_angularSpringStiffness:        btVector3DoubleData;
    m_angularSpringDamping:          btVector3DoubleData;
    m_angularEquilibriumPoint:       btVector3DoubleData;
    m_angularEnableMotor:            [4] u8;
    m_angularServoMotor:             [4] u8;
    m_angularEnableSpring:           [4] u8;
    m_angularSpringStiffnessLimited: [4] u8;
    m_angularSpringDampingLimited:   [4] u8;

    m_rotateOrder:                   s32;
}

// Constraint similar to ODE Hinge2 Joint
// has 3 degrees of frredom:
// 2 rotational degrees of freedom, similar to Euler rotations around Z (axis 1) and X (axis 2)
// 1 translational (along axis Z) with suspension spring
btHinge2Constraint :: struct {
    #as using btgeneric6dofspring2constraint: btGeneric6DofSpring2Constraint;

    m_anchor: btVector3;
    m_axis1:  btVector3;
    m_axis2:  btVector3;

    // constructor
    // anchor, axis1 and axis2 are in world coordinate system
    // axis1 must be orthogonal to axis2
    Constructor :: (this: *btHinge2Constraint, rbA: *btRigidBody, rbB: *btRigidBody, anchor: *btVector3, axis1: *btVector3, axis2: *btVector3) -> void #cpp_method #foreign bullet3 "??0btHinge2Constraint@@QEAA@AEAVbtRigidBody@@0AEAVbtVector3@@11@Z";

    // access
    getAnchor :: (this: *btHinge2Constraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAnchor@btHinge2Constraint@@QEAAAEBVbtVector3@@XZ";
    getAnchor2 :: (this: *btHinge2Constraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAnchor2@btHinge2Constraint@@QEAAAEBVbtVector3@@XZ";
    getAxis1 :: (this: *btHinge2Constraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAxis1@btHinge2Constraint@@QEAAAEBVbtVector3@@XZ";
    getAxis2 :: (this: *btHinge2Constraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAxis2@btHinge2Constraint@@QEAAAEBVbtVector3@@XZ";
    getAngle1 :: (this: *btHinge2Constraint) -> btScalar #cpp_method #foreign bullet3 "?getAngle1@btHinge2Constraint@@QEAAMXZ";
    getAngle2 :: (this: *btHinge2Constraint) -> btScalar #cpp_method #foreign bullet3 "?getAngle2@btHinge2Constraint@@QEAAMXZ";

    // limits
    setUpperLimit :: (this: *btHinge2Constraint, ang1max: btScalar) -> void #cpp_method #foreign bullet3 "?setUpperLimit@btHinge2Constraint@@QEAAXM@Z";
    setLowerLimit :: (this: *btHinge2Constraint, ang1min: btScalar) -> void #cpp_method #foreign bullet3 "?setLowerLimit@btHinge2Constraint@@QEAAXM@Z";
}


///The btGeatConstraint will couple the angular velocity for two bodies around given local axis and ratio.
///See Bullet/Demos/ConstraintDemo for an example use.
btGearConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_axisInA:   btVector3;
    m_axisInB:   btVector3;
    m_useFrameA: bool;
    m_ratio:     btScalar;

    Constructor :: (this: *btGearConstraint, rbA: *btRigidBody, rbB: *btRigidBody, axisInA: *btVector3, axisInB: *btVector3, ratio: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "??0btGearConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtVector3@@1M@Z";
    Constructor :: (this: *btGearConstraint, rbA: *btRigidBody, rbB: *btRigidBody, axisInA: btVector3, axisInB: btVector3, ratio: btScalar = 1.0) #no_context {
        Constructor(this, rbA, rbB, *axisInA, *axisInB, ratio);
    }

    setAxisA :: (this: *btGearConstraint, axisA: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxisA@btGearConstraint@@QEAAXAEAVbtVector3@@@Z";

    setAxisB :: (this: *btGearConstraint, axisB: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxisB@btGearConstraint@@QEAAXAEAVbtVector3@@@Z";

    setRatio :: (this: *btGearConstraint, ratio: btScalar) -> void #cpp_method #foreign bullet3 "?setRatio@btGearConstraint@@QEAAXM@Z";

    getAxisA :: (this: *btGearConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAxisA@btGearConstraint@@QEBAAEBVbtVector3@@XZ";

    getAxisB :: (this: *btGearConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getAxisB@btGearConstraint@@QEBAAEBVbtVector3@@XZ";

    getRatio :: (this: *btGearConstraint) -> btScalar #cpp_method #foreign bullet3 "?getRatio@btGearConstraint@@QEBAMXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGearConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGearConstraint@@UEAA@XZ";

    ///internal method used by the constraint solver, don't use them directly
    virtual_getInfo1 :: (this: *btGearConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btGearConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    ///internal method used by the constraint solver, don't use them directly
    virtual_getInfo2 :: (this: *btGearConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btGearConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    virtual_setParam :: (this: *btGearConstraint, num: s32, value: btScalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@btGearConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *btGearConstraint, num: s32, axis: s32 = -1) -> btScalar #cpp_method #foreign bullet3 "?getParam@btGearConstraint@@UEBAMHH@Z";

    virtual_calculateSerializeBufferSize :: (this: *btGearConstraint) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btGearConstraint@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btGearConstraint, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btGearConstraint@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btGearConstraintFloatData :: struct {
    m_typeConstraintData: btTypedConstraintFloatData;

    m_axisInA:            btVector3FloatData;
    m_axisInB:            btVector3FloatData;

    m_ratio:              float;
    m_padding:            [4] u8;
}

btGearConstraintDoubleData :: struct {
    m_typeConstraintData: btTypedConstraintDoubleData;

    m_axisInA:            btVector3DoubleData;
    m_axisInB:            btVector3DoubleData;

    m_ratio:              float64;
}

btFixedConstraint :: struct {
    #as using btgeneric6dofspring2constraint: btGeneric6DofSpring2Constraint;

    Constructor :: (this: *btFixedConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: *btTransform, frameInB: *btTransform) -> void #cpp_method #foreign bullet3 "??0btFixedConstraint@@QEAA@AEAVbtRigidBody@@0AEBVbtTransform@@1@Z";
    Constructor :: (this: *btFixedConstraint, rbA: *btRigidBody, rbB: *btRigidBody, frameInA: btTransform, frameInB: btTransform) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btFixedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btFixedConstraint@@UEAA@XZ";
}

/// btConstraintSolver provides solver interface
btConstraintSolverType :: enum s32 {
    SEQUENTIAL_IMPULSE_SOLVER :: 1;
    MLCP_SOLVER               :: 2;
    NNCG_SOLVER               :: 4;
    MULTIBODY_SOLVER          :: 8;
    BLOCK_SOLVER              :: 16;

    BT_SEQUENTIAL_IMPULSE_SOLVER :: SEQUENTIAL_IMPULSE_SOLVER;
    BT_MLCP_SOLVER               :: MLCP_SOLVER;
    BT_NNCG_SOLVER               :: NNCG_SOLVER;
    BT_MULTIBODY_SOLVER          :: MULTIBODY_SOLVER;
    BT_BLOCK_SOLVER              :: BLOCK_SOLVER;
}

btConstraintSolver :: struct {
    vtable: *btConstraintSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btConstraintSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConstraintSolver@@UEAA@XZ";

    virtual_prepareSolve :: (this: *btConstraintSolver, unknown0: s32, unknown1: s32) -> void #cpp_method #foreign bullet3 "?prepareSolve@btConstraintSolver@@UEAAXHH@Z";

    virtual_allSolved :: (this: *btConstraintSolver, unknown0: *btContactSolverInfo, unknown1: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?allSolved@btConstraintSolver@@UEAAXAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
}
btConstraintSolver_VTable :: struct #type_info_none {
    Destructor: (this: *btConstraintSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    prepareSolve: (this: *btConstraintSolver, unknown0: s32, unknown1: s32) -> void #cpp_method;

    solveGroup: (this: *btConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> btScalar #cpp_method;

    allSolved: (this: *btConstraintSolver, unknown0: *btContactSolverInfo, unknown1: *btIDebugDraw) -> void #cpp_method;

    reset: (this: *btConstraintSolver) -> void #cpp_method;

    getSolverType: (this: *btConstraintSolver) -> btConstraintSolverType #cpp_method;
}

btConstraintSolver_Destructor :: inline (this: *btConstraintSolver, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btConstraintSolver_prepareSolve :: inline (this: *btConstraintSolver, unknown0: s32, unknown1: s32) { this.vtable.prepareSolve(this, unknown0, unknown1); }

btConstraintSolver_solveGroup :: inline (this: *btConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> btScalar { return this.vtable.solveGroup(this, bodies, numBodies, manifold, numManifolds, constraints, numConstraints, info, debugDrawer, dispatcher); }

btConstraintSolver_allSolved :: inline (this: *btConstraintSolver, unknown0: *btContactSolverInfo, unknown1: *btIDebugDraw) { this.vtable.allSolved(this, unknown0, unknown1); }

btConstraintSolver_reset :: inline (this: *btConstraintSolver) { this.vtable.reset(this); }

btConstraintSolver_getSolverType :: inline (this: *btConstraintSolver) -> btConstraintSolverType { return this.vtable.getSolverType(this); }



btSingleConstraintRowSolver :: #type (unknown0: *btSolverBody, unknown1: *btSolverBody, unknown2: *btSolverConstraint) -> btScalar #c_call;

btSolverAnalyticsData :: struct {
    Constructor :: (this: *btSolverAnalyticsData) -> void #cpp_method #foreign bullet3 "??0btSolverAnalyticsData@@QEAA@XZ";

    m_islandId:                      s32;
    m_numBodies:                     s32;
    m_numContactManifolds:           s32;
    m_numSolverCalls:                s32;
    m_numIterationsUsed:             s32;
    m_remainingLeastSquaresResidual: float64;
}

///The btSequentialImpulseConstraintSolver is a fast SIMD implementation of the Projected Gauss Seidel (iterative LCP) method.
btSequentialImpulseConstraintSolver :: struct {
    #as using btconstraintsolver: btConstraintSolver;

    m_tmpSolverBodyPool:                             btAlignedObjectArray(btSolverBody);
    m_tmpSolverContactConstraintPool:                btConstraintArray;
    m_tmpSolverNonContactConstraintPool:             btConstraintArray;
    m_tmpSolverContactFrictionConstraintPool:        btConstraintArray;
    m_tmpSolverContactRollingFrictionConstraintPool: btConstraintArray;

    m_orderTmpConstraintPool:                        btAlignedObjectArray(s32);
    m_orderNonContactConstraintPool:                 btAlignedObjectArray(s32);
    m_orderFrictionConstraintPool:                   btAlignedObjectArray(s32);
    m_tmpConstraintSizesPool:                        btAlignedObjectArray(btTypedConstraint.btConstraintInfo1);
    m_maxOverrideNumSolverIterations:                s32;
    m_fixedBodyId:                                   s32;

    m_kinematicBodyUniqueIdToSolverBodyTable:        btAlignedObjectArray(s32); // only used for multithreading

    m_resolveSingleConstraintRowGeneric:             btSingleConstraintRowSolver;
    m_resolveSingleConstraintRowLowerLimit:          btSingleConstraintRowSolver;
    m_resolveSplitPenetrationImpulse:                btSingleConstraintRowSolver;
    m_cachedSolverMode:                              s32; // used to check if SOLVER_SIMD flag has been changed
    setupSolverFunctions :: (this: *btSequentialImpulseConstraintSolver, useSimd: bool) -> void #cpp_method #foreign bullet3 "?setupSolverFunctions@btSequentialImpulseConstraintSolver@@IEAAX_N@Z";

    m_leastSquaresResidual:                          btScalar;

    setupFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, normalAxis: *btVector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, rel_pos1: *btVector3, rel_pos2: *btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: *btContactSolverInfo, desiredVelocity: btScalar = 0.0, cfmSlip: btScalar = 0.0) -> void #cpp_method #foreign bullet3 "?setupFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@AEBVbtVector3@@HHAEAVbtManifoldPoint@@11PEAVbtCollisionObject@@3MAEBUbtContactSolverInfo@@MM@Z";
    setupFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, normalAxis: btVector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, rel_pos1: btVector3, rel_pos2: btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: btContactSolverInfo, desiredVelocity: btScalar = 0.0, cfmSlip: btScalar = 0.0) #no_context {
        setupFrictionConstraint(this, solverConstraint, *normalAxis, solverBodyIdA, solverBodyIdB, cp, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, *infoGlobal, desiredVelocity, cfmSlip);
    }

    setupTorsionalFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, normalAxis: *btVector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, rel_pos1: *btVector3, rel_pos2: *btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, desiredVelocity: btScalar = 0.0, cfmSlip: btScalar = 0.0) -> void #cpp_method #foreign bullet3 "?setupTorsionalFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@AEBVbtVector3@@HHAEAVbtManifoldPoint@@M11PEAVbtCollisionObject@@3MMM@Z";
    setupTorsionalFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, normalAxis: btVector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, rel_pos1: btVector3, rel_pos2: btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, desiredVelocity: btScalar = 0.0, cfmSlip: btScalar = 0.0) #no_context {
        setupTorsionalFrictionConstraint(this, solverConstraint, *normalAxis, solverBodyIdA, solverBodyIdB, cp, combinedTorsionalFriction, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
    }

    addFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, normalAxis: *btVector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *btManifoldPoint, rel_pos1: *btVector3, rel_pos2: *btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: *btContactSolverInfo, desiredVelocity: btScalar = 0.0, cfmSlip: btScalar = 0.0) -> *btSolverConstraint #cpp_method #foreign bullet3 "?addFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAAEAUbtSolverConstraint@@AEBVbtVector3@@HHHAEAVbtManifoldPoint@@00PEAVbtCollisionObject@@2MAEBUbtContactSolverInfo@@MM@Z";
    addFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, normalAxis: btVector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *btManifoldPoint, rel_pos1: btVector3, rel_pos2: btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: btContactSolverInfo, desiredVelocity: btScalar = 0.0, cfmSlip: btScalar = 0.0) -> *btSolverConstraint #no_context {
        return addFrictionConstraint(this, *normalAxis, solverBodyIdA, solverBodyIdB, frictionIndex, cp, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, *infoGlobal, desiredVelocity, cfmSlip);
    }
    addTorsionalFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, normalAxis: *btVector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *btManifoldPoint, torsionalFriction: btScalar, rel_pos1: *btVector3, rel_pos2: *btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0.0) -> *btSolverConstraint #cpp_method #foreign bullet3 "?addTorsionalFrictionConstraint@btSequentialImpulseConstraintSolver@@IEAAAEAUbtSolverConstraint@@AEBVbtVector3@@HHHAEAVbtManifoldPoint@@M00PEAVbtCollisionObject@@2MMM@Z";
    addTorsionalFrictionConstraint :: (this: *btSequentialImpulseConstraintSolver, normalAxis: btVector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *btManifoldPoint, torsionalFriction: btScalar, rel_pos1: btVector3, rel_pos2: btVector3, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0.0) -> *btSolverConstraint #no_context {
        return addTorsionalFrictionConstraint(this, *normalAxis, solverBodyIdA, solverBodyIdB, frictionIndex, cp, torsionalFriction, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
    }

    setupContactConstraint :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, infoGlobal: *btContactSolverInfo, relaxation: *btScalar, rel_pos1: *btVector3, rel_pos2: *btVector3) -> void #cpp_method #foreign bullet3 "?setupContactConstraint@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@HHAEAVbtManifoldPoint@@AEBUbtContactSolverInfo@@AEAMAEBVbtVector3@@4@Z";
    setupContactConstraint :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, infoGlobal: btContactSolverInfo, relaxation: *btScalar, rel_pos1: btVector3, rel_pos2: btVector3) #no_context {
        setupContactConstraint(this, solverConstraint, solverBodyIdA, solverBodyIdB, cp, *infoGlobal, relaxation, *rel_pos1, *rel_pos2);
    }

    applyAnisotropicFriction :: (colObj: *btCollisionObject, frictionDirection: *btVector3, frictionMode: s32) -> void #foreign bullet3 "?applyAnisotropicFriction@btSequentialImpulseConstraintSolver@@KAXPEAVbtCollisionObject@@AEAVbtVector3@@H@Z";

    setFrictionConstraintImpulse :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setFrictionConstraintImpulse@btSequentialImpulseConstraintSolver@@IEAAXAEAUbtSolverConstraint@@HHAEAVbtManifoldPoint@@AEBUbtContactSolverInfo@@@Z";
    setFrictionConstraintImpulse :: (this: *btSequentialImpulseConstraintSolver, solverConstraint: *btSolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *btManifoldPoint, infoGlobal: btContactSolverInfo) #no_context {
        setFrictionConstraintImpulse(this, solverConstraint, solverBodyIdA, solverBodyIdB, cp, *infoGlobal);
    }

    ///m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
    m_btSeed2:                                       u32;

    restitutionCurve :: (this: *btSequentialImpulseConstraintSolver, rel_vel: btScalar, restitution: btScalar, velocityThreshold: btScalar) -> btScalar #cpp_method #foreign bullet3 "?restitutionCurve@btSequentialImpulseConstraintSolver@@IEAAMMMM@Z";

    convertContact :: (this: *btSequentialImpulseConstraintSolver, manifold: *btPersistentManifold, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertContact@btSequentialImpulseConstraintSolver@@IEAAXPEAVbtPersistentManifold@@AEBUbtContactSolverInfo@@@Z";
    convertContact :: (this: *btSequentialImpulseConstraintSolver, manifold: *btPersistentManifold, infoGlobal: btContactSolverInfo) #no_context {
        convertContact(this, manifold, *infoGlobal);
    }

    convertJoint :: (this: *btSequentialImpulseConstraintSolver, currentConstraintRow: *btSolverConstraint, constraint: *btTypedConstraint, info1: *btTypedConstraint.btConstraintInfo1, solverBodyIdA: s32, solverBodyIdB: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertJoint@btSequentialImpulseConstraintSolver@@IEAAXPEAUbtSolverConstraint@@PEAVbtTypedConstraint@@AEBUbtConstraintInfo1@3@HHAEBUbtContactSolverInfo@@@Z";
    convertJoint :: (this: *btSequentialImpulseConstraintSolver, currentConstraintRow: *btSolverConstraint, constraint: *btTypedConstraint, info1: btTypedConstraint.btConstraintInfo1, solverBodyIdA: s32, solverBodyIdB: s32, infoGlobal: btContactSolverInfo) #no_context {
        convertJoint(this, currentConstraintRow, constraint, *info1, solverBodyIdA, solverBodyIdB, *infoGlobal);
    }

    resolveSplitPenetrationSIMD :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSplitPenetrationSIMD@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSplitPenetrationSIMD :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSplitPenetrationSIMD(this, bodyA, bodyB, *contactConstraint);
    }

    resolveSplitPenetrationImpulseCacheFriendly :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSplitPenetrationImpulseCacheFriendly@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSplitPenetrationImpulseCacheFriendly :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSplitPenetrationImpulseCacheFriendly(this, bodyA, bodyB, *contactConstraint);
    }

    //internal method
    getOrInitSolverBody :: (this: *btSequentialImpulseConstraintSolver, body: *btCollisionObject, timeStep: btScalar) -> s32 #cpp_method #foreign bullet3 "?getOrInitSolverBody@btSequentialImpulseConstraintSolver@@IEAAHAEAVbtCollisionObject@@M@Z";
    initSolverBody :: (this: *btSequentialImpulseConstraintSolver, solverBody: *btSolverBody, collisionObject: *btCollisionObject, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?initSolverBody@btSequentialImpulseConstraintSolver@@IEAAXPEAUbtSolverBody@@PEAVbtCollisionObject@@M@Z";

    resolveSingleConstraintRowGeneric :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSingleConstraintRowGeneric@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSingleConstraintRowGeneric :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSingleConstraintRowGeneric(this, bodyA, bodyB, *contactConstraint);
    }
    resolveSingleConstraintRowGenericSIMD :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSingleConstraintRowGenericSIMD@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSingleConstraintRowGenericSIMD :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSingleConstraintRowGenericSIMD(this, bodyA, bodyB, *contactConstraint);
    }
    resolveSingleConstraintRowLowerLimit :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSingleConstraintRowLowerLimit@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSingleConstraintRowLowerLimit :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSingleConstraintRowLowerLimit(this, bodyA, bodyB, *contactConstraint);
    }
    resolveSingleConstraintRowLowerLimitSIMD :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSingleConstraintRowLowerLimitSIMD@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSingleConstraintRowLowerLimitSIMD :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSingleConstraintRowLowerLimitSIMD(this, bodyA, bodyB, *contactConstraint);
    }
    resolveSplitPenetrationImpulse :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: *btSolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSplitPenetrationImpulse@btSequentialImpulseConstraintSolver@@IEAAMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z";
    resolveSplitPenetrationImpulse :: (this: *btSequentialImpulseConstraintSolver, bodyA: *btSolverBody, bodyB: *btSolverBody, contactConstraint: btSolverConstraint) -> btScalar #no_context {
        return resolveSplitPenetrationImpulse(this, bodyA, bodyB, *contactConstraint);
    }

    writeBackContacts :: (this: *btSequentialImpulseConstraintSolver, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?writeBackContacts@btSequentialImpulseConstraintSolver@@IEAAXHHAEBUbtContactSolverInfo@@@Z";
    writeBackContacts :: (this: *btSequentialImpulseConstraintSolver, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        writeBackContacts(this, iBegin, iEnd, *infoGlobal);
    }
    writeBackJoints :: (this: *btSequentialImpulseConstraintSolver, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?writeBackJoints@btSequentialImpulseConstraintSolver@@IEAAXHHAEBUbtContactSolverInfo@@@Z";
    writeBackJoints :: (this: *btSequentialImpulseConstraintSolver, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        writeBackJoints(this, iBegin, iEnd, *infoGlobal);
    }
    writeBackBodies :: (this: *btSequentialImpulseConstraintSolver, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?writeBackBodies@btSequentialImpulseConstraintSolver@@IEAAXHHAEBUbtContactSolverInfo@@@Z";
    writeBackBodies :: (this: *btSequentialImpulseConstraintSolver, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        writeBackBodies(this, iBegin, iEnd, *infoGlobal);
    }

    Constructor :: (this: *btSequentialImpulseConstraintSolver) -> void #cpp_method #foreign bullet3 "??0btSequentialImpulseConstraintSolver@@QEAA@XZ";

    btRand2 :: (this: *btSequentialImpulseConstraintSolver) -> u32 #cpp_method #foreign bullet3 "?btRand2@btSequentialImpulseConstraintSolver@@QEAAKXZ";

    btRandInt2 :: (this: *btSequentialImpulseConstraintSolver, n: s32) -> s32 #cpp_method #foreign bullet3 "?btRandInt2@btSequentialImpulseConstraintSolver@@QEAAHH@Z";

    setRandSeed :: (this: *btSequentialImpulseConstraintSolver, seed: u32) -> void #cpp_method #foreign bullet3 "?setRandSeed@btSequentialImpulseConstraintSolver@@QEAAXK@Z";

    getRandSeed :: (this: *btSequentialImpulseConstraintSolver) -> u32 #cpp_method #foreign bullet3 "?getRandSeed@btSequentialImpulseConstraintSolver@@QEBAKXZ";

    getActiveConstraintRowSolverGeneric :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getActiveConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";

    setConstraintRowSolverGeneric :: (this: *btSequentialImpulseConstraintSolver, rowSolver: btSingleConstraintRowSolver) -> void #cpp_method #foreign bullet3 "?setConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAXP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z@Z";

    getActiveConstraintRowSolverLowerLimit :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getActiveConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";

    setConstraintRowSolverLowerLimit :: (this: *btSequentialImpulseConstraintSolver, rowSolver: btSingleConstraintRowSolver) -> void #cpp_method #foreign bullet3 "?setConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAXP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@Z@Z";

    ///Various implementations of solving a single constraint row using a generic equality constraint, using scalar reference, SSE2 or SSE4
    getScalarConstraintRowSolverGeneric :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getScalarConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";
    getSSE2ConstraintRowSolverGeneric :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getSSE2ConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";
    getSSE4_1ConstraintRowSolverGeneric :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getSSE4_1ConstraintRowSolverGeneric@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";

    ///Various implementations of solving a single constraint row using an inequality (lower limit) constraint, using scalar reference, SSE2 or SSE4
    getScalarConstraintRowSolverLowerLimit :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getScalarConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";
    getSSE2ConstraintRowSolverLowerLimit :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getSSE2ConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";
    getSSE4_1ConstraintRowSolverLowerLimit :: (this: *btSequentialImpulseConstraintSolver) -> btSingleConstraintRowSolver #cpp_method #foreign bullet3 "?getSSE4_1ConstraintRowSolverLowerLimit@btSequentialImpulseConstraintSolver@@QEAAP6AMAEAUbtSolverBody@@0AEBUbtSolverConstraint@@@ZXZ";
    m_analyticsData:                                 btSolverAnalyticsData;
    #place btconstraintsolver; btsequentialimpulseconstraintsolver_vtable: *btSequentialImpulseConstraintSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_convertContacts :: (this: *btSequentialImpulseConstraintSolver, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertContacts@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z";

    virtual_convertJoints :: (this: *btSequentialImpulseConstraintSolver, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertJoints@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@@Z";

    virtual_convertBodies :: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertBodies@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    virtual_solveGroupCacheFriendlySplitImpulseIterations :: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySplitImpulseIterations@btSequentialImpulseConstraintSolver@@MEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
    virtual_solveGroupCacheFriendlyFinish :: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyFinish@btSequentialImpulseConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";
    virtual_solveSingleIteration :: (this: *btSequentialImpulseConstraintSolver, iteration: s32, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveSingleIteration@btSequentialImpulseConstraintSolver@@MEAAMHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_solveGroupCacheFriendlySetup :: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@btSequentialImpulseConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
    virtual_solveGroupCacheFriendlyIterations :: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyIterations@btSequentialImpulseConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_Destructor :: (this: *btSequentialImpulseConstraintSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSequentialImpulseConstraintSolver@@UEAA@XZ";

    virtual_solveGroup :: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> btScalar #cpp_method #foreign bullet3 "?solveGroup@btSequentialImpulseConstraintSolver@@UEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z";

    ///clear internal cached data and reset random seed
    virtual_reset :: (this: *btSequentialImpulseConstraintSolver) -> void #cpp_method #foreign bullet3 "?reset@btSequentialImpulseConstraintSolver@@UEAAXXZ";

    virtual_getSolverType :: (this: *btSequentialImpulseConstraintSolver) -> btConstraintSolverType #cpp_method #foreign bullet3 "?getSolverType@btSequentialImpulseConstraintSolver@@UEBA?AW4btConstraintSolverType@@XZ";
}
btSequentialImpulseConstraintSolver_VTable :: struct #type_info_none {
    using btconstraintsolver: btConstraintSolver_VTable;
    convertContacts: (this: *btSequentialImpulseConstraintSolver, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    convertJoints: (this: *btSequentialImpulseConstraintSolver, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    convertBodies: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    solveGroupCacheFriendlySplitImpulseIterations: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> void #cpp_method;
    solveGroupCacheFriendlyFinish: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method;
    solveSingleIteration: (this: *btSequentialImpulseConstraintSolver, iteration: s32, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method;

    solveGroupCacheFriendlySetup: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method;
    solveGroupCacheFriendlyIterations: (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method;
}

btSequentialImpulseConstraintSolver_convertContacts :: inline (this: *btSequentialImpulseConstraintSolver, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) { this.btsequentialimpulseconstraintsolver_vtable.convertContacts(this, manifoldPtr, numManifolds, infoGlobal); }

btSequentialImpulseConstraintSolver_convertJoints :: inline (this: *btSequentialImpulseConstraintSolver, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo) { this.btsequentialimpulseconstraintsolver_vtable.convertJoints(this, constraints, numConstraints, infoGlobal); }

btSequentialImpulseConstraintSolver_convertBodies :: inline (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) { this.btsequentialimpulseconstraintsolver_vtable.convertBodies(this, bodies, numBodies, infoGlobal); }

btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySplitImpulseIterations :: inline (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) { this.btsequentialimpulseconstraintsolver_vtable.solveGroupCacheFriendlySplitImpulseIterations(this, bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer); }
btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyFinish :: inline (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar { return this.btsequentialimpulseconstraintsolver_vtable.solveGroupCacheFriendlyFinish(this, bodies, numBodies, infoGlobal); }
btSequentialImpulseConstraintSolver_solveSingleIteration :: inline (this: *btSequentialImpulseConstraintSolver, iteration: s32, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar { return this.btsequentialimpulseconstraintsolver_vtable.solveSingleIteration(this, iteration, bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer); }

btSequentialImpulseConstraintSolver_solveGroupCacheFriendlySetup :: inline (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar { return this.btsequentialimpulseconstraintsolver_vtable.solveGroupCacheFriendlySetup(this, bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer); }
btSequentialImpulseConstraintSolver_solveGroupCacheFriendlyIterations :: inline (this: *btSequentialImpulseConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar { return this.btsequentialimpulseconstraintsolver_vtable.solveGroupCacheFriendlyIterations(this, bodies, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer); }

vtable :: (obj: *btSequentialImpulseConstraintSolver) -> *btSequentialImpulseConstraintSolver_VTable { return obj.btsequentialimpulseconstraintsolver_vtable; }



/// btVehicleRaycaster is provides interface for between vehicle simulation and raycasting
btVehicleRaycaster :: struct {
    vtable: *btVehicleRaycaster_VTable;
    btVehicleRaycasterResult :: struct {
        Constructor :: (this: *btVehicleRaycasterResult) -> void #cpp_method #foreign bullet3 "??0btVehicleRaycasterResult@btVehicleRaycaster@@QEAA@XZ";
        m_hitPointInWorld:  btVector3;
        m_hitNormalInWorld: btVector3;
        m_distFraction:     btScalar;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btVehicleRaycaster, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btVehicleRaycaster@@UEAA@XZ";
}
btVehicleRaycaster_VTable :: struct #type_info_none {
    Destructor: (this: *btVehicleRaycaster, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    castRay: (this: *btVehicleRaycaster, from: *btVector3, to: *btVector3, result: *btVehicleRaycaster.btVehicleRaycasterResult) -> *void #cpp_method;
}

btVehicleRaycaster_Destructor :: inline (this: *btVehicleRaycaster, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btVehicleRaycaster_castRay :: inline (this: *btVehicleRaycaster, from: *btVector3, to: *btVector3, result: *btVehicleRaycaster.btVehicleRaycasterResult) -> *void { return this.vtable.castRay(this, from, to, result); }



btWheelInfoConstructionInfo :: struct {
    m_chassisConnectionCS:      btVector3;
    m_wheelDirectionCS:         btVector3;
    m_wheelAxleCS:              btVector3;
    m_suspensionRestLength:     btScalar;
    m_maxSuspensionTravelCm:    btScalar;
    m_wheelRadius:              btScalar;

    m_suspensionStiffness:      btScalar;
    m_wheelsDampingCompression: btScalar;
    m_wheelsDampingRelaxation:  btScalar;
    m_frictionSlip:             btScalar;
    m_maxSuspensionForce:       btScalar;
    m_bIsFrontWheel:            bool;
}

/// btWheelInfo contains information per wheel about friction and suspension.
btWheelInfo :: struct {
    RaycastInfo :: struct {
        m_contactNormalWS:  btVector3; //contactnormal
        m_contactPointWS:   btVector3; //raycast hitpoint
        m_suspensionLength: btScalar;
        m_hardPointWS:      btVector3; //raycast starting point
        m_wheelDirectionWS: btVector3; //direction in worldspace
        m_wheelAxleWS:      btVector3; // axle in worldspace
        m_isInContact:      bool;
        m_groundObject:     *void; //could be general void* ptr
    }

    m_raycastInfo:                    RaycastInfo;

    m_worldTransform:                 btTransform;

    m_chassisConnectionPointCS:       btVector3; //const
    m_wheelDirectionCS:               btVector3; //const
    m_wheelAxleCS:                    btVector3; // const or modified by steering
    m_suspensionRestLength1:          btScalar; //const
    m_maxSuspensionTravelCm:          btScalar;
    getSuspensionRestLength :: (this: *btWheelInfo) -> btScalar #cpp_method #foreign bullet3 "?getSuspensionRestLength@btWheelInfo@@QEBAMXZ";
    m_wheelsRadius:                   btScalar; //const
    m_suspensionStiffness:            btScalar; //const
    m_wheelsDampingCompression:       btScalar; //const
    m_wheelsDampingRelaxation:        btScalar; //const
    m_frictionSlip:                   btScalar;
    m_steering:                       btScalar;
    m_rotation:                       btScalar;
    m_deltaRotation:                  btScalar;
    m_rollInfluence:                  btScalar;
    m_maxSuspensionForce:             btScalar;

    m_engineForce:                    btScalar;

    m_brake:                          btScalar;

    m_bIsFrontWheel:                  bool;

    m_clientInfo:                     *void; //can be used to store pointer to sync transforms...

    Constructor :: (this: *btWheelInfo) -> void #cpp_method #foreign bullet3 "??0btWheelInfo@@QEAA@XZ";

    Constructor :: (this: *btWheelInfo, ci: *btWheelInfoConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btWheelInfo@@QEAA@AEAUbtWheelInfoConstructionInfo@@@Z";

    updateWheel :: (this: *btWheelInfo, chassis: *btRigidBody, raycastInfo: *RaycastInfo) -> void #cpp_method #foreign bullet3 "?updateWheel@btWheelInfo@@QEAAXAEBVbtRigidBody@@AEAURaycastInfo@1@@Z";
    updateWheel :: (this: *btWheelInfo, chassis: btRigidBody, raycastInfo: *RaycastInfo) #no_context {
        updateWheel(this, *chassis, raycastInfo);
    }

    m_clippedInvContactDotSuspension: btScalar;
    m_suspensionRelativeVelocity:     btScalar;

    //calculated by suspension
    m_wheelsSuspensionForce:          btScalar;
    m_skidInfo:                       btScalar;
}

///Basic interface to allow actions such as vehicles and characters to be updated inside a btDynamicsWorld
btActionInterface :: struct {
    vtable: *btActionInterface_VTable;
    getFixedBody :: () -> *btRigidBody #foreign bullet3 "?getFixedBody@btActionInterface@@KAAEAVbtRigidBody@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btActionInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btActionInterface@@UEAA@XZ";
}
btActionInterface_VTable :: struct #type_info_none {
    Destructor: (this: *btActionInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    updateAction: (this: *btActionInterface, collisionWorld: *btCollisionWorld, deltaTimeStep: btScalar) -> void #cpp_method;

    debugDraw: (this: *btActionInterface, debugDrawer: *btIDebugDraw) -> void #cpp_method;
}

btActionInterface_Destructor :: inline (this: *btActionInterface, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btActionInterface_updateAction :: inline (this: *btActionInterface, collisionWorld: *btCollisionWorld, deltaTimeStep: btScalar) { this.vtable.updateAction(this, collisionWorld, deltaTimeStep); }

btActionInterface_debugDraw :: inline (this: *btActionInterface, debugDrawer: *btIDebugDraw) { this.vtable.debugDraw(this, debugDrawer); }



///rayCast vehicle, very special constraint that turn a rigidbody into a vehicle.
btRaycastVehicle :: struct {
    #as using btactioninterface: btActionInterface;

    m_forwardWS:                 btAlignedObjectArray(btVector3);
    m_axle:                      btAlignedObjectArray(btVector3);
    m_forwardImpulse:            btAlignedObjectArray(btScalar);
    m_sideImpulse:               btAlignedObjectArray(btScalar);

    ///backwards compatibility
    m_userConstraintType:        s32;
    m_userConstraintId:          s32;

    btVehicleTuning :: struct {
        m_suspensionStiffness:   btScalar;
        m_suspensionCompression: btScalar;
        m_suspensionDamping:     btScalar;
        m_maxSuspensionTravelCm: btScalar;
        m_frictionSlip:          btScalar;
        m_maxSuspensionForce:    btScalar;
    }

    m_vehicleRaycaster:          *btVehicleRaycaster;
    m_pitchControl:              btScalar;
    m_steeringValue:             btScalar;
    m_currentVehicleSpeedKmHour: btScalar;

    m_chassisBody:               *btRigidBody;

    m_indexRightAxis:            s32;
    m_indexUpAxis:               s32;
    m_indexForwardAxis:          s32;

    defaultInit :: (this: *btRaycastVehicle, tuning: *btVehicleTuning) -> void #cpp_method #foreign bullet3 "?defaultInit@btRaycastVehicle@@AEAAXAEBVbtVehicleTuning@1@@Z";
    defaultInit :: (this: *btRaycastVehicle, tuning: btVehicleTuning) #no_context {
        defaultInit(this, *tuning);
    }

    //constructor to create a car from an existing rigidbody
    Constructor :: (this: *btRaycastVehicle, tuning: *btVehicleTuning, chassis: *btRigidBody, raycaster: *btVehicleRaycaster) -> void #cpp_method #foreign bullet3 "??0btRaycastVehicle@@QEAA@AEBVbtVehicleTuning@0@PEAVbtRigidBody@@PEAUbtVehicleRaycaster@@@Z";
    Constructor :: (this: *btRaycastVehicle, tuning: btVehicleTuning, chassis: *btRigidBody, raycaster: *btVehicleRaycaster) #no_context {
        Constructor(this, *tuning, chassis, raycaster);
    }

    getChassisWorldTransform :: (this: *btRaycastVehicle) -> *btTransform #cpp_method #foreign bullet3 "?getChassisWorldTransform@btRaycastVehicle@@QEBAAEBVbtTransform@@XZ";

    rayCast :: (this: *btRaycastVehicle, wheel: *btWheelInfo) -> btScalar #cpp_method #foreign bullet3 "?rayCast@btRaycastVehicle@@QEAAMAEAUbtWheelInfo@@@Z";

    resetSuspension :: (this: *btRaycastVehicle) -> void #cpp_method #foreign bullet3 "?resetSuspension@btRaycastVehicle@@QEAAXXZ";

    getSteeringValue :: (this: *btRaycastVehicle, wheel: s32) -> btScalar #cpp_method #foreign bullet3 "?getSteeringValue@btRaycastVehicle@@QEBAMH@Z";

    setSteeringValue :: (this: *btRaycastVehicle, steering: btScalar, wheel: s32) -> void #cpp_method #foreign bullet3 "?setSteeringValue@btRaycastVehicle@@QEAAXMH@Z";

    applyEngineForce :: (this: *btRaycastVehicle, force: btScalar, wheel: s32) -> void #cpp_method #foreign bullet3 "?applyEngineForce@btRaycastVehicle@@QEAAXMH@Z";

    getWheelTransformWS :: (this: *btRaycastVehicle, wheelIndex: s32) -> *btTransform #cpp_method #foreign bullet3 "?getWheelTransformWS@btRaycastVehicle@@QEBAAEBVbtTransform@@H@Z";

    updateWheelTransform :: (this: *btRaycastVehicle, wheelIndex: s32, interpolatedTransform := true) -> void #cpp_method #foreign bullet3 "?updateWheelTransform@btRaycastVehicle@@QEAAXH_N@Z";

    //	void	setRaycastWheelInfo( int wheelIndex , bool isInContact, const btVector3& hitPoint, const btVector3& hitNormal,btScalar depth);
    addWheel :: (this: *btRaycastVehicle, connectionPointCS0: *btVector3, wheelDirectionCS0: *btVector3, wheelAxleCS: *btVector3, suspensionRestLength: btScalar, wheelRadius: btScalar, tuning: *btVehicleTuning, isFrontWheel: bool) -> *btWheelInfo #cpp_method #foreign bullet3 "?addWheel@btRaycastVehicle@@QEAAAEAUbtWheelInfo@@AEBVbtVector3@@00MMAEBVbtVehicleTuning@1@_N@Z";
    addWheel :: (this: *btRaycastVehicle, connectionPointCS0: btVector3, wheelDirectionCS0: btVector3, wheelAxleCS: btVector3, suspensionRestLength: btScalar, wheelRadius: btScalar, tuning: btVehicleTuning, isFrontWheel: bool) -> *btWheelInfo #no_context {
        return addWheel(this, *connectionPointCS0, *wheelDirectionCS0, *wheelAxleCS, suspensionRestLength, wheelRadius, *tuning, isFrontWheel);
    }

    getNumWheels :: (this: *btRaycastVehicle) -> s32 #cpp_method #foreign bullet3 "?getNumWheels@btRaycastVehicle@@QEBAHXZ";

    m_wheelInfo:                 btAlignedObjectArray(btWheelInfo);

    getWheelInfo :: (this: /*const*/ *btRaycastVehicle, index: s32) -> *btWheelInfo #cpp_method #foreign bullet3 "?getWheelInfo@btRaycastVehicle@@QEBAAEBUbtWheelInfo@@H@Z";

    getWheelInfo_1 :: (this: *btRaycastVehicle, index: s32) -> *btWheelInfo #cpp_method #foreign bullet3 "?getWheelInfo@btRaycastVehicle@@QEAAAEAUbtWheelInfo@@H@Z";

    updateWheelTransformsWS :: (this: *btRaycastVehicle, wheel: *btWheelInfo, interpolatedTransform := true) -> void #cpp_method #foreign bullet3 "?updateWheelTransformsWS@btRaycastVehicle@@QEAAXAEAUbtWheelInfo@@_N@Z";

    setBrake :: (this: *btRaycastVehicle, brake: btScalar, wheelIndex: s32) -> void #cpp_method #foreign bullet3 "?setBrake@btRaycastVehicle@@QEAAXMH@Z";

    setPitchControl :: (this: *btRaycastVehicle, pitch: btScalar) -> void #cpp_method #foreign bullet3 "?setPitchControl@btRaycastVehicle@@QEAAXM@Z";

    updateSuspension :: (this: *btRaycastVehicle, deltaTime: btScalar) -> void #cpp_method #foreign bullet3 "?updateSuspension@btRaycastVehicle@@QEAAXM@Z";

    getRigidBody :: (this: *btRaycastVehicle) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBody@btRaycastVehicle@@QEAAPEAVbtRigidBody@@XZ";

    getRigidBody_1 :: (this: /*const*/ *btRaycastVehicle) -> *btRigidBody #cpp_method #foreign bullet3 "?getRigidBody@btRaycastVehicle@@QEBAPEBVbtRigidBody@@XZ";

    getRightAxis :: (this: *btRaycastVehicle) -> s32 #cpp_method #foreign bullet3 "?getRightAxis@btRaycastVehicle@@QEBAHXZ";

    getUpAxis :: (this: *btRaycastVehicle) -> s32 #cpp_method #foreign bullet3 "?getUpAxis@btRaycastVehicle@@QEBAHXZ";

    getForwardAxis :: (this: *btRaycastVehicle) -> s32 #cpp_method #foreign bullet3 "?getForwardAxis@btRaycastVehicle@@QEBAHXZ";

    ///Worldspace forward vector
    getForwardVector :: (this: *btRaycastVehicle) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getForwardVector@btRaycastVehicle@@QEBA?AVbtVector3@@XZ";

    ///Velocity of vehicle (positive if velocity vector has same direction as foward vector)
    getCurrentSpeedKmHour :: (this: *btRaycastVehicle) -> btScalar #cpp_method #foreign bullet3 "?getCurrentSpeedKmHour@btRaycastVehicle@@QEBAMXZ";

    ///backwards compatibility
    getUserConstraintType :: (this: *btRaycastVehicle) -> s32 #cpp_method #foreign bullet3 "?getUserConstraintType@btRaycastVehicle@@QEBAHXZ";

    setUserConstraintType :: (this: *btRaycastVehicle, userConstraintType: s32) -> void #cpp_method #foreign bullet3 "?setUserConstraintType@btRaycastVehicle@@QEAAXH@Z";

    setUserConstraintId :: (this: *btRaycastVehicle, uid: s32) -> void #cpp_method #foreign bullet3 "?setUserConstraintId@btRaycastVehicle@@QEAAXH@Z";

    getUserConstraintId :: (this: *btRaycastVehicle) -> s32 #cpp_method #foreign bullet3 "?getUserConstraintId@btRaycastVehicle@@QEBAHXZ";
    #place btactioninterface; btraycastvehicle_vtable: *btRaycastVehicle_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btRaycastVehicle, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btRaycastVehicle@@UEAA@XZ";

    ///btActionInterface interface
    virtual_updateAction :: (this: *btRaycastVehicle, collisionWorld: *btCollisionWorld, step: btScalar) -> void #cpp_method #foreign bullet3 "?updateAction@btRaycastVehicle@@UEAAXPEAVbtCollisionWorld@@M@Z";

    ///btActionInterface interface
    virtual_debugDraw :: (this: *btRaycastVehicle, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btRaycastVehicle@@UEAAXPEAVbtIDebugDraw@@@Z";

    virtual_updateVehicle :: (this: *btRaycastVehicle, step: btScalar) -> void #cpp_method #foreign bullet3 "?updateVehicle@btRaycastVehicle@@UEAAXM@Z";

    virtual_updateFriction :: (this: *btRaycastVehicle, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateFriction@btRaycastVehicle@@UEAAXM@Z";

    virtual_setCoordinateSystem :: (this: *btRaycastVehicle, rightIndex: s32, upIndex: s32, forwardIndex: s32) -> void #cpp_method #foreign bullet3 "?setCoordinateSystem@btRaycastVehicle@@UEAAXHHH@Z";
}
btRaycastVehicle_VTable :: struct #type_info_none {
    using btactioninterface: btActionInterface_VTable;
    updateVehicle: (this: *btRaycastVehicle, step: btScalar) -> void #cpp_method;

    updateFriction: (this: *btRaycastVehicle, timeStep: btScalar) -> void #cpp_method;

    setCoordinateSystem: (this: *btRaycastVehicle, rightIndex: s32, upIndex: s32, forwardIndex: s32) -> void #cpp_method;
}

btRaycastVehicle_updateVehicle :: inline (this: *btRaycastVehicle, step: btScalar) { this.btraycastvehicle_vtable.updateVehicle(this, step); }

btRaycastVehicle_updateFriction :: inline (this: *btRaycastVehicle, timeStep: btScalar) { this.btraycastvehicle_vtable.updateFriction(this, timeStep); }

btRaycastVehicle_setCoordinateSystem :: inline (this: *btRaycastVehicle, rightIndex: s32, upIndex: s32, forwardIndex: s32) { this.btraycastvehicle_vtable.setCoordinateSystem(this, rightIndex, upIndex, forwardIndex); }

vtable :: (obj: *btRaycastVehicle) -> *btRaycastVehicle_VTable { return obj.btraycastvehicle_vtable; }


btDefaultVehicleRaycaster :: struct {
    #as using btvehicleraycaster: btVehicleRaycaster;

    m_dynamicsWorld: *btDynamicsWorld;

    Constructor :: (this: *btDefaultVehicleRaycaster, world: *btDynamicsWorld) -> void #cpp_method #foreign bullet3 "??0btDefaultVehicleRaycaster@@QEAA@PEAVbtDynamicsWorld@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_castRay :: (this: *btDefaultVehicleRaycaster, from: *btVector3, to: *btVector3, result: *btVehicleRaycaster.btVehicleRaycasterResult) -> *void #cpp_method #foreign bullet3 "?castRay@btDefaultVehicleRaycaster@@UEAAPEAXAEBVbtVector3@@0AEAUbtVehicleRaycasterResult@btVehicleRaycaster@@@Z";
}

b3ProfileZone :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

b3PrintfFunc :: #type (msg: *u8) -> void #c_call;
b3WarningMessageFunc :: #type (msg: *u8) -> void #c_call;
b3ErrorMessageFunc :: #type (msg: *u8) -> void #c_call;
b3EnterProfileZoneFunc :: #type (msg: *u8) -> void #c_call;
b3LeaveProfileZoneFunc :: #type () -> void #c_call;

b3Scalar :: float;

///rudimentary class to provide type info
b3TypedObject :: struct {
    Constructor :: (this: *b3TypedObject, objectType: s32) -> void #cpp_method #foreign bullet3 "??0b3TypedObject@@QEAA@H@Z";

    m_objectType: s32;
    getObjectType :: (this: *b3TypedObject) -> s32 #cpp_method #foreign bullet3 "?getObjectType@b3TypedObject@@QEBAHXZ";
}

btSizeType :: s32;

b3AlignedAllocFunc :: #type (size: size_t, alignment: s32) -> *void #c_call;
b3AlignedFreeFunc :: #type (memblock: *void) -> void #c_call;
b3AllocFunc :: #type (size: size_t) -> *void #c_call;
b3FreeFunc :: #type (memblock: *void) -> void #c_call;

///The b3AlignedAllocator is a portable class for aligned memory allocations.
///Default implementations for unaligned and aligned allocations can be overridden by a custom allocator using b3AlignedAllocSetCustom and b3AlignedAllocSetCustomAligned.
b3AlignedAllocator :: struct(T: Type, Alignment: u32) {
    self_type :: b3AlignedAllocator(T, UnknownTemplateArgumentPlaceholder);

    const_pointer :: *T;
    const_reference :: *T;
    pointer :: *T;
    reference :: *T;
    value_type :: T;

    rebind :: struct(O: Type) {
        other :: b3AlignedAllocator(O, UnknownTemplateArgumentPlaceholder);
    }
}

///The b3AlignedObjectArray template class uses a subset of the stl::vector interface for its methods
///It is developed to replace stl::vector to avoid portability issues, including STL alignment issues to add SIMD/SSE data
b3AlignedObjectArray :: struct(T: Type) {
    m_allocator:  b3AlignedAllocator(T, UnknownTemplateArgumentPlaceholder) = 16;

    m_size:       s32;
    m_capacity:   s32;
    m_data:       *T;

    //PCK: added this line
    m_ownsMemory: bool;

    less :: struct {}
}

b3CommandLineArgs :: struct {
    pairs: std.map(std.string, std.string);
}

b3FileUtils :: struct {
    vtable: *b3FileUtils_VTable;
}
b3FileUtils_VTable :: struct #type_info_none {
    Destructor: (this: *b3FileUtils, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
b3FileUtils_Destructor :: inline (this: *b3FileUtils, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



///very basic hashable string implementation, compatible with b3HashMap
b3HashString :: struct {
    m_string: std.string;
    m_hash:   u32;

    getHash :: (this: *b3HashString) -> u32 #cpp_method #foreign bullet3 "?getHash@b3HashString@@QEBAIXZ";

    Constructor :: (this: *b3HashString) -> void #cpp_method #foreign bullet3 "??0b3HashString@@QEAA@XZ";

    Constructor :: (this: *b3HashString, name: *u8) -> void #cpp_method #foreign bullet3 "??0b3HashString@@QEAA@PEBD@Z";

    portableStringCompare :: (this: *b3HashString, src: *u8, dst: *u8) -> s32 #cpp_method #foreign bullet3 "?portableStringCompare@b3HashString@@QEBAHPEBD0@Z";

    equals :: (this: *b3HashString, other: *b3HashString) -> bool #cpp_method #foreign bullet3 "?equals@b3HashString@@QEBA_NAEBU1@@Z";
    equals :: (this: *b3HashString, other: b3HashString) -> bool #no_context {
        return equals(this, *other);
    }
}

b3HashInt :: struct {
    m_uid: s32;

    Constructor :: (this: *b3HashInt, uid: s32) -> void #cpp_method #foreign bullet3 "??0b3HashInt@@QEAA@H@Z";

    getUid1 :: (this: *b3HashInt) -> s32 #cpp_method #foreign bullet3 "?getUid1@b3HashInt@@QEBAHXZ";

    setUid1 :: (this: *b3HashInt, uid: s32) -> void #cpp_method #foreign bullet3 "?setUid1@b3HashInt@@QEAAXH@Z";

    equals :: (this: *b3HashInt, other: *b3HashInt) -> bool #cpp_method #foreign bullet3 "?equals@b3HashInt@@QEBA_NAEBV1@@Z";
    equals :: (this: *b3HashInt, other: b3HashInt) -> bool #no_context {
        return equals(this, *other);
    }

    //to our success
    getHash :: (this: *b3HashInt) -> u32 #cpp_method #foreign bullet3 "?getHash@b3HashInt@@QEBAIXZ";
}

b3HashPtr :: struct {
    union {
        m_pointer:    *void;
        m_hashValues: [2] s32;
    }

    Constructor :: (this: *b3HashPtr, ptr: *void) -> void #cpp_method #foreign bullet3 "??0b3HashPtr@@QEAA@PEBX@Z";

    getPointer :: (this: *b3HashPtr) -> *void #cpp_method #foreign bullet3 "?getPointer@b3HashPtr@@QEBAPEBXXZ";

    equals :: (this: *b3HashPtr, other: *b3HashPtr) -> bool #cpp_method #foreign bullet3 "?equals@b3HashPtr@@QEBA_NAEBV1@@Z";
    equals :: (this: *b3HashPtr, other: b3HashPtr) -> bool #no_context {
        return equals(this, *other);
    }

    //to our success
    getHash :: (this: *b3HashPtr) -> u32 #cpp_method #foreign bullet3 "?getHash@b3HashPtr@@QEBAIXZ";
}

b3HashKeyPtr :: struct(Value: Type) {
    m_uid: s32;
}

b3HashKey :: struct(Value: Type) {
    m_uid: s32;
}

///The b3HashMap template class implements a generic and lightweight hashmap.
///A basic sample of how to use b3HashMap is located in Demos\BasicDemo\main.cpp
b3HashMap :: struct(Key: Type, Value: Type) {
    m_hashTable:  b3AlignedObjectArray(s32);
    m_next:       b3AlignedObjectArray(s32);

    m_valueArray: b3AlignedObjectArray(Value);
    m_keyArray:   b3AlignedObjectArray(Key);
}

/**@brief b3Vector3 can be used to represent 3D points and vectors.
* It has an un-used w component to suit 16-byte alignment when b3Vector3 is stored in containers. This extra component can be used by derived classes (Quaternion?) or by user
* Ideally, this class should be replaced by a platform optimized SIMD version that keeps the data in registers
*/
b3Vector3 :: struct {
    union {
        m_floats: [4] float;
        struct {
            x: float;
            y: float;
            z: float;
            w: float;
        }
    }

    /**@brief Return the dot product
    * @param v The other vector in the dot product */
    dot :: (this: *b3Vector3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?dot@b3Vector3@@QEBAMAEBV1@@Z";
    dot :: (this: *b3Vector3, v: b3Vector3) -> b3Scalar #no_context {
        return dot(this, *v);
    }

    /**@brief Return the length of the vector squared */
    length2 :: (this: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?length2@b3Vector3@@QEBAMXZ";

    /**@brief Return the length of the vector */
    length :: (this: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?length@b3Vector3@@QEBAMXZ";

    /**@brief Return the distance squared between the ends of this and another vector
    * This is symantically treating the vector like a point */
    distance2 :: (this: *b3Vector3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?distance2@b3Vector3@@QEBAMAEBV1@@Z";
    distance2 :: (this: *b3Vector3, v: b3Vector3) -> b3Scalar #no_context {
        return distance2(this, *v);
    }

    /**@brief Return the distance between the ends of this and another vector
    * This is symantically treating the vector like a point */
    distance :: (this: *b3Vector3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?distance@b3Vector3@@QEBAMAEBV1@@Z";
    distance :: (this: *b3Vector3, v: b3Vector3) -> b3Scalar #no_context {
        return distance(this, *v);
    }

    safeNormalize :: (this: *b3Vector3) -> *b3Vector3 #cpp_method #foreign bullet3 "?safeNormalize@b3Vector3@@QEAAAEAV1@XZ";

    /**@brief Normalize this vector
    * x^2 + y^2 + z^2 = 1 */
    normalize :: (this: *b3Vector3) -> *b3Vector3 #cpp_method #foreign bullet3 "?normalize@b3Vector3@@QEAAAEAV1@XZ";

    /**@brief Return a normalized version of this vector */
    normalized :: (this: *b3Vector3) -> b3Vector3 #cpp_method #foreign bullet3 "?normalized@b3Vector3@@QEBA?AV1@XZ";

    /**@brief Return a rotated version of this vector
    * @param wAxis The axis to rotate about
    * @param angle The angle to rotate by */
    rotate :: (this: *b3Vector3, wAxis: *b3Vector3, angle: b3Scalar) -> b3Vector3 #cpp_method #foreign bullet3 "?rotate@b3Vector3@@QEBA?AV1@AEBV1@M@Z";
    rotate :: (this: *b3Vector3, wAxis: b3Vector3, angle: b3Scalar) -> b3Vector3 #no_context {
        return rotate(this, *wAxis, angle);
    }

    /**@brief Return the angle between this and another vector
    * @param v The other vector */
    angle :: (this: *b3Vector3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?angle@b3Vector3@@QEBAMAEBV1@@Z";
    angle :: (this: *b3Vector3, v: b3Vector3) -> b3Scalar #no_context {
        return angle(this, *v);
    }

    /**@brief Return a vector will the absolute values of each element */
    absolute :: (this: *b3Vector3) -> b3Vector3 #cpp_method #foreign bullet3 "?absolute@b3Vector3@@QEBA?AV1@XZ";

    /**@brief Return the cross product between this and another vector
    * @param v The other vector */
    cross :: (this: *b3Vector3, v: *b3Vector3) -> b3Vector3 #cpp_method #foreign bullet3 "?cross@b3Vector3@@QEBA?AV1@AEBV1@@Z";
    cross :: (this: *b3Vector3, v: b3Vector3) -> b3Vector3 #no_context {
        return cross(this, *v);
    }

    triple :: (this: *b3Vector3, v1: *b3Vector3, v2: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?triple@b3Vector3@@QEBAMAEBV1@0@Z";
    triple :: (this: *b3Vector3, v1: b3Vector3, v2: b3Vector3) -> b3Scalar #no_context {
        return triple(this, *v1, *v2);
    }

    /**@brief Return the axis with the smallest value
    * Note return values are 0,1,2 for x, y, or z */
    minAxis :: (this: *b3Vector3) -> s32 #cpp_method #foreign bullet3 "?minAxis@b3Vector3@@QEBAHXZ";

    /**@brief Return the axis with the largest value
    * Note return values are 0,1,2 for x, y, or z */
    maxAxis :: (this: *b3Vector3) -> s32 #cpp_method #foreign bullet3 "?maxAxis@b3Vector3@@QEBAHXZ";

    furthestAxis :: (this: *b3Vector3) -> s32 #cpp_method #foreign bullet3 "?furthestAxis@b3Vector3@@QEBAHXZ";

    closestAxis :: (this: *b3Vector3) -> s32 #cpp_method #foreign bullet3 "?closestAxis@b3Vector3@@QEBAHXZ";

    setInterpolate3 :: (this: *b3Vector3, v0: *b3Vector3, v1: *b3Vector3, rt: b3Scalar) -> void #cpp_method #foreign bullet3 "?setInterpolate3@b3Vector3@@QEAAXAEBV1@0M@Z";
    setInterpolate3 :: (this: *b3Vector3, v0: b3Vector3, v1: b3Vector3, rt: b3Scalar) #no_context {
        setInterpolate3(this, *v0, *v1, rt);
    }

    /**@brief Return the linear interpolation between this and another vector
    * @param v The other vector
    * @param t The ration of this to v (t = 0 => return this, t=1 => return other) */
    lerp :: (this: *b3Vector3, v: *b3Vector3, t: *b3Scalar) -> b3Vector3 #cpp_method #foreign bullet3 "?lerp@b3Vector3@@QEBA?AV1@AEBV1@AEBM@Z";
    lerp :: (this: *b3Vector3, v: b3Vector3, t: b3Scalar) -> b3Vector3 #no_context {
        return lerp(this, *v, *t);
    }

    /**@brief Return the x value */
    getX :: (this: *b3Vector3) -> *b3Scalar #cpp_method #foreign bullet3 "?getX@b3Vector3@@QEBAAEBMXZ";

    /**@brief Return the y value */
    getY :: (this: *b3Vector3) -> *b3Scalar #cpp_method #foreign bullet3 "?getY@b3Vector3@@QEBAAEBMXZ";

    /**@brief Return the z value */
    getZ :: (this: *b3Vector3) -> *b3Scalar #cpp_method #foreign bullet3 "?getZ@b3Vector3@@QEBAAEBMXZ";

    /**@brief Return the w value */
    getW :: (this: *b3Vector3) -> *b3Scalar #cpp_method #foreign bullet3 "?getW@b3Vector3@@QEBAAEBMXZ";

    /**@brief Set the x value */
    setX :: (this: *b3Vector3, _x: b3Scalar) -> void #cpp_method #foreign bullet3 "?setX@b3Vector3@@QEAAXM@Z";

    /**@brief Set the y value */
    setY :: (this: *b3Vector3, _y: b3Scalar) -> void #cpp_method #foreign bullet3 "?setY@b3Vector3@@QEAAXM@Z";

    /**@brief Set the z value */
    setZ :: (this: *b3Vector3, _z: b3Scalar) -> void #cpp_method #foreign bullet3 "?setZ@b3Vector3@@QEAAXM@Z";

    /**@brief Set the w value */
    setW :: (this: *b3Vector3, _w: b3Scalar) -> void #cpp_method #foreign bullet3 "?setW@b3Vector3@@QEAAXM@Z";

    /**@brief Set each element to the max of the current values and the values of another b3Vector3
    * @param other The other b3Vector3 to compare with
    */
    setMax :: (this: *b3Vector3, other: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setMax@b3Vector3@@QEAAXAEBV1@@Z";
    setMax :: (this: *b3Vector3, other: b3Vector3) #no_context {
        setMax(this, *other);
    }

    /**@brief Set each element to the min of the current values and the values of another b3Vector3
    * @param other The other b3Vector3 to compare with
    */
    setMin :: (this: *b3Vector3, other: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setMin@b3Vector3@@QEAAXAEBV1@@Z";
    setMin :: (this: *b3Vector3, other: b3Vector3) #no_context {
        setMin(this, *other);
    }

    setValue :: (this: *b3Vector3, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setValue@b3Vector3@@QEAAXAEBM00@Z";
    setValue :: (this: *b3Vector3, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar) #no_context {
        setValue(this, *_x, *_y, *_z);
    }

    getSkewSymmetricMatrix :: (this: *b3Vector3, v0: *b3Vector3, v1: *b3Vector3, v2: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getSkewSymmetricMatrix@b3Vector3@@QEBAXPEAV1@00@Z";

    setZero :: (this: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setZero@b3Vector3@@QEAAXXZ";

    isZero :: (this: *b3Vector3) -> bool #cpp_method #foreign bullet3 "?isZero@b3Vector3@@QEBA_NXZ";

    fuzzyZero :: (this: *b3Vector3) -> bool #cpp_method #foreign bullet3 "?fuzzyZero@b3Vector3@@QEBA_NXZ";

    serialize :: (this: *b3Vector3, dataOut: *b3Vector3FloatData) -> void #cpp_method #foreign bullet3 "?serialize@b3Vector3@@QEBAXAEAUb3Vector3FloatData@@@Z";

    deSerialize :: (this: *b3Vector3, dataIn: *b3Vector3FloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@b3Vector3@@QEAAXAEBUb3Vector3FloatData@@@Z";
    deSerialize :: (this: *b3Vector3, dataIn: b3Vector3FloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    serializeFloat :: (this: *b3Vector3, dataOut: *b3Vector3FloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@b3Vector3@@QEBAXAEAUb3Vector3FloatData@@@Z";

    deSerializeFloat :: (this: *b3Vector3, dataIn: *b3Vector3FloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@b3Vector3@@QEAAXAEBUb3Vector3FloatData@@@Z";
    deSerializeFloat :: (this: *b3Vector3, dataIn: b3Vector3FloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }

    serializeDouble :: (this: *b3Vector3, dataOut: *b3Vector3DoubleData) -> void #cpp_method #foreign bullet3 "?serializeDouble@b3Vector3@@QEBAXAEAUb3Vector3DoubleData@@@Z";

    deSerializeDouble :: (this: *b3Vector3, dataIn: *b3Vector3DoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@b3Vector3@@QEAAXAEBUb3Vector3DoubleData@@@Z";
    deSerializeDouble :: (this: *b3Vector3, dataIn: b3Vector3DoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }

    /**@brief returns index of maximum dot product between this and vectors in array[]
    * @param array The other vectors
    * @param array_count The number of other vectors
    * @param dotOut The maximum dot product */
    maxDot :: (this: *b3Vector3, array: *b3Vector3, array_count: s32, dotOut: *b3Scalar) -> s32 #cpp_method #foreign bullet3 "?maxDot@b3Vector3@@QEBAJPEBV1@JAEAM@Z";

    /**@brief returns index of minimum dot product between this and vectors in array[]
    * @param array The other vectors
    * @param array_count The number of other vectors
    * @param dotOut The minimum dot product */
    minDot :: (this: *b3Vector3, array: *b3Vector3, array_count: s32, dotOut: *b3Scalar) -> s32 #cpp_method #foreign bullet3 "?minDot@b3Vector3@@QEBAJPEBV1@JAEAM@Z";

    /* create a vector as  b3Vector3( this->dot( b3Vector3 v0 ), this->dot( b3Vector3 v1), this->dot( b3Vector3 v2 ))  */
    dot3 :: (this: *b3Vector3, v0: *b3Vector3, v1: *b3Vector3, v2: *b3Vector3) -> b3Vector3 #cpp_method #foreign bullet3 "?dot3@b3Vector3@@QEBA?AV1@AEBV1@00@Z";
    dot3 :: (this: *b3Vector3, v0: b3Vector3, v1: b3Vector3, v2: b3Vector3) -> b3Vector3 #no_context {
        return dot3(this, *v0, *v1, *v2);
    }
}


/**@brief Add a vector to this one
* @param The vector to add to this one */
operator+= :: (this: *b3Vector3, v: *b3Vector3) -> *b3Vector3 #cpp_method #foreign bullet3 "??Yb3Vector3@@QEAAAEAV0@AEBV0@@Z";
operator+= :: (this: *b3Vector3, v: b3Vector3) -> *b3Vector3 #no_context {
    return operator+=(this, *v);
}

/**@brief Subtract a vector from this one
* @param The vector to subtract */
operator-= :: (this: *b3Vector3, v: *b3Vector3) -> *b3Vector3 #cpp_method #foreign bullet3 "??Zb3Vector3@@QEAAAEAV0@AEBV0@@Z";
operator-= :: (this: *b3Vector3, v: b3Vector3) -> *b3Vector3 #no_context {
    return operator-=(this, *v);
}

/**@brief Scale the vector
* @param s Scale factor */
operator*= :: (this: *b3Vector3, s: *b3Scalar) -> *b3Vector3 #cpp_method #foreign bullet3 "??Xb3Vector3@@QEAAAEAV0@AEBM@Z";
operator*= :: (this: *b3Vector3, s: b3Scalar) -> *b3Vector3 #no_context {
    return operator*=(this, *s);
}

/**@brief Inversely scale the vector
* @param s Scale factor to divide by */
operator/= :: (this: *b3Vector3, s: *b3Scalar) -> *b3Vector3 #cpp_method #foreign bullet3 "??_0b3Vector3@@QEAAAEAV0@AEBM@Z";
operator/= :: (this: *b3Vector3, s: b3Scalar) -> *b3Vector3 #no_context {
    return operator/=(this, *s);
}

/**@brief Elementwise multiply this vector by the other
* @param v The other vector */
operator*= :: (this: *b3Vector3, v: *b3Vector3) -> *b3Vector3 #cpp_method #foreign bullet3 "??Xb3Vector3@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *b3Vector3, v: b3Vector3) -> *b3Vector3 #no_context {
    return operator*=(this, *v);
}

operator== :: (this: *b3Vector3, other: *b3Vector3) -> bool #cpp_method #foreign bullet3 "??8b3Vector3@@QEBA_NAEBV0@@Z";
operator== :: (this: b3Vector3, other: b3Vector3) -> bool #no_context {
    return operator==(*this, *other);
}

operator!= :: (this: *b3Vector3, other: *b3Vector3) -> bool #cpp_method #foreign bullet3 "??9b3Vector3@@QEBA_NAEBV0@@Z";
operator!= :: (this: b3Vector3, other: b3Vector3) -> bool #no_context {
    return operator!=(*this, *other);
}

b3Vector4 :: struct {
    #as using b3vector3: b3Vector3;

    absolute4 :: (this: *b3Vector4) -> b3Vector4 #cpp_method #foreign bullet3 "?absolute4@b3Vector4@@QEBA?AV1@XZ";

    getW :: (this: *b3Vector4) -> b3Scalar #cpp_method #foreign bullet3 "?getW@b3Vector4@@QEBAMXZ";

    maxAxis4 :: (this: *b3Vector4) -> s32 #cpp_method #foreign bullet3 "?maxAxis4@b3Vector4@@QEBAHXZ";

    minAxis4 :: (this: *b3Vector4) -> s32 #cpp_method #foreign bullet3 "?minAxis4@b3Vector4@@QEBAHXZ";

    closestAxis4 :: (this: *b3Vector4) -> s32 #cpp_method #foreign bullet3 "?closestAxis4@b3Vector4@@QEBAHXZ";

    /*		void getValue(b3Scalar *m) const
    {
    m[0] = m_floats[0];
    m[1] = m_floats[1];
    m[2] =m_floats[2];
    }
    */
    /**@brief Set the values
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    * @param w Value of w
    */
    setValue :: (this: *b3Vector4, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar, _w: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setValue@b3Vector4@@QEAAXAEBM000@Z";
    setValue :: (this: *b3Vector4, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar, _w: b3Scalar) #no_context {
        setValue(this, *_x, *_y, *_z, *_w);
    }
}

b3Vector3FloatData :: struct {
    m_floats: [4] float;
}

b3Vector3DoubleData :: struct {
    m_floats: [4] float64;
}

b3QuadWord :: struct {
    union {
        m_floats: [4] b3Scalar;
        struct {
            x: b3Scalar;
            y: b3Scalar;
            z: b3Scalar;
            w: b3Scalar;
        }
    }

    /**@brief Return the x value */
    getX :: (this: *b3QuadWord) -> *b3Scalar #cpp_method #foreign bullet3 "?getX@b3QuadWord@@QEBAAEBMXZ";

    /**@brief Return the y value */
    getY :: (this: *b3QuadWord) -> *b3Scalar #cpp_method #foreign bullet3 "?getY@b3QuadWord@@QEBAAEBMXZ";

    /**@brief Return the z value */
    getZ :: (this: *b3QuadWord) -> *b3Scalar #cpp_method #foreign bullet3 "?getZ@b3QuadWord@@QEBAAEBMXZ";

    /**@brief Set the x value */
    setX :: (this: *b3QuadWord, _x: b3Scalar) -> void #cpp_method #foreign bullet3 "?setX@b3QuadWord@@QEAAXM@Z";

    /**@brief Set the y value */
    setY :: (this: *b3QuadWord, _y: b3Scalar) -> void #cpp_method #foreign bullet3 "?setY@b3QuadWord@@QEAAXM@Z";

    /**@brief Set the z value */
    setZ :: (this: *b3QuadWord, _z: b3Scalar) -> void #cpp_method #foreign bullet3 "?setZ@b3QuadWord@@QEAAXM@Z";

    /**@brief Set the w value */
    setW :: (this: *b3QuadWord, _w: b3Scalar) -> void #cpp_method #foreign bullet3 "?setW@b3QuadWord@@QEAAXM@Z";

    /**@brief Set x,y,z and zero w 
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    */
    setValue :: (this: *b3QuadWord, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setValue@b3QuadWord@@QEAAXAEBM00@Z";
    setValue :: (this: *b3QuadWord, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar) #no_context {
        setValue(this, *_x, *_y, *_z);
    }

    /*		void getValue(b3Scalar *m) const 
    {
    m[0] = m_floats[0];
    m[1] = m_floats[1];
    m[2] = m_floats[2];
    }
    */
    /**@brief Set the values 
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    * @param w Value of w
    */
    setValue :: (this: *b3QuadWord, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar, _w: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setValue@b3QuadWord@@QEAAXAEBM000@Z";
    setValue :: (this: *b3QuadWord, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar, _w: b3Scalar) #no_context {
        setValue(this, *_x, *_y, *_z, *_w);
    }

    /**@brief No initialization constructor */
    Constructor :: (this: *b3QuadWord) -> void #cpp_method #foreign bullet3 "??0b3QuadWord@@QEAA@XZ";

    /**@brief Three argument constructor (zeros w)
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    */
    Constructor :: (this: *b3QuadWord, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3QuadWord@@QEAA@AEBM00@Z";
    Constructor :: (this: *b3QuadWord, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar) #no_context {
        Constructor(this, *_x, *_y, *_z);
    }

    /**@brief Initializing constructor
    * @param x Value of x
    * @param y Value of y
    * @param z Value of z
    * @param w Value of w
    */
    Constructor :: (this: *b3QuadWord, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar, _w: *b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3QuadWord@@QEAA@AEBM000@Z";
    Constructor :: (this: *b3QuadWord, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar, _w: b3Scalar) #no_context {
        Constructor(this, *_x, *_y, *_z, *_w);
    }

    /**@brief Set each element to the max of the current values and the values of another b3QuadWord
    * @param other The other b3QuadWord to compare with 
    */
    setMax :: (this: *b3QuadWord, other: *b3QuadWord) -> void #cpp_method #foreign bullet3 "?setMax@b3QuadWord@@QEAAXAEBV1@@Z";
    setMax :: (this: *b3QuadWord, other: b3QuadWord) #no_context {
        setMax(this, *other);
    }

    /**@brief Set each element to the min of the current values and the values of another b3QuadWord
    * @param other The other b3QuadWord to compare with 
    */
    setMin :: (this: *b3QuadWord, other: *b3QuadWord) -> void #cpp_method #foreign bullet3 "?setMin@b3QuadWord@@QEAAXAEBV1@@Z";
    setMin :: (this: *b3QuadWord, other: b3QuadWord) #no_context {
        setMin(this, *other);
    }
}

operator== :: (this: *b3QuadWord, other: *b3QuadWord) -> bool #cpp_method #foreign bullet3 "??8b3QuadWord@@QEBA_NAEBV0@@Z";
operator== :: (this: b3QuadWord, other: b3QuadWord) -> bool #no_context {
    return operator==(*this, *other);
}

operator!= :: (this: *b3QuadWord, other: *b3QuadWord) -> bool #cpp_method #foreign bullet3 "??9b3QuadWord@@QEBA_NAEBV0@@Z";
operator!= :: (this: b3QuadWord, other: b3QuadWord) -> bool #no_context {
    return operator!=(*this, *other);
}

/**@brief The b3Quaternion implements quaternion to perform linear algebra rotations in combination with b3Matrix3x3, b3Vector3 and b3Transform. */
b3Quaternion :: struct {
    #as using b3quadword: b3QuadWord;

    /**@brief No initialization constructor */
    Constructor :: (this: *b3Quaternion) -> void #cpp_method #foreign bullet3 "??0b3Quaternion@@QEAA@XZ";

    //		template <typename b3Scalar>
    //		explicit Quaternion(const b3Scalar *v) : Tuple4<b3Scalar>(v) {}
    /**@brief Constructor from scalars */
    Constructor :: (this: *b3Quaternion, _x: *b3Scalar, _y: *b3Scalar, _z: *b3Scalar, _w: *b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3Quaternion@@QEAA@AEBM000@Z";
    Constructor :: (this: *b3Quaternion, _x: b3Scalar, _y: b3Scalar, _z: b3Scalar, _w: b3Scalar) #no_context {
        Constructor(this, *_x, *_y, *_z, *_w);
    }

    /**@brief Axis angle Constructor
    * @param axis The axis which the rotation is around
    * @param angle The magnitude of the rotation around the angle (Radians) */
    Constructor :: (this: *b3Quaternion, _axis: *b3Vector3, _angle: *b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3Quaternion@@QEAA@AEBVb3Vector3@@AEBM@Z";
    Constructor :: (this: *b3Quaternion, _axis: b3Vector3, _angle: b3Scalar) #no_context {
        Constructor(this, *_axis, *_angle);
    }

    /**@brief Constructor from Euler angles
    * @param yaw Angle around Y unless B3_EULER_DEFAULT_ZYX defined then Z
    * @param pitch Angle around X unless B3_EULER_DEFAULT_ZYX defined then Y
    * @param roll Angle around Z unless B3_EULER_DEFAULT_ZYX defined then X */
    Constructor :: (this: *b3Quaternion, yaw: *b3Scalar, pitch: *b3Scalar, roll: *b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3Quaternion@@QEAA@AEBM00@Z";
    Constructor :: (this: *b3Quaternion, yaw: b3Scalar, pitch: b3Scalar, roll: b3Scalar) #no_context {
        Constructor(this, *yaw, *pitch, *roll);
    }

    /**@brief Set the rotation using axis angle notation 
    * @param axis The axis around which to rotate
    * @param angle The magnitude of the rotation in Radians */
    setRotation :: (this: *b3Quaternion, axis1: *b3Vector3, _angle: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setRotation@b3Quaternion@@QEAAXAEBVb3Vector3@@AEBM@Z";
    setRotation :: (this: *b3Quaternion, axis1: b3Vector3, _angle: b3Scalar) #no_context {
        setRotation(this, *axis1, *_angle);
    }

    /**@brief Set the quaternion using Euler angles
    * @param yaw Angle around Y
    * @param pitch Angle around X
    * @param roll Angle around Z */
    setEuler :: (this: *b3Quaternion, yaw: *b3Scalar, pitch: *b3Scalar, roll: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setEuler@b3Quaternion@@QEAAXAEBM00@Z";
    setEuler :: (this: *b3Quaternion, yaw: b3Scalar, pitch: b3Scalar, roll: b3Scalar) #no_context {
        setEuler(this, *yaw, *pitch, *roll);
    }

    /**@brief Set the quaternion using euler angles 
    * @param yaw Angle around Z
    * @param pitch Angle around Y
    * @param roll Angle around X */
    setEulerZYX :: (this: *b3Quaternion, yawZ: *b3Scalar, pitchY: *b3Scalar, rollX: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setEulerZYX@b3Quaternion@@QEAAXAEBM00@Z";
    setEulerZYX :: (this: *b3Quaternion, yawZ: b3Scalar, pitchY: b3Scalar, rollX: b3Scalar) #no_context {
        setEulerZYX(this, *yawZ, *pitchY, *rollX);
    }

    /**@brief Get the euler angles from this quaternion
    * @param yaw Angle around Z
    * @param pitch Angle around Y
    * @param roll Angle around X */
    getEulerZYX :: (this: *b3Quaternion, yawZ: *b3Scalar, pitchY: *b3Scalar, rollX: *b3Scalar) -> void #cpp_method #foreign bullet3 "?getEulerZYX@b3Quaternion@@QEBAXAEAM00@Z";

    /**@brief Return the dot product between this quaternion and another
    * @param q The other quaternion */
    dot :: (this: *b3Quaternion, q: *b3Quaternion) -> b3Scalar #cpp_method #foreign bullet3 "?dot@b3Quaternion@@QEBAMAEBV1@@Z";
    dot :: (this: *b3Quaternion, q: b3Quaternion) -> b3Scalar #no_context {
        return dot(this, *q);
    }

    /**@brief Return the length squared of the quaternion */
    length2 :: (this: *b3Quaternion) -> b3Scalar #cpp_method #foreign bullet3 "?length2@b3Quaternion@@QEBAMXZ";

    /**@brief Return the length of the quaternion */
    length :: (this: *b3Quaternion) -> b3Scalar #cpp_method #foreign bullet3 "?length@b3Quaternion@@QEBAMXZ";

    /**@brief Normalize the quaternion 
    * Such that x^2 + y^2 + z^2 +w^2 = 1 */
    normalize :: (this: *b3Quaternion) -> *b3Quaternion #cpp_method #foreign bullet3 "?normalize@b3Quaternion@@QEAAAEAV1@XZ";

    /**@brief Return a normalized version of this quaternion */
    normalized :: (this: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?normalized@b3Quaternion@@QEBA?AV1@XZ";

    /**@brief Return the angle between this quaternion and the other 
    * @param q The other quaternion */
    angle :: (this: *b3Quaternion, q: *b3Quaternion) -> b3Scalar #cpp_method #foreign bullet3 "?angle@b3Quaternion@@QEBAMAEBV1@@Z";
    angle :: (this: *b3Quaternion, q: b3Quaternion) -> b3Scalar #no_context {
        return angle(this, *q);
    }

    /**@brief Return the angle of rotation represented by this quaternion */
    getAngle :: (this: *b3Quaternion) -> b3Scalar #cpp_method #foreign bullet3 "?getAngle@b3Quaternion@@QEBAMXZ";

    /**@brief Return the axis of the rotation represented by this quaternion */
    getAxis :: (this: *b3Quaternion) -> b3Vector3 #cpp_method #foreign bullet3 "?getAxis@b3Quaternion@@QEBA?AVb3Vector3@@XZ";

    /**@brief Return the inverse of this quaternion */
    inverse :: (this: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverse@b3Quaternion@@QEBA?AV1@XZ";

    /**@todo document this and it's use */
    farthest :: (this: *b3Quaternion, qd: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?farthest@b3Quaternion@@QEBA?AV1@AEBV1@@Z";
    farthest :: (this: *b3Quaternion, qd: b3Quaternion) -> b3Quaternion #no_context {
        return farthest(this, *qd);
    }

    /**@todo document this and it's use */
    nearest :: (this: *b3Quaternion, qd: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?nearest@b3Quaternion@@QEBA?AV1@AEBV1@@Z";
    nearest :: (this: *b3Quaternion, qd: b3Quaternion) -> b3Quaternion #no_context {
        return nearest(this, *qd);
    }

    /**@brief Return the quaternion which is the result of Spherical Linear Interpolation between this and the other quaternion
    * @param q The other quaternion to interpolate with 
    * @param t The ratio between this and q to interpolate.  If t = 0 the result is this, if t=1 the result is q.
    * Slerp interpolates assuming constant velocity.  */
    slerp :: (this: *b3Quaternion, q: *b3Quaternion, t: *b3Scalar) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?slerp@b3Quaternion@@QEBA?AV1@AEBV1@AEBM@Z";
    slerp :: (this: *b3Quaternion, q: b3Quaternion, t: b3Scalar) -> b3Quaternion #no_context {
        return slerp(this, *q, *t);
    }

    getIdentity :: () -> *b3Quaternion #foreign bullet3 "?getIdentity@b3Quaternion@@SAAEBV1@XZ";

    getW :: (this: *b3Quaternion) -> *b3Scalar #cpp_method #foreign bullet3 "?getW@b3Quaternion@@QEBAAEBMXZ";
}

/**@brief Add two quaternions
* @param q The quaternion to add to this one */
operator+= :: (this: *b3Quaternion, q: *b3Quaternion) -> *b3Quaternion #cpp_method #foreign bullet3 "??Yb3Quaternion@@QEAAAEAV0@AEBV0@@Z";
operator+= :: (this: *b3Quaternion, q: b3Quaternion) -> *b3Quaternion #no_context {
    return operator+=(this, *q);
}

/**@brief Subtract out a quaternion
* @param q The quaternion to subtract from this one */
operator-= :: (this: *b3Quaternion, q: *b3Quaternion) -> *b3Quaternion #cpp_method #foreign bullet3 "??Zb3Quaternion@@QEAAAEAV0@AEBV0@@Z";
operator-= :: (this: *b3Quaternion, q: b3Quaternion) -> *b3Quaternion #no_context {
    return operator-=(this, *q);
}

/**@brief Scale this quaternion
* @param s The scalar to scale by */
operator*= :: (this: *b3Quaternion, s: *b3Scalar) -> *b3Quaternion #cpp_method #foreign bullet3 "??Xb3Quaternion@@QEAAAEAV0@AEBM@Z";
operator*= :: (this: *b3Quaternion, s: b3Scalar) -> *b3Quaternion #no_context {
    return operator*=(this, *s);
}

/**@brief Multiply this quaternion by q on the right
* @param q The other quaternion 
* Equivilant to this = this * q */
operator*= :: (this: *b3Quaternion, q: *b3Quaternion) -> *b3Quaternion #cpp_method #foreign bullet3 "??Xb3Quaternion@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *b3Quaternion, q: b3Quaternion) -> *b3Quaternion #no_context {
    return operator*=(this, *q);
}

/**@brief Return a scaled version of this quaternion
* @param s The scale factor */
operator* :: (this: *b3Quaternion, s: *b3Scalar) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Db3Quaternion@@QEBA?AV0@AEBM@Z";
operator* :: (this: b3Quaternion, s: b3Scalar) -> b3Quaternion #no_context {
    return operator*(*this, *s);
}

/**@brief Return an inversely scaled versionof this quaternion
* @param s The inverse scale factor */
operator/ :: (this: *b3Quaternion, s: *b3Scalar) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Kb3Quaternion@@QEBA?AV0@AEBM@Z";
operator/ :: (this: b3Quaternion, s: b3Scalar) -> b3Quaternion #no_context {
    return operator/(*this, *s);
}

/**@brief Inversely scale this quaternion
* @param s The scale factor */
operator/= :: (this: *b3Quaternion, s: *b3Scalar) -> *b3Quaternion #cpp_method #foreign bullet3 "??_0b3Quaternion@@QEAAAEAV0@AEBM@Z";
operator/= :: (this: *b3Quaternion, s: b3Scalar) -> *b3Quaternion #no_context {
    return operator/=(this, *s);
}

/**@brief Return the sum of this quaternion and the other 
* @param q2 The other quaternion */
operator+ :: (this: *b3Quaternion, q2: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Hb3Quaternion@@QEBA?AV0@AEBV0@@Z";
operator+ :: (this: b3Quaternion, q2: b3Quaternion) -> b3Quaternion #no_context {
    return operator+(*this, *q2);
}

/**@brief Return the difference between this quaternion and the other 
* @param q2 The other quaternion */
operator- :: (this: *b3Quaternion, q2: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Gb3Quaternion@@QEBA?AV0@AEBV0@@Z";
operator- :: (this: b3Quaternion, q2: b3Quaternion) -> b3Quaternion #no_context {
    return operator-(*this, *q2);
}

/**@brief Return the negative of this quaternion 
* This simply negates each element */
operator- :: (this: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Gb3Quaternion@@QEBA?AV0@XZ";
operator- :: (this: b3Quaternion) -> b3Quaternion #no_context {
    return operator-(*this);
}

/**@brief The b3Matrix3x3 class implements a 3x3 rotation matrix, to perform linear algebra in combination with b3Quaternion, b3Transform and b3Vector3.
* Make sure to only include a pure orthogonal matrix without scaling. */
b3Matrix3x3 :: struct {
    ///Data storage for the matrix, each vector is a row of the matrix
    m_el: [3] b3Vector3;

    /** @brief No initializaion constructor */
    Constructor :: (this: *b3Matrix3x3) -> void #cpp_method #foreign bullet3 "??0b3Matrix3x3@@QEAA@XZ";

    /**@brief Constructor from Quaternion */
    Constructor :: (this: *b3Matrix3x3, q: *b3Quaternion) -> void #cpp_method #foreign bullet3 "??0b3Matrix3x3@@QEAA@AEBVb3Quaternion@@@Z";
    Constructor :: (this: *b3Matrix3x3, q: b3Quaternion) #no_context {
        Constructor(this, *q);
    }

    /*
    template <typename b3Scalar>
    Matrix3x3(const b3Scalar& yaw, const b3Scalar& pitch, const b3Scalar& roll)
    { 
    setEulerYPR(yaw, pitch, roll);
    }
    */
    /** @brief Constructor with row major formatting */
    Constructor :: (this: *b3Matrix3x3, _xx: *b3Scalar, xy: *b3Scalar, xz: *b3Scalar, yx: *b3Scalar, yy: *b3Scalar, yz: *b3Scalar, zx: *b3Scalar, zy: *b3Scalar, zz: *b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3Matrix3x3@@QEAA@AEBM00000000@Z";
    Constructor :: (this: *b3Matrix3x3, _xx: b3Scalar, xy: b3Scalar, xz: b3Scalar, yx: b3Scalar, yy: b3Scalar, yz: b3Scalar, zx: b3Scalar, zy: b3Scalar, zz: b3Scalar) #no_context {
        Constructor(this, *_xx, *xy, *xz, *yx, *yy, *yz, *zx, *zy, *zz);
    }

    /** @brief Copy constructor */
    CopyConstructor :: (this: *b3Matrix3x3, other: *b3Matrix3x3) -> void #cpp_method #foreign bullet3 "??0b3Matrix3x3@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *b3Matrix3x3, other: b3Matrix3x3) #no_context {
        CopyConstructor(this, *other);
    }

    /** @brief Get a column of the matrix as a vector 
    *  @param i Column number 0 indexed */
    getColumn :: (this: *b3Matrix3x3, i: s32) -> b3Vector3 #cpp_method #foreign bullet3 "?getColumn@b3Matrix3x3@@QEBA?AVb3Vector3@@H@Z";

    /** @brief Get a row of the matrix as a vector 
    *  @param i Row number 0 indexed */
    getRow :: (this: *b3Matrix3x3, i: s32) -> *b3Vector3 #cpp_method #foreign bullet3 "?getRow@b3Matrix3x3@@QEBAAEBVb3Vector3@@H@Z";

    /** @brief Set from the rotational part of a 4x4 OpenGL matrix
    *  @param m A pointer to the beginning of the array of scalars*/
    setFromOpenGLSubMatrix :: (this: *b3Matrix3x3, m: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setFromOpenGLSubMatrix@b3Matrix3x3@@QEAAXPEBM@Z";

    /** @brief Set the values of the matrix explicitly (row major)
    *  @param xx Top left
    *  @param xy Top Middle
    *  @param xz Top Right
    *  @param yx Middle Left
    *  @param yy Middle Middle
    *  @param yz Middle Right
    *  @param zx Bottom Left
    *  @param zy Bottom Middle
    *  @param zz Bottom Right*/
    setValue :: (this: *b3Matrix3x3, _xx: *b3Scalar, xy: *b3Scalar, xz: *b3Scalar, yx: *b3Scalar, yy: *b3Scalar, yz: *b3Scalar, zx: *b3Scalar, zy: *b3Scalar, zz: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setValue@b3Matrix3x3@@QEAAXAEBM00000000@Z";
    setValue :: (this: *b3Matrix3x3, _xx: b3Scalar, xy: b3Scalar, xz: b3Scalar, yx: b3Scalar, yy: b3Scalar, yz: b3Scalar, zx: b3Scalar, zy: b3Scalar, zz: b3Scalar) #no_context {
        setValue(this, *_xx, *xy, *xz, *yx, *yy, *yz, *zx, *zy, *zz);
    }

    /** @brief Set the matrix from a quaternion
    *  @param q The Quaternion to match */
    setRotation :: (this: *b3Matrix3x3, q: *b3Quaternion) -> void #cpp_method #foreign bullet3 "?setRotation@b3Matrix3x3@@QEAAXAEBVb3Quaternion@@@Z";
    setRotation :: (this: *b3Matrix3x3, q: b3Quaternion) #no_context {
        setRotation(this, *q);
    }

    /** @brief Set the matrix from euler angles using YPR around YXZ respectively
    *  @param yaw Yaw about Y axis
    *  @param pitch Pitch about X axis
    *  @param roll Roll about Z axis 
    */
    setEulerYPR :: (this: *b3Matrix3x3, yaw: *b3Scalar, pitch: *b3Scalar, roll: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setEulerYPR@b3Matrix3x3@@QEAAXAEBM00@Z";
    setEulerYPR :: (this: *b3Matrix3x3, yaw: b3Scalar, pitch: b3Scalar, roll: b3Scalar) #no_context {
        setEulerYPR(this, *yaw, *pitch, *roll);
    }

    /** @brief Set the matrix from euler angles YPR around ZYX axes
    * @param eulerX Roll about X axis
    * @param eulerY Pitch around Y axis
    * @param eulerZ Yaw aboud Z axis
    * 
    * These angles are used to produce a rotation matrix. The euler
    * angles are applied in ZYX order. I.e a vector is first rotated 
    * about X then Y and then Z
    **/
    setEulerZYX :: (this: *b3Matrix3x3, eulerX: b3Scalar, eulerY: b3Scalar, eulerZ: b3Scalar) -> void #cpp_method #foreign bullet3 "?setEulerZYX@b3Matrix3x3@@QEAAXMMM@Z";

    /**@brief Set the matrix to the identity */
    setIdentity :: (this: *b3Matrix3x3) -> void #cpp_method #foreign bullet3 "?setIdentity@b3Matrix3x3@@QEAAXXZ";

    getIdentity :: () -> *b3Matrix3x3 #foreign bullet3 "?getIdentity@b3Matrix3x3@@SAAEBV1@XZ";

    /**@brief Fill the rotational part of an OpenGL matrix and clear the shear/perspective
    * @param m The array to be filled */
    getOpenGLSubMatrix :: (this: *b3Matrix3x3, m: *b3Scalar) -> void #cpp_method #foreign bullet3 "?getOpenGLSubMatrix@b3Matrix3x3@@QEBAXPEAM@Z";

    /**@brief Get the matrix represented as a quaternion 
    * @param q The quaternion which will be set */
    getRotation :: (this: *b3Matrix3x3, q: *b3Quaternion) -> void #cpp_method #foreign bullet3 "?getRotation@b3Matrix3x3@@QEBAXAEAVb3Quaternion@@@Z";

    /**@brief Get the matrix represented as euler angles around YXZ, roundtrip with setEulerYPR
    * @param yaw Yaw around Y axis
    * @param pitch Pitch around X axis
    * @param roll around Z axis */
    getEulerYPR :: (this: *b3Matrix3x3, yaw: *b3Scalar, pitch: *b3Scalar, roll: *b3Scalar) -> void #cpp_method #foreign bullet3 "?getEulerYPR@b3Matrix3x3@@QEBAXAEAM00@Z";

    /**@brief Get the matrix represented as euler angles around ZYX
    * @param yaw Yaw around X axis
    * @param pitch Pitch around Y axis
    * @param roll around X axis 
    * @param solution_number Which solution of two possible solutions ( 1 or 2) are possible values*/
    getEulerZYX :: (this: *b3Matrix3x3, yaw: *b3Scalar, pitch: *b3Scalar, roll: *b3Scalar, solution_number: u32 = 1) -> void #cpp_method #foreign bullet3 "?getEulerZYX@b3Matrix3x3@@QEBAXAEAM00I@Z";

    /**@brief Create a scaled copy of the matrix 
    * @param s Scaling vector The elements of the vector will scale each column */
    scaled :: (this: *b3Matrix3x3, s: *b3Vector3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?scaled@b3Matrix3x3@@QEBA?AV1@AEBVb3Vector3@@@Z";
    scaled :: (this: *b3Matrix3x3, s: b3Vector3) -> b3Matrix3x3 #no_context {
        return scaled(this, *s);
    }

    /**@brief Return the determinant of the matrix */
    determinant :: (this: *b3Matrix3x3) -> b3Scalar #cpp_method #foreign bullet3 "?determinant@b3Matrix3x3@@QEBAMXZ";

    /**@brief Return the adjoint of the matrix */
    adjoint :: (this: *b3Matrix3x3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?adjoint@b3Matrix3x3@@QEBA?AV1@XZ";

    /**@brief Return the matrix with all values non negative */
    absolute :: (this: *b3Matrix3x3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?absolute@b3Matrix3x3@@QEBA?AV1@XZ";

    /**@brief Return the transpose of the matrix */
    transpose :: (this: *b3Matrix3x3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?transpose@b3Matrix3x3@@QEBA?AV1@XZ";

    /**@brief Return the inverse of the matrix */
    inverse :: (this: *b3Matrix3x3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverse@b3Matrix3x3@@QEBA?AV1@XZ";

    transposeTimes :: (this: *b3Matrix3x3, m: *b3Matrix3x3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?transposeTimes@b3Matrix3x3@@QEBA?AV1@AEBV1@@Z";
    transposeTimes :: (this: *b3Matrix3x3, m: b3Matrix3x3) -> b3Matrix3x3 #no_context {
        return transposeTimes(this, *m);
    }

    timesTranspose :: (this: *b3Matrix3x3, m: *b3Matrix3x3) -> b3Matrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?timesTranspose@b3Matrix3x3@@QEBA?AV1@AEBV1@@Z";
    timesTranspose :: (this: *b3Matrix3x3, m: b3Matrix3x3) -> b3Matrix3x3 #no_context {
        return timesTranspose(this, *m);
    }

    tdotx :: (this: *b3Matrix3x3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?tdotx@b3Matrix3x3@@QEBAMAEBVb3Vector3@@@Z";
    tdotx :: (this: *b3Matrix3x3, v: b3Vector3) -> b3Scalar #no_context {
        return tdotx(this, *v);
    }

    tdoty :: (this: *b3Matrix3x3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?tdoty@b3Matrix3x3@@QEBAMAEBVb3Vector3@@@Z";
    tdoty :: (this: *b3Matrix3x3, v: b3Vector3) -> b3Scalar #no_context {
        return tdoty(this, *v);
    }

    tdotz :: (this: *b3Matrix3x3, v: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?tdotz@b3Matrix3x3@@QEBAMAEBVb3Vector3@@@Z";
    tdotz :: (this: *b3Matrix3x3, v: b3Vector3) -> b3Scalar #no_context {
        return tdotz(this, *v);
    }

    /**@brief diagonalizes this matrix by the Jacobi method.
    * @param rot stores the rotation from the coordinate system in which the matrix is diagonal to the original
    * coordinate system, i.e., old_this = rot * new_this * rot^T. 
    * @param threshold See iteration
    * @param iteration The iteration stops when all off-diagonal elements are less than the threshold multiplied 
    * by the sum of the absolute values of the diagonal, or when maxSteps have been executed. 
    * 
    * Note that this matrix is assumed to be symmetric. 
    */
    diagonalize :: (this: *b3Matrix3x3, rot: *b3Matrix3x3, threshold: b3Scalar, maxSteps: s32) -> void #cpp_method #foreign bullet3 "?diagonalize@b3Matrix3x3@@QEAAXAEAV1@MH@Z";

    /**@brief Calculate the matrix cofactor 
    * @param r1 The first row to use for calculating the cofactor
    * @param c1 The first column to use for calculating the cofactor
    * @param r1 The second row to use for calculating the cofactor
    * @param c1 The second column to use for calculating the cofactor
    * See http://en.wikipedia.org/wiki/Cofactor_(linear_algebra) for more details
    */
    cofac :: (this: *b3Matrix3x3, r1: s32, c1: s32, r2: s32, c2: s32) -> b3Scalar #cpp_method #foreign bullet3 "?cofac@b3Matrix3x3@@QEBAMHHHH@Z";

    serialize :: (this: *b3Matrix3x3, dataOut: *b3Matrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?serialize@b3Matrix3x3@@QEBAXAEAUb3Matrix3x3FloatData@@@Z";

    serializeFloat :: (this: *b3Matrix3x3, dataOut: *b3Matrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@b3Matrix3x3@@QEBAXAEAUb3Matrix3x3FloatData@@@Z";

    deSerialize :: (this: *b3Matrix3x3, dataIn: *b3Matrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@b3Matrix3x3@@QEAAXAEBUb3Matrix3x3FloatData@@@Z";
    deSerialize :: (this: *b3Matrix3x3, dataIn: b3Matrix3x3FloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    deSerializeFloat :: (this: *b3Matrix3x3, dataIn: *b3Matrix3x3FloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@b3Matrix3x3@@QEAAXAEBUb3Matrix3x3FloatData@@@Z";
    deSerializeFloat :: (this: *b3Matrix3x3, dataIn: b3Matrix3x3FloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }

    deSerializeDouble :: (this: *b3Matrix3x3, dataIn: *b3Matrix3x3DoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@b3Matrix3x3@@QEAAXAEBUb3Matrix3x3DoubleData@@@Z";
    deSerializeDouble :: (this: *b3Matrix3x3, dataIn: b3Matrix3x3DoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }
}

/** @brief Assignment Operator */
operator_assign :: (this: *b3Matrix3x3, other: *b3Matrix3x3) -> *b3Matrix3x3 #cpp_method #foreign bullet3 "??4b3Matrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator_assign :: (this: *b3Matrix3x3, other: b3Matrix3x3) -> *b3Matrix3x3 #no_context {
    return operator_assign(this, *other);
}

/** @brief Get a mutable reference to a row of the matrix as a vector 
*  @param i Row number 0 indexed */
operator[] :: (this: *b3Matrix3x3, i: s32) -> *b3Vector3 #cpp_method #foreign bullet3 "??Ab3Matrix3x3@@QEAAAEAVb3Vector3@@H@Z";
operator[] :: (this: b3Matrix3x3, i: s32) -> *b3Vector3 #no_context {
    return operator[](*this, i);
}

/** @brief Get a const reference to a row of the matrix as a vector 
*  @param i Row number 0 indexed */
operator_brackets_1 :: (this: /*const*/ *b3Matrix3x3, i: s32) -> *b3Vector3 #cpp_method #foreign bullet3 "??Ab3Matrix3x3@@QEBAAEBVb3Vector3@@H@Z";
operator_brackets_1 :: (this: b3Matrix3x3, i: s32) -> *b3Vector3 #no_context {
    return operator_brackets_1(*this, i);
}

/** @brief Multiply by the target matrix on the right
*  @param m Rotation matrix to be applied 
* Equivilant to this = this * m */
operator*= :: (this: *b3Matrix3x3, m: *b3Matrix3x3) -> *b3Matrix3x3 #cpp_method #foreign bullet3 "??Xb3Matrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *b3Matrix3x3, m: b3Matrix3x3) -> *b3Matrix3x3 #no_context {
    return operator*=(this, *m);
}

/** @brief Adds by the target matrix on the right
*  @param m matrix to be applied 
* Equivilant to this = this + m */
operator+= :: (this: *b3Matrix3x3, m: *b3Matrix3x3) -> *b3Matrix3x3 #cpp_method #foreign bullet3 "??Yb3Matrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator+= :: (this: *b3Matrix3x3, m: b3Matrix3x3) -> *b3Matrix3x3 #no_context {
    return operator+=(this, *m);
}

/** @brief Substractss by the target matrix on the right
*  @param m matrix to be applied 
* Equivilant to this = this - m */
operator-= :: (this: *b3Matrix3x3, m: *b3Matrix3x3) -> *b3Matrix3x3 #cpp_method #foreign bullet3 "??Zb3Matrix3x3@@QEAAAEAV0@AEBV0@@Z";
operator-= :: (this: *b3Matrix3x3, m: b3Matrix3x3) -> *b3Matrix3x3 #no_context {
    return operator-=(this, *m);
}

///for serialization
b3Matrix3x3FloatData :: struct {
    m_el: [3] b3Vector3FloatData;
}

///for serialization
b3Matrix3x3DoubleData :: struct {
    m_el: [3] b3Vector3DoubleData;
}

///The b3PoolAllocator class allows to efficiently allocate a large pool of objects, instead of dynamically allocating them separately.
b3PoolAllocator :: struct {
    m_elemSize:    s32;
    m_maxElements: s32;
    m_freeCount:   s32;
    m_firstFree:   *void;
    m_pool:        *u8;
}

B3_POOL_HANDLE_TERMINAL :: enum s32 {
    FREE :: -1;
    USED :: -2;

    B3_POOL_HANDLE_TERMINAL_FREE :: FREE;
    B3_POOL_HANDLE_TERMINAL_USED :: USED;
}

b3PoolBodyHandle :: struct(U: Type) {
    #as u: U; // jai: no "using" to avoid name-clashes

    m_nextFreeHandle: s32;
}

b3ResizablePool :: struct(T: Type) {
    m_bodyHandles:     b3AlignedObjectArray(T);
    m_numUsedHandles:  s32; // number of active handles
    m_firstFreeHandle: s32; // free handles list
}

///The b3Block class is an internal structure for the b3StackAlloc memory allocator.
b3Block :: struct {
    previous: *b3Block;
    address:  *u8;
}

///The StackAlloc class provides some fast stack-based memory allocator (LIFO last-in first-out)
b3StackAlloc :: struct {
    Constructor :: (this: *b3StackAlloc, size: u32) -> void #cpp_method #foreign bullet3 "??0b3StackAlloc@@QEAA@I@Z";

    Destructor :: (this: *b3StackAlloc) -> void #cpp_method #foreign bullet3 "??1b3StackAlloc@@QEAA@XZ";

    create :: (this: *b3StackAlloc, size: u32) -> void #cpp_method #foreign bullet3 "?create@b3StackAlloc@@QEAAXI@Z";

    destroy :: (this: *b3StackAlloc) -> void #cpp_method #foreign bullet3 "?destroy@b3StackAlloc@@QEAAXXZ";

    getAvailableMemory :: (this: *b3StackAlloc) -> s32 #cpp_method #foreign bullet3 "?getAvailableMemory@b3StackAlloc@@QEBAHXZ";

    allocate :: (this: *b3StackAlloc, size: u32) -> *u8 #cpp_method #foreign bullet3 "?allocate@b3StackAlloc@@QEAAPEAEI@Z";

    beginBlock :: (this: *b3StackAlloc) -> *b3Block #cpp_method #foreign bullet3 "?beginBlock@b3StackAlloc@@QEAAPEAUb3Block@@XZ";

    endBlock :: (this: *b3StackAlloc, block: *b3Block) -> void #cpp_method #foreign bullet3 "?endBlock@b3StackAlloc@@QEAAXPEAUb3Block@@@Z";

    ctor :: (this: *b3StackAlloc) -> void #cpp_method #foreign bullet3 "?ctor@b3StackAlloc@@AEAAXXZ";

    data:      *u8;
    totalsize: u32;
    usedsize:  u32;
    current:   *b3Block;
    ischild:   bool;
}

/**@brief The b3Transform class supports rigid transforms with only translation and rotation and no scaling/shear.
*It can be used in combination with b3Vector3, b3Quaternion and b3Matrix3x3 linear algebra classes. */
b3Transform :: struct {
    ///Storage for the rotation
    m_basis:  b3Matrix3x3;

    ///Storage for the translation
    m_origin: b3Vector3;

    /**@brief No initialization constructor */
    Constructor :: (this: *b3Transform) -> void #cpp_method #foreign bullet3 "??0b3Transform@@QEAA@XZ";

    /**@brief Constructor from b3Quaternion (optional b3Vector3 )
    * @param q Rotation from quaternion 
    * @param c Translation from Vector (default 0,0,0) */
    Constructor :: (this: *b3Transform, q: *b3Quaternion, c: *b3Vector3) -> void #cpp_method #foreign bullet3 "??0b3Transform@@QEAA@AEBVb3Quaternion@@AEBVb3Vector3@@@Z";
    Constructor :: (this: *b3Transform, q: b3Quaternion, c: b3Vector3) #no_context {
        Constructor(this, *q, *c);
    }

    /**@brief Constructor from b3Matrix3x3 (optional b3Vector3)
    * @param b Rotation from Matrix 
    * @param c Translation from Vector default (0,0,0)*/
    Constructor :: (this: *b3Transform, b: *b3Matrix3x3, c: *b3Vector3) -> void #cpp_method #foreign bullet3 "??0b3Transform@@QEAA@AEBVb3Matrix3x3@@AEBVb3Vector3@@@Z";
    Constructor :: (this: *b3Transform, b: b3Matrix3x3, c: b3Vector3) #no_context {
        Constructor(this, *b, *c);
    }

    /**@brief Copy constructor */
    CopyConstructor :: (this: *b3Transform, other: *b3Transform) -> void #cpp_method #foreign bullet3 "??0b3Transform@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *b3Transform, other: b3Transform) #no_context {
        CopyConstructor(this, *other);
    }

    /**@brief Set the current transform as the value of the product of two transforms
    * @param t1 Transform 1
    * @param t2 Transform 2
    * This = Transform1 * Transform2 */
    mult :: (this: *b3Transform, t1: *b3Transform, t2: *b3Transform) -> void #cpp_method #foreign bullet3 "?mult@b3Transform@@QEAAXAEBV1@0@Z";
    mult :: (this: *b3Transform, t1: b3Transform, t2: b3Transform) #no_context {
        mult(this, *t1, *t2);
    }

    /**@brief Return the basis matrix for the rotation */
    getBasis :: (this: *b3Transform) -> *b3Matrix3x3 #cpp_method #foreign bullet3 "?getBasis@b3Transform@@QEAAAEAVb3Matrix3x3@@XZ";

    /**@brief Return the basis matrix for the rotation */
    getBasis_1 :: (this: /*const*/ *b3Transform) -> *b3Matrix3x3 #cpp_method #foreign bullet3 "?getBasis@b3Transform@@QEBAAEBVb3Matrix3x3@@XZ";

    /**@brief Return the origin vector translation */
    getOrigin :: (this: *b3Transform) -> *b3Vector3 #cpp_method #foreign bullet3 "?getOrigin@b3Transform@@QEAAAEAVb3Vector3@@XZ";

    /**@brief Return the origin vector translation */
    getOrigin_1 :: (this: /*const*/ *b3Transform) -> *b3Vector3 #cpp_method #foreign bullet3 "?getOrigin@b3Transform@@QEBAAEBVb3Vector3@@XZ";

    /**@brief Return a quaternion representing the rotation */
    getRotation :: (this: *b3Transform) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getRotation@b3Transform@@QEBA?AVb3Quaternion@@XZ";

    /**@brief Set from an array 
    * @param m A pointer to a 15 element array (12 rotation(row major padded on the right by 1), and 3 translation */
    setFromOpenGLMatrix :: (this: *b3Transform, m: *b3Scalar) -> void #cpp_method #foreign bullet3 "?setFromOpenGLMatrix@b3Transform@@QEAAXPEBM@Z";

    /**@brief Fill an array representation
    * @param m A pointer to a 15 element array (12 rotation(row major padded on the right by 1), and 3 translation */
    getOpenGLMatrix :: (this: *b3Transform, m: *b3Scalar) -> void #cpp_method #foreign bullet3 "?getOpenGLMatrix@b3Transform@@QEBAXPEAM@Z";

    /**@brief Set the translational element
    * @param origin The vector to set the translation to */
    setOrigin :: (this: *b3Transform, origin: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setOrigin@b3Transform@@QEAAXAEBVb3Vector3@@@Z";
    setOrigin :: (this: *b3Transform, origin: b3Vector3) #no_context {
        setOrigin(this, *origin);
    }

    invXform :: (this: *b3Transform, inVec: *b3Vector3) -> b3Vector3 #cpp_method #foreign bullet3 "?invXform@b3Transform@@QEBA?AVb3Vector3@@AEBV2@@Z";
    invXform :: (this: *b3Transform, inVec: b3Vector3) -> b3Vector3 #no_context {
        return invXform(this, *inVec);
    }

    /**@brief Set the rotational element by b3Matrix3x3 */
    setBasis :: (this: *b3Transform, basis: *b3Matrix3x3) -> void #cpp_method #foreign bullet3 "?setBasis@b3Transform@@QEAAXAEBVb3Matrix3x3@@@Z";
    setBasis :: (this: *b3Transform, basis: b3Matrix3x3) #no_context {
        setBasis(this, *basis);
    }

    /**@brief Set the rotational element by b3Quaternion */
    setRotation :: (this: *b3Transform, q: *b3Quaternion) -> void #cpp_method #foreign bullet3 "?setRotation@b3Transform@@QEAAXAEBVb3Quaternion@@@Z";
    setRotation :: (this: *b3Transform, q: b3Quaternion) #no_context {
        setRotation(this, *q);
    }

    /**@brief Set this transformation to the identity */
    setIdentity :: (this: *b3Transform) -> void #cpp_method #foreign bullet3 "?setIdentity@b3Transform@@QEAAXXZ";

    /**@brief Return the inverse of this transform */
    inverse :: (this: *b3Transform) -> b3Transform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverse@b3Transform@@QEBA?AV1@XZ";

    /**@brief Return the inverse of this transform times the other transform
    * @param t The other transform 
    * return this.inverse() * the other */
    inverseTimes :: (this: *b3Transform, t: *b3Transform) -> b3Transform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?inverseTimes@b3Transform@@QEBA?AV1@AEBV1@@Z";
    inverseTimes :: (this: *b3Transform, t: b3Transform) -> b3Transform #no_context {
        return inverseTimes(this, *t);
    }

    /**@brief Return an identity transform */
    getIdentity :: () -> *b3Transform #foreign bullet3 "?getIdentity@b3Transform@@SAAEBV1@XZ";

    serialize :: (this: *b3Transform, dataOut: *b3TransformFloatData) -> void #cpp_method #foreign bullet3 "?serialize@b3Transform@@QEBAXAEAUb3TransformFloatData@@@Z";

    serializeFloat :: (this: *b3Transform, dataOut: *b3TransformFloatData) -> void #cpp_method #foreign bullet3 "?serializeFloat@b3Transform@@QEBAXAEAUb3TransformFloatData@@@Z";

    deSerialize :: (this: *b3Transform, dataIn: *b3TransformFloatData) -> void #cpp_method #foreign bullet3 "?deSerialize@b3Transform@@QEAAXAEBUb3TransformFloatData@@@Z";
    deSerialize :: (this: *b3Transform, dataIn: b3TransformFloatData) #no_context {
        deSerialize(this, *dataIn);
    }

    deSerializeDouble :: (this: *b3Transform, dataIn: *b3TransformDoubleData) -> void #cpp_method #foreign bullet3 "?deSerializeDouble@b3Transform@@QEAAXAEBUb3TransformDoubleData@@@Z";
    deSerializeDouble :: (this: *b3Transform, dataIn: b3TransformDoubleData) #no_context {
        deSerializeDouble(this, *dataIn);
    }

    deSerializeFloat :: (this: *b3Transform, dataIn: *b3TransformFloatData) -> void #cpp_method #foreign bullet3 "?deSerializeFloat@b3Transform@@QEAAXAEBUb3TransformFloatData@@@Z";
    deSerializeFloat :: (this: *b3Transform, dataIn: b3TransformFloatData) #no_context {
        deSerializeFloat(this, *dataIn);
    }
}

/**@brief Return the transform of the vector */
operator* :: (this: *b3Transform, x: *b3Vector3) -> b3Vector3 #cpp_method #foreign bullet3 "??Db3Transform@@QEBA?AVb3Vector3@@AEBV1@@Z";
operator* :: (this: b3Transform, x: b3Vector3) -> b3Vector3 #no_context {
    return operator*(*this, *x);
}

/**@brief Return the transform of the b3Quaternion */
operator* :: (this: *b3Transform, q: *b3Quaternion) -> b3Quaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Db3Transform@@QEBA?AVb3Quaternion@@AEBV1@@Z";
operator* :: (this: b3Transform, q: b3Quaternion) -> b3Quaternion #no_context {
    return operator*(*this, *q);
}

/**@brief Multiply this Transform by another(this = this * another) 
* @param t The other transform */
operator*= :: (this: *b3Transform, t: *b3Transform) -> *b3Transform #cpp_method #foreign bullet3 "??Xb3Transform@@QEAAAEAV0@AEBV0@@Z";
operator*= :: (this: *b3Transform, t: b3Transform) -> *b3Transform #no_context {
    return operator*=(this, *t);
}

/**@brief Return the product of this transform and the other */
operator* :: (this: *b3Transform, t: *b3Transform) -> b3Transform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??Db3Transform@@QEBA?AV0@AEBV0@@Z";
operator* :: (this: b3Transform, t: b3Transform) -> b3Transform #no_context {
    return operator*(*this, *t);
}

///for serialization
b3TransformFloatData :: struct {
    m_basis:  b3Matrix3x3FloatData;
    m_origin: b3Vector3FloatData;
}

b3TransformDoubleData :: struct {
    m_basis:  b3Matrix3x3DoubleData;
    m_origin: b3Vector3DoubleData;
}

/// Utils related to temporal transforms
b3TransformUtil :: struct {
    integrateTransform :: (curTrans: *b3Transform, linvel: *b3Vector3, angvel: *b3Vector3, timeStep: b3Scalar, predictedTransform: *b3Transform) -> void #foreign bullet3 "?integrateTransform@b3TransformUtil@@SAXAEBVb3Transform@@AEBVb3Vector3@@1MAEAV2@@Z";
    integrateTransform :: (curTrans: b3Transform, linvel: b3Vector3, angvel: b3Vector3, timeStep: b3Scalar, predictedTransform: *b3Transform) #no_context {
        integrateTransform(*curTrans, *linvel, *angvel, timeStep, predictedTransform);
    }

    calculateVelocityQuaternion :: (pos0: *b3Vector3, pos1: *b3Vector3, orn0: *b3Quaternion, orn1: *b3Quaternion, timeStep: b3Scalar, linVel: *b3Vector3, angVel: *b3Vector3) -> void #foreign bullet3 "?calculateVelocityQuaternion@b3TransformUtil@@SAXAEBVb3Vector3@@0AEBVb3Quaternion@@1MAEAV2@2@Z";
    calculateVelocityQuaternion :: (pos0: b3Vector3, pos1: b3Vector3, orn0: b3Quaternion, orn1: b3Quaternion, timeStep: b3Scalar, linVel: *b3Vector3, angVel: *b3Vector3) #no_context {
        calculateVelocityQuaternion(*pos0, *pos1, *orn0, *orn1, timeStep, linVel, angVel);
    }

    calculateDiffAxisAngleQuaternion :: (orn0: *b3Quaternion, orn1a: *b3Quaternion, axis: *b3Vector3, angle: *b3Scalar) -> void #foreign bullet3 "?calculateDiffAxisAngleQuaternion@b3TransformUtil@@SAXAEBVb3Quaternion@@0AEAVb3Vector3@@AEAM@Z";
    calculateDiffAxisAngleQuaternion :: (orn0: b3Quaternion, orn1a: b3Quaternion, axis: *b3Vector3, angle: *b3Scalar) #no_context {
        calculateDiffAxisAngleQuaternion(*orn0, *orn1a, axis, angle);
    }

    calculateVelocity :: (transform0: *b3Transform, transform1: *b3Transform, timeStep: b3Scalar, linVel: *b3Vector3, angVel: *b3Vector3) -> void #foreign bullet3 "?calculateVelocity@b3TransformUtil@@SAXAEBVb3Transform@@0MAEAVb3Vector3@@1@Z";
    calculateVelocity :: (transform0: b3Transform, transform1: b3Transform, timeStep: b3Scalar, linVel: *b3Vector3, angVel: *b3Vector3) #no_context {
        calculateVelocity(*transform0, *transform1, timeStep, linVel, angVel);
    }

    calculateDiffAxisAngle :: (transform0: *b3Transform, transform1: *b3Transform, axis: *b3Vector3, angle: *b3Scalar) -> void #foreign bullet3 "?calculateDiffAxisAngle@b3TransformUtil@@SAXAEBVb3Transform@@0AEAVb3Vector3@@AEAM@Z";
    calculateDiffAxisAngle :: (transform0: b3Transform, transform1: b3Transform, axis: *b3Vector3, angle: *b3Scalar) #no_context {
        calculateDiffAxisAngle(*transform0, *transform1, axis, angle);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///The b3ConvexSeparatingDistanceUtil can help speed up convex collision detection
///by conservatively updating a cached separating distance/vector instead of re-calculating the closest distance
b3ConvexSeparatingDistanceUtil :: struct {
    m_ornA:               b3Quaternion;
    m_ornB:               b3Quaternion;
    m_posA:               b3Vector3;
    m_posB:               b3Vector3;

    m_separatingNormal:   b3Vector3;

    m_boundingRadiusA:    b3Scalar;
    m_boundingRadiusB:    b3Scalar;
    m_separatingDistance: b3Scalar;

    Constructor :: (this: *b3ConvexSeparatingDistanceUtil, boundingRadiusA: b3Scalar, boundingRadiusB: b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3ConvexSeparatingDistanceUtil@@QEAA@MM@Z";

    getConservativeSeparatingDistance :: (this: *b3ConvexSeparatingDistanceUtil) -> b3Scalar #cpp_method #foreign bullet3 "?getConservativeSeparatingDistance@b3ConvexSeparatingDistanceUtil@@QEAAMXZ";

    updateSeparatingDistance :: (this: *b3ConvexSeparatingDistanceUtil, transA: *b3Transform, transB: *b3Transform) -> void #cpp_method #foreign bullet3 "?updateSeparatingDistance@b3ConvexSeparatingDistanceUtil@@QEAAXAEBVb3Transform@@0@Z";
    updateSeparatingDistance :: (this: *b3ConvexSeparatingDistanceUtil, transA: b3Transform, transB: b3Transform) #no_context {
        updateSeparatingDistance(this, *transA, *transB);
    }

    initSeparatingDistance :: (this: *b3ConvexSeparatingDistanceUtil, separatingVector: *b3Vector3, separatingDistance: b3Scalar, transA: *b3Transform, transB: *b3Transform) -> void #cpp_method #foreign bullet3 "?initSeparatingDistance@b3ConvexSeparatingDistanceUtil@@QEAAXAEBVb3Vector3@@MAEBVb3Transform@@1@Z";
    initSeparatingDistance :: (this: *b3ConvexSeparatingDistanceUtil, separatingVector: b3Vector3, separatingDistance: b3Scalar, transA: b3Transform, transB: b3Transform) #no_context {
        initSeparatingDistance(this, *separatingVector, separatingDistance, *transA, *transB);
    }
}

b3RayInfo :: struct {
    m_from: b3Vector3;
    m_to:   b3Vector3;
}

b3RayHit :: struct {
    m_hitFraction: b3Scalar;
    m_hitBody:     s32;
    m_hitResult1:  s32;
    m_hitResult2:  s32;
    m_hitPoint:    b3Vector3;
    m_hitNormal:   b3Vector3;
}

b3CpuRigidBodyPipeline :: struct {
    vtable: *b3CpuRigidBodyPipeline_VTable;
    b3CpuRigidBodyPipelineInternalData :: struct {}
    m_data: *b3CpuRigidBodyPipelineInternalData;

    Constructor :: (this: *b3CpuRigidBodyPipeline, narrowphase: *b3CpuNarrowPhase, broadphaseDbvt: *b3DynamicBvhBroadphase, config: *b3Config) -> void #cpp_method #foreign bullet3 "??0b3CpuRigidBodyPipeline@@QEAA@PEAVb3CpuNarrowPhase@@PEAUb3DynamicBvhBroadphase@@AEBUb3Config@@@Z";
    Constructor :: (this: *b3CpuRigidBodyPipeline, narrowphase: *b3CpuNarrowPhase, broadphaseDbvt: *b3DynamicBvhBroadphase, config: b3Config) #no_context {
        Constructor(this, narrowphase, broadphaseDbvt, *config);
    }

    registerPhysicsInstance :: (this: *b3CpuRigidBodyPipeline, mass: float, position: *float, orientation: *float, collisionShapeIndex: s32, userData: s32) -> s32 #cpp_method #foreign bullet3 "?registerPhysicsInstance@b3CpuRigidBodyPipeline@@QEAAHMPEBM0HH@Z";

    getBodyBuffer :: (this: *b3CpuRigidBodyPipeline) -> *b3RigidBodyData #cpp_method #foreign bullet3 "?getBodyBuffer@b3CpuRigidBodyPipeline@@QEBAPEBUb3RigidBodyData@@XZ";

    getNumBodies :: (this: *b3CpuRigidBodyPipeline) -> s32 #cpp_method #foreign bullet3 "?getNumBodies@b3CpuRigidBodyPipeline@@QEBAHXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3CpuRigidBodyPipeline, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3CpuRigidBodyPipeline@@UEAA@XZ";

    virtual_stepSimulation :: (this: *b3CpuRigidBodyPipeline, deltaTime: float) -> void #cpp_method #foreign bullet3 "?stepSimulation@b3CpuRigidBodyPipeline@@UEAAXM@Z";
    virtual_integrate :: (this: *b3CpuRigidBodyPipeline, timeStep: float) -> void #cpp_method #foreign bullet3 "?integrate@b3CpuRigidBodyPipeline@@UEAAXM@Z";
    virtual_updateAabbWorldSpace :: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method #foreign bullet3 "?updateAabbWorldSpace@b3CpuRigidBodyPipeline@@UEAAXXZ";
    virtual_computeOverlappingPairs :: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method #foreign bullet3 "?computeOverlappingPairs@b3CpuRigidBodyPipeline@@UEAAXXZ";
    virtual_computeContactPoints :: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method #foreign bullet3 "?computeContactPoints@b3CpuRigidBodyPipeline@@UEAAXXZ";
    virtual_solveContactConstraints :: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method #foreign bullet3 "?solveContactConstraints@b3CpuRigidBodyPipeline@@UEAAXXZ";
}
b3CpuRigidBodyPipeline_VTable :: struct #type_info_none {
    Destructor: (this: *b3CpuRigidBodyPipeline, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    stepSimulation: (this: *b3CpuRigidBodyPipeline, deltaTime: float) -> void #cpp_method;
    integrate: (this: *b3CpuRigidBodyPipeline, timeStep: float) -> void #cpp_method;
    updateAabbWorldSpace: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method;
    computeOverlappingPairs: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method;
    computeContactPoints: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method;
    solveContactConstraints: (this: *b3CpuRigidBodyPipeline) -> void #cpp_method;
}

b3CpuRigidBodyPipeline_Destructor :: inline (this: *b3CpuRigidBodyPipeline, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3CpuRigidBodyPipeline_stepSimulation :: inline (this: *b3CpuRigidBodyPipeline, deltaTime: float) { this.vtable.stepSimulation(this, deltaTime); }
b3CpuRigidBodyPipeline_integrate :: inline (this: *b3CpuRigidBodyPipeline, timeStep: float) { this.vtable.integrate(this, timeStep); }
b3CpuRigidBodyPipeline_updateAabbWorldSpace :: inline (this: *b3CpuRigidBodyPipeline) { this.vtable.updateAabbWorldSpace(this); }
b3CpuRigidBodyPipeline_computeOverlappingPairs :: inline (this: *b3CpuRigidBodyPipeline) { this.vtable.computeOverlappingPairs(this); }
b3CpuRigidBodyPipeline_computeContactPoints :: inline (this: *b3CpuRigidBodyPipeline) { this.vtable.computeContactPoints(this); }
b3CpuRigidBodyPipeline_solveContactConstraints :: inline (this: *b3CpuRigidBodyPipeline) { this.vtable.solveContactConstraints(this); }



/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
b3ConvexHullComputer :: struct {
    compute :: (this: *b3ConvexHullComputer, coords: *void, doubleCoords: bool, stride: s32, count: s32, shrink: b3Scalar, shrinkClamp: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?compute@b3ConvexHullComputer@@AEAAMPEBX_NHHMM@Z";

    Edge :: struct {
        next:         s32;
        reverse:      s32;
        targetVertex: s32;
    }

    // Vertices of the output hull
    vertices: b3AlignedObjectArray(b3Vector3);

    // Edges of the output hull
    edges:    b3AlignedObjectArray(Edge);

    // Faces of the convex hull. Each entry is an index into the "edges" array pointing to an edge of the face. Faces are planar n-gons
    faces:    b3AlignedObjectArray(s32);

    /*
    Compute convex hull of "count" vertices stored in "coords". "stride" is the difference in bytes
    between the addresses of consecutive vertices. If "shrink" is positive, the convex hull is shrunken
    by that amount (each face is moved by "shrink" length units towards the center along its normal).
    If "shrinkClamp" is positive, "shrink" is clamped to not exceed "shrinkClamp * innerRadius", where "innerRadius"
    is the minimum distance of a face to the center of the convex hull.
    
    The returned value is the amount by which the hull has been shrunken. If it is negative, the amount was so large
    that the resulting convex hull is empty.
    
    The output convex hull can be found in the member variables "vertices", "edges", "faces".
    */
    compute :: (this: *b3ConvexHullComputer, coords: *float, stride: s32, count: s32, shrink: b3Scalar, shrinkClamp: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?compute@b3ConvexHullComputer@@QEAAMPEBMHHMM@Z";

    // same as above, but double precision
    compute :: (this: *b3ConvexHullComputer, coords: *float64, stride: s32, count: s32, shrink: b3Scalar, shrinkClamp: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?compute@b3ConvexHullComputer@@QEAAMPEBNHHMM@Z";
}

///The b3GeometryUtil helper class provides a few methods to convert between plane equations and vertices.
b3GeometryUtil :: struct {
    getPlaneEquationsFromVertices :: (vertices: *b3AlignedObjectArray(b3Vector3), planeEquationsOut: *b3AlignedObjectArray(b3Vector3)) -> void #foreign bullet3 "?getPlaneEquationsFromVertices@b3GeometryUtil@@SAXAEAV?$b3AlignedObjectArray@Vb3Vector3@@@@0@Z";

    getVerticesFromPlaneEquations :: (planeEquations: *b3AlignedObjectArray(b3Vector3), verticesOut: *b3AlignedObjectArray(b3Vector3)) -> void #foreign bullet3 "?getVerticesFromPlaneEquations@b3GeometryUtil@@SAXAEBV?$b3AlignedObjectArray@Vb3Vector3@@@@AEAV2@@Z";
    getVerticesFromPlaneEquations :: (planeEquations: b3AlignedObjectArray(b3Vector3), verticesOut: *b3AlignedObjectArray(b3Vector3)) #no_context {
        getVerticesFromPlaneEquations(*planeEquations, verticesOut);
    }

    isPointInsidePlanes :: (planeEquations: *b3AlignedObjectArray(b3Vector3), point: *b3Vector3, margin: b3Scalar) -> bool #foreign bullet3 "?isPointInsidePlanes@b3GeometryUtil@@SA_NAEBV?$b3AlignedObjectArray@Vb3Vector3@@@@AEBVb3Vector3@@M@Z";
    isPointInsidePlanes :: (planeEquations: b3AlignedObjectArray(b3Vector3), point: b3Vector3, margin: b3Scalar) -> bool #no_context {
        return isPointInsidePlanes(*planeEquations, *point, margin);
    }

    areVerticesBehindPlane :: (planeNormal: *b3Vector3, vertices: *b3AlignedObjectArray(b3Vector3), margin: b3Scalar) -> bool #foreign bullet3 "?areVerticesBehindPlane@b3GeometryUtil@@SA_NAEBVb3Vector3@@AEBV?$b3AlignedObjectArray@Vb3Vector3@@@@M@Z";
    areVerticesBehindPlane :: (planeNormal: b3Vector3, vertices: b3AlignedObjectArray(b3Vector3), margin: b3Scalar) -> bool #no_context {
        return areVerticesBehindPlane(*planeNormal, *vertices, margin);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

b3GrahamVector3 :: struct {
    #as using b3vector3: b3Vector3;

    Constructor :: (this: *b3GrahamVector3, org: *b3Vector3, orgIndex: s32) -> void #cpp_method #foreign bullet3 "??0b3GrahamVector3@@QEAA@AEBVb3Vector3@@H@Z";
    Constructor :: (this: *b3GrahamVector3, org: b3Vector3, orgIndex: s32) #no_context {
        Constructor(this, *org, orgIndex);
    }

    m_angle:    b3Scalar;
    m_orgIndex: s32;
}

b3AngleCompareFunc :: struct {
    m_anchor: b3Vector3;
    Constructor :: (this: *b3AngleCompareFunc, anchor: *b3Vector3) -> void #cpp_method #foreign bullet3 "??0b3AngleCompareFunc@@QEAA@AEBVb3Vector3@@@Z";
    Constructor :: (this: *b3AngleCompareFunc, anchor: b3Vector3) #no_context {
        Constructor(this, *anchor);
    }
}

///btGjkEpaSolver contributed under zlib by Nathanael Presson
btGjkEpaSolver2 :: struct {
    sResults :: struct {
        eStatus :: enum s32 {
            Separated   :: 0;
            Penetrating :: 1;
            GJK_Failed  :: 2;
            EPA_Failed  :: 3;
        }

        status:    eStatus;
        witnesses: [2] btVector3;
        normal:    btVector3;
        distance:  btScalar;
    }

    StackSizeRequirement :: () -> s32 #foreign bullet3 "?StackSizeRequirement@btGjkEpaSolver2@@SAHXZ";

    Distance :: (shape0: *btConvexShape, wtrs0: *btTransform, shape1: *btConvexShape, wtrs1: *btTransform, guess: *btVector3, results: *sResults) -> bool #foreign bullet3 "?Distance@btGjkEpaSolver2@@SA_NPEBVbtConvexShape@@AEBVbtTransform@@01AEBVbtVector3@@AEAUsResults@1@@Z";
    Distance :: (shape0: *btConvexShape, wtrs0: btTransform, shape1: *btConvexShape, wtrs1: btTransform, guess: btVector3, results: *sResults) -> bool #no_context {
        return Distance(shape0, *wtrs0, shape1, *wtrs1, *guess, results);
    }

    Penetration :: (shape0: *btConvexShape, wtrs0: *btTransform, shape1: *btConvexShape, wtrs1: *btTransform, guess: *btVector3, results: *sResults, usemargins := true) -> bool #foreign bullet3 "?Penetration@btGjkEpaSolver2@@SA_NPEBVbtConvexShape@@AEBVbtTransform@@01AEBVbtVector3@@AEAUsResults@1@_N@Z";
    Penetration :: (shape0: *btConvexShape, wtrs0: btTransform, shape1: *btConvexShape, wtrs1: btTransform, guess: btVector3, results: *sResults, usemargins := true) -> bool #no_context {
        return Penetration(shape0, *wtrs0, shape1, *wtrs1, *guess, results, usemargins);
    }

    SignedDistance :: (position: *btVector3, margin: btScalar, shape: *btConvexShape, wtrs: *btTransform, results: *sResults) -> btScalar #foreign bullet3 "?SignedDistance@btGjkEpaSolver2@@SAMAEBVbtVector3@@MPEBVbtConvexShape@@AEBVbtTransform@@AEAUsResults@1@@Z";
    SignedDistance :: (position: btVector3, margin: btScalar, shape: *btConvexShape, wtrs: btTransform, results: *sResults) -> btScalar #no_context {
        return SignedDistance(*position, margin, shape, *wtrs, results);
    }

    SignedDistance :: (shape0: *btConvexShape, wtrs0: *btTransform, shape1: *btConvexShape, wtrs1: *btTransform, guess: *btVector3, results: *sResults) -> bool #foreign bullet3 "?SignedDistance@btGjkEpaSolver2@@SA_NPEBVbtConvexShape@@AEBVbtTransform@@01AEBVbtVector3@@AEAUsResults@1@@Z";
    SignedDistance :: (shape0: *btConvexShape, wtrs0: btTransform, shape1: *btConvexShape, wtrs1: btTransform, guess: btVector3, results: *sResults) -> bool #no_context {
        return SignedDistance(shape0, *wtrs0, shape1, *wtrs1, *guess, results);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

btSparseSdf :: struct(CELLSIZE: s32) {
    //
    // Inner types
    //
    IntFrac :: struct {
        b: s32;
        i: s32;
        f: btScalar;
    }

    Cell :: struct {
        d:       [btScalar] [btScalar] [btScalar] btScalar;
        c:       [3] s32;
        puid:    s32;
        hash:    u32;
        pclient: *btCollisionShape;
        next:    *Cell;
    }

    //
    // Fields
    //
    cells:            btAlignedObjectArray(*Cell);
    voxelsz:          btScalar;
    m_defaultVoxelsz: btScalar;
    puid:             s32;
    ncells:           s32;
    m_clampCells:     s32;
    nprobes:          s32;
    nqueries:         s32;
}

btMultiBodyLinkFlags :: enum s32 {
    PARENT_COLLISION     :: 1;
    ALL_PARENT_COLLISION :: 2;

    BT_MULTIBODYLINKFLAGS_DISABLE_PARENT_COLLISION     :: PARENT_COLLISION;
    BT_MULTIBODYLINKFLAGS_DISABLE_ALL_PARENT_COLLISION :: ALL_PARENT_COLLISION;
}

btSpatialForceVector :: struct {
    m_topVec:    btVector3;
    m_bottomVec: btVector3;

    //
    Constructor :: (this: *btSpatialForceVector) -> void #cpp_method #foreign bullet3 "??0btSpatialForceVector@@QEAA@XZ";
    Constructor :: (this: *btSpatialForceVector, angular: *btVector3, linear: *btVector3) -> void #cpp_method #foreign bullet3 "??0btSpatialForceVector@@QEAA@AEBVbtVector3@@0@Z";
    Constructor :: (this: *btSpatialForceVector, angular: btVector3, linear: btVector3) #no_context {
        Constructor(this, *angular, *linear);
    }
    Constructor :: (this: *btSpatialForceVector, ax: *btScalar, ay: *btScalar, az: *btScalar, lx: *btScalar, ly: *btScalar, lz: *btScalar) -> void #cpp_method #foreign bullet3 "??0btSpatialForceVector@@QEAA@AEBM00000@Z";
    Constructor :: (this: *btSpatialForceVector, ax: btScalar, ay: btScalar, az: btScalar, lx: btScalar, ly: btScalar, lz: btScalar) #no_context {
        Constructor(this, *ax, *ay, *az, *lx, *ly, *lz);
    }

    //
    setVector :: (this: *btSpatialForceVector, angular: *btVector3, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?setVector@btSpatialForceVector@@QEAAXAEBVbtVector3@@0@Z";
    setVector :: (this: *btSpatialForceVector, angular: btVector3, linear: btVector3) #no_context {
        setVector(this, *angular, *linear);
    }

    setValue :: (this: *btSpatialForceVector, ax: *btScalar, ay: *btScalar, az: *btScalar, lx: *btScalar, ly: *btScalar, lz: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btSpatialForceVector@@QEAAXAEBM00000@Z";
    setValue :: (this: *btSpatialForceVector, ax: btScalar, ay: btScalar, az: btScalar, lx: btScalar, ly: btScalar, lz: btScalar) #no_context {
        setValue(this, *ax, *ay, *az, *lx, *ly, *lz);
    }

    //
    addVector :: (this: *btSpatialForceVector, angular: *btVector3, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?addVector@btSpatialForceVector@@QEAAXAEBVbtVector3@@0@Z";
    addVector :: (this: *btSpatialForceVector, angular: btVector3, linear: btVector3) #no_context {
        addVector(this, *angular, *linear);
    }

    addValue :: (this: *btSpatialForceVector, ax: *btScalar, ay: *btScalar, az: *btScalar, lx: *btScalar, ly: *btScalar, lz: *btScalar) -> void #cpp_method #foreign bullet3 "?addValue@btSpatialForceVector@@QEAAXAEBM00000@Z";
    addValue :: (this: *btSpatialForceVector, ax: btScalar, ay: btScalar, az: btScalar, lx: btScalar, ly: btScalar, lz: btScalar) #no_context {
        addValue(this, *ax, *ay, *az, *lx, *ly, *lz);
    }

    //
    getLinear :: (this: *btSpatialForceVector) -> *btVector3 #cpp_method #foreign bullet3 "?getLinear@btSpatialForceVector@@QEBAAEBVbtVector3@@XZ";
    getAngular :: (this: *btSpatialForceVector) -> *btVector3 #cpp_method #foreign bullet3 "?getAngular@btSpatialForceVector@@QEBAAEBVbtVector3@@XZ";

    //
    setLinear :: (this: *btSpatialForceVector, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinear@btSpatialForceVector@@QEAAXAEBVbtVector3@@@Z";
    setLinear :: (this: *btSpatialForceVector, linear: btVector3) #no_context {
        setLinear(this, *linear);
    }
    setAngular :: (this: *btSpatialForceVector, angular: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngular@btSpatialForceVector@@QEAAXAEBVbtVector3@@@Z";
    setAngular :: (this: *btSpatialForceVector, angular: btVector3) #no_context {
        setAngular(this, *angular);
    }

    //
    addAngular :: (this: *btSpatialForceVector, angular: *btVector3) -> void #cpp_method #foreign bullet3 "?addAngular@btSpatialForceVector@@QEAAXAEBVbtVector3@@@Z";
    addAngular :: (this: *btSpatialForceVector, angular: btVector3) #no_context {
        addAngular(this, *angular);
    }
    addLinear :: (this: *btSpatialForceVector, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?addLinear@btSpatialForceVector@@QEAAXAEBVbtVector3@@@Z";
    addLinear :: (this: *btSpatialForceVector, linear: btVector3) #no_context {
        addLinear(this, *linear);
    }

    //
    setZero :: (this: *btSpatialForceVector) -> void #cpp_method #foreign bullet3 "?setZero@btSpatialForceVector@@QEAAXXZ";
}

//
operator+= :: (this: *btSpatialForceVector, vec: *btSpatialForceVector) -> *btSpatialForceVector #cpp_method #foreign bullet3 "??YbtSpatialForceVector@@QEAAAEAU0@AEBU0@@Z";
operator+= :: (this: *btSpatialForceVector, vec: btSpatialForceVector) -> *btSpatialForceVector #no_context {
    return operator+=(this, *vec);
}

operator-= :: (this: *btSpatialForceVector, vec: *btSpatialForceVector) -> *btSpatialForceVector #cpp_method #foreign bullet3 "??ZbtSpatialForceVector@@QEAAAEAU0@AEBU0@@Z";
operator-= :: (this: *btSpatialForceVector, vec: btSpatialForceVector) -> *btSpatialForceVector #no_context {
    return operator-=(this, *vec);
}

operator- :: (this: *btSpatialForceVector, vec: *btSpatialForceVector) -> btSpatialForceVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtSpatialForceVector@@QEBA?AU0@AEBU0@@Z";
operator- :: (this: btSpatialForceVector, vec: btSpatialForceVector) -> btSpatialForceVector #no_context {
    return operator-(*this, *vec);
}
operator+ :: (this: *btSpatialForceVector, vec: *btSpatialForceVector) -> btSpatialForceVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??HbtSpatialForceVector@@QEBA?AU0@AEBU0@@Z";
operator+ :: (this: btSpatialForceVector, vec: btSpatialForceVector) -> btSpatialForceVector #no_context {
    return operator+(*this, *vec);
}
operator- :: (this: *btSpatialForceVector) -> btSpatialForceVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtSpatialForceVector@@QEBA?AU0@XZ";
operator- :: (this: btSpatialForceVector) -> btSpatialForceVector #no_context {
    return operator-(*this);
}
operator* :: (this: *btSpatialForceVector, s: *btScalar) -> btSpatialForceVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtSpatialForceVector@@QEBA?AU0@AEBM@Z";
operator* :: (this: btSpatialForceVector, s: btScalar) -> btSpatialForceVector #no_context {
    return operator*(*this, *s);
}

btSpatialMotionVector :: struct {
    m_topVec:    btVector3;
    m_bottomVec: btVector3;

    //
    Constructor :: (this: *btSpatialMotionVector) -> void #cpp_method #foreign bullet3 "??0btSpatialMotionVector@@QEAA@XZ";
    Constructor :: (this: *btSpatialMotionVector, angular: *btVector3, linear: *btVector3) -> void #cpp_method #foreign bullet3 "??0btSpatialMotionVector@@QEAA@AEBVbtVector3@@0@Z";
    Constructor :: (this: *btSpatialMotionVector, angular: btVector3, linear: btVector3) #no_context {
        Constructor(this, *angular, *linear);
    }

    //
    setVector :: (this: *btSpatialMotionVector, angular: *btVector3, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?setVector@btSpatialMotionVector@@QEAAXAEBVbtVector3@@0@Z";
    setVector :: (this: *btSpatialMotionVector, angular: btVector3, linear: btVector3) #no_context {
        setVector(this, *angular, *linear);
    }

    setValue :: (this: *btSpatialMotionVector, ax: *btScalar, ay: *btScalar, az: *btScalar, lx: *btScalar, ly: *btScalar, lz: *btScalar) -> void #cpp_method #foreign bullet3 "?setValue@btSpatialMotionVector@@QEAAXAEBM00000@Z";
    setValue :: (this: *btSpatialMotionVector, ax: btScalar, ay: btScalar, az: btScalar, lx: btScalar, ly: btScalar, lz: btScalar) #no_context {
        setValue(this, *ax, *ay, *az, *lx, *ly, *lz);
    }

    //
    addVector :: (this: *btSpatialMotionVector, angular: *btVector3, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?addVector@btSpatialMotionVector@@QEAAXAEBVbtVector3@@0@Z";
    addVector :: (this: *btSpatialMotionVector, angular: btVector3, linear: btVector3) #no_context {
        addVector(this, *angular, *linear);
    }

    addValue :: (this: *btSpatialMotionVector, ax: *btScalar, ay: *btScalar, az: *btScalar, lx: *btScalar, ly: *btScalar, lz: *btScalar) -> void #cpp_method #foreign bullet3 "?addValue@btSpatialMotionVector@@QEAAXAEBM00000@Z";
    addValue :: (this: *btSpatialMotionVector, ax: btScalar, ay: btScalar, az: btScalar, lx: btScalar, ly: btScalar, lz: btScalar) #no_context {
        addValue(this, *ax, *ay, *az, *lx, *ly, *lz);
    }

    //
    getAngular :: (this: *btSpatialMotionVector) -> *btVector3 #cpp_method #foreign bullet3 "?getAngular@btSpatialMotionVector@@QEBAAEBVbtVector3@@XZ";
    getLinear :: (this: *btSpatialMotionVector) -> *btVector3 #cpp_method #foreign bullet3 "?getLinear@btSpatialMotionVector@@QEBAAEBVbtVector3@@XZ";

    //
    setAngular :: (this: *btSpatialMotionVector, angular: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngular@btSpatialMotionVector@@QEAAXAEBVbtVector3@@@Z";
    setAngular :: (this: *btSpatialMotionVector, angular: btVector3) #no_context {
        setAngular(this, *angular);
    }
    setLinear :: (this: *btSpatialMotionVector, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinear@btSpatialMotionVector@@QEAAXAEBVbtVector3@@@Z";
    setLinear :: (this: *btSpatialMotionVector, linear: btVector3) #no_context {
        setLinear(this, *linear);
    }

    //
    addAngular :: (this: *btSpatialMotionVector, angular: *btVector3) -> void #cpp_method #foreign bullet3 "?addAngular@btSpatialMotionVector@@QEAAXAEBVbtVector3@@@Z";
    addAngular :: (this: *btSpatialMotionVector, angular: btVector3) #no_context {
        addAngular(this, *angular);
    }
    addLinear :: (this: *btSpatialMotionVector, linear: *btVector3) -> void #cpp_method #foreign bullet3 "?addLinear@btSpatialMotionVector@@QEAAXAEBVbtVector3@@@Z";
    addLinear :: (this: *btSpatialMotionVector, linear: btVector3) #no_context {
        addLinear(this, *linear);
    }

    //
    setZero :: (this: *btSpatialMotionVector) -> void #cpp_method #foreign bullet3 "?setZero@btSpatialMotionVector@@QEAAXXZ";

    //
    dot :: (this: *btSpatialMotionVector, b: *btSpatialForceVector) -> btScalar #cpp_method #foreign bullet3 "?dot@btSpatialMotionVector@@QEBAMAEBUbtSpatialForceVector@@@Z";
    dot :: (this: *btSpatialMotionVector, b: btSpatialForceVector) -> btScalar #no_context {
        return dot(this, *b);
    }
}

//
operator+= :: (this: *btSpatialMotionVector, vec: *btSpatialMotionVector) -> *btSpatialMotionVector #cpp_method #foreign bullet3 "??YbtSpatialMotionVector@@QEAAAEAU0@AEBU0@@Z";
operator+= :: (this: *btSpatialMotionVector, vec: btSpatialMotionVector) -> *btSpatialMotionVector #no_context {
    return operator+=(this, *vec);
}

operator-= :: (this: *btSpatialMotionVector, vec: *btSpatialMotionVector) -> *btSpatialMotionVector #cpp_method #foreign bullet3 "??ZbtSpatialMotionVector@@QEAAAEAU0@AEBU0@@Z";
operator-= :: (this: *btSpatialMotionVector, vec: btSpatialMotionVector) -> *btSpatialMotionVector #no_context {
    return operator-=(this, *vec);
}

operator*= :: (this: *btSpatialMotionVector, s: *btScalar) -> *btSpatialMotionVector #cpp_method #foreign bullet3 "??XbtSpatialMotionVector@@QEAAAEAU0@AEBM@Z";
operator*= :: (this: *btSpatialMotionVector, s: btScalar) -> *btSpatialMotionVector #no_context {
    return operator*=(this, *s);
}

operator- :: (this: *btSpatialMotionVector, vec: *btSpatialMotionVector) -> btSpatialMotionVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtSpatialMotionVector@@QEBA?AU0@AEBU0@@Z";
operator- :: (this: btSpatialMotionVector, vec: btSpatialMotionVector) -> btSpatialMotionVector #no_context {
    return operator-(*this, *vec);
}
operator+ :: (this: *btSpatialMotionVector, vec: *btSpatialMotionVector) -> btSpatialMotionVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??HbtSpatialMotionVector@@QEBA?AU0@AEBU0@@Z";
operator+ :: (this: btSpatialMotionVector, vec: btSpatialMotionVector) -> btSpatialMotionVector #no_context {
    return operator+(*this, *vec);
}
operator- :: (this: *btSpatialMotionVector) -> btSpatialMotionVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtSpatialMotionVector@@QEBA?AU0@XZ";
operator- :: (this: btSpatialMotionVector) -> btSpatialMotionVector #no_context {
    return operator-(*this);
}
operator* :: (this: *btSpatialMotionVector, s: *btScalar) -> btSpatialMotionVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtSpatialMotionVector@@QEBA?AU0@AEBM@Z";
operator* :: (this: btSpatialMotionVector, s: btScalar) -> btSpatialMotionVector #no_context {
    return operator*(*this, *s);
}

btSymmetricSpatialDyad :: struct {
    m_topLeftMat:    btMatrix3x3;
    m_topRightMat:   btMatrix3x3;
    m_bottomLeftMat: btMatrix3x3;

    //
    Constructor :: (this: *btSymmetricSpatialDyad) -> void #cpp_method #foreign bullet3 "??0btSymmetricSpatialDyad@@QEAA@XZ";
    Constructor :: (this: *btSymmetricSpatialDyad, topLeftMat: *btMatrix3x3, topRightMat: *btMatrix3x3, bottomLeftMat: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "??0btSymmetricSpatialDyad@@QEAA@AEBVbtMatrix3x3@@00@Z";
    Constructor :: (this: *btSymmetricSpatialDyad, topLeftMat: btMatrix3x3, topRightMat: btMatrix3x3, bottomLeftMat: btMatrix3x3) #no_context {
        Constructor(this, *topLeftMat, *topRightMat, *bottomLeftMat);
    }

    //
    setMatrix :: (this: *btSymmetricSpatialDyad, topLeftMat: *btMatrix3x3, topRightMat: *btMatrix3x3, bottomLeftMat: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setMatrix@btSymmetricSpatialDyad@@QEAAXAEBVbtMatrix3x3@@00@Z";
    setMatrix :: (this: *btSymmetricSpatialDyad, topLeftMat: btMatrix3x3, topRightMat: btMatrix3x3, bottomLeftMat: btMatrix3x3) #no_context {
        setMatrix(this, *topLeftMat, *topRightMat, *bottomLeftMat);
    }

    //
    addMatrix :: (this: *btSymmetricSpatialDyad, topLeftMat: *btMatrix3x3, topRightMat: *btMatrix3x3, bottomLeftMat: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?addMatrix@btSymmetricSpatialDyad@@QEAAXAEBVbtMatrix3x3@@00@Z";
    addMatrix :: (this: *btSymmetricSpatialDyad, topLeftMat: btMatrix3x3, topRightMat: btMatrix3x3, bottomLeftMat: btMatrix3x3) #no_context {
        addMatrix(this, *topLeftMat, *topRightMat, *bottomLeftMat);
    }

    //
    setIdentity :: (this: *btSymmetricSpatialDyad) -> void #cpp_method #foreign bullet3 "?setIdentity@btSymmetricSpatialDyad@@QEAAXXZ";
}

//
operator-= :: (this: *btSymmetricSpatialDyad, mat: *btSymmetricSpatialDyad) -> *btSymmetricSpatialDyad #cpp_method #foreign bullet3 "??ZbtSymmetricSpatialDyad@@QEAAAEAU0@AEBU0@@Z";
operator-= :: (this: *btSymmetricSpatialDyad, mat: btSymmetricSpatialDyad) -> *btSymmetricSpatialDyad #no_context {
    return operator-=(this, *mat);
}

//
operator* :: (this: *btSymmetricSpatialDyad, vec: *btSpatialMotionVector) -> btSpatialForceVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DbtSymmetricSpatialDyad@@QEAA?AUbtSpatialForceVector@@AEBUbtSpatialMotionVector@@@Z";
operator* :: (this: btSymmetricSpatialDyad, vec: btSpatialMotionVector) -> btSpatialForceVector #no_context {
    return operator*(*this, *vec);
}

btSpatialTransformationMatrix :: struct {
    m_rotMat: btMatrix3x3; //btMatrix3x3 m_trnCrossMat;
    m_trnVec: btVector3;

    //
    eOutputOperation :: enum s32 {
        None     :: 0;
        Add      :: 1;
        Subtract :: 2;
    }

    transformInverse :: (this: *btSpatialTransformationMatrix, inMat: *btSymmetricSpatialDyad, outMat: *btSymmetricSpatialDyad, outOp: eOutputOperation = .None) -> void #cpp_method #foreign bullet3 "?transformInverse@btSpatialTransformationMatrix@@QEAAXAEBUbtSymmetricSpatialDyad@@AEAU2@W4eOutputOperation@1@@Z";
    transformInverse :: (this: *btSpatialTransformationMatrix, inMat: btSymmetricSpatialDyad, outMat: *btSymmetricSpatialDyad, outOp: eOutputOperation = .None) #no_context {
        transformInverse(this, *inMat, outMat, outOp);
    }
}

//
// Link struct
//
btMultibodyLink :: struct {
    m_mass:                              btScalar; // mass of link
    m_inertiaLocal:                      btVector3; // inertia of link (local frame; diagonal)

    m_parent:                            s32; // index of the parent link (assumed to be < index of this link), or -1 if parent is the base link.

    m_zeroRotParentToThis:               btQuaternion; // rotates vectors in parent-frame to vectors in local-frame (when q=0). constant.

    m_dVector:                           btVector3; // vector from the inboard joint pos to this link's COM. (local frame.) constant.

    // m_eVector is constant, but depends on the joint type:
    // revolute, fixed, prismatic, spherical: vector from parent's COM to the pivot point, in PARENT's frame.
    // planar: vector from COM of parent to COM of this link, WHEN Q = 0. (local frame.)
    // todo: fix the planar so it is consistent with the other joints
    m_eVector:                           btVector3;

    m_absFrameTotVelocity:               btSpatialMotionVector;
    m_absFrameLocVelocity:               btSpatialMotionVector;

    eFeatherstoneJointType :: enum s32 {
        Revolute  :: 0;
        Prismatic :: 1;
        Spherical :: 2;
        Planar    :: 3;
        Fixed     :: 4;
        Invalid   :: 5;

        eRevolute  :: Revolute;
        ePrismatic :: Prismatic;
        eSpherical :: Spherical;
        ePlanar    :: Planar;
        eFixed     :: Fixed;
        eInvalid   :: Invalid;
    }

    // "axis" = spatial joint axis (Mirtich Defn 9 p104). (expressed in local frame.) constant.
    // for prismatic: m_axesTop[0] = zero;
    //                m_axesBottom[0] = unit vector along the joint axis.
    // for revolute: m_axesTop[0] = unit vector along the rotation axis (u);
    //               m_axesBottom[0] = u cross m_dVector (i.e. COM linear motion due to the rotation at the joint)
    //
    // for spherical: m_axesTop[0][1][2] (u1,u2,u3) form a 3x3 identity matrix (3 rotation axes)
    //				  m_axesBottom[0][1][2] cross u1,u2,u3 (i.e. COM linear motion due to the rotation at the joint)
    //
    // for planar: m_axesTop[0] = unit vector along the rotation axis (u); defines the plane of motion
    //			   m_axesTop[1][2] = zero
    //			   m_axesBottom[0] = zero
    //			   m_axesBottom[1][2] = unit vectors along the translational axes on that plane
    m_axes:                              [6] btSpatialMotionVector;
    setAxisTop :: (this: *btMultibodyLink, dof: s32, axis: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxisTop@btMultibodyLink@@QEAAXHAEBVbtVector3@@@Z";
    setAxisTop :: (this: *btMultibodyLink, dof: s32, axis: btVector3) #no_context {
        setAxisTop(this, dof, *axis);
    }
    setAxisBottom :: (this: *btMultibodyLink, dof: s32, axis: *btVector3) -> void #cpp_method #foreign bullet3 "?setAxisBottom@btMultibodyLink@@QEAAXHAEBVbtVector3@@@Z";
    setAxisBottom :: (this: *btMultibodyLink, dof: s32, axis: btVector3) #no_context {
        setAxisBottom(this, dof, *axis);
    }

    setAxisTop :: (this: *btMultibodyLink, dof: s32, x: *btScalar, y: *btScalar, z: *btScalar) -> void #cpp_method #foreign bullet3 "?setAxisTop@btMultibodyLink@@QEAAXHAEBM00@Z";
    setAxisTop :: (this: *btMultibodyLink, dof: s32, x: btScalar, y: btScalar, z: btScalar) #no_context {
        setAxisTop(this, dof, *x, *y, *z);
    }

    setAxisBottom :: (this: *btMultibodyLink, dof: s32, x: *btScalar, y: *btScalar, z: *btScalar) -> void #cpp_method #foreign bullet3 "?setAxisBottom@btMultibodyLink@@QEAAXHAEBM00@Z";
    setAxisBottom :: (this: *btMultibodyLink, dof: s32, x: btScalar, y: btScalar, z: btScalar) #no_context {
        setAxisBottom(this, dof, *x, *y, *z);
    }

    getAxisTop :: (this: *btMultibodyLink, dof: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getAxisTop@btMultibodyLink@@QEBAAEBVbtVector3@@H@Z";
    getAxisBottom :: (this: *btMultibodyLink, dof: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getAxisBottom@btMultibodyLink@@QEBAAEBVbtVector3@@H@Z";

    m_dofOffset:                         s32;
    m_cfgOffset:                         s32;

    m_cachedRotParentToThis:             btQuaternion; // rotates vectors in parent frame to vectors in local frame
    m_cachedRVector:                     btVector3; // vector from COM of parent to COM of this link, in local frame.

    m_cachedRotParentToThis_interpolate: btQuaternion; // rotates vectors in parent frame to vectors in local frame
    m_cachedRVector_interpolate:         btVector3; // vector from COM of parent to COM of this link, in local frame.

    m_appliedForce:                      btVector3; // In WORLD frame
    m_appliedTorque:                     btVector3; // In WORLD frame

    m_appliedConstraintForce:            btVector3; // In WORLD frame
    m_appliedConstraintTorque:           btVector3; // In WORLD frame

    m_jointPos:                          [7] btScalar;
    m_jointPos_interpolate:              [7] btScalar;

    //m_jointTorque is the joint torque applied by the user using 'addJointTorque'.
    //It gets set to zero after each internal stepSimulation call
    m_jointTorque:                       [6] btScalar;

    m_collider:                          *btMultiBodyLinkCollider;
    m_flags:                             s32;

    m_dofCount:                          s32; //redundant but handy
    m_posVarCount:                       s32; //redundant but handy

    m_jointType:                         eFeatherstoneJointType;

    m_jointFeedback:                     *btMultiBodyJointFeedback;

    m_cachedWorldTransform:              btTransform; //this cache is updated when calling btMultiBody::forwardKinematics

    m_linkName:                          *u8; //m_linkName memory needs to be managed by the developer/user!
    m_jointName:                         *u8; //m_jointName memory needs to be managed by the developer/user!
    m_userPtr:                           *void; //m_userPtr ptr needs to be managed by the developer/user!

    m_jointDamping:                      btScalar; //todo: implement this internally. It is unused for now, it is set by a URDF loader. User can apply manual damping.
    m_jointFriction:                     btScalar; //todo: implement this internally. It is unused for now, it is set by a URDF loader. User can apply manual friction using a velocity motor.
    m_jointLowerLimit:                   btScalar; //todo: implement this internally. It is unused for now, it is set by a URDF loader.
    m_jointUpperLimit:                   btScalar; //todo: implement this internally. It is unused for now, it is set by a URDF loader.
    m_jointMaxForce:                     btScalar; //todo: implement this internally. It is unused for now, it is set by a URDF loader.
    m_jointMaxVelocity:                  btScalar; //todo: implement this internally. It is unused for now, it is set by a URDF loader.

    // ctor: set some sensible defaults
    Constructor :: (this: *btMultibodyLink) -> void #cpp_method #foreign bullet3 "??0btMultibodyLink@@QEAA@XZ";

    // routine to update m_cachedRotParentToThis and m_cachedRVector
    updateCacheMultiDof :: (this: *btMultibodyLink, pq: *btScalar = null) -> void #cpp_method #foreign bullet3 "?updateCacheMultiDof@btMultibodyLink@@QEAAXPEAM@Z";

    updateInterpolationCacheMultiDof :: (this: *btMultibodyLink) -> void #cpp_method #foreign bullet3 "?updateInterpolationCacheMultiDof@btMultibodyLink@@QEAAXXZ";
}


btMultiBody :: struct {
    vtable: *btMultiBody_VTable;
    //
    // initialization
    //
    Constructor :: (this: *btMultiBody, n_links: s32, mass: btScalar, inertia: *btVector3, fixedBase: bool, canSleep: bool, deprecatedMultiDof := true) -> void #cpp_method #foreign bullet3 "??0btMultiBody@@QEAA@HMAEBVbtVector3@@_N11@Z";
    Constructor :: (this: *btMultiBody, n_links: s32, mass: btScalar, inertia: btVector3, fixedBase: bool, canSleep: bool, deprecatedMultiDof := true) #no_context {
        Constructor(this, n_links, mass, *inertia, fixedBase, canSleep, deprecatedMultiDof);
    }

    //note: fixed link collision with parent is always disabled
    setupFixed :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: *btVector3, parent: s32, rotParentToThis: *btQuaternion, parentComToThisPivotOffset: *btVector3, thisPivotToThisComOffset: *btVector3, deprecatedDisableParentCollision := true) -> void #cpp_method #foreign bullet3 "?setupFixed@btMultiBody@@QEAAXHMAEBVbtVector3@@HAEBVbtQuaternion@@00_N@Z";
    setupFixed :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: btVector3, parent: s32, rotParentToThis: btQuaternion, parentComToThisPivotOffset: btVector3, thisPivotToThisComOffset: btVector3, deprecatedDisableParentCollision := true) #no_context {
        setupFixed(this, i, mass, *inertia, parent, *rotParentToThis, *parentComToThisPivotOffset, *thisPivotToThisComOffset, deprecatedDisableParentCollision);
    }

    setupPrismatic :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: *btVector3, parent: s32, rotParentToThis: *btQuaternion, jointAxis: *btVector3, parentComToThisPivotOffset: *btVector3, thisPivotToThisComOffset: *btVector3, disableParentCollision: bool) -> void #cpp_method #foreign bullet3 "?setupPrismatic@btMultiBody@@QEAAXHMAEBVbtVector3@@HAEBVbtQuaternion@@000_N@Z";
    setupPrismatic :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: btVector3, parent: s32, rotParentToThis: btQuaternion, jointAxis: btVector3, parentComToThisPivotOffset: btVector3, thisPivotToThisComOffset: btVector3, disableParentCollision: bool) #no_context {
        setupPrismatic(this, i, mass, *inertia, parent, *rotParentToThis, *jointAxis, *parentComToThisPivotOffset, *thisPivotToThisComOffset, disableParentCollision);
    }

    setupRevolute :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: *btVector3, parentIndex: s32, rotParentToThis: *btQuaternion, jointAxis: *btVector3, parentComToThisPivotOffset: *btVector3, thisPivotToThisComOffset: *btVector3, disableParentCollision := false) -> void #cpp_method #foreign bullet3 "?setupRevolute@btMultiBody@@QEAAXHMAEBVbtVector3@@HAEBVbtQuaternion@@000_N@Z";
    setupRevolute :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: btVector3, parentIndex: s32, rotParentToThis: btQuaternion, jointAxis: btVector3, parentComToThisPivotOffset: btVector3, thisPivotToThisComOffset: btVector3, disableParentCollision := false) #no_context {
        setupRevolute(this, i, mass, *inertia, parentIndex, *rotParentToThis, *jointAxis, *parentComToThisPivotOffset, *thisPivotToThisComOffset, disableParentCollision);
    }

    setupSpherical :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: *btVector3, parent: s32, rotParentToThis: *btQuaternion, parentComToThisPivotOffset: *btVector3, thisPivotToThisComOffset: *btVector3, disableParentCollision := false) -> void #cpp_method #foreign bullet3 "?setupSpherical@btMultiBody@@QEAAXHMAEBVbtVector3@@HAEBVbtQuaternion@@00_N@Z";
    setupSpherical :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: btVector3, parent: s32, rotParentToThis: btQuaternion, parentComToThisPivotOffset: btVector3, thisPivotToThisComOffset: btVector3, disableParentCollision := false) #no_context {
        setupSpherical(this, i, mass, *inertia, parent, *rotParentToThis, *parentComToThisPivotOffset, *thisPivotToThisComOffset, disableParentCollision);
    }

    setupPlanar :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: *btVector3, parent: s32, rotParentToThis: *btQuaternion, rotationAxis: *btVector3, parentComToThisComOffset: *btVector3, disableParentCollision := false) -> void #cpp_method #foreign bullet3 "?setupPlanar@btMultiBody@@QEAAXHMAEBVbtVector3@@HAEBVbtQuaternion@@00_N@Z";
    setupPlanar :: (this: *btMultiBody, i: s32, mass: btScalar, inertia: btVector3, parent: s32, rotParentToThis: btQuaternion, rotationAxis: btVector3, parentComToThisComOffset: btVector3, disableParentCollision := false) #no_context {
        setupPlanar(this, i, mass, *inertia, parent, *rotParentToThis, *rotationAxis, *parentComToThisComOffset, disableParentCollision);
    }

    getLink :: (this: /*const*/ *btMultiBody, index: s32) -> *btMultibodyLink #cpp_method #foreign bullet3 "?getLink@btMultiBody@@QEBAAEBUbtMultibodyLink@@H@Z";

    getLink_1 :: (this: *btMultiBody, index: s32) -> *btMultibodyLink #cpp_method #foreign bullet3 "?getLink@btMultiBody@@QEAAAEAUbtMultibodyLink@@H@Z";

    setBaseCollider :: (this: *btMultiBody, collider: *btMultiBodyLinkCollider) -> void #cpp_method #foreign bullet3 "?setBaseCollider@btMultiBody@@QEAAXPEAVbtMultiBodyLinkCollider@@@Z";

    getBaseCollider :: (this: /*const*/ *btMultiBody) -> *btMultiBodyLinkCollider #cpp_method #foreign bullet3 "?getBaseCollider@btMultiBody@@QEBAPEBVbtMultiBodyLinkCollider@@XZ";

    getBaseCollider_1 :: (this: *btMultiBody) -> *btMultiBodyLinkCollider #cpp_method #foreign bullet3 "?getBaseCollider@btMultiBody@@QEAAPEAVbtMultiBodyLinkCollider@@XZ";

    getLinkCollider :: (this: /*const*/ *btMultiBody, index: s32) -> *btMultiBodyLinkCollider #cpp_method #foreign bullet3 "?getLinkCollider@btMultiBody@@QEBAPEBVbtMultiBodyLinkCollider@@H@Z";

    getLinkCollider_1 :: (this: *btMultiBody, index: s32) -> *btMultiBodyLinkCollider #cpp_method #foreign bullet3 "?getLinkCollider@btMultiBody@@QEAAPEAVbtMultiBodyLinkCollider@@H@Z";

    //
    // get parent
    // input: link num from 0 to num_links-1
    // output: link num from 0 to num_links-1, OR -1 to mean the base.
    //
    getParent :: (this: *btMultiBody, link_num: s32) -> s32 #cpp_method #foreign bullet3 "?getParent@btMultiBody@@QEBAHH@Z";

    //
    // get number of m_links, masses, moments of inertia
    //
    getNumLinks :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?getNumLinks@btMultiBody@@QEBAHXZ";
    getNumDofs :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?getNumDofs@btMultiBody@@QEBAHXZ";
    getNumPosVars :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?getNumPosVars@btMultiBody@@QEBAHXZ";
    getBaseMass :: (this: *btMultiBody) -> btScalar #cpp_method #foreign bullet3 "?getBaseMass@btMultiBody@@QEBAMXZ";
    getBaseInertia :: (this: *btMultiBody) -> *btVector3 #cpp_method #foreign bullet3 "?getBaseInertia@btMultiBody@@QEBAAEBVbtVector3@@XZ";
    getLinkMass :: (this: *btMultiBody, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getLinkMass@btMultiBody@@QEBAMH@Z";
    getLinkInertia :: (this: *btMultiBody, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getLinkInertia@btMultiBody@@QEBAAEBVbtVector3@@H@Z";

    //
    // change mass (incomplete: can only change base mass and inertia at present)
    //
    setBaseMass :: (this: *btMultiBody, mass: btScalar) -> void #cpp_method #foreign bullet3 "?setBaseMass@btMultiBody@@QEAAXM@Z";
    setBaseInertia :: (this: *btMultiBody, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?setBaseInertia@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    setBaseInertia :: (this: *btMultiBody, inertia: btVector3) #no_context {
        setBaseInertia(this, *inertia);
    }

    //
    // get/set pos/vel/rot/omega for the base link
    //
    getBasePos :: (this: *btMultiBody) -> *btVector3 #cpp_method #foreign bullet3 "?getBasePos@btMultiBody@@QEBAAEBVbtVector3@@XZ";

    getBaseVel :: (this: *btMultiBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getBaseVel@btMultiBody@@QEBA?BVbtVector3@@XZ";

    getWorldToBaseRot :: (this: *btMultiBody) -> *btQuaternion #cpp_method #foreign bullet3 "?getWorldToBaseRot@btMultiBody@@QEBAAEBVbtQuaternion@@XZ";

    getInterpolateBasePos :: (this: *btMultiBody) -> *btVector3 #cpp_method #foreign bullet3 "?getInterpolateBasePos@btMultiBody@@QEBAAEBVbtVector3@@XZ";

    getInterpolateWorldToBaseRot :: (this: *btMultiBody) -> *btQuaternion #cpp_method #foreign bullet3 "?getInterpolateWorldToBaseRot@btMultiBody@@QEBAAEBVbtQuaternion@@XZ";

    // rotates world vectors into base frame
    getBaseOmega :: (this: *btMultiBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getBaseOmega@btMultiBody@@QEBA?AVbtVector3@@XZ";

    setBasePos :: (this: *btMultiBody, pos: *btVector3) -> void #cpp_method #foreign bullet3 "?setBasePos@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    setBasePos :: (this: *btMultiBody, pos: btVector3) #no_context {
        setBasePos(this, *pos);
    }

    setInterpolateBasePos :: (this: *btMultiBody, pos: *btVector3) -> void #cpp_method #foreign bullet3 "?setInterpolateBasePos@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    setInterpolateBasePos :: (this: *btMultiBody, pos: btVector3) #no_context {
        setInterpolateBasePos(this, *pos);
    }

    setBaseWorldTransform :: (this: *btMultiBody, tr: *btTransform) -> void #cpp_method #foreign bullet3 "?setBaseWorldTransform@btMultiBody@@QEAAXAEBVbtTransform@@@Z";
    setBaseWorldTransform :: (this: *btMultiBody, tr: btTransform) #no_context {
        setBaseWorldTransform(this, *tr);
    }

    getBaseWorldTransform :: (this: *btMultiBody) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getBaseWorldTransform@btMultiBody@@QEBA?AVbtTransform@@XZ";

    setInterpolateBaseWorldTransform :: (this: *btMultiBody, tr: *btTransform) -> void #cpp_method #foreign bullet3 "?setInterpolateBaseWorldTransform@btMultiBody@@QEAAXAEBVbtTransform@@@Z";
    setInterpolateBaseWorldTransform :: (this: *btMultiBody, tr: btTransform) #no_context {
        setInterpolateBaseWorldTransform(this, *tr);
    }

    getInterpolateBaseWorldTransform :: (this: *btMultiBody) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getInterpolateBaseWorldTransform@btMultiBody@@QEBA?AVbtTransform@@XZ";

    setBaseVel :: (this: *btMultiBody, vel: *btVector3) -> void #cpp_method #foreign bullet3 "?setBaseVel@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    setBaseVel :: (this: *btMultiBody, vel: btVector3) #no_context {
        setBaseVel(this, *vel);
    }

    setWorldToBaseRot :: (this: *btMultiBody, rot: *btQuaternion) -> void #cpp_method #foreign bullet3 "?setWorldToBaseRot@btMultiBody@@QEAAXAEBVbtQuaternion@@@Z";
    setWorldToBaseRot :: (this: *btMultiBody, rot: btQuaternion) #no_context {
        setWorldToBaseRot(this, *rot);
    }

    setInterpolateWorldToBaseRot :: (this: *btMultiBody, rot: *btQuaternion) -> void #cpp_method #foreign bullet3 "?setInterpolateWorldToBaseRot@btMultiBody@@QEAAXAEBVbtQuaternion@@@Z";
    setInterpolateWorldToBaseRot :: (this: *btMultiBody, rot: btQuaternion) #no_context {
        setInterpolateWorldToBaseRot(this, *rot);
    }

    setBaseOmega :: (this: *btMultiBody, omega: *btVector3) -> void #cpp_method #foreign bullet3 "?setBaseOmega@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    setBaseOmega :: (this: *btMultiBody, omega: btVector3) #no_context {
        setBaseOmega(this, *omega);
    }

    saveKinematicState :: (this: *btMultiBody, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?saveKinematicState@btMultiBody@@QEAAXM@Z";

    //
    // get/set pos/vel for child m_links (i = 0 to num_links-1)
    //
    getJointPos :: (this: *btMultiBody, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getJointPos@btMultiBody@@QEBAMH@Z";
    getJointVel :: (this: *btMultiBody, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getJointVel@btMultiBody@@QEBAMH@Z";

    getJointVelMultiDof :: (this: *btMultiBody, i: s32) -> *btScalar #cpp_method #foreign bullet3 "?getJointVelMultiDof@btMultiBody@@QEAAPEAMH@Z";
    getJointPosMultiDof :: (this: *btMultiBody, i: s32) -> *btScalar #cpp_method #foreign bullet3 "?getJointPosMultiDof@btMultiBody@@QEAAPEAMH@Z";

    getJointVelMultiDof_1 :: (this: /*const*/ *btMultiBody, i: s32) -> *btScalar #cpp_method #foreign bullet3 "?getJointVelMultiDof@btMultiBody@@QEBAPEBMH@Z";
    getJointPosMultiDof_1 :: (this: /*const*/ *btMultiBody, i: s32) -> *btScalar #cpp_method #foreign bullet3 "?getJointPosMultiDof@btMultiBody@@QEBAPEBMH@Z";

    setJointPos :: (this: *btMultiBody, i: s32, q: btScalar) -> void #cpp_method #foreign bullet3 "?setJointPos@btMultiBody@@QEAAXHM@Z";
    setJointVel :: (this: *btMultiBody, i: s32, qdot: btScalar) -> void #cpp_method #foreign bullet3 "?setJointVel@btMultiBody@@QEAAXHM@Z";
    setJointPosMultiDof :: (this: *btMultiBody, i: s32, q: *float64) -> void #cpp_method #foreign bullet3 "?setJointPosMultiDof@btMultiBody@@QEAAXHPEBN@Z";
    setJointVelMultiDof :: (this: *btMultiBody, i: s32, qdot: *float64) -> void #cpp_method #foreign bullet3 "?setJointVelMultiDof@btMultiBody@@QEAAXHPEBN@Z";
    setJointPosMultiDof :: (this: *btMultiBody, i: s32, q: *float) -> void #cpp_method #foreign bullet3 "?setJointPosMultiDof@btMultiBody@@QEAAXHPEBM@Z";
    setJointVelMultiDof :: (this: *btMultiBody, i: s32, qdot: *float) -> void #cpp_method #foreign bullet3 "?setJointVelMultiDof@btMultiBody@@QEAAXHPEBM@Z";

    //
    // direct access to velocities as a vector of 6 + num_links elements.
    // (omega first, then v, then joint velocities.)
    //
    getVelocityVector :: (this: *btMultiBody) -> *btScalar #cpp_method #foreign bullet3 "?getVelocityVector@btMultiBody@@QEBAPEBMXZ";

    getDeltaVelocityVector :: (this: *btMultiBody) -> *btScalar #cpp_method #foreign bullet3 "?getDeltaVelocityVector@btMultiBody@@QEBAPEBMXZ";

    getSplitVelocityVector :: (this: *btMultiBody) -> *btScalar #cpp_method #foreign bullet3 "?getSplitVelocityVector@btMultiBody@@QEBAPEBMXZ";

    //
    // get the frames of reference (positions and orientations) of the child m_links
    // (i = 0 to num_links-1)
    //
    getRVector :: (this: *btMultiBody, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getRVector@btMultiBody@@QEBAAEBVbtVector3@@H@Z";
    getParentToLocalRot :: (this: *btMultiBody, i: s32) -> *btQuaternion #cpp_method #foreign bullet3 "?getParentToLocalRot@btMultiBody@@QEBAAEBVbtQuaternion@@H@Z";
    getInterpolateRVector :: (this: *btMultiBody, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getInterpolateRVector@btMultiBody@@QEBAAEBVbtVector3@@H@Z";
    getInterpolateParentToLocalRot :: (this: *btMultiBody, i: s32) -> *btQuaternion #cpp_method #foreign bullet3 "?getInterpolateParentToLocalRot@btMultiBody@@QEBAAEBVbtQuaternion@@H@Z";

    //
    // transform vectors in local frame of link i to world frame (or vice versa)
    //
    localPosToWorld :: (this: *btMultiBody, i: s32, local_pos: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localPosToWorld@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z";
    localPosToWorld :: (this: *btMultiBody, i: s32, local_pos: btVector3) -> btVector3 #no_context {
        return localPosToWorld(this, i, *local_pos);
    }
    localDirToWorld :: (this: *btMultiBody, i: s32, local_dir: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localDirToWorld@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z";
    localDirToWorld :: (this: *btMultiBody, i: s32, local_dir: btVector3) -> btVector3 #no_context {
        return localDirToWorld(this, i, *local_dir);
    }
    worldPosToLocal :: (this: *btMultiBody, i: s32, world_pos: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?worldPosToLocal@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z";
    worldPosToLocal :: (this: *btMultiBody, i: s32, world_pos: btVector3) -> btVector3 #no_context {
        return worldPosToLocal(this, i, *world_pos);
    }
    worldDirToLocal :: (this: *btMultiBody, i: s32, world_dir: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?worldDirToLocal@btMultiBody@@QEBA?AVbtVector3@@HAEBV2@@Z";
    worldDirToLocal :: (this: *btMultiBody, i: s32, world_dir: btVector3) -> btVector3 #no_context {
        return worldDirToLocal(this, i, *world_dir);
    }

    //
    // transform a frame in local coordinate to a frame in world coordinate
    //
    localFrameToWorld :: (this: *btMultiBody, i: s32, local_frame: *btMatrix3x3) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localFrameToWorld@btMultiBody@@QEBA?AVbtMatrix3x3@@HAEBV2@@Z";
    localFrameToWorld :: (this: *btMultiBody, i: s32, local_frame: btMatrix3x3) -> btMatrix3x3 #no_context {
        return localFrameToWorld(this, i, *local_frame);
    }

    //
    // set external forces and torques. Note all external forces/torques are given in the WORLD frame.
    //
    clearForcesAndTorques :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?clearForcesAndTorques@btMultiBody@@QEAAXXZ";
    clearConstraintForces :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?clearConstraintForces@btMultiBody@@QEAAXXZ";

    clearVelocities :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?clearVelocities@btMultiBody@@QEAAXXZ";

    addBaseForce :: (this: *btMultiBody, f: *btVector3) -> void #cpp_method #foreign bullet3 "?addBaseForce@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    addBaseForce :: (this: *btMultiBody, f: btVector3) #no_context {
        addBaseForce(this, *f);
    }

    addBaseTorque :: (this: *btMultiBody, t: *btVector3) -> void #cpp_method #foreign bullet3 "?addBaseTorque@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    addBaseTorque :: (this: *btMultiBody, t: btVector3) #no_context {
        addBaseTorque(this, *t);
    }
    addLinkForce :: (this: *btMultiBody, i: s32, f: *btVector3) -> void #cpp_method #foreign bullet3 "?addLinkForce@btMultiBody@@QEAAXHAEBVbtVector3@@@Z";
    addLinkForce :: (this: *btMultiBody, i: s32, f: btVector3) #no_context {
        addLinkForce(this, i, *f);
    }
    addLinkTorque :: (this: *btMultiBody, i: s32, t: *btVector3) -> void #cpp_method #foreign bullet3 "?addLinkTorque@btMultiBody@@QEAAXHAEBVbtVector3@@@Z";
    addLinkTorque :: (this: *btMultiBody, i: s32, t: btVector3) #no_context {
        addLinkTorque(this, i, *t);
    }

    addBaseConstraintForce :: (this: *btMultiBody, f: *btVector3) -> void #cpp_method #foreign bullet3 "?addBaseConstraintForce@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    addBaseConstraintForce :: (this: *btMultiBody, f: btVector3) #no_context {
        addBaseConstraintForce(this, *f);
    }

    addBaseConstraintTorque :: (this: *btMultiBody, t: *btVector3) -> void #cpp_method #foreign bullet3 "?addBaseConstraintTorque@btMultiBody@@QEAAXAEBVbtVector3@@@Z";
    addBaseConstraintTorque :: (this: *btMultiBody, t: btVector3) #no_context {
        addBaseConstraintTorque(this, *t);
    }
    addLinkConstraintForce :: (this: *btMultiBody, i: s32, f: *btVector3) -> void #cpp_method #foreign bullet3 "?addLinkConstraintForce@btMultiBody@@QEAAXHAEBVbtVector3@@@Z";
    addLinkConstraintForce :: (this: *btMultiBody, i: s32, f: btVector3) #no_context {
        addLinkConstraintForce(this, i, *f);
    }
    addLinkConstraintTorque :: (this: *btMultiBody, i: s32, t: *btVector3) -> void #cpp_method #foreign bullet3 "?addLinkConstraintTorque@btMultiBody@@QEAAXHAEBVbtVector3@@@Z";
    addLinkConstraintTorque :: (this: *btMultiBody, i: s32, t: btVector3) #no_context {
        addLinkConstraintTorque(this, i, *t);
    }

    addJointTorque :: (this: *btMultiBody, i: s32, Q: btScalar) -> void #cpp_method #foreign bullet3 "?addJointTorque@btMultiBody@@QEAAXHM@Z";
    addJointTorqueMultiDof :: (this: *btMultiBody, i: s32, dof: s32, Q: btScalar) -> void #cpp_method #foreign bullet3 "?addJointTorqueMultiDof@btMultiBody@@QEAAXHHM@Z";
    addJointTorqueMultiDof :: (this: *btMultiBody, i: s32, Q: *btScalar) -> void #cpp_method #foreign bullet3 "?addJointTorqueMultiDof@btMultiBody@@QEAAXHPEBM@Z";

    getBaseForce :: (this: *btMultiBody) -> *btVector3 #cpp_method #foreign bullet3 "?getBaseForce@btMultiBody@@QEBAAEBVbtVector3@@XZ";
    getBaseTorque :: (this: *btMultiBody) -> *btVector3 #cpp_method #foreign bullet3 "?getBaseTorque@btMultiBody@@QEBAAEBVbtVector3@@XZ";
    getLinkForce :: (this: *btMultiBody, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getLinkForce@btMultiBody@@QEBAAEBVbtVector3@@H@Z";
    getLinkTorque :: (this: *btMultiBody, i: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getLinkTorque@btMultiBody@@QEBAAEBVbtVector3@@H@Z";
    getJointTorque :: (this: *btMultiBody, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getJointTorque@btMultiBody@@QEBAMH@Z";
    getJointTorqueMultiDof :: (this: *btMultiBody, i: s32) -> *btScalar #cpp_method #foreign bullet3 "?getJointTorqueMultiDof@btMultiBody@@QEAAPEAMH@Z";

    // timestep the velocities (given the external forces/torques set using addBaseForce etc).
    // also sets up caches for calcAccelerationDeltas.
    //
    // Note: the caller must provide three vectors which are used as
    // temporary scratch space. The idea here is to reduce dynamic
    // memory allocation: the same scratch vectors can be re-used
    // again and again for different Multibodies, instead of each
    // btMultiBody allocating (and then deallocating) their own
    // individual scratch buffers. This gives a considerable speed
    // improvement, at least on Windows (where dynamic memory
    // allocation appears to be fairly slow).
    //
    computeAccelerationsArticulatedBodyAlgorithmMultiDof :: (this: *btMultiBody, dt: btScalar, scratch_r: *btAlignedObjectArray(btScalar), scratch_v: *btAlignedObjectArray(btVector3), scratch_m: *btAlignedObjectArray(btMatrix3x3), isConstraintPass: bool, jointFeedbackInWorldSpace: bool, jointFeedbackInJointFrame: bool) -> void #cpp_method #foreign bullet3 "?computeAccelerationsArticulatedBodyAlgorithmMultiDof@btMultiBody@@QEAAXMAEAV?$btAlignedObjectArray@M@@AEAV?$btAlignedObjectArray@VbtVector3@@@@AEAV?$btAlignedObjectArray@VbtMatrix3x3@@@@_N33@Z";

    // calcAccelerationDeltasMultiDof
    // input: force vector (in same format as jacobian, i.e.:
    //                      3 torque values, 3 force values, num_links joint torque values)
    // output: 3 omegadot values, 3 vdot values, num_links q_double_dot values
    // (existing contents of output array are replaced)
    // calcAccelerationDeltasMultiDof must have been called first.
    calcAccelerationDeltasMultiDof :: (this: *btMultiBody, force: *btScalar, output: *btScalar, scratch_r: *btAlignedObjectArray(btScalar), scratch_v: *btAlignedObjectArray(btVector3)) -> void #cpp_method #foreign bullet3 "?calcAccelerationDeltasMultiDof@btMultiBody@@QEBAXPEBMPEAMAEAV?$btAlignedObjectArray@M@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    applyDeltaVeeMultiDof2 :: (this: *btMultiBody, delta_vee: *btScalar, multiplier: btScalar) -> void #cpp_method #foreign bullet3 "?applyDeltaVeeMultiDof2@btMultiBody@@QEAAXPEBMM@Z";

    applyDeltaSplitVeeMultiDof :: (this: *btMultiBody, delta_vee: *btScalar, multiplier: btScalar) -> void #cpp_method #foreign bullet3 "?applyDeltaSplitVeeMultiDof@btMultiBody@@QEAAXPEBMM@Z";

    addSplitV :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?addSplitV@btMultiBody@@QEAAXXZ";

    substractSplitV :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?substractSplitV@btMultiBody@@QEAAXXZ";

    processDeltaVeeMultiDof2 :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?processDeltaVeeMultiDof2@btMultiBody@@QEAAXXZ";

    applyDeltaVeeMultiDof :: (this: *btMultiBody, delta_vee: *btScalar, multiplier: btScalar) -> void #cpp_method #foreign bullet3 "?applyDeltaVeeMultiDof@btMultiBody@@QEAAXPEBMM@Z";

    // timestep the positions (given current velocities).
    stepPositionsMultiDof :: (this: *btMultiBody, dt: btScalar, pq: *btScalar = null, pqd: *btScalar = null) -> void #cpp_method #foreign bullet3 "?stepPositionsMultiDof@btMultiBody@@QEAAXMPEAM0@Z";

    // predict the positions
    predictPositionsMultiDof :: (this: *btMultiBody, dt: btScalar) -> void #cpp_method #foreign bullet3 "?predictPositionsMultiDof@btMultiBody@@QEAAXM@Z";

    // This routine fills out a contact constraint jacobian for this body.
    // the 'normal' supplied must be -n for body1 or +n for body2 of the contact.
    // 'normal' & 'contact_point' are both given in world coordinates.
    fillContactJacobianMultiDof :: (this: *btMultiBody, link: s32, contact_point: *btVector3, normal: *btVector3, jac: *btScalar, scratch_r: *btAlignedObjectArray(btScalar), scratch_v: *btAlignedObjectArray(btVector3), scratch_m: *btAlignedObjectArray(btMatrix3x3)) -> void #cpp_method #foreign bullet3 "?fillContactJacobianMultiDof@btMultiBody@@QEBAXHAEBVbtVector3@@0PEAMAEAV?$btAlignedObjectArray@M@@AEAV?$btAlignedObjectArray@VbtVector3@@@@AEAV?$btAlignedObjectArray@VbtMatrix3x3@@@@@Z";
    fillContactJacobianMultiDof :: (this: *btMultiBody, link: s32, contact_point: btVector3, normal: btVector3, jac: *btScalar, scratch_r: *btAlignedObjectArray(btScalar), scratch_v: *btAlignedObjectArray(btVector3), scratch_m: *btAlignedObjectArray(btMatrix3x3)) #no_context {
        fillContactJacobianMultiDof(this, link, *contact_point, *normal, jac, scratch_r, scratch_v, scratch_m);
    }

    //a more general version of fillContactJacobianMultiDof which does not assume..
    //.. that the constraint in question is contact or, to be more precise, constrains linear velocity only
    fillConstraintJacobianMultiDof :: (this: *btMultiBody, link: s32, contact_point: *btVector3, normal_ang: *btVector3, normal_lin: *btVector3, jac: *btScalar, scratch_r: *btAlignedObjectArray(btScalar), scratch_v: *btAlignedObjectArray(btVector3), scratch_m: *btAlignedObjectArray(btMatrix3x3)) -> void #cpp_method #foreign bullet3 "?fillConstraintJacobianMultiDof@btMultiBody@@QEBAXHAEBVbtVector3@@00PEAMAEAV?$btAlignedObjectArray@M@@AEAV?$btAlignedObjectArray@VbtVector3@@@@AEAV?$btAlignedObjectArray@VbtMatrix3x3@@@@@Z";
    fillConstraintJacobianMultiDof :: (this: *btMultiBody, link: s32, contact_point: btVector3, normal_ang: btVector3, normal_lin: btVector3, jac: *btScalar, scratch_r: *btAlignedObjectArray(btScalar), scratch_v: *btAlignedObjectArray(btVector3), scratch_m: *btAlignedObjectArray(btMatrix3x3)) #no_context {
        fillConstraintJacobianMultiDof(this, link, *contact_point, *normal_ang, *normal_lin, jac, scratch_r, scratch_v, scratch_m);
    }

    //
    // sleeping
    //
    setCanSleep :: (this: *btMultiBody, canSleep: bool) -> void #cpp_method #foreign bullet3 "?setCanSleep@btMultiBody@@QEAAX_N@Z";

    getCanSleep :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?getCanSleep@btMultiBody@@QEBA_NXZ";

    getCanWakeup :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?getCanWakeup@btMultiBody@@QEBA_NXZ";

    setCanWakeup :: (this: *btMultiBody, canWakeup: bool) -> void #cpp_method #foreign bullet3 "?setCanWakeup@btMultiBody@@QEAAX_N@Z";

    isAwake :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?isAwake@btMultiBody@@QEBA_NXZ";

    wakeUp :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?wakeUp@btMultiBody@@QEAAXXZ";
    goToSleep :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?goToSleep@btMultiBody@@QEAAXXZ";
    checkMotionAndSleepIfRequired :: (this: *btMultiBody, timestep: btScalar) -> void #cpp_method #foreign bullet3 "?checkMotionAndSleepIfRequired@btMultiBody@@QEAAXM@Z";

    hasFixedBase :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?hasFixedBase@btMultiBody@@QEBA_NXZ";

    isBaseKinematic :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?isBaseKinematic@btMultiBody@@QEBA_NXZ";

    isBaseStaticOrKinematic :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?isBaseStaticOrKinematic@btMultiBody@@QEBA_NXZ";

    // set the dynamic type in the base's collision flags.
    setBaseDynamicType :: (this: *btMultiBody, dynamicType: s32) -> void #cpp_method #foreign bullet3 "?setBaseDynamicType@btMultiBody@@QEAAXH@Z";

    setFixedBase :: (this: *btMultiBody, fixedBase: bool) -> void #cpp_method #foreign bullet3 "?setFixedBase@btMultiBody@@QEAAX_N@Z";

    getCompanionId :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?getCompanionId@btMultiBody@@QEBAHXZ";

    setCompanionId :: (this: *btMultiBody, id: s32) -> void #cpp_method #foreign bullet3 "?setCompanionId@btMultiBody@@QEAAXH@Z";

    setNumLinks :: (this: *btMultiBody, numLinks: s32) -> void #cpp_method #foreign bullet3 "?setNumLinks@btMultiBody@@QEAAXH@Z";

    getLinearDamping :: (this: *btMultiBody) -> btScalar #cpp_method #foreign bullet3 "?getLinearDamping@btMultiBody@@QEBAMXZ";

    setLinearDamping :: (this: *btMultiBody, damp: btScalar) -> void #cpp_method #foreign bullet3 "?setLinearDamping@btMultiBody@@QEAAXM@Z";

    getAngularDamping :: (this: *btMultiBody) -> btScalar #cpp_method #foreign bullet3 "?getAngularDamping@btMultiBody@@QEBAMXZ";

    setAngularDamping :: (this: *btMultiBody, damp: btScalar) -> void #cpp_method #foreign bullet3 "?setAngularDamping@btMultiBody@@QEAAXM@Z";

    getUseGyroTerm :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?getUseGyroTerm@btMultiBody@@QEBA_NXZ";

    setUseGyroTerm :: (this: *btMultiBody, useGyro: bool) -> void #cpp_method #foreign bullet3 "?setUseGyroTerm@btMultiBody@@QEAAX_N@Z";

    getMaxCoordinateVelocity :: (this: *btMultiBody) -> btScalar #cpp_method #foreign bullet3 "?getMaxCoordinateVelocity@btMultiBody@@QEBAMXZ";

    setMaxCoordinateVelocity :: (this: *btMultiBody, maxVel: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxCoordinateVelocity@btMultiBody@@QEAAXM@Z";

    getMaxAppliedImpulse :: (this: *btMultiBody) -> btScalar #cpp_method #foreign bullet3 "?getMaxAppliedImpulse@btMultiBody@@QEBAMXZ";

    setMaxAppliedImpulse :: (this: *btMultiBody, maxImp: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxAppliedImpulse@btMultiBody@@QEAAXM@Z";

    setHasSelfCollision :: (this: *btMultiBody, hasSelfCollision: bool) -> void #cpp_method #foreign bullet3 "?setHasSelfCollision@btMultiBody@@QEAAX_N@Z";

    hasSelfCollision :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?hasSelfCollision@btMultiBody@@QEBA_NXZ";

    finalizeMultiDof :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBody@@QEAAXXZ";

    useRK4Integration :: (this: *btMultiBody, use: bool) -> void #cpp_method #foreign bullet3 "?useRK4Integration@btMultiBody@@QEAAX_N@Z";
    isUsingRK4Integration :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?isUsingRK4Integration@btMultiBody@@QEBA_NXZ";
    useGlobalVelocities :: (this: *btMultiBody, use: bool) -> void #cpp_method #foreign bullet3 "?useGlobalVelocities@btMultiBody@@QEAAX_N@Z";
    isUsingGlobalVelocities :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?isUsingGlobalVelocities@btMultiBody@@QEBA_NXZ";

    isPosUpdated :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?isPosUpdated@btMultiBody@@QEBA_NXZ";

    setPosUpdated :: (this: *btMultiBody, updated: bool) -> void #cpp_method #foreign bullet3 "?setPosUpdated@btMultiBody@@QEAAX_N@Z";

    //internalNeedsJointFeedback is for internal use only
    internalNeedsJointFeedback :: (this: *btMultiBody) -> bool #cpp_method #foreign bullet3 "?internalNeedsJointFeedback@btMultiBody@@QEBA_NXZ";

    forwardKinematics :: (this: *btMultiBody, world_to_local: *btAlignedObjectArray(btQuaternion), local_origin: *btAlignedObjectArray(btVector3)) -> void #cpp_method #foreign bullet3 "?forwardKinematics@btMultiBody@@QEAAXAEAV?$btAlignedObjectArray@VbtQuaternion@@@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    compTreeLinkVelocities :: (this: *btMultiBody, omega: *btVector3, vel: *btVector3) -> void #cpp_method #foreign bullet3 "?compTreeLinkVelocities@btMultiBody@@QEBAXPEAVbtVector3@@0@Z";

    updateCollisionObjectWorldTransforms :: (this: *btMultiBody, world_to_local: *btAlignedObjectArray(btQuaternion), local_origin: *btAlignedObjectArray(btVector3)) -> void #cpp_method #foreign bullet3 "?updateCollisionObjectWorldTransforms@btMultiBody@@QEAAXAEAV?$btAlignedObjectArray@VbtQuaternion@@@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    updateCollisionObjectInterpolationWorldTransforms :: (this: *btMultiBody, world_to_local: *btAlignedObjectArray(btQuaternion), local_origin: *btAlignedObjectArray(btVector3)) -> void #cpp_method #foreign bullet3 "?updateCollisionObjectInterpolationWorldTransforms@btMultiBody@@QEAAXAEAV?$btAlignedObjectArray@VbtQuaternion@@@@AEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    getBaseName :: (this: *btMultiBody) -> *u8 #cpp_method #foreign bullet3 "?getBaseName@btMultiBody@@QEBAPEBDXZ";

    ///memory of setBaseName needs to be manager by user
    setBaseName :: (this: *btMultiBody, name: *u8) -> void #cpp_method #foreign bullet3 "?setBaseName@btMultiBody@@QEAAXPEBD@Z";

    ///users can point to their objects, userPointer is not used by Bullet
    getUserPointer :: (this: *btMultiBody) -> *void #cpp_method #foreign bullet3 "?getUserPointer@btMultiBody@@QEBAPEAXXZ";

    getUserIndex :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?getUserIndex@btMultiBody@@QEBAHXZ";

    getUserIndex2 :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?getUserIndex2@btMultiBody@@QEBAHXZ";

    ///users can point to their objects, userPointer is not used by Bullet
    setUserPointer :: (this: *btMultiBody, userPointer: *void) -> void #cpp_method #foreign bullet3 "?setUserPointer@btMultiBody@@QEAAXPEAX@Z";

    ///users can point to their objects, userPointer is not used by Bullet
    setUserIndex :: (this: *btMultiBody, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex@btMultiBody@@QEAAXH@Z";

    setUserIndex2 :: (this: *btMultiBody, index: s32) -> void #cpp_method #foreign bullet3 "?setUserIndex2@btMultiBody@@QEAAXH@Z";

    spatialTransform :: (rotation_matrix: *btMatrix3x3, displacement: *btVector3, top_in: *btVector3, bottom_in: *btVector3, top_out: *btVector3, bottom_out: *btVector3) -> void #foreign bullet3 "?spatialTransform@btMultiBody@@SAXAEBVbtMatrix3x3@@AEBVbtVector3@@11AEAV3@2@Z";
    spatialTransform :: (rotation_matrix: btMatrix3x3, displacement: btVector3, top_in: btVector3, bottom_in: btVector3, top_out: *btVector3, bottom_out: *btVector3) #no_context {
        spatialTransform(*rotation_matrix, *displacement, *top_in, *bottom_in, top_out, bottom_out);
    }

    setLinkDynamicType :: (this: *btMultiBody, i: s32, type: s32) -> void #cpp_method #foreign bullet3 "?setLinkDynamicType@btMultiBody@@QEAAXHH@Z";

    isLinkStaticOrKinematic :: (this: *btMultiBody, i: s32) -> bool #cpp_method #foreign bullet3 "?isLinkStaticOrKinematic@btMultiBody@@QEBA_NH@Z";

    isLinkKinematic :: (this: *btMultiBody, i: s32) -> bool #cpp_method #foreign bullet3 "?isLinkKinematic@btMultiBody@@QEBA_NH@Z";

    isLinkAndAllAncestorsStaticOrKinematic :: (this: *btMultiBody, i: s32) -> bool #cpp_method #foreign bullet3 "?isLinkAndAllAncestorsStaticOrKinematic@btMultiBody@@QEBA_NH@Z";

    isLinkAndAllAncestorsKinematic :: (this: *btMultiBody, i: s32) -> bool #cpp_method #foreign bullet3 "?isLinkAndAllAncestorsKinematic@btMultiBody@@QEBA_NH@Z";

    setSleepThreshold :: (this: *btMultiBody, sleepThreshold: btScalar) -> void #cpp_method #foreign bullet3 "?setSleepThreshold@btMultiBody@@QEAAXM@Z";

    setSleepTimeout :: (this: *btMultiBody, sleepTimeout: btScalar) -> void #cpp_method #foreign bullet3 "?setSleepTimeout@btMultiBody@@QEAAXM@Z";

    solveImatrix :: (this: *btMultiBody, rhs_top: *btVector3, rhs_bot: *btVector3, result: *[6] btScalar) -> void #cpp_method #foreign bullet3 "?solveImatrix@btMultiBody@@AEBAXAEBVbtVector3@@0QEAM@Z";
    solveImatrix :: (this: *btMultiBody, rhs_top: btVector3, rhs_bot: btVector3, result: *[6] btScalar) #no_context {
        solveImatrix(this, *rhs_top, *rhs_bot, result);
    }
    solveImatrix :: (this: *btMultiBody, rhs: *btSpatialForceVector, result: *btSpatialMotionVector) -> void #cpp_method #foreign bullet3 "?solveImatrix@btMultiBody@@AEBAXAEBUbtSpatialForceVector@@AEAUbtSpatialMotionVector@@@Z";
    solveImatrix :: (this: *btMultiBody, rhs: btSpatialForceVector, result: *btSpatialMotionVector) #no_context {
        solveImatrix(this, *rhs, result);
    }

    updateLinksDofOffsets :: (this: *btMultiBody) -> void #cpp_method #foreign bullet3 "?updateLinksDofOffsets@btMultiBody@@AEAAXXZ";

    mulMatrix :: (this: *btMultiBody, pA: *btScalar, pB: *btScalar, rowsA: s32, colsA: s32, rowsB: s32, colsB: s32, pC: *btScalar) -> void #cpp_method #foreign bullet3 "?mulMatrix@btMultiBody@@AEBAXPEBM0HHHHPEAM@Z";

    m_baseCollider:                 *btMultiBodyLinkCollider; //can be NULL
    m_baseName:                     *u8; //memory needs to be manager by user!

    m_basePos:                      btVector3; // position of COM of base (world frame)
    m_basePos_interpolate:          btVector3; // position of interpolated COM of base (world frame)
    m_baseQuat:                     btQuaternion; // rotates world points into base frame
    m_baseQuat_interpolate:         btQuaternion;

    m_baseMass:                     btScalar; // mass of the base
    m_baseInertia:                  btVector3; // inertia of the base (in local frame; diagonal)

    m_baseForce:                    btVector3; // external force applied to base. World frame.
    m_baseTorque:                   btVector3; // external torque applied to base. World frame.

    m_baseConstraintForce:          btVector3; // external force applied to base. World frame.
    m_baseConstraintTorque:         btVector3; // external torque applied to base. World frame.

    m_links:                        btAlignedObjectArray(btMultibodyLink); // array of m_links, excluding the base. index from 0 to num_links-1.

    //
    // realBuf:
    //  offset         size            array
    //   0              6 + num_links   v (base_omega; base_vel; joint_vels)					MULTIDOF [sysdof x sysdof for D matrices (TOO MUCH!) + pos_delta which is sys-cfg sized]
    //   6+num_links    num_links       D
    //
    // vectorBuf:
    //  offset         size         array
    //   0              num_links    h_top
    //   num_links      num_links    h_bottom
    //
    // matrixBuf:
    //  offset         size         array
    //   0              num_links+1  rot_from_parent
    //
    m_splitV:                       btAlignedObjectArray(btScalar);
    m_deltaV:                       btAlignedObjectArray(btScalar);
    m_realBuf:                      btAlignedObjectArray(btScalar);
    m_vectorBuf:                    btAlignedObjectArray(btVector3);
    m_matrixBuf:                    btAlignedObjectArray(btMatrix3x3);

    m_cachedInertiaTopLeft:         btMatrix3x3;
    m_cachedInertiaTopRight:        btMatrix3x3;
    m_cachedInertiaLowerLeft:       btMatrix3x3;
    m_cachedInertiaLowerRight:      btMatrix3x3;
    m_cachedInertiaValid:           bool;

    m_fixedBase:                    bool;

    // Sleep parameters.
    m_awake:                        bool;
    m_canSleep:                     bool;
    m_canWakeup:                    bool;
    m_sleepTimer:                   btScalar;
    m_sleepEpsilon:                 btScalar;
    m_sleepTimeout:                 btScalar;

    m_userObjectPointer:            *void;
    m_userIndex2:                   s32;
    m_userIndex:                    s32;

    m_companionId:                  s32;
    m_linearDamping:                btScalar;
    m_angularDamping:               btScalar;
    m_useGyroTerm:                  bool;
    m_maxAppliedImpulse:            btScalar;
    m_maxCoordinateVelocity:        btScalar;
    m_hasSelfCollision:             bool;

    __posUpdated:                   bool;
    m_dofCount:                     s32;
    m_posVarCnt:                    s32;

    m_useRK4:                       bool;
    m_useGlobalVelocities:          bool;

    ///the m_needsJointFeedback gets updated/computed during the stepVelocitiesMultiDof and it for internal usage only
    m_internalNeedsJointFeedback:   bool;

    //If enabled, calculate the velocity based on kinematic transform changes. Currently only implemented for the base.
    m_kinematic_calculate_velocity: bool;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBody@@UEAA@XZ";

    virtual_calculateSerializeBufferSize :: (this: *btMultiBody) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btMultiBody@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btMultiBody, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btMultiBody@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btMultiBody_VTable :: struct #type_info_none {
    Destructor: (this: *btMultiBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    calculateSerializeBufferSize: (this: *btMultiBody) -> s32 #cpp_method;

    serialize: (this: *btMultiBody, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method;
}

btMultiBody_Destructor :: inline (this: *btMultiBody, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btMultiBody_calculateSerializeBufferSize :: inline (this: *btMultiBody) -> s32 { return this.vtable.calculateSerializeBufferSize(this); }

btMultiBody_serialize :: inline (this: *btMultiBody, dataBuffer: *void, serializer: *btSerializer) -> *u8 { return this.vtable.serialize(this, dataBuffer, serializer); }




btMultiBodyLinkDoubleData :: struct {
    m_zeroRotParentToThis:        btQuaternionDoubleData;
    m_parentComToThisPivotOffset: btVector3DoubleData;
    m_thisPivotToThisComOffset:   btVector3DoubleData;
    m_jointAxisTop:               [6] btVector3DoubleData;
    m_jointAxisBottom:            [6] btVector3DoubleData;

    m_linkInertia:                btVector3DoubleData; // inertia of the base (in local frame; diagonal)
    m_absFrameTotVelocityTop:     btVector3DoubleData;
    m_absFrameTotVelocityBottom:  btVector3DoubleData;
    m_absFrameLocVelocityTop:     btVector3DoubleData;
    m_absFrameLocVelocityBottom:  btVector3DoubleData;

    m_linkMass:                   float64;
    m_parentIndex:                s32;
    m_jointType:                  s32;

    m_dofCount:                   s32;
    m_posVarCount:                s32;
    m_jointPos:                   [7] float64;
    m_jointVel:                   [6] float64;
    m_jointTorque:                [6] float64;

    m_jointDamping:               float64;
    m_jointFriction:              float64;
    m_jointLowerLimit:            float64;
    m_jointUpperLimit:            float64;
    m_jointMaxForce:              float64;
    m_jointMaxVelocity:           float64;

    m_linkName:                   *u8;
    m_jointName:                  *u8;
    m_linkCollider:               *btCollisionObjectDoubleData;
    m_paddingPtr:                 *u8;
}

btMultiBodyLinkFloatData :: struct {
    m_zeroRotParentToThis:        btQuaternionFloatData;
    m_parentComToThisPivotOffset: btVector3FloatData;
    m_thisPivotToThisComOffset:   btVector3FloatData;
    m_jointAxisTop:               [6] btVector3FloatData;
    m_jointAxisBottom:            [6] btVector3FloatData;
    m_linkInertia:                btVector3FloatData; // inertia of the base (in local frame; diagonal)
    m_absFrameTotVelocityTop:     btVector3FloatData;
    m_absFrameTotVelocityBottom:  btVector3FloatData;
    m_absFrameLocVelocityTop:     btVector3FloatData;
    m_absFrameLocVelocityBottom:  btVector3FloatData;

    m_dofCount:                   s32;
    m_linkMass:                   float;
    m_parentIndex:                s32;
    m_jointType:                  s32;

    m_jointPos:                   [7] float;
    m_jointVel:                   [6] float;
    m_jointTorque:                [6] float;
    m_posVarCount:                s32;
    m_jointDamping:               float;
    m_jointFriction:              float;
    m_jointLowerLimit:            float;
    m_jointUpperLimit:            float;
    m_jointMaxForce:              float;
    m_jointMaxVelocity:           float;

    m_linkName:                   *u8;
    m_jointName:                  *u8;
    m_linkCollider:               *btCollisionObjectFloatData;
    m_paddingPtr:                 *u8;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btMultiBodyDoubleData :: struct {
    m_baseWorldPosition:    btVector3DoubleData;
    m_baseWorldOrientation: btQuaternionDoubleData;
    m_baseLinearVelocity:   btVector3DoubleData;
    m_baseAngularVelocity:  btVector3DoubleData;
    m_baseInertia:          btVector3DoubleData; // inertia of the base (in local frame; diagonal)
    m_baseMass:             float64;
    m_numLinks:             s32;
    m_padding:              [4] u8;

    m_baseName:             *u8;
    m_links:                *btMultiBodyLinkDoubleData;
    m_baseCollider:         *btCollisionObjectDoubleData;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btMultiBodyFloatData :: struct {
    m_baseWorldPosition:    btVector3FloatData;
    m_baseWorldOrientation: btQuaternionFloatData;
    m_baseLinearVelocity:   btVector3FloatData;
    m_baseAngularVelocity:  btVector3FloatData;

    m_baseInertia:          btVector3FloatData; // inertia of the base (in local frame; diagonal)
    m_baseMass:             float;
    m_numLinks:             s32;

    m_baseName:             *u8;
    m_links:                *btMultiBodyLinkFloatData;
    m_baseCollider:         *btCollisionObjectFloatData;
}

btMultiBodyLinkCollider :: struct {
    #as using btcollisionobject: btCollisionObject;

    //protected:
    m_multiBody: *btMultiBody;
    m_link:      s32;

    Constructor :: (this: *btMultiBodyLinkCollider, multiBody: *btMultiBody, link: s32) -> void #cpp_method #foreign bullet3 "??0btMultiBodyLinkCollider@@QEAA@PEAVbtMultiBody@@H@Z";

    upcast :: (colObj: *btCollisionObject) -> *btMultiBodyLinkCollider #foreign bullet3 "?upcast@btMultiBodyLinkCollider@@SAPEAV1@PEAVbtCollisionObject@@@Z";

    upcast_1 :: (colObj: /*const*/ *btCollisionObject) -> *btMultiBodyLinkCollider #foreign bullet3 "?upcast@btMultiBodyLinkCollider@@SAPEBV1@PEBVbtCollisionObject@@@Z";

    isStaticOrKinematic :: (this: *btMultiBodyLinkCollider) -> bool #cpp_method #foreign bullet3 "?isStaticOrKinematic@btMultiBodyLinkCollider@@QEBA_NXZ";

    isKinematic :: (this: *btMultiBodyLinkCollider) -> bool #cpp_method #foreign bullet3 "?isKinematic@btMultiBodyLinkCollider@@QEBA_NXZ";

    setDynamicType :: (this: *btMultiBodyLinkCollider, dynamicType: s32) -> void #cpp_method #foreign bullet3 "?setDynamicType@btMultiBodyLinkCollider@@QEAAXH@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodyLinkCollider, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyLinkCollider@@UEAA@XZ";

    virtual_checkCollideWithOverride :: (this: *btMultiBodyLinkCollider, co: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?checkCollideWithOverride@btMultiBodyLinkCollider@@UEBA_NPEBVbtCollisionObject@@@Z";

    // clang-format on
    virtual_calculateSerializeBufferSize :: (this: *btMultiBodyLinkCollider) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btMultiBodyLinkCollider@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btMultiBodyLinkCollider, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btMultiBodyLinkCollider@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}

// clang-format off
btMultiBodyLinkColliderFloatData :: struct {
    m_colObjData: btCollisionObjectFloatData;
    m_multiBody:  *btMultiBodyFloatData;
    m_link:       s32;
    m_padding:    [4] u8;
}

btMultiBodyLinkColliderDoubleData :: struct {
    m_colObjData: btCollisionObjectDoubleData;
    m_multiBody:  *btMultiBodyDoubleData;
    m_link:       s32;
    m_padding:    [4] u8;
}

//Don't change any of the existing enum values, so add enum types at the end for serialization compatibility
btTypedMultiBodyConstraintType :: enum s32 {
    ULTIBODY_CONSTRAINT_LIMIT            :: 3;
    ULTIBODY_CONSTRAINT_1DOF_JOINT_MOTOR :: 4;
    ULTIBODY_CONSTRAINT_GEAR             :: 5;
    ULTIBODY_CONSTRAINT_POINT_TO_POINT   :: 6;
    ULTIBODY_CONSTRAINT_SLIDER           :: 7;
    ULTIBODY_CONSTRAINT_SPHERICAL_MOTOR  :: 8;
    ULTIBODY_CONSTRAINT_FIXED            :: 9;
    ULTIBODY_CONSTRAINT_SPHERICAL_LIMIT  :: 10;
    AX_MULTIBODY_CONSTRAINT_TYPE         :: 11;

    MULTIBODY_CONSTRAINT_LIMIT            :: ULTIBODY_CONSTRAINT_LIMIT;
    MULTIBODY_CONSTRAINT_1DOF_JOINT_MOTOR :: ULTIBODY_CONSTRAINT_1DOF_JOINT_MOTOR;
    MULTIBODY_CONSTRAINT_GEAR             :: ULTIBODY_CONSTRAINT_GEAR;
    MULTIBODY_CONSTRAINT_POINT_TO_POINT   :: ULTIBODY_CONSTRAINT_POINT_TO_POINT;
    MULTIBODY_CONSTRAINT_SLIDER           :: ULTIBODY_CONSTRAINT_SLIDER;
    MULTIBODY_CONSTRAINT_SPHERICAL_MOTOR  :: ULTIBODY_CONSTRAINT_SPHERICAL_MOTOR;
    MULTIBODY_CONSTRAINT_FIXED            :: ULTIBODY_CONSTRAINT_FIXED;
    MULTIBODY_CONSTRAINT_SPHERICAL_LIMIT  :: ULTIBODY_CONSTRAINT_SPHERICAL_LIMIT;
    MAX_MULTIBODY_CONSTRAINT_TYPE         :: AX_MULTIBODY_CONSTRAINT_TYPE;
}

btSolverInfo :: struct {}

///1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
btMultiBodySolverConstraint :: struct {
    Constructor :: (this: *btMultiBodySolverConstraint) -> void #cpp_method #foreign bullet3 "??0btMultiBodySolverConstraint@@QEAA@XZ";

    m_deltaVelAindex:              s32; //more generic version of m_relpos1CrossNormal/m_contactNormal1
    m_jacAindex:                   s32;
    m_deltaVelBindex:              s32;
    m_jacBindex:                   s32;

    m_relpos1CrossNormal:          btVector3;
    m_contactNormal1:              btVector3;
    m_relpos2CrossNormal:          btVector3;
    m_contactNormal2:              btVector3; //usually m_contactNormal2 == -m_contactNormal1, but not always

    m_angularComponentA:           btVector3;
    m_angularComponentB:           btVector3;

    m_appliedPushImpulse:          btScalar;
    m_appliedImpulse:              btScalar;

    m_friction:                    btScalar;
    m_jacDiagABInv:                btScalar;
    m_rhs:                         btScalar;
    m_cfm:                         btScalar;

    m_lowerLimit:                  btScalar;
    m_upperLimit:                  btScalar;
    m_rhsPenetration:              btScalar;
    union {
        m_originalContactPoint: *void;
        m_unusedPadding4:       btScalar;
    }

    m_overrideNumSolverIterations: s32;
    m_frictionIndex:               s32;

    m_solverBodyIdA:               s32;
    m_multiBodyA:                  *btMultiBody;
    m_linkA:                       s32;

    m_solverBodyIdB:               s32;
    m_multiBodyB:                  *btMultiBody;
    m_linkB:                       s32;

    //for writing back applied impulses
    m_orgConstraint:               *btMultiBodyConstraint;
    m_orgDofIndex:                 s32;

    btSolverConstraintType :: enum s32 {
        CONTACT_1D  :: 0;
        FRICTION_1D :: 1;

        BT_SOLVER_CONTACT_1D  :: CONTACT_1D;
        BT_SOLVER_FRICTION_1D :: FRICTION_1D;
    }
}


btMultiBodyConstraintArray :: btAlignedObjectArray(btMultiBodySolverConstraint);

btMultiBodyJacobianData :: struct {
    m_jacobians:                  btAlignedObjectArray(btScalar);
    m_deltaVelocitiesUnitImpulse: btAlignedObjectArray(btScalar); //holds the joint-space response of the corresp. tree to the test impulse in each constraint space dimension
    m_deltaVelocities:            btAlignedObjectArray(btScalar); //holds joint-space vectors of all the constrained trees accumulating the effect of corrective impulses applied in SI
    scratch_r:                    btAlignedObjectArray(btScalar);
    scratch_v:                    btAlignedObjectArray(btVector3);
    scratch_m:                    btAlignedObjectArray(btMatrix3x3);
    m_solverBodyPool:             *btAlignedObjectArray(btSolverBody);
    m_fixedBodyId:                s32;
}

btMultiBodyConstraint :: struct {
    vtable: *btMultiBodyConstraint_VTable;
    m_bodyA:             *btMultiBody;
    m_bodyB:             *btMultiBody;
    m_linkA:             s32;
    m_linkB:             s32;

    m_type:              s32; //btTypedMultiBodyConstraintType

    m_numRows:           s32;
    m_jacSizeA:          s32;
    m_jacSizeBoth:       s32;
    m_posOffset:         s32;

    m_isUnilateral:      bool;
    m_numDofsFinalized:  s32;
    m_maxAppliedImpulse: btScalar;

    // warning: the data block lay out is not consistent for all constraints
    // data block laid out as follows:
    // cached impulses. (one per row.)
    // jacobians. (interleaved, row1 body1 then row1 body2 then row2 body 1 etc)
    // positions. (one per row.)
    m_data:              btAlignedObjectArray(btScalar);

    applyDeltaVee :: (this: *btMultiBodyConstraint, data: *btMultiBodyJacobianData, delta_vee: *btScalar, impulse: btScalar, velocityIndex: s32, ndof: s32) -> void #cpp_method #foreign bullet3 "?applyDeltaVee@btMultiBodyConstraint@@IEAAXAEAUbtMultiBodyJacobianData@@PEAMMHH@Z";

    fillMultiBodyConstraint :: (this: *btMultiBodyConstraint, solverConstraint: *btMultiBodySolverConstraint, data: *btMultiBodyJacobianData, jacOrgA: *btScalar, jacOrgB: *btScalar, constraintNormalAng: *btVector3, constraintNormalLin: *btVector3, posAworld: *btVector3, posBworld: *btVector3, posError: btScalar, infoGlobal: *btContactSolverInfo, lowerLimit: btScalar, upperLimit: btScalar, angConstraint := false, relaxation: btScalar = 1.0, isFriction := false, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0, damping: btScalar = 1.0) -> btScalar #cpp_method #foreign bullet3 "?fillMultiBodyConstraint@btMultiBodyConstraint@@IEAAMAEAUbtMultiBodySolverConstraint@@AEAUbtMultiBodyJacobianData@@PEAM2AEBVbtVector3@@333MAEBUbtContactSolverInfo@@MM_NM5MMM@Z";
    fillMultiBodyConstraint :: (this: *btMultiBodyConstraint, solverConstraint: *btMultiBodySolverConstraint, data: *btMultiBodyJacobianData, jacOrgA: *btScalar, jacOrgB: *btScalar, constraintNormalAng: btVector3, constraintNormalLin: btVector3, posAworld: btVector3, posBworld: btVector3, posError: btScalar, infoGlobal: btContactSolverInfo, lowerLimit: btScalar, upperLimit: btScalar, angConstraint := false, relaxation: btScalar = 1.0, isFriction := false, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0, damping: btScalar = 1.0) -> btScalar #no_context {
        return fillMultiBodyConstraint(this, solverConstraint, data, jacOrgA, jacOrgB, *constraintNormalAng, *constraintNormalLin, *posAworld, *posBworld, posError, *infoGlobal, lowerLimit, upperLimit, angConstraint, relaxation, isFriction, desiredVelocity, cfmSlip, damping);
    }

    Constructor :: (this: *btMultiBodyConstraint, bodyA: *btMultiBody, bodyB: *btMultiBody, linkA: s32, linkB: s32, numRows: s32, isUnilateral: bool, type: s32) -> void #cpp_method #foreign bullet3 "??0btMultiBodyConstraint@@QEAA@PEAVbtMultiBody@@0HHH_NH@Z";

    updateJacobianSizes :: (this: *btMultiBodyConstraint) -> void #cpp_method #foreign bullet3 "?updateJacobianSizes@btMultiBodyConstraint@@QEAAXXZ";
    allocateJacobiansMultiDof :: (this: *btMultiBodyConstraint) -> void #cpp_method #foreign bullet3 "?allocateJacobiansMultiDof@btMultiBodyConstraint@@QEAAXXZ";

    getConstraintType :: (this: *btMultiBodyConstraint) -> s32 #cpp_method #foreign bullet3 "?getConstraintType@btMultiBodyConstraint@@QEBAHXZ";

    getNumRows :: (this: *btMultiBodyConstraint) -> s32 #cpp_method #foreign bullet3 "?getNumRows@btMultiBodyConstraint@@QEBAHXZ";

    getMultiBodyA :: (this: *btMultiBodyConstraint) -> *btMultiBody #cpp_method #foreign bullet3 "?getMultiBodyA@btMultiBodyConstraint@@QEAAPEAVbtMultiBody@@XZ";

    getMultiBodyB :: (this: *btMultiBodyConstraint) -> *btMultiBody #cpp_method #foreign bullet3 "?getMultiBodyB@btMultiBodyConstraint@@QEAAPEAVbtMultiBody@@XZ";

    getLinkA :: (this: *btMultiBodyConstraint) -> s32 #cpp_method #foreign bullet3 "?getLinkA@btMultiBodyConstraint@@QEBAHXZ";

    getLinkB :: (this: *btMultiBodyConstraint) -> s32 #cpp_method #foreign bullet3 "?getLinkB@btMultiBodyConstraint@@QEBAHXZ";

    internalSetAppliedImpulse :: (this: *btMultiBodyConstraint, dof: s32, appliedImpulse: btScalar) -> void #cpp_method #foreign bullet3 "?internalSetAppliedImpulse@btMultiBodyConstraint@@QEAAXHM@Z";

    getAppliedImpulse :: (this: *btMultiBodyConstraint, dof: s32) -> btScalar #cpp_method #foreign bullet3 "?getAppliedImpulse@btMultiBodyConstraint@@QEAAMH@Z";

    // current constraint position
    // constraint is pos >= 0 for unilateral, or pos = 0 for bilateral
    // NOTE: ignored position for friction rows.
    getPosition :: (this: *btMultiBodyConstraint, row: s32) -> btScalar #cpp_method #foreign bullet3 "?getPosition@btMultiBodyConstraint@@QEBAMH@Z";

    setPosition :: (this: *btMultiBodyConstraint, row: s32, pos: btScalar) -> void #cpp_method #foreign bullet3 "?setPosition@btMultiBodyConstraint@@QEAAXHM@Z";

    isUnilateral :: (this: *btMultiBodyConstraint) -> bool #cpp_method #foreign bullet3 "?isUnilateral@btMultiBodyConstraint@@QEBA_NXZ";

    // jacobian blocks.
    // each of size 6 + num_links. (jacobian2 is null if no body2.)
    // format: 3 'omega' coefficients, 3 'v' coefficients, then the 'qdot' coefficients.
    jacobianA :: (this: *btMultiBodyConstraint, row: s32) -> *btScalar #cpp_method #foreign bullet3 "?jacobianA@btMultiBodyConstraint@@QEAAPEAMH@Z";

    jacobianA_1 :: (this: /*const*/ *btMultiBodyConstraint, row: s32) -> *btScalar #cpp_method #foreign bullet3 "?jacobianA@btMultiBodyConstraint@@QEBAPEBMH@Z";

    jacobianB :: (this: *btMultiBodyConstraint, row: s32) -> *btScalar #cpp_method #foreign bullet3 "?jacobianB@btMultiBodyConstraint@@QEAAPEAMH@Z";

    jacobianB_1 :: (this: /*const*/ *btMultiBodyConstraint, row: s32) -> *btScalar #cpp_method #foreign bullet3 "?jacobianB@btMultiBodyConstraint@@QEBAPEBMH@Z";

    getMaxAppliedImpulse :: (this: *btMultiBodyConstraint) -> btScalar #cpp_method #foreign bullet3 "?getMaxAppliedImpulse@btMultiBodyConstraint@@QEBAMXZ";

    setMaxAppliedImpulse :: (this: *btMultiBodyConstraint, maxImp: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxAppliedImpulse@btMultiBodyConstraint@@QEAAXM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodyConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyConstraint@@UEAA@XZ";

    //many constraints have setFrameInB/setPivotInB. Will use 'getConstraintType' later.
    virtual_setFrameInB :: (this: *btMultiBodyConstraint, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInB@btMultiBodyConstraint@@UEAAXAEBVbtMatrix3x3@@@Z";
    virtual_setPivotInB :: (this: *btMultiBodyConstraint, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInB@btMultiBodyConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_setGearRatio :: (this: *btMultiBodyConstraint, ratio: btScalar) -> void #cpp_method #foreign bullet3 "?setGearRatio@btMultiBodyConstraint@@UEAAXM@Z";
    virtual_setGearAuxLink :: (this: *btMultiBodyConstraint, gearAuxLink: s32) -> void #cpp_method #foreign bullet3 "?setGearAuxLink@btMultiBodyConstraint@@UEAAXH@Z";
    virtual_setRelativePositionTarget :: (this: *btMultiBodyConstraint, relPosTarget: btScalar) -> void #cpp_method #foreign bullet3 "?setRelativePositionTarget@btMultiBodyConstraint@@UEAAXM@Z";
    virtual_setErp :: (this: *btMultiBodyConstraint, erp: btScalar) -> void #cpp_method #foreign bullet3 "?setErp@btMultiBodyConstraint@@UEAAXM@Z";
}
btMultiBodyConstraint_VTable :: struct #type_info_none {
    Destructor: (this: *btMultiBodyConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    setFrameInB: (this: *btMultiBodyConstraint, frameInB: *btMatrix3x3) -> void #cpp_method;
    setPivotInB: (this: *btMultiBodyConstraint, pivotInB: *btVector3) -> void #cpp_method;

    finalizeMultiDof: (this: *btMultiBodyConstraint) -> void #cpp_method;

    getIslandIdA: (this: *btMultiBodyConstraint) -> s32 #cpp_method;
    getIslandIdB: (this: *btMultiBodyConstraint) -> s32 #cpp_method;

    createConstraintRows: (this: *btMultiBodyConstraint, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    debugDraw: (this: *btMultiBodyConstraint, drawer: *btIDebugDraw) -> void #cpp_method;

    setGearRatio: (this: *btMultiBodyConstraint, ratio: btScalar) -> void #cpp_method;
    setGearAuxLink: (this: *btMultiBodyConstraint, gearAuxLink: s32) -> void #cpp_method;
    setRelativePositionTarget: (this: *btMultiBodyConstraint, relPosTarget: btScalar) -> void #cpp_method;
    setErp: (this: *btMultiBodyConstraint, erp: btScalar) -> void #cpp_method;
}

btMultiBodyConstraint_Destructor :: inline (this: *btMultiBodyConstraint, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btMultiBodyConstraint_setFrameInB :: inline (this: *btMultiBodyConstraint, frameInB: *btMatrix3x3) { this.vtable.setFrameInB(this, frameInB); }
btMultiBodyConstraint_setPivotInB :: inline (this: *btMultiBodyConstraint, pivotInB: *btVector3) { this.vtable.setPivotInB(this, pivotInB); }

btMultiBodyConstraint_finalizeMultiDof :: inline (this: *btMultiBodyConstraint) { this.vtable.finalizeMultiDof(this); }

btMultiBodyConstraint_getIslandIdA :: inline (this: *btMultiBodyConstraint) -> s32 { return this.vtable.getIslandIdA(this); }
btMultiBodyConstraint_getIslandIdB :: inline (this: *btMultiBodyConstraint) -> s32 { return this.vtable.getIslandIdB(this); }

btMultiBodyConstraint_createConstraintRows :: inline (this: *btMultiBodyConstraint, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) { this.vtable.createConstraintRows(this, constraintRows, data, infoGlobal); }

btMultiBodyConstraint_debugDraw :: inline (this: *btMultiBodyConstraint, drawer: *btIDebugDraw) { this.vtable.debugDraw(this, drawer); }

btMultiBodyConstraint_setGearRatio :: inline (this: *btMultiBodyConstraint, ratio: btScalar) { this.vtable.setGearRatio(this, ratio); }
btMultiBodyConstraint_setGearAuxLink :: inline (this: *btMultiBodyConstraint, gearAuxLink: s32) { this.vtable.setGearAuxLink(this, gearAuxLink); }
btMultiBodyConstraint_setRelativePositionTarget :: inline (this: *btMultiBodyConstraint, relPosTarget: btScalar) { this.vtable.setRelativePositionTarget(this, relPosTarget); }
btMultiBodyConstraint_setErp :: inline (this: *btMultiBodyConstraint, erp: btScalar) { this.vtable.setErp(this, erp); }




/* btSoftBodyWorldInfo	*/
btSoftBodyWorldInfo :: struct {
    air_density:       btScalar;
    water_density:     btScalar;
    water_offset:      btScalar;
    m_maxDisplacement: btScalar;
    water_normal:      btVector3;
    m_broadphase:      *btBroadphaseInterface;
    m_dispatcher:      *btDispatcher;
    m_gravity:         btVector3;
    m_sparsesdf:       btSparseSdf(UnknownTemplateArgumentPlaceholder) = 3;

    Constructor :: (this: *btSoftBodyWorldInfo) -> void #cpp_method #foreign bullet3 "??0btSoftBodyWorldInfo@@QEAA@XZ";
}

///The btSoftBody is an class to simulate cloth and volumetric soft bodies.
///There is two-way interaction between btSoftBody and btRigidBody/btCollisionObject.
btSoftBody :: struct {
    #as using btcollisionobject: btCollisionObject;

    m_collisionDisabledObjects:        btAlignedObjectArray(*btCollisionObject);

    // The solver object that handles this soft body
    m_softBodySolver:                  *btSoftBodySolver;

    ///eAeroModel
    eAeroModel :: struct {
        _ :: enum s32 {
            V_Point            :: 0;
            V_TwoSided         :: 1;
            V_TwoSidedLiftDrag :: 2;
            V_OneSided         :: 3;
            F_TwoSided         :: 4;
            F_TwoSidedLiftDrag :: 5;
            F_OneSided         :: 6;
            END                :: 7;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    ///eVSolver : velocities solvers
    eVSolver :: struct {
        _ :: enum s32 {
            Linear :: 0;
            END    :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    ///ePSolver : positions solvers
    ePSolver :: struct {
        _ :: enum s32 {
            Linear    :: 0;
            Anchors   :: 1;
            RContacts :: 2;
            SContacts :: 3;
            END       :: 4;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    ///eSolverPresets
    eSolverPresets :: struct {
        _ :: enum s32 {
            Positions  :: 0;
            Velocities :: 1;
            Default    :: 0;
            END        :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    ///eFeature
    eFeature :: struct {
        _ :: enum s32 {
            None  :: 0;
            Node  :: 1;
            Link  :: 2;
            Face  :: 3;
            Tetra :: 4;
            END   :: 5;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    tVSolverArray :: btAlignedObjectArray(eVSolver._);
    tPSolverArray :: btAlignedObjectArray(ePSolver._);

    ///fCollision
    fCollision :: struct {
        _ :: enum s32 {
            RVSmask  :: 15;
            SDF_RS   :: 1;
            CL_RS    :: 2;
            SDF_RD   :: 4;

            SVSmask  :: 240;
            VF_SS    :: 16;
            CL_SS    :: 32;
            CL_SELF  :: 64;
            VF_DD    :: 128;

            RVDFmask :: 3840;
            SDF_RDF  :: 256;
            SDF_MDF  :: 512;
            SDF_RDN  :: 1024;

            Default  :: 1;
            END      :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    ///fMaterial
    fMaterial :: struct {
        _ :: enum s32 {
            DebugDraw :: 1;

            Default   :: 1;
            END       :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /* sRayCast		*/
    sRayCast :: struct {
        body:     *btSoftBody;
        /// soft body
        feature:  eFeature._;
        /// feature type
        index:    s32;
        /// feature index
        fraction: btScalar;
    }

    /* ImplicitFn	*/
    ImplicitFn :: struct {
        vtable: *ImplicitFn_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *ImplicitFn, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1ImplicitFn@btSoftBody@@UEAA@XZ";
    }
    ImplicitFn_VTable :: struct #type_info_none {
        Destructor: (this: *ImplicitFn, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        Eval: (this: *ImplicitFn, x: *btVector3) -> btScalar #cpp_method;
    }

    ImplicitFn_Destructor :: inline (this: *ImplicitFn, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    ImplicitFn_Eval :: inline (this: *ImplicitFn, x: *btVector3) -> btScalar { return this.vtable.Eval(this, x); }



    //
    // Internal types
    //
    tScalarArray :: btAlignedObjectArray(btScalar);
    tVector3Array :: btAlignedObjectArray(btVector3);

    /* sCti is Softbody contact info	*/
    sCti :: struct {
        m_colObj: *btCollisionObject; /* Rigid body			*/
        m_normal: btVector3; /* Outward normal		*/
        m_offset: btScalar; /* Offset from origin	*/
        m_bary:   btVector3; /* Barycentric weights for faces */
    }

    /* sMedium		*/
    sMedium :: struct {
        m_velocity: btVector3; /* Velocity				*/
        m_pressure: btScalar; /* Pressure				*/
        m_density:  btScalar; /* Density				*/
    }

    /* Base type	*/
    Element :: struct {
        m_tag: *void; // User data
        Constructor :: (this: *Element) -> void #cpp_method #foreign bullet3 "??0Element@btSoftBody@@QEAA@XZ";
    }

    /* Material		*/
    Material :: struct {
        #as using element: Element;

        m_kLST:  btScalar; // Linear stiffness coefficient [0,1]
        m_kAST:  btScalar; // Area/Angular stiffness coefficient [0,1]
        m_kVST:  btScalar; // Volume stiffness coefficient [0,1]
        m_flags: s32; // Flags
    }

    /* Feature		*/
    Feature :: struct {
        #as using element: Element;

        m_material: *Material; // Material
    }

    /* Node			*/
    RenderNode :: struct {
        m_x:      btVector3;
        m_uv1:    btVector3;
        m_normal: btVector3;
    }

    Node :: struct {
        #as using feature: Feature;

        m_x:                 btVector3; // Position
        m_q:                 btVector3; // Previous step position/Test position
        m_v:                 btVector3; // Velocity
        m_vn:                btVector3; // Previous step velocity
        m_f:                 btVector3; // Force accumulator
        m_n:                 btVector3; // Normal
        m_im:                btScalar; // 1/mass
        m_area:              btScalar; // Area
        m_leaf:              *btDbvtNode; // Leaf data
        m_constrained:       s32; // depth of penetration
        m_battach:           s32; // Attached
        index:               s32;
        m_splitv:            btVector3 #align 8; // velocity associated with split impulse
        m_effectiveMass:     btMatrix3x3; // effective mass in contact
        m_effectiveMass_inv: btMatrix3x3; // inverse of effective mass
    }

    /* Link			*/
    Link :: struct {
        #as using feature: Feature;

        m_c3:       btVector3; // gradient
        m_n:        [2] *Node; // Node pointers
        m_rl:       btScalar; // Rest length
        m_bbending: s32; // Bending link
        m_c0:       btScalar; // (ima+imb)*kLST
        m_c1:       btScalar; // rl^2
        m_c2:       btScalar; // |gradient|^2/c0
    }

    RenderFace :: struct {
        m_n: [3] *RenderNode; // Node pointers
    }

    /* Face			*/
    Face :: struct {
        #as using feature: Feature;

        m_n:        [3] *Node; // Node pointers
        m_normal:   btVector3; // Normal
        m_ra:       btScalar; // Rest area
        m_leaf:     *btDbvtNode; // Leaf data
        m_pcontact: btVector4; // barycentric weights of the persistent contact
        m_n0:       btVector3;
        m_n1:       btVector3;
        m_vn:       btVector3;
        m_index:    s32;
    }

    /* Tetra		*/
    Tetra :: struct {
        #as using feature: Feature;

        m_n:               [4] *Node; // Node pointers
        m_rv:              btScalar; // Rest volume
        m_leaf:            *btDbvtNode; // Leaf data
        m_c0:              [4] btVector3; // gradients
        m_c1:              btScalar; // (4*kVST)/(im0+im1+im2+im3)
        m_c2:              btScalar; // m_c1/sum(|g0..3|^2)
        m_Dm_inverse:      btMatrix3x3; // rest Dm^-1
        m_F:               btMatrix3x3;
        m_element_measure: btScalar;
        m_P_inv:           [3] btVector4; // first three columns of P_inv matrix
    }

    /*  TetraScratch  */
    TetraScratch :: struct {
        m_F:          btMatrix3x3; // deformation gradient F
        m_trace:      btScalar; // trace of F^T * F
        m_J:          btScalar; // det(F)
        m_cofF:       btMatrix3x3; // cofactor of F
        m_corotation: btMatrix3x3; // corotatio of the tetra
    }

    /* RContact		*/
    RContact :: struct {
        m_cti:               sCti; // Contact infos
        m_node:              *Node; // Owner node
        m_c0:                btMatrix3x3; // Impulse matrix
        m_c1:                btVector3; // Relative anchor
        m_c2:                btScalar; // ima*dt
        m_c3:                btScalar; // Friction
        m_c4:                btScalar; // Hardness

        // jacobians and unit impulse responses for multibody
        jacobianData_normal: btMultiBodyJacobianData;
        jacobianData_t1:     btMultiBodyJacobianData;
        jacobianData_t2:     btMultiBodyJacobianData;
        t1:                  btVector3;
        t2:                  btVector3;
    }

    DeformableRigidContact :: struct {
        m_cti:               sCti; // Contact infos
        m_c0:                btMatrix3x3; // Impulse matrix
        m_c1:                btVector3; // Relative anchor
        m_c2:                btScalar; // inverse mass of node/face
        m_c3:                btScalar; // Friction
        m_c4:                btScalar; // Hardness
        m_c5:                btMatrix3x3 #align 8; // inverse effective mass

        // jacobians and unit impulse responses for multibody
        jacobianData_normal: btMultiBodyJacobianData;
        jacobianData_t1:     btMultiBodyJacobianData;
        jacobianData_t2:     btMultiBodyJacobianData;
        t1:                  btVector3;
        t2:                  btVector3;
    }

    DeformableNodeRigidContact :: struct {
        #as using deformablerigidcontact: DeformableRigidContact;

        m_node: *Node; // Owner node
    }

    DeformableNodeRigidAnchor :: struct {
        #as using deformablenoderigidcontact: DeformableNodeRigidContact;

        m_local: btVector3; // Anchor position in body space
    }

    DeformableFaceRigidContact :: struct {
        #as using deformablerigidcontact: DeformableRigidContact;

        m_face:         *Face; // Owner face
        m_contactPoint: btVector3; // Contact point
        m_bary:         btVector3; // Barycentric weights
        m_weights:      btVector3; // v_contactPoint * m_weights[i] = m_face->m_node[i]->m_v;
    }

    DeformableFaceNodeContact :: struct {
        m_node:     *Node; // Node
        m_face:     *Face; // Face
        m_bary:     btVector3; // Barycentric weights
        m_weights:  btVector3; // v_contactPoint * m_weights[i] = m_face->m_node[i]->m_v;
        m_normal:   btVector3; // Normal
        m_margin:   btScalar; // Margin
        m_friction: btScalar; // Friction
        m_imf:      btScalar; // inverse mass of the face at contact point
        m_c0:       btScalar; // scale of the impulse matrix;
        m_colObj:   *btCollisionObject; // Collision object to collide with.
    }

    /* SContact		*/
    SContact :: struct {
        m_node:     *Node; // Node
        m_face:     *Face; // Face
        m_weights:  btVector3; // Weigths
        m_normal:   btVector3; // Normal
        m_margin:   btScalar; // Margin
        m_friction: btScalar; // Friction
        m_cfm:      [2] btScalar; // Constraint force mixing
    }

    /* Anchor		*/
    Anchor :: struct {
        m_node:      *Node; // Node pointer
        m_local:     btVector3; // Anchor position in body space
        m_body:      *btRigidBody; // Body
        m_influence: btScalar;
        m_c0:        btMatrix3x3 #align 8; // Impulse matrix
        m_c1:        btVector3; // Relative anchor
        m_c2:        btScalar; // ima*dt
    }

    /* Note			*/
    Note :: struct {
        #as using element: Element;

        m_text:   *u8; // Text
        m_offset: btVector3; // Offset
        m_rank:   s32; // Rank
        m_nodes:  [4] *Node; // Nodes
        m_coords: [4] btScalar; // Coordinates
    }

    /* Pose			*/
    Pose :: struct {
        m_bvolume: bool; // Is valid
        m_bframe:  bool; // Is frame
        m_volume:  btScalar; // Rest volume
        m_pos:     tVector3Array; // Reference positions
        m_wgh:     tScalarArray; // Weights
        m_com:     btVector3; // COM
        m_rot:     btMatrix3x3; // Rotation
        m_scl:     btMatrix3x3; // Scale
        m_aqq:     btMatrix3x3; // Base scaling
    }

    /* Cluster		*/
    Cluster :: struct {
        m_masses:                     tScalarArray;
        m_nodes:                      btAlignedObjectArray(*Node);
        m_framerefs:                  tVector3Array;
        m_framexform:                 btTransform;
        m_idmass:                     btScalar;
        m_imass:                      btScalar;
        m_locii:                      btMatrix3x3;
        m_invwi:                      btMatrix3x3;
        m_com:                        btVector3;
        m_vimpulses:                  [2] btVector3;
        m_dimpulses:                  [2] btVector3;
        m_nvimpulses:                 s32;
        m_ndimpulses:                 s32;
        m_lv:                         btVector3;
        m_av:                         btVector3;
        m_leaf:                       *btDbvtNode;
        m_ndamping:                   btScalar; /* Node damping		*/
        m_ldamping:                   btScalar; /* Linear damping	*/
        m_adamping:                   btScalar; /* Angular damping	*/
        m_matching:                   btScalar;
        m_maxSelfCollisionImpulse:    btScalar;
        m_selfCollisionImpulseFactor: btScalar;
        m_containsAnchor:             bool;
        m_collide:                    bool;
        m_clusterIndex:               s32;
        Constructor :: (this: *Cluster) -> void #cpp_method #foreign bullet3 "??0Cluster@btSoftBody@@QEAA@XZ";
    }

    /* Impulse		*/
    Impulse :: struct {
        m_velocity:   btVector3;
        m_drift:      btVector3;
        m_asVelocity: s32;
        #place m_asVelocity; /*bitfield 1*/ m_asDrift:    s32;
        Constructor :: (this: *Impulse) -> void #cpp_method #foreign bullet3 "??0Impulse@btSoftBody@@QEAA@XZ";
    }
    operator- :: (this: *btSoftBody.Impulse) -> btSoftBody.Impulse #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GImpulse@btSoftBody@@QEBA?AU01@XZ";
    operator- :: (this: btSoftBody.Impulse) -> btSoftBody.Impulse #no_context {
        return operator-(*this);
    }

    operator* :: (this: *btSoftBody.Impulse, x: btScalar) -> btSoftBody.Impulse #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??DImpulse@btSoftBody@@QEBA?AU01@M@Z";
    operator* :: (this: btSoftBody.Impulse, x: btScalar) -> btSoftBody.Impulse #no_context {
        return operator*(*this, x);
    }

    /* Body			*/
    Body :: struct {
        m_soft:            *Cluster;
        m_rigid:           *btRigidBody;
        m_collisionObject: *btCollisionObject;

        Constructor :: (this: *Body) -> void #cpp_method #foreign bullet3 "??0Body@btSoftBody@@QEAA@XZ";
        Constructor :: (this: *Body, p: *Cluster) -> void #cpp_method #foreign bullet3 "??0Body@btSoftBody@@QEAA@PEAUCluster@1@@Z";
        Constructor :: (this: *Body, colObj: *btCollisionObject) -> void #cpp_method #foreign bullet3 "??0Body@btSoftBody@@QEAA@PEBVbtCollisionObject@@@Z";

        activate :: (this: *Body) -> void #cpp_method #foreign bullet3 "?activate@Body@btSoftBody@@QEBAXXZ";

        invWorldInertia :: (this: *Body) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?invWorldInertia@Body@btSoftBody@@QEBAAEBVbtMatrix3x3@@XZ";

        invMass :: (this: *Body) -> btScalar #cpp_method #foreign bullet3 "?invMass@Body@btSoftBody@@QEBAMXZ";

        xform :: (this: *Body) -> *btTransform #cpp_method #foreign bullet3 "?xform@Body@btSoftBody@@QEBAAEBVbtTransform@@XZ";

        linearVelocity :: (this: *Body) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?linearVelocity@Body@btSoftBody@@QEBA?AVbtVector3@@XZ";

        angularVelocity :: (this: *Body, rpos: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?angularVelocity@Body@btSoftBody@@QEBA?AVbtVector3@@AEBV3@@Z";
        angularVelocity :: (this: *Body, rpos: btVector3) -> btVector3 #no_context {
            return angularVelocity(this, *rpos);
        }

        angularVelocity :: (this: *Body) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?angularVelocity@Body@btSoftBody@@QEBA?AVbtVector3@@XZ";

        velocity :: (this: *Body, rpos: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?velocity@Body@btSoftBody@@QEBA?AVbtVector3@@AEBV3@@Z";
        velocity :: (this: *Body, rpos: btVector3) -> btVector3 #no_context {
            return velocity(this, *rpos);
        }

        applyVImpulse :: (this: *Body, impulse: *btVector3, rpos: *btVector3) -> void #cpp_method #foreign bullet3 "?applyVImpulse@Body@btSoftBody@@QEBAXAEBVbtVector3@@0@Z";
        applyVImpulse :: (this: *Body, impulse: btVector3, rpos: btVector3) #no_context {
            applyVImpulse(this, *impulse, *rpos);
        }

        applyDImpulse :: (this: *Body, impulse: *btVector3, rpos: *btVector3) -> void #cpp_method #foreign bullet3 "?applyDImpulse@Body@btSoftBody@@QEBAXAEBVbtVector3@@0@Z";
        applyDImpulse :: (this: *Body, impulse: btVector3, rpos: btVector3) #no_context {
            applyDImpulse(this, *impulse, *rpos);
        }

        applyImpulse :: (this: *Body, impulse: *Impulse, rpos: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@Body@btSoftBody@@QEBAXAEBUImpulse@2@AEBVbtVector3@@@Z";
        applyImpulse :: (this: *Body, impulse: Impulse, rpos: btVector3) #no_context {
            applyImpulse(this, *impulse, *rpos);
        }

        applyVAImpulse :: (this: *Body, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyVAImpulse@Body@btSoftBody@@QEBAXAEBVbtVector3@@@Z";
        applyVAImpulse :: (this: *Body, impulse: btVector3) #no_context {
            applyVAImpulse(this, *impulse);
        }

        applyDAImpulse :: (this: *Body, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyDAImpulse@Body@btSoftBody@@QEBAXAEBVbtVector3@@@Z";
        applyDAImpulse :: (this: *Body, impulse: btVector3) #no_context {
            applyDAImpulse(this, *impulse);
        }

        applyAImpulse :: (this: *Body, impulse: *Impulse) -> void #cpp_method #foreign bullet3 "?applyAImpulse@Body@btSoftBody@@QEBAXAEBUImpulse@2@@Z";
        applyAImpulse :: (this: *Body, impulse: Impulse) #no_context {
            applyAImpulse(this, *impulse);
        }

        applyDCImpulse :: (this: *Body, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyDCImpulse@Body@btSoftBody@@QEBAXAEBVbtVector3@@@Z";
        applyDCImpulse :: (this: *Body, impulse: btVector3) #no_context {
            applyDCImpulse(this, *impulse);
        }
    }

    /* Joint		*/
    Joint :: struct {
        vtable: *Joint_VTable;
        eType :: struct {
            _ :: enum s32 {
                Linear  :: 0;
                Angular :: 1;
                Contact :: 2;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        Specs :: struct {
            Constructor :: (this: *Specs) -> void #cpp_method #foreign bullet3 "??0Specs@Joint@btSoftBody@@QEAA@XZ";
            erp:   btScalar;
            cfm:   btScalar;
            split: btScalar;
        }

        m_bodies:     [2] Body;
        m_refs:       [2] btVector3;
        m_cfm:        btScalar;
        m_erp:        btScalar;
        m_split:      btScalar;
        m_drift:      btVector3 #align 8;
        m_sdrift:     btVector3;
        m_massmatrix: btMatrix3x3;
        m_delete:     bool;

        Constructor :: (this: *Joint) -> void #cpp_method #foreign bullet3 "??0Joint@btSoftBody@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *Joint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1Joint@btSoftBody@@UEAA@XZ";

        virtual_Prepare :: (this: *Joint, dt: btScalar, iterations: s32) -> void #cpp_method #foreign bullet3 "?Prepare@Joint@btSoftBody@@UEAAXMH@Z";
    }
    Joint_VTable :: struct #type_info_none {
        Destructor: (this: *Joint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        Prepare: (this: *Joint, dt: btScalar, iterations: s32) -> void #cpp_method;
        Solve: (this: *Joint, dt: btScalar, sor: btScalar) -> void #cpp_method;
        Terminate: (this: *Joint, dt: btScalar) -> void #cpp_method;
        Type: (this: *Joint) -> Joint.eType._ #cpp_method;
    }

    Joint_Destructor :: inline (this: *Joint, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    Joint_Prepare :: inline (this: *Joint, dt: btScalar, iterations: s32) { this.vtable.Prepare(this, dt, iterations); }
    Joint_Solve :: inline (this: *Joint, dt: btScalar, sor: btScalar) { this.vtable.Solve(this, dt, sor); }
    Joint_Terminate :: inline (this: *Joint, dt: btScalar) { this.vtable.Terminate(this, dt); }
    Joint_Type :: inline (this: *Joint) -> Joint.eType._ { return this.vtable.Type(this); }



    /* LJoint		*/
    LJoint :: struct {
        #as joint: Joint; // jai: no "using" to avoid name-clashes

        Specs :: struct {
            #as using specs: Joint.Specs;

            position: btVector3 #align 8;
        }

        m_rpos: [2] btVector3;
    }

    /* AJoint		*/
    AJoint :: struct {
        #as joint: Joint; // jai: no "using" to avoid name-clashes

        IControl :: struct {
            vtable: *IControl_VTable;
            Default :: () -> *IControl #foreign bullet3 "?Default@IControl@AJoint@btSoftBody@@SAPEAU123@XZ";

            // Virtual functions:
            // Normally you should call them via the vtable.
            // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
            // or need to create a vtable yourself.

            virtual_Destructor :: (this: *IControl, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1IControl@AJoint@btSoftBody@@UEAA@XZ";
            virtual_Prepare :: (this: *IControl, unknown0: *AJoint) -> void #cpp_method #foreign bullet3 "?Prepare@IControl@AJoint@btSoftBody@@UEAAXPEAU23@@Z";
            virtual_Speed :: (this: *IControl, unknown0: *AJoint, current: btScalar) -> btScalar #cpp_method #foreign bullet3 "?Speed@IControl@AJoint@btSoftBody@@UEAAMPEAU23@M@Z";
        }
        IControl_VTable :: struct #type_info_none {
            Destructor: (this: *IControl, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
            Prepare: (this: *IControl, unknown0: *AJoint) -> void #cpp_method;
            Speed: (this: *IControl, unknown0: *AJoint, current: btScalar) -> btScalar #cpp_method;
        }

        IControl_Destructor :: inline (this: *IControl, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
        IControl_Prepare :: inline (this: *IControl, unknown0: *AJoint) { this.vtable.Prepare(this, unknown0); }
        IControl_Speed :: inline (this: *IControl, unknown0: *AJoint, current: btScalar) -> btScalar { return this.vtable.Speed(this, unknown0, current); }



        Specs :: struct {
            #as using specs: Joint.Specs;

            axis:     btVector3 #align 8;
            icontrol: *IControl;
        }

        m_axis:     [2] btVector3;
        m_icontrol: *IControl;
    }

    /* CJoint		*/
    CJoint :: struct {
        #as using joint: Joint;

        m_life:     s32;
        m_maxlife:  s32;
        m_rpos:     [2] btVector3;
        m_normal:   btVector3;
        m_friction: btScalar;
    }

    /* Config		*/
    Config :: struct {
        aeromodel:   eAeroModel._; // Aerodynamic model (default: V_Point)
        kVCF:        btScalar; // Velocities correction factor (Baumgarte)
        kDP:         btScalar; // Damping coefficient [0,1]
        kDG:         btScalar; // Drag coefficient [0,+inf]
        kLF:         btScalar; // Lift coefficient [0,+inf]
        kPR:         btScalar; // Pressure coefficient [-inf,+inf]
        kVC:         btScalar; // Volume conversation coefficient [0,+inf]
        kDF:         btScalar; // Dynamic friction coefficient [0,1]
        kMT:         btScalar; // Pose matching coefficient [0,1]
        kCHR:        btScalar; // Rigid contacts hardness [0,1]
        kKHR:        btScalar; // Kinetic contacts hardness [0,1]
        kSHR:        btScalar; // Soft contacts hardness [0,1]
        kAHR:        btScalar; // Anchors hardness [0,1]
        kSRHR_CL:    btScalar; // Soft vs rigid hardness [0,1] (cluster only)
        kSKHR_CL:    btScalar; // Soft vs kinetic hardness [0,1] (cluster only)
        kSSHR_CL:    btScalar; // Soft vs soft hardness [0,1] (cluster only)
        kSR_SPLT_CL: btScalar; // Soft vs rigid impulse split [0,1] (cluster only)
        kSK_SPLT_CL: btScalar; // Soft vs rigid impulse split [0,1] (cluster only)
        kSS_SPLT_CL: btScalar; // Soft vs rigid impulse split [0,1] (cluster only)
        maxvolume:   btScalar; // Maximum volume ratio for pose
        timescale:   btScalar; // Time scale
        viterations: s32; // Velocities solver iterations
        piterations: s32; // Positions solver iterations
        diterations: s32; // Drift solver iterations
        citerations: s32; // Cluster solver iterations
        collisions:  s32; // Collisions flags
        m_vsequence: tVSolverArray; // Velocity solvers sequence
        m_psequence: tPSolverArray; // Position solvers sequence
        m_dsequence: tPSolverArray; // Drift solvers sequence
        drag:        btScalar; // deformable air drag
        m_maxStress: btScalar; // Maximum principle first Piola stress
    }

    /* SolverState	*/
    SolverState :: struct {
        //if you add new variables, always initialize them!
        Constructor :: (this: *SolverState) -> void #cpp_method #foreign bullet3 "??0SolverState@btSoftBody@@QEAA@XZ";

        sdt:    btScalar; // dt*timescale
        isdt:   btScalar; // 1/sdt
        velmrg: btScalar; // velocity margin
        radmrg: btScalar; // radial margin
        updmrg: btScalar; // Update margin
    }

    /// RayFromToCaster takes a ray from, ray to (instead of direction!)
    RayFromToCaster :: struct {
        #as using icollide: btDbvt.ICollide;

        m_rayFrom:                btVector3;
        m_rayTo:                  btVector3;
        m_rayNormalizedDirection: btVector3;
        m_mint:                   btScalar;
        m_face:                   *Face;
        m_tests:                  s32;
    }

    //
    // Typedefs
    //
    psolver_t :: #type (unknown0: *btSoftBody, unknown1: btScalar, unknown2: btScalar) -> void #c_call;
    vsolver_t :: #type (unknown0: *btSoftBody, unknown1: btScalar) -> void #c_call;
    tClusterArray :: btAlignedObjectArray(*Cluster);
    tNoteArray :: btAlignedObjectArray(Note);
    tNodeArray :: btAlignedObjectArray(Node);
    tRenderNodeArray :: btAlignedObjectArray(RenderNode);
    tLeafArray :: btAlignedObjectArray(*btDbvtNode);
    tLinkArray :: btAlignedObjectArray(Link);
    tFaceArray :: btAlignedObjectArray(Face);
    tRenderFaceArray :: btAlignedObjectArray(RenderFace);
    tTetraArray :: btAlignedObjectArray(Tetra);
    tAnchorArray :: btAlignedObjectArray(Anchor);
    tRContactArray :: btAlignedObjectArray(RContact);
    tSContactArray :: btAlignedObjectArray(SContact);
    tMaterialArray :: btAlignedObjectArray(*Material);
    tJointArray :: btAlignedObjectArray(*Joint);
    tSoftBodyArray :: btAlignedObjectArray(*btSoftBody);
    tDenseMatrix :: btAlignedObjectArray(btAlignedObjectArray(btScalar));

    m_cfg:                             Config; // Configuration
    m_sst:                             SolverState; // Solver state
    m_pose:                            Pose; // Pose
    m_tag:                             *void; // User data
    m_worldInfo:                       *btSoftBodyWorldInfo; // World info
    m_notes:                           tNoteArray; // Notes
    m_nodes:                           tNodeArray; // Nodes
    m_renderNodes:                     tRenderNodeArray; // Render Nodes
    m_links:                           tLinkArray; // Links
    m_faces:                           tFaceArray; // Faces
    m_renderFaces:                     tRenderFaceArray; // Faces
    m_tetras:                          tTetraArray; // Tetras
    m_tetraScratches:                  btAlignedObjectArray(TetraScratch);
    m_tetraScratchesTn:                btAlignedObjectArray(TetraScratch);
    m_anchors:                         tAnchorArray; // Anchors
    m_deformableAnchors:               btAlignedObjectArray(DeformableNodeRigidAnchor);
    m_rcontacts:                       tRContactArray; // Rigid contacts
    m_nodeRigidContacts:               btAlignedObjectArray(DeformableNodeRigidContact);
    m_faceNodeContacts:                btAlignedObjectArray(DeformableFaceNodeContact);
    m_faceRigidContacts:               btAlignedObjectArray(DeformableFaceRigidContact);
    m_faceNodeContactsCCD:             btAlignedObjectArray(DeformableFaceNodeContact);
    m_scontacts:                       tSContactArray; // Soft contacts
    m_joints:                          tJointArray; // Joints
    m_materials:                       tMaterialArray; // Materials
    m_timeacc:                         btScalar; // Time accumulator
    m_bounds:                          [2] btVector3; // Spatial bounds
    m_bUpdateRtCst:                    bool; // Update runtime constants
    m_ndbvt:                           btDbvt; // Nodes tree
    m_fdbvt:                           btDbvt; // Faces tree
    m_fdbvnt:                          *btDbvntNode; // Faces tree with normals
    m_cdbvt:                           btDbvt; // Clusters tree
    m_clusters:                        tClusterArray; // Clusters
    m_dampingCoefficient:              btScalar; // Damping Coefficient
    m_sleepingThreshold:               btScalar;
    m_maxSpeedSquared:                 btScalar;
    m_quads:                           btAlignedObjectArray(btVector3); // quadrature points for collision detection
    m_repulsionStiffness:              btScalar;
    m_gravityFactor:                   btScalar;
    m_cacheBarycenter:                 bool;
    m_X:                               btAlignedObjectArray(btVector3); // initial positions

    m_renderNodesInterpolationWeights: btAlignedObjectArray(btVector4);
    m_renderNodesParents:              btAlignedObjectArray(btAlignedObjectArray(*Node));
    m_z:                               btAlignedObjectArray(btScalar); // vertical distance used in extrapolation
    m_useSelfCollision:                bool;
    m_softSoftCollision:               bool;

    m_clusterConnectivity:             btAlignedObjectArray(bool); //cluster connectivity, for self-collision

    m_windVelocity:                    btVector3;

    m_restLengthScale:                 btScalar;

    m_reducedModel:                    bool; // Reduced deformable model flag

    /* ctor																	*/
    Constructor :: (this: *btSoftBody, worldInfo: *btSoftBodyWorldInfo, node_count: s32, x: *btVector3, m: *btScalar) -> void #cpp_method #foreign bullet3 "??0btSoftBody@@QEAA@PEAUbtSoftBodyWorldInfo@@HPEBVbtVector3@@PEBM@Z";

    /* ctor																	*/
    Constructor :: (this: *btSoftBody, worldInfo: *btSoftBodyWorldInfo) -> void #cpp_method #foreign bullet3 "??0btSoftBody@@QEAA@PEAUbtSoftBodyWorldInfo@@@Z";

    initDefaults :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?initDefaults@btSoftBody@@QEAAXXZ";

    /* Check for existing link												*/
    m_userIndexMapping:                btAlignedObjectArray(s32);

    getWorldInfo :: (this: *btSoftBody) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btSoftBody@@QEAAPEAUbtSoftBodyWorldInfo@@XZ";

    setDampingCoefficient :: (this: *btSoftBody, damping_coeff: btScalar) -> void #cpp_method #foreign bullet3 "?setDampingCoefficient@btSoftBody@@QEAAXM@Z";

    checkLink :: (this: *btSoftBody, node0: s32, node1: s32) -> bool #cpp_method #foreign bullet3 "?checkLink@btSoftBody@@QEBA_NHH@Z";

    checkLink :: (this: *btSoftBody, node0: *Node, node1: *Node) -> bool #cpp_method #foreign bullet3 "?checkLink@btSoftBody@@QEBA_NPEBUNode@1@0@Z";

    /* Check for existring face												*/
    checkFace :: (this: *btSoftBody, node0: s32, node1: s32, node2: s32) -> bool #cpp_method #foreign bullet3 "?checkFace@btSoftBody@@QEBA_NHHH@Z";

    /* Append material														*/
    appendMaterial :: (this: *btSoftBody) -> *Material #cpp_method #foreign bullet3 "?appendMaterial@btSoftBody@@QEAAPEAUMaterial@1@XZ";

    /* Append note															*/
    appendNote :: (this: *btSoftBody, text: *u8, o: *btVector3, c: *btVector4, n0: *Node = null, n1: *Node = null, n2: *Node = null, n3: *Node = null) -> void #cpp_method #foreign bullet3 "?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@AEBVbtVector4@@PEAUNode@1@333@Z";
    appendNote :: (this: *btSoftBody, text: *u8, o: btVector3, c: btVector4 = btVector4.{1, 0, 0, 0}, n0: *Node = null, n1: *Node = null, n2: *Node = null, n3: *Node = null) #no_context {
        appendNote(this, text, *o, *c, n0, n1, n2, n3);
    }

    appendNote :: (this: *btSoftBody, text: *u8, o: *btVector3, feature: *Node) -> void #cpp_method #foreign bullet3 "?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@PEAUNode@1@@Z";
    appendNote :: (this: *btSoftBody, text: *u8, o: btVector3, feature: *Node) #no_context {
        appendNote(this, text, *o, feature);
    }

    appendNote :: (this: *btSoftBody, text: *u8, o: *btVector3, feature: *Link) -> void #cpp_method #foreign bullet3 "?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@PEAULink@1@@Z";
    appendNote :: (this: *btSoftBody, text: *u8, o: btVector3, feature: *Link) #no_context {
        appendNote(this, text, *o, feature);
    }

    appendNote :: (this: *btSoftBody, text: *u8, o: *btVector3, feature: *Face) -> void #cpp_method #foreign bullet3 "?appendNote@btSoftBody@@QEAAXPEBDAEBVbtVector3@@PEAUFace@1@@Z";
    appendNote :: (this: *btSoftBody, text: *u8, o: btVector3, feature: *Face) #no_context {
        appendNote(this, text, *o, feature);
    }

    /* Append node															*/
    appendNode :: (this: *btSoftBody, x: *btVector3, m: btScalar) -> void #cpp_method #foreign bullet3 "?appendNode@btSoftBody@@QEAAXAEBVbtVector3@@M@Z";
    appendNode :: (this: *btSoftBody, x: btVector3, m: btScalar) #no_context {
        appendNode(this, *x, m);
    }

    /* Append link															*/
    appendLink :: (this: *btSoftBody, model: s32 = -1, mat: *Material = null) -> void #cpp_method #foreign bullet3 "?appendLink@btSoftBody@@QEAAXHPEAUMaterial@1@@Z";
    appendLink :: (this: *btSoftBody, node0: s32, node1: s32, mat: *Material = null, bcheckexist := false) -> void #cpp_method #foreign bullet3 "?appendLink@btSoftBody@@QEAAXHHPEAUMaterial@1@_N@Z";

    appendLink :: (this: *btSoftBody, node0: *Node, node1: *Node, mat: *Material = null, bcheckexist := false) -> void #cpp_method #foreign bullet3 "?appendLink@btSoftBody@@QEAAXPEAUNode@1@0PEAUMaterial@1@_N@Z";

    /* Append face															*/
    appendFace :: (this: *btSoftBody, model: s32 = -1, mat: *Material = null) -> void #cpp_method #foreign bullet3 "?appendFace@btSoftBody@@QEAAXHPEAUMaterial@1@@Z";
    appendFace :: (this: *btSoftBody, node0: s32, node1: s32, node2: s32, mat: *Material = null) -> void #cpp_method #foreign bullet3 "?appendFace@btSoftBody@@QEAAXHHHPEAUMaterial@1@@Z";

    appendTetra :: (this: *btSoftBody, model: s32, mat: *Material) -> void #cpp_method #foreign bullet3 "?appendTetra@btSoftBody@@QEAAXHPEAUMaterial@1@@Z";

    //
    appendTetra :: (this: *btSoftBody, node0: s32, node1: s32, node2: s32, node3: s32, mat: *Material = null) -> void #cpp_method #foreign bullet3 "?appendTetra@btSoftBody@@QEAAXHHHHPEAUMaterial@1@@Z";

    /* Append anchor														*/
    appendDeformableAnchor :: (this: *btSoftBody, node: s32, body: *btRigidBody) -> void #cpp_method #foreign bullet3 "?appendDeformableAnchor@btSoftBody@@QEAAXHPEAVbtRigidBody@@@Z";
    appendDeformableAnchor :: (this: *btSoftBody, node: s32, link: *btMultiBodyLinkCollider) -> void #cpp_method #foreign bullet3 "?appendDeformableAnchor@btSoftBody@@QEAAXHPEAVbtMultiBodyLinkCollider@@@Z";
    appendAnchor :: (this: *btSoftBody, node: s32, body: *btRigidBody, disableCollisionBetweenLinkedBodies := false, influence: btScalar = 1) -> void #cpp_method #foreign bullet3 "?appendAnchor@btSoftBody@@QEAAXHPEAVbtRigidBody@@_NM@Z";

    appendAnchor :: (this: *btSoftBody, node: s32, body: *btRigidBody, localPivot: *btVector3, disableCollisionBetweenLinkedBodies := false, influence: btScalar = 1) -> void #cpp_method #foreign bullet3 "?appendAnchor@btSoftBody@@QEAAXHPEAVbtRigidBody@@AEBVbtVector3@@_NM@Z";
    appendAnchor :: (this: *btSoftBody, node: s32, body: *btRigidBody, localPivot: btVector3, disableCollisionBetweenLinkedBodies := false, influence: btScalar = 1) #no_context {
        appendAnchor(this, node, body, *localPivot, disableCollisionBetweenLinkedBodies, influence);
    }
    removeAnchor :: (this: *btSoftBody, node: s32) -> void #cpp_method #foreign bullet3 "?removeAnchor@btSoftBody@@QEAAXH@Z";

    /* Append linear joint													*/
    appendLinearJoint :: (this: *btSoftBody, specs: *LJoint.Specs, body0: *Cluster, body1: Body) -> void #cpp_method #foreign bullet3 "?appendLinearJoint@btSoftBody@@QEAAXAEBUSpecs@LJoint@1@PEAUCluster@1@UBody@1@@Z";
    appendLinearJoint :: (this: *btSoftBody, specs: LJoint.Specs, body0: *Cluster, body1: Body) #no_context {
        appendLinearJoint(this, *specs, body0, body1);
    }
    appendLinearJoint :: (this: *btSoftBody, specs: *LJoint.Specs, body: Body = Body.{}) -> void #cpp_method #foreign bullet3 "?appendLinearJoint@btSoftBody@@QEAAXAEBUSpecs@LJoint@1@UBody@1@@Z";
    appendLinearJoint :: (this: *btSoftBody, specs: LJoint.Specs, body: Body = Body.{}) #no_context {
        appendLinearJoint(this, *specs, body);
    }
    appendLinearJoint :: (this: *btSoftBody, specs: *LJoint.Specs, body: *btSoftBody) -> void #cpp_method #foreign bullet3 "?appendLinearJoint@btSoftBody@@QEAAXAEBUSpecs@LJoint@1@PEAV1@@Z";
    appendLinearJoint :: (this: *btSoftBody, specs: LJoint.Specs, body: *btSoftBody) #no_context {
        appendLinearJoint(this, *specs, body);
    }

    /* Append linear joint													*/
    appendAngularJoint :: (this: *btSoftBody, specs: *AJoint.Specs, body0: *Cluster, body1: Body) -> void #cpp_method #foreign bullet3 "?appendAngularJoint@btSoftBody@@QEAAXAEBUSpecs@AJoint@1@PEAUCluster@1@UBody@1@@Z";
    appendAngularJoint :: (this: *btSoftBody, specs: AJoint.Specs, body0: *Cluster, body1: Body) #no_context {
        appendAngularJoint(this, *specs, body0, body1);
    }
    appendAngularJoint :: (this: *btSoftBody, specs: *AJoint.Specs, body: Body = Body.{}) -> void #cpp_method #foreign bullet3 "?appendAngularJoint@btSoftBody@@QEAAXAEBUSpecs@AJoint@1@UBody@1@@Z";
    appendAngularJoint :: (this: *btSoftBody, specs: AJoint.Specs, body: Body = Body.{}) #no_context {
        appendAngularJoint(this, *specs, body);
    }
    appendAngularJoint :: (this: *btSoftBody, specs: *AJoint.Specs, body: *btSoftBody) -> void #cpp_method #foreign bullet3 "?appendAngularJoint@btSoftBody@@QEAAXAEBUSpecs@AJoint@1@PEAV1@@Z";
    appendAngularJoint :: (this: *btSoftBody, specs: AJoint.Specs, body: *btSoftBody) #no_context {
        appendAngularJoint(this, *specs, body);
    }

    /* Add force (or gravity) to the entire body							*/
    addForce :: (this: *btSoftBody, force: *btVector3) -> void #cpp_method #foreign bullet3 "?addForce@btSoftBody@@QEAAXAEBVbtVector3@@@Z";
    addForce :: (this: *btSoftBody, force: btVector3) #no_context {
        addForce(this, *force);
    }

    /* Add force (or gravity) to a node of the body							*/
    addForce :: (this: *btSoftBody, force: *btVector3, node: s32) -> void #cpp_method #foreign bullet3 "?addForce@btSoftBody@@QEAAXAEBVbtVector3@@H@Z";
    addForce :: (this: *btSoftBody, force: btVector3, node: s32) #no_context {
        addForce(this, *force, node);
    }

    /* Add aero force to a node of the body */
    addAeroForceToNode :: (this: *btSoftBody, windVelocity: *btVector3, nodeIndex: s32) -> void #cpp_method #foreign bullet3 "?addAeroForceToNode@btSoftBody@@QEAAXAEBVbtVector3@@H@Z";
    addAeroForceToNode :: (this: *btSoftBody, windVelocity: btVector3, nodeIndex: s32) #no_context {
        addAeroForceToNode(this, *windVelocity, nodeIndex);
    }

    /* Add aero force to a face of the body */
    addAeroForceToFace :: (this: *btSoftBody, windVelocity: *btVector3, faceIndex: s32) -> void #cpp_method #foreign bullet3 "?addAeroForceToFace@btSoftBody@@QEAAXAEBVbtVector3@@H@Z";
    addAeroForceToFace :: (this: *btSoftBody, windVelocity: btVector3, faceIndex: s32) #no_context {
        addAeroForceToFace(this, *windVelocity, faceIndex);
    }

    /* Add velocity to the entire body										*/
    addVelocity :: (this: *btSoftBody, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?addVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z";
    addVelocity :: (this: *btSoftBody, velocity: btVector3) #no_context {
        addVelocity(this, *velocity);
    }

    /* Set velocity for the entire body										*/
    setVelocity :: (this: *btSoftBody, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?setVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z";
    setVelocity :: (this: *btSoftBody, velocity: btVector3) #no_context {
        setVelocity(this, *velocity);
    }

    /* Add velocity to a node of the body									*/
    addVelocity :: (this: *btSoftBody, velocity: *btVector3, node: s32) -> void #cpp_method #foreign bullet3 "?addVelocity@btSoftBody@@QEAAXAEBVbtVector3@@H@Z";
    addVelocity :: (this: *btSoftBody, velocity: btVector3, node: s32) #no_context {
        addVelocity(this, *velocity, node);
    }

    /* Set mass																*/
    setMass :: (this: *btSoftBody, node: s32, mass: btScalar) -> void #cpp_method #foreign bullet3 "?setMass@btSoftBody@@QEAAXHM@Z";

    /* Get mass																*/
    getMass :: (this: *btSoftBody, node: s32) -> btScalar #cpp_method #foreign bullet3 "?getMass@btSoftBody@@QEBAMH@Z";

    /* Get total mass														*/
    getTotalMass :: (this: *btSoftBody) -> btScalar #cpp_method #foreign bullet3 "?getTotalMass@btSoftBody@@QEBAMXZ";

    /* Set total mass (weighted by previous masses)							*/
    setTotalMass :: (this: *btSoftBody, mass: btScalar, fromfaces := false) -> void #cpp_method #foreign bullet3 "?setTotalMass@btSoftBody@@QEAAXM_N@Z";

    /* Set total density													*/
    setTotalDensity :: (this: *btSoftBody, density: btScalar) -> void #cpp_method #foreign bullet3 "?setTotalDensity@btSoftBody@@QEAAXM@Z";

    /* Set volume mass (using tetrahedrons)									*/
    setVolumeMass :: (this: *btSoftBody, mass: btScalar) -> void #cpp_method #foreign bullet3 "?setVolumeMass@btSoftBody@@QEAAXM@Z";

    /* Set volume density (using tetrahedrons)								*/
    setVolumeDensity :: (this: *btSoftBody, density: btScalar) -> void #cpp_method #foreign bullet3 "?setVolumeDensity@btSoftBody@@QEAAXM@Z";

    /* Get the linear velocity of the center of mass                        */
    getLinearVelocity :: (this: *btSoftBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getLinearVelocity@btSoftBody@@QEAA?AVbtVector3@@XZ";

    /* Set the linear velocity of the center of mass                        */
    setLinearVelocity :: (this: *btSoftBody, linVel: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z";
    setLinearVelocity :: (this: *btSoftBody, linVel: btVector3) #no_context {
        setLinearVelocity(this, *linVel);
    }

    /* Set the angular velocity of the center of mass                       */
    setAngularVelocity :: (this: *btSoftBody, angVel: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z";
    setAngularVelocity :: (this: *btSoftBody, angVel: btVector3) #no_context {
        setAngularVelocity(this, *angVel);
    }

    /* Get best fit rigid transform                                         */
    getRigidTransform :: (this: *btSoftBody) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getRigidTransform@btSoftBody@@QEAA?AVbtTransform@@XZ";

    /* Get link resting lengths scale										*/
    getRestLengthScale :: (this: *btSoftBody) -> btScalar #cpp_method #foreign bullet3 "?getRestLengthScale@btSoftBody@@QEAAMXZ";

    /* Scale resting length of all springs									*/
    setRestLengthScale :: (this: *btSoftBody, restLength: btScalar) -> void #cpp_method #foreign bullet3 "?setRestLengthScale@btSoftBody@@QEAAXM@Z";

    /* Set current state as pose											*/
    setPose :: (this: *btSoftBody, bvolume: bool, bframe: bool) -> void #cpp_method #foreign bullet3 "?setPose@btSoftBody@@QEAAX_N0@Z";

    /* Set current link lengths as resting lengths							*/
    resetLinkRestLengths :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?resetLinkRestLengths@btSoftBody@@QEAAXXZ";

    /* Return the volume													*/
    getVolume :: (this: *btSoftBody) -> btScalar #cpp_method #foreign bullet3 "?getVolume@btSoftBody@@QEBAMXZ";

    /* Cluster count														*/
    getCenterOfMass :: (this: *btSoftBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getCenterOfMass@btSoftBody@@QEBA?AVbtVector3@@XZ";

    clusterCount :: (this: *btSoftBody) -> s32 #cpp_method #foreign bullet3 "?clusterCount@btSoftBody@@QEBAHXZ";

    /* Cluster center of mass												*/
    clusterCom :: (cluster: *Cluster) -> btVector3 #cpp_return_type_is_non_pod #foreign bullet3 "?clusterCom@btSoftBody@@SA?AVbtVector3@@PEBUCluster@1@@Z";
    clusterCom :: (this: *btSoftBody, cluster: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?clusterCom@btSoftBody@@QEBA?AVbtVector3@@H@Z";

    /* Cluster velocity at rpos												*/
    clusterVelocity :: (cluster: *Cluster, rpos: *btVector3) -> btVector3 #cpp_return_type_is_non_pod #foreign bullet3 "?clusterVelocity@btSoftBody@@SA?AVbtVector3@@PEBUCluster@1@AEBV2@@Z";
    clusterVelocity :: (cluster: *Cluster, rpos: btVector3) -> btVector3 #no_context {
        return clusterVelocity(cluster, *rpos);
    }

    /* Cluster impulse														*/
    clusterVImpulse :: (cluster: *Cluster, rpos: *btVector3, impulse: *btVector3) -> void #foreign bullet3 "?clusterVImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@1@Z";
    clusterVImpulse :: (cluster: *Cluster, rpos: btVector3, impulse: btVector3) #no_context {
        clusterVImpulse(cluster, *rpos, *impulse);
    }
    clusterDImpulse :: (cluster: *Cluster, rpos: *btVector3, impulse: *btVector3) -> void #foreign bullet3 "?clusterDImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@1@Z";
    clusterDImpulse :: (cluster: *Cluster, rpos: btVector3, impulse: btVector3) #no_context {
        clusterDImpulse(cluster, *rpos, *impulse);
    }
    clusterImpulse :: (cluster: *Cluster, rpos: *btVector3, impulse: *Impulse) -> void #foreign bullet3 "?clusterImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@AEBUImpulse@1@@Z";
    clusterImpulse :: (cluster: *Cluster, rpos: btVector3, impulse: Impulse) #no_context {
        clusterImpulse(cluster, *rpos, *impulse);
    }
    clusterVAImpulse :: (cluster: *Cluster, impulse: *btVector3) -> void #foreign bullet3 "?clusterVAImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@@Z";
    clusterVAImpulse :: (cluster: *Cluster, impulse: btVector3) #no_context {
        clusterVAImpulse(cluster, *impulse);
    }
    clusterDAImpulse :: (cluster: *Cluster, impulse: *btVector3) -> void #foreign bullet3 "?clusterDAImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@@Z";
    clusterDAImpulse :: (cluster: *Cluster, impulse: btVector3) #no_context {
        clusterDAImpulse(cluster, *impulse);
    }
    clusterAImpulse :: (cluster: *Cluster, impulse: *Impulse) -> void #foreign bullet3 "?clusterAImpulse@btSoftBody@@SAXPEAUCluster@1@AEBUImpulse@1@@Z";
    clusterAImpulse :: (cluster: *Cluster, impulse: Impulse) #no_context {
        clusterAImpulse(cluster, *impulse);
    }
    clusterDCImpulse :: (cluster: *Cluster, impulse: *btVector3) -> void #foreign bullet3 "?clusterDCImpulse@btSoftBody@@SAXPEAUCluster@1@AEBVbtVector3@@@Z";
    clusterDCImpulse :: (cluster: *Cluster, impulse: btVector3) #no_context {
        clusterDCImpulse(cluster, *impulse);
    }

    /* Generate bending constraints based on distance in the adjency graph	*/
    generateBendingConstraints :: (this: *btSoftBody, distance: s32, mat: *Material = null) -> s32 #cpp_method #foreign bullet3 "?generateBendingConstraints@btSoftBody@@QEAAHHPEAUMaterial@1@@Z";

    /* Randomize constraints to reduce solver bias							*/
    randomizeConstraints :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?randomizeConstraints@btSoftBody@@QEAAXXZ";

    updateState :: (this: *btSoftBody, qs: *btAlignedObjectArray(btVector3), vs: *btAlignedObjectArray(btVector3)) -> void #cpp_method #foreign bullet3 "?updateState@btSoftBody@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@0@Z";
    updateState :: (this: *btSoftBody, qs: btAlignedObjectArray(btVector3), vs: btAlignedObjectArray(btVector3)) #no_context {
        updateState(this, *qs, *vs);
    }

    /* Release clusters														*/
    releaseCluster :: (this: *btSoftBody, index: s32) -> void #cpp_method #foreign bullet3 "?releaseCluster@btSoftBody@@QEAAXH@Z";
    releaseClusters :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?releaseClusters@btSoftBody@@QEAAXXZ";

    /* Generate clusters (K-mean)											*/
    ///generateClusters with k=0 will create a convex cluster for each tetrahedron or triangle
    ///otherwise an approximation will be used (better performance)
    generateClusters :: (this: *btSoftBody, k: s32, maxiterations: s32 = 8192) -> s32 #cpp_method #foreign bullet3 "?generateClusters@btSoftBody@@QEAAHHH@Z";

    /* Refine																*/
    refine :: (this: *btSoftBody, ifn: *ImplicitFn, accurary: btScalar, cut: bool) -> void #cpp_method #foreign bullet3 "?refine@btSoftBody@@QEAAXPEAUImplicitFn@1@M_N@Z";

    /* CutLink																*/
    cutLink :: (this: *btSoftBody, node0: s32, node1: s32, position: btScalar) -> bool #cpp_method #foreign bullet3 "?cutLink@btSoftBody@@QEAA_NHHM@Z";
    cutLink :: (this: *btSoftBody, node0: *Node, node1: *Node, position: btScalar) -> bool #cpp_method #foreign bullet3 "?cutLink@btSoftBody@@QEAA_NPEBUNode@1@0M@Z";

    ///Ray casting using rayFrom and rayTo in worldspace, (not direction!)
    rayTest :: (this: *btSoftBody, rayFrom: *btVector3, rayTo: *btVector3, results: *sRayCast) -> bool #cpp_method #foreign bullet3 "?rayTest@btSoftBody@@QEAA_NAEBVbtVector3@@0AEAUsRayCast@1@@Z";
    rayTest :: (this: *btSoftBody, rayFrom: btVector3, rayTo: btVector3, results: *sRayCast) -> bool #no_context {
        return rayTest(this, *rayFrom, *rayTo, results);
    }

    rayFaceTest :: (this: *btSoftBody, rayFrom: *btVector3, rayTo: *btVector3, results: *sRayCast) -> bool #cpp_method #foreign bullet3 "?rayFaceTest@btSoftBody@@QEAA_NAEBVbtVector3@@0AEAUsRayCast@1@@Z";
    rayFaceTest :: (this: *btSoftBody, rayFrom: btVector3, rayTo: btVector3, results: *sRayCast) -> bool #no_context {
        return rayFaceTest(this, *rayFrom, *rayTo, results);
    }

    rayFaceTest :: (this: *btSoftBody, rayFrom: *btVector3, rayTo: *btVector3, mint: *btScalar, index: *s32) -> s32 #cpp_method #foreign bullet3 "?rayFaceTest@btSoftBody@@QEBAHAEBVbtVector3@@0AEAMAEAH@Z";
    rayFaceTest :: (this: *btSoftBody, rayFrom: btVector3, rayTo: btVector3, mint: *btScalar, index: *s32) -> s32 #no_context {
        return rayFaceTest(this, *rayFrom, *rayTo, mint, index);
    }

    /* Solver presets														*/
    setSolver :: (this: *btSoftBody, preset: eSolverPresets._) -> void #cpp_method #foreign bullet3 "?setSolver@btSoftBody@@QEAAXW4_@eSolverPresets@1@@Z";

    /* predictMotion														*/
    predictMotion :: (this: *btSoftBody, dt: btScalar) -> void #cpp_method #foreign bullet3 "?predictMotion@btSoftBody@@QEAAXM@Z";

    /* solveConstraints														*/
    solveConstraints :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?solveConstraints@btSoftBody@@QEAAXXZ";

    /* staticSolve															*/
    staticSolve :: (this: *btSoftBody, iterations: s32) -> void #cpp_method #foreign bullet3 "?staticSolve@btSoftBody@@QEAAXH@Z";

    /* solveCommonConstraints												*/
    solveCommonConstraints :: (bodies: **btSoftBody, count: s32, iterations: s32) -> void #foreign bullet3 "?solveCommonConstraints@btSoftBody@@SAXPEAPEAV1@HH@Z";

    /* solveClusters														*/
    solveClusters :: (bodies: *btAlignedObjectArray(*btSoftBody)) -> void #foreign bullet3 "?solveClusters@btSoftBody@@SAXAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@@Z";
    solveClusters :: (bodies: btAlignedObjectArray(*btSoftBody)) #no_context {
        solveClusters(*bodies);
    }

    /* integrateMotion														*/
    integrateMotion :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?integrateMotion@btSoftBody@@QEAAXXZ";

    /* defaultCollisionHandlers												*/
    defaultCollisionHandler :: (this: *btSoftBody, pcoWrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?defaultCollisionHandler@btSoftBody@@QEAAXPEBUbtCollisionObjectWrapper@@@Z";
    defaultCollisionHandler :: (this: *btSoftBody, psb: *btSoftBody) -> void #cpp_method #foreign bullet3 "?defaultCollisionHandler@btSoftBody@@QEAAXPEAV1@@Z";
    setSelfCollision :: (this: *btSoftBody, useSelfCollision: bool) -> void #cpp_method #foreign bullet3 "?setSelfCollision@btSoftBody@@QEAAX_N@Z";
    useSelfCollision :: (this: *btSoftBody) -> bool #cpp_method #foreign bullet3 "?useSelfCollision@btSoftBody@@QEAA_NXZ";
    updateDeactivation :: (this: *btSoftBody, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateDeactivation@btSoftBody@@QEAAXM@Z";
    setZeroVelocity :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?setZeroVelocity@btSoftBody@@QEAAXXZ";
    wantsSleeping :: (this: *btSoftBody) -> bool #cpp_method #foreign bullet3 "?wantsSleeping@btSoftBody@@QEAA_NXZ";

    /**
    * Set a wind velocity for interaction with the air.
    */
    setWindVelocity :: (this: *btSoftBody, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?setWindVelocity@btSoftBody@@QEAAXAEBVbtVector3@@@Z";
    setWindVelocity :: (this: *btSoftBody, velocity: btVector3) #no_context {
        setWindVelocity(this, *velocity);
    }

    /**
    * Return the wind velocity for interaction with the air.
    */
    getWindVelocity :: (this: *btSoftBody) -> *btVector3 #cpp_method #foreign bullet3 "?getWindVelocity@btSoftBody@@QEAAAEBVbtVector3@@XZ";

    //
    // Set the solver that handles this soft body
    // Should not be allowed to get out of sync with reality
    // Currently called internally on addition to the world
    setSoftBodySolver :: (this: *btSoftBody, softBodySolver: *btSoftBodySolver) -> void #cpp_method #foreign bullet3 "?setSoftBodySolver@btSoftBody@@QEAAXPEAVbtSoftBodySolver@@@Z";

    //
    // Return the solver that handles this soft body
    //
    getSoftBodySolver :: (this: *btSoftBody) -> *btSoftBodySolver #cpp_method #foreign bullet3 "?getSoftBodySolver@btSoftBody@@QEAAPEAVbtSoftBodySolver@@XZ";

    //
    // Return the solver that handles this soft body
    //
    getSoftBodySolver_1 :: (this: /*const*/ *btSoftBody) -> *btSoftBodySolver #cpp_method #foreign bullet3 "?getSoftBodySolver@btSoftBody@@QEBAPEAVbtSoftBodySolver@@XZ";

    //
    // Cast
    //
    upcast :: (colObj: /*const*/ *btCollisionObject) -> *btSoftBody #foreign bullet3 "?upcast@btSoftBody@@SAPEBV1@PEBVbtCollisionObject@@@Z";

    upcast_1 :: (colObj: *btCollisionObject) -> *btSoftBody #foreign bullet3 "?upcast@btSoftBody@@SAPEAV1@PEAVbtCollisionObject@@@Z";

    //
    // Private
    //
    pointersToIndices :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?pointersToIndices@btSoftBody@@QEAAXXZ";
    indicesToPointers :: (this: *btSoftBody, map: *s32 = null) -> void #cpp_method #foreign bullet3 "?indicesToPointers@btSoftBody@@QEAAXPEBH@Z";

    rayTest :: (this: *btSoftBody, rayFrom: *btVector3, rayTo: *btVector3, mint: *btScalar, feature: *eFeature._, index: *s32, bcountonly: bool) -> s32 #cpp_method #foreign bullet3 "?rayTest@btSoftBody@@QEBAHAEBVbtVector3@@0AEAMAEAW4_@eFeature@1@AEAH_N@Z";
    rayTest :: (this: *btSoftBody, rayFrom: btVector3, rayTo: btVector3, mint: *btScalar, feature: *eFeature._, index: *s32, bcountonly: bool) -> s32 #no_context {
        return rayTest(this, *rayFrom, *rayTo, mint, feature, index, bcountonly);
    }

    initializeFaceTree :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?initializeFaceTree@btSoftBody@@QEAAXXZ";
    rebuildNodeTree :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?rebuildNodeTree@btSoftBody@@QEAAXXZ";
    evaluateCom :: (this: *btSoftBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?evaluateCom@btSoftBody@@QEBA?AVbtVector3@@XZ";
    checkDeformableContact :: (this: *btSoftBody, colObjWrap: *btCollisionObjectWrapper, x: *btVector3, margin: btScalar, cti: *sCti, predict := false) -> bool #cpp_method #foreign bullet3 "?checkDeformableContact@btSoftBody@@QEBA_NPEBUbtCollisionObjectWrapper@@AEBVbtVector3@@MAEAUsCti@1@_N@Z";
    checkDeformableContact :: (this: *btSoftBody, colObjWrap: *btCollisionObjectWrapper, x: btVector3, margin: btScalar, cti: *sCti, predict := false) -> bool #no_context {
        return checkDeformableContact(this, colObjWrap, *x, margin, cti, predict);
    }
    checkDeformableFaceContact :: (this: *btSoftBody, colObjWrap: *btCollisionObjectWrapper, f: *Face, contact_point: *btVector3, bary: *btVector3, margin: btScalar, cti: *sCti, predict := false) -> bool #cpp_method #foreign bullet3 "?checkDeformableFaceContact@btSoftBody@@QEBA_NPEBUbtCollisionObjectWrapper@@AEAUFace@1@AEAVbtVector3@@2MAEAUsCti@1@_N@Z";
    checkContact :: (this: *btSoftBody, colObjWrap: *btCollisionObjectWrapper, x: *btVector3, margin: btScalar, cti: *sCti) -> bool #cpp_method #foreign bullet3 "?checkContact@btSoftBody@@QEBA_NPEBUbtCollisionObjectWrapper@@AEBVbtVector3@@MAEAUsCti@1@@Z";
    checkContact :: (this: *btSoftBody, colObjWrap: *btCollisionObjectWrapper, x: btVector3, margin: btScalar, cti: *sCti) -> bool #no_context {
        return checkContact(this, colObjWrap, *x, margin, cti);
    }
    updateNormals :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updateNormals@btSoftBody@@QEAAXXZ";
    updateBounds :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updateBounds@btSoftBody@@QEAAXXZ";
    updatePose :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updatePose@btSoftBody@@QEAAXXZ";
    updateConstants :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updateConstants@btSoftBody@@QEAAXXZ";
    updateLinkConstants :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updateLinkConstants@btSoftBody@@QEAAXXZ";
    updateArea :: (this: *btSoftBody, averageArea := true) -> void #cpp_method #foreign bullet3 "?updateArea@btSoftBody@@QEAAX_N@Z";
    initializeClusters :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?initializeClusters@btSoftBody@@QEAAXXZ";
    updateClusters :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updateClusters@btSoftBody@@QEAAXXZ";
    cleanupClusters :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?cleanupClusters@btSoftBody@@QEAAXXZ";
    prepareClusters :: (this: *btSoftBody, iterations: s32) -> void #cpp_method #foreign bullet3 "?prepareClusters@btSoftBody@@QEAAXH@Z";
    solveClusters :: (this: *btSoftBody, sor: btScalar) -> void #cpp_method #foreign bullet3 "?solveClusters@btSoftBody@@QEAAXM@Z";
    applyClusters :: (this: *btSoftBody, drift: bool) -> void #cpp_method #foreign bullet3 "?applyClusters@btSoftBody@@QEAAX_N@Z";
    dampClusters :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?dampClusters@btSoftBody@@QEAAXXZ";
    setSpringStiffness :: (this: *btSoftBody, k: btScalar) -> void #cpp_method #foreign bullet3 "?setSpringStiffness@btSoftBody@@QEAAXM@Z";
    setGravityFactor :: (this: *btSoftBody, gravFactor: btScalar) -> void #cpp_method #foreign bullet3 "?setGravityFactor@btSoftBody@@QEAAXM@Z";
    setCacheBarycenter :: (this: *btSoftBody, cacheBarycenter: bool) -> void #cpp_method #foreign bullet3 "?setCacheBarycenter@btSoftBody@@QEAAX_N@Z";
    initializeDmInverse :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?initializeDmInverse@btSoftBody@@QEAAXXZ";
    updateDeformation :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?updateDeformation@btSoftBody@@QEAAXXZ";
    advanceDeformation :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?advanceDeformation@btSoftBody@@QEAAXXZ";
    applyForces :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?applyForces@btSoftBody@@QEAAXXZ";
    setMaxStress :: (this: *btSoftBody, maxStress: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxStress@btSoftBody@@QEAAXM@Z";
    interpolateRenderMesh :: (this: *btSoftBody) -> void #cpp_method #foreign bullet3 "?interpolateRenderMesh@btSoftBody@@QEAAXXZ";
    setCollisionQuadrature :: (this: *btSoftBody, N: s32) -> void #cpp_method #foreign bullet3 "?setCollisionQuadrature@btSoftBody@@QEAAXH@Z";
    PSolve_Anchors :: (psb: *btSoftBody, kst: btScalar, ti: btScalar) -> void #foreign bullet3 "?PSolve_Anchors@btSoftBody@@SAXPEAV1@MM@Z";
    PSolve_RContacts :: (psb: *btSoftBody, kst: btScalar, ti: btScalar) -> void #foreign bullet3 "?PSolve_RContacts@btSoftBody@@SAXPEAV1@MM@Z";
    PSolve_SContacts :: (psb: *btSoftBody, unknown0: btScalar, ti: btScalar) -> void #foreign bullet3 "?PSolve_SContacts@btSoftBody@@SAXPEAV1@MM@Z";
    PSolve_Links :: (psb: *btSoftBody, kst: btScalar, ti: btScalar) -> void #foreign bullet3 "?PSolve_Links@btSoftBody@@SAXPEAV1@MM@Z";
    VSolve_Links :: (psb: *btSoftBody, kst: btScalar) -> void #foreign bullet3 "?VSolve_Links@btSoftBody@@SAXPEAV1@M@Z";
    getSolver :: (solver: ePSolver._) -> psolver_t #foreign bullet3 "?getSolver@btSoftBody@@SAP6AXPEAV1@MM@ZW4_@ePSolver@1@@Z";
    getSolver :: (solver: eVSolver._) -> vsolver_t #foreign bullet3 "?getSolver@btSoftBody@@SAP6AXPEAV1@M@ZW4_@eVSolver@1@@Z";
    geometricCollisionHandler :: (this: *btSoftBody, psb: *btSoftBody) -> void #cpp_method #foreign bullet3 "?geometricCollisionHandler@btSoftBody@@QEAAXPEAV1@@Z";

    updateNode :: (this: *btSoftBody, node: *btDbvtNode, use_velocity: bool, margin: bool) -> void #cpp_method #foreign bullet3 "?updateNode@btSoftBody@@QEAAXPEAUbtDbvtNode@@_N1@Z";

    updateNodeTree :: (this: *btSoftBody, use_velocity: bool, margin: bool) -> void #cpp_method #foreign bullet3 "?updateNodeTree@btSoftBody@@QEAAX_N0@Z";

    updateFaceTree :: (this: *btSoftBody, use_velocity: bool, margin: bool) -> void #cpp_method #foreign bullet3 "?updateFaceTree@btSoftBody@@QEAAX_N0@Z";

    applyRepulsionForce :: (this: *btSoftBody, timeStep: btScalar, applySpringForce: bool) -> void #cpp_method #foreign bullet3 "?applyRepulsionForce@btSoftBody@@QEAAXM_N@Z";
    #place btcollisionobject; btsoftbody_vtable: *btSoftBody_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    /* dtor																	*/
    virtual_Destructor :: (this: *btSoftBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBody@@UEAA@XZ";

    ///@todo: avoid internal softbody shape hack and move collision code to collision library
    virtual_setCollisionShape :: (this: *btSoftBody, collisionShape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?setCollisionShape@btSoftBody@@UEAAXPEAVbtCollisionShape@@@Z";

    /* Transform to given pose                                              */
    virtual_transformTo :: (this: *btSoftBody, trs: *btTransform) -> void #cpp_method #foreign bullet3 "?transformTo@btSoftBody@@UEAAXAEBVbtTransform@@@Z";

    /* Transform															*/
    virtual_transform :: (this: *btSoftBody, trs: *btTransform) -> void #cpp_method #foreign bullet3 "?transform@btSoftBody@@UEAAXAEBVbtTransform@@@Z";

    /* Translate															*/
    virtual_translate :: (this: *btSoftBody, trs: *btVector3) -> void #cpp_method #foreign bullet3 "?translate@btSoftBody@@UEAAXAEBVbtVector3@@@Z";

    /* Rotate															*/
    virtual_rotate :: (this: *btSoftBody, rot: *btQuaternion) -> void #cpp_method #foreign bullet3 "?rotate@btSoftBody@@UEAAXAEBVbtQuaternion@@@Z";

    /* Scale																*/
    virtual_scale :: (this: *btSoftBody, scl: *btVector3) -> void #cpp_method #foreign bullet3 "?scale@btSoftBody@@UEAAXAEBVbtVector3@@@Z";

    virtual_getImpulseFactor :: (this: *btSoftBody, n_node: s32) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getImpulseFactor@btSoftBody@@UEAA?AVbtMatrix3x3@@H@Z";

    //
    // ::btCollisionObject
    //
    virtual_getAabb :: (this: *btSoftBody, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btSoftBody@@UEBAXAEAVbtVector3@@0@Z";

    virtual_calculateSerializeBufferSize :: (this: *btSoftBody) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btSoftBody@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btSoftBody, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btSoftBody@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}
btSoftBody_VTable :: struct #type_info_none {
    using btcollisionobject: btCollisionObject_VTable;
    transformTo: (this: *btSoftBody, trs: *btTransform) -> void #cpp_method;

    transform: (this: *btSoftBody, trs: *btTransform) -> void #cpp_method;

    translate: (this: *btSoftBody, trs: *btVector3) -> void #cpp_method;

    rotate: (this: *btSoftBody, rot: *btQuaternion) -> void #cpp_method;

    scale: (this: *btSoftBody, scl: *btVector3) -> void #cpp_method;

    getImpulseFactor: (this: *btSoftBody, n_node: s32) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod;

    getAabb: (this: *btSoftBody, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;
}

btSoftBody_transformTo :: inline (this: *btSoftBody, trs: *btTransform) { this.btsoftbody_vtable.transformTo(this, trs); }

btSoftBody_transform :: inline (this: *btSoftBody, trs: *btTransform) { this.btsoftbody_vtable.transform(this, trs); }

btSoftBody_translate :: inline (this: *btSoftBody, trs: *btVector3) { this.btsoftbody_vtable.translate(this, trs); }

btSoftBody_rotate :: inline (this: *btSoftBody, rot: *btQuaternion) { this.btsoftbody_vtable.rotate(this, rot); }

btSoftBody_scale :: inline (this: *btSoftBody, scl: *btVector3) { this.btsoftbody_vtable.scale(this, scl); }

btSoftBody_getImpulseFactor :: inline (this: *btSoftBody, n_node: s32) -> btMatrix3x3 { return this.btsoftbody_vtable.getImpulseFactor(this, n_node); }

btSoftBody_getAabb :: inline (this: *btSoftBody, aabbMin: *btVector3, aabbMax: *btVector3) { this.btsoftbody_vtable.getAabb(this, aabbMin, aabbMax); }

vtable :: (obj: *btSoftBody) -> *btSoftBody_VTable { return obj.btsoftbody_vtable; }


DeformableContactConstraint :: struct {
    m_node:             *btSoftBody.Node;
    m_contact:          btAlignedObjectArray(*btSoftBody.RContact);
    m_total_normal_dv:  btAlignedObjectArray(btVector3);
    m_total_tangent_dv: btAlignedObjectArray(btVector3);
    m_static:           btAlignedObjectArray(bool);
    m_can_be_dynamic:   btAlignedObjectArray(bool);

    Constructor :: (this: *DeformableContactConstraint, rcontact: *btSoftBody.RContact) -> void #cpp_method #foreign bullet3 "??0DeformableContactConstraint@@QEAA@AEBURContact@btSoftBody@@@Z";
    Constructor :: (this: *DeformableContactConstraint, rcontact: btSoftBody.RContact) #no_context {
        Constructor(this, *rcontact);
    }

    Constructor :: (this: *DeformableContactConstraint) -> void #cpp_method #foreign bullet3 "??0DeformableContactConstraint@@QEAA@XZ";

    append :: (this: *DeformableContactConstraint, rcontact: *btSoftBody.RContact) -> void #cpp_method #foreign bullet3 "?append@DeformableContactConstraint@@QEAAXAEBURContact@btSoftBody@@@Z";
    append :: (this: *DeformableContactConstraint, rcontact: btSoftBody.RContact) #no_context {
        append(this, *rcontact);
    }

    replace :: (this: *DeformableContactConstraint, rcontact: *btSoftBody.RContact) -> void #cpp_method #foreign bullet3 "?replace@DeformableContactConstraint@@QEAAXAEBURContact@btSoftBody@@@Z";
    replace :: (this: *DeformableContactConstraint, rcontact: btSoftBody.RContact) #no_context {
        replace(this, *rcontact);
    }

    Destructor :: (this: *DeformableContactConstraint) -> void #cpp_method #foreign bullet3 "??1DeformableContactConstraint@@QEAA@XZ";
}

btCGProjection :: struct {
    vtable: *btCGProjection_VTable;
    TVStack :: btAlignedObjectArray(btVector3);
    TVArrayStack :: btAlignedObjectArray(btAlignedObjectArray(btVector3));
    TArrayStack :: btAlignedObjectArray(btAlignedObjectArray(btScalar));
    m_softBodies: *btAlignedObjectArray(*btSoftBody);
    m_dt:         *btScalar;

    // map from node indices to node pointers
    m_nodes:      *btAlignedObjectArray(*btSoftBody.Node);

    Constructor :: (this: *btCGProjection, softBodies: *btAlignedObjectArray(*btSoftBody), dt: *btScalar) -> void #cpp_method #foreign bullet3 "??0btCGProjection@@QEAA@AEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@AEBM@Z";
    Constructor :: (this: *btCGProjection, softBodies: *btAlignedObjectArray(*btSoftBody), dt: btScalar) #no_context {
        Constructor(this, softBodies, *dt);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCGProjection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCGProjection@@UEAA@XZ";

    virtual_reinitialize :: (this: *btCGProjection, nodeUpdated: bool) -> void #cpp_method #foreign bullet3 "?reinitialize@btCGProjection@@UEAAX_N@Z";

    virtual_setIndices :: (this: *btCGProjection, nodes: *btAlignedObjectArray(*btSoftBody.Node)) -> void #cpp_method #foreign bullet3 "?setIndices@btCGProjection@@UEAAXPEBV?$btAlignedObjectArray@PEAUNode@btSoftBody@@@@@Z";
}
btCGProjection_VTable :: struct #type_info_none {
    Destructor: (this: *btCGProjection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    project: (this: *btCGProjection, x: *btCGProjection.TVStack) -> void #cpp_method;

    setConstraints: (this: *btCGProjection) -> void #cpp_method;

    update: (this: *btCGProjection) -> btScalar #cpp_method;

    reinitialize: (this: *btCGProjection, nodeUpdated: bool) -> void #cpp_method;

    setIndices: (this: *btCGProjection, nodes: *btAlignedObjectArray(*btSoftBody.Node)) -> void #cpp_method;
}

btCGProjection_Destructor :: inline (this: *btCGProjection, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCGProjection_project :: inline (this: *btCGProjection, x: *btCGProjection.TVStack) { this.vtable.project(this, x); }

btCGProjection_setConstraints :: inline (this: *btCGProjection) { this.vtable.setConstraints(this); }

btCGProjection_update :: inline (this: *btCGProjection) -> btScalar { return this.vtable.update(this); }

btCGProjection_reinitialize :: inline (this: *btCGProjection, nodeUpdated: bool) { this.vtable.reinitialize(this, nodeUpdated); }

btCGProjection_setIndices :: inline (this: *btCGProjection, nodes: *btAlignedObjectArray(*btSoftBody.Node)) { this.vtable.setIndices(this, nodes); }



btKrylovSolver :: struct(MatrixX: Type) {
    TVStack :: btAlignedObjectArray(btVector3);

    m_maxIterations: s32;
    m_tolerance:     btScalar;
}

btConjugateGradient :: struct(MatrixX: Type) {
    #as btkrylovsolver: btKrylovSolver(MatrixX); // jai: no "using" to avoid name-clashes

    TVStack :: btAlignedObjectArray(btVector3);
    Base :: btKrylovSolver(MatrixX);
    r:       TVStack;
    p:       TVStack;
    z:       TVStack;
    temp:    TVStack;
}

btConjugateResidual :: struct(MatrixX: Type) {
    #as btkrylovsolver: btKrylovSolver(MatrixX); // jai: no "using" to avoid name-clashes

    TVStack :: btAlignedObjectArray(btVector3);
    Base :: btKrylovSolver(MatrixX);
    r:       TVStack;
    p:       TVStack;
    z:       TVStack;
    temp_p:  TVStack;
    temp_r:  TVStack;
    best_x:  TVStack;

    // temp_r = A*r
    // temp_p = A*p
    // z = M^(-1) * temp_p = M^(-1) * A * p
    best_r:  btScalar;
}

btSoftBodyTriangleData :: struct {}
btSoftBodyLinkData :: struct {}
btSoftBodyVertexData :: struct {}

btSoftBodySolver :: struct {
    vtable: *btSoftBodySolver_VTable;
    SolverTypes :: enum s32 {
        DEFAULT_SOLVER            :: 0;
        CPU_SOLVER                :: 1;
        CL_SOLVER                 :: 2;
        CL_SIMD_SOLVER            :: 3;
        DX_SOLVER                 :: 4;
        DX_SIMD_SOLVER            :: 5;
        DEFORMABLE_SOLVER         :: 6;
        REDUCED_DEFORMABLE_SOLVER :: 7;
    }

    m_numberOfPositionIterations: s32;
    m_numberOfVelocityIterations: s32;

    // Simulation timescale
    m_timeScale:                  float;

    Constructor :: (this: *btSoftBodySolver) -> void #cpp_method #foreign bullet3 "??0btSoftBodySolver@@QEAA@XZ";

    /** Return the timescale that the simulation is using */
    getTimeScale :: (this: *btSoftBodySolver) -> float #cpp_method #foreign bullet3 "?getTimeScale@btSoftBodySolver@@QEAAMXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftBodySolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBodySolver@@UEAA@XZ";

    /** Set the number of velocity constraint solver iterations this solver uses. */
    virtual_setNumberOfPositionIterations :: (this: *btSoftBodySolver, iterations: s32) -> void #cpp_method #foreign bullet3 "?setNumberOfPositionIterations@btSoftBodySolver@@UEAAXH@Z";

    /** Get the number of velocity constraint solver iterations this solver uses. */
    virtual_getNumberOfPositionIterations :: (this: *btSoftBodySolver) -> s32 #cpp_method #foreign bullet3 "?getNumberOfPositionIterations@btSoftBodySolver@@UEAAHXZ";

    /** Set the number of velocity constraint solver iterations this solver uses. */
    virtual_setNumberOfVelocityIterations :: (this: *btSoftBodySolver, iterations: s32) -> void #cpp_method #foreign bullet3 "?setNumberOfVelocityIterations@btSoftBodySolver@@UEAAXH@Z";

    /** Get the number of velocity constraint solver iterations this solver uses. */
    virtual_getNumberOfVelocityIterations :: (this: *btSoftBodySolver) -> s32 #cpp_method #foreign bullet3 "?getNumberOfVelocityIterations@btSoftBodySolver@@UEAAHXZ";
}
btSoftBodySolver_VTable :: struct #type_info_none {
    Destructor: (this: *btSoftBodySolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getSolverType: (this: *btSoftBodySolver) -> btSoftBodySolver.SolverTypes #cpp_method;

    checkInitialized: (this: *btSoftBodySolver) -> bool #cpp_method;

    optimize: (this: *btSoftBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), forceUpdate := false) -> void #cpp_method;

    copyBackToSoftBodies: (this: *btSoftBodySolver, bMove := true) -> void #cpp_method;

    predictMotion: (this: *btSoftBodySolver, solverdt: btScalar) -> void #cpp_method;

    solveConstraints: (this: *btSoftBodySolver, solverdt: btScalar) -> void #cpp_method;

    updateSoftBodies: (this: *btSoftBodySolver) -> void #cpp_method;

    processCollision: (this: *btSoftBodySolver, unknown0: *btSoftBody, unknown1: *btSoftBody) -> void #cpp_method;

    processCollision_1: (this: *btSoftBodySolver, unknown0: *btSoftBody, unknown1: /*const*/ *btCollisionObjectWrapper) -> void #cpp_method;

    setNumberOfPositionIterations: (this: *btSoftBodySolver, iterations: s32) -> void #cpp_method;

    getNumberOfPositionIterations: (this: *btSoftBodySolver) -> s32 #cpp_method;

    setNumberOfVelocityIterations: (this: *btSoftBodySolver, iterations: s32) -> void #cpp_method;

    getNumberOfVelocityIterations: (this: *btSoftBodySolver) -> s32 #cpp_method;
}

btSoftBodySolver_Destructor :: inline (this: *btSoftBodySolver, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btSoftBodySolver_getSolverType :: inline (this: *btSoftBodySolver) -> btSoftBodySolver.SolverTypes { return this.vtable.getSolverType(this); }

btSoftBodySolver_checkInitialized :: inline (this: *btSoftBodySolver) -> bool { return this.vtable.checkInitialized(this); }

btSoftBodySolver_optimize :: inline (this: *btSoftBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), forceUpdate := false) { this.vtable.optimize(this, softBodies, forceUpdate); }

btSoftBodySolver_copyBackToSoftBodies :: inline (this: *btSoftBodySolver, bMove := true) { this.vtable.copyBackToSoftBodies(this, bMove); }

btSoftBodySolver_predictMotion :: inline (this: *btSoftBodySolver, solverdt: btScalar) { this.vtable.predictMotion(this, solverdt); }

btSoftBodySolver_solveConstraints :: inline (this: *btSoftBodySolver, solverdt: btScalar) { this.vtable.solveConstraints(this, solverdt); }

btSoftBodySolver_updateSoftBodies :: inline (this: *btSoftBodySolver) { this.vtable.updateSoftBodies(this); }

btSoftBodySolver_processCollision :: inline (this: *btSoftBodySolver, unknown0: *btSoftBody, unknown1: *btSoftBody) { this.vtable.processCollision(this, unknown0, unknown1); }

btSoftBodySolver_processCollision_1 :: inline (this: *btSoftBodySolver, unknown0: *btSoftBody, unknown1: /*const*/ *btCollisionObjectWrapper) { this.vtable.processCollision_1(this, unknown0, unknown1); }

btSoftBodySolver_setNumberOfPositionIterations :: inline (this: *btSoftBodySolver, iterations: s32) { this.vtable.setNumberOfPositionIterations(this, iterations); }

btSoftBodySolver_getNumberOfPositionIterations :: inline (this: *btSoftBodySolver) -> s32 { return this.vtable.getNumberOfPositionIterations(this); }

btSoftBodySolver_setNumberOfVelocityIterations :: inline (this: *btSoftBodySolver, iterations: s32) { this.vtable.setNumberOfVelocityIterations(this, iterations); }

btSoftBodySolver_getNumberOfVelocityIterations :: inline (this: *btSoftBodySolver) -> s32 { return this.vtable.getNumberOfVelocityIterations(this); }



/** 
* Class to manage movement of data from a solver to a given target.
* This version is abstract. Subclasses will have custom pairings for different combinations.
*/
btSoftBodySolverOutput :: struct {
    vtable: *btSoftBodySolverOutput_VTable;
    Constructor :: (this: *btSoftBodySolverOutput) -> void #cpp_method #foreign bullet3 "??0btSoftBodySolverOutput@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftBodySolverOutput, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBodySolverOutput@@UEAA@XZ";
}
btSoftBodySolverOutput_VTable :: struct #type_info_none {
    Destructor: (this: *btSoftBodySolverOutput, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    copySoftBodyToVertexBuffer: (this: *btSoftBodySolverOutput, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) -> void #cpp_method;
}

btSoftBodySolverOutput_Destructor :: inline (this: *btSoftBodySolverOutput, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btSoftBodySolverOutput_copySoftBodyToVertexBuffer :: inline (this: *btSoftBodySolverOutput, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) { this.vtable.copySoftBodyToVertexBuffer(this, softBody, vertexBuffer); }



btVertexBufferDescriptor :: struct {
    vtable: *btVertexBufferDescriptor_VTable;
    BufferTypes :: enum s32 {
        CPU_BUFFER    :: 0;
        DX11_BUFFER   :: 1;
        OPENGL_BUFFER :: 2;
    }

    m_hasVertexPositions: bool;
    m_hasNormals:         bool;

    m_vertexOffset:       s32;
    m_vertexStride:       s32;

    m_normalOffset:       s32;
    m_normalStride:       s32;

    Constructor :: (this: *btVertexBufferDescriptor) -> void #cpp_method #foreign bullet3 "??0btVertexBufferDescriptor@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btVertexBufferDescriptor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btVertexBufferDescriptor@@UEAA@XZ";

    virtual_hasVertexPositions :: (this: *btVertexBufferDescriptor) -> bool #cpp_method #foreign bullet3 "?hasVertexPositions@btVertexBufferDescriptor@@UEBA_NXZ";

    virtual_hasNormals :: (this: *btVertexBufferDescriptor) -> bool #cpp_method #foreign bullet3 "?hasNormals@btVertexBufferDescriptor@@UEBA_NXZ";

    /**
    * Return the vertex offset in floats from the base pointer.
    */
    virtual_getVertexOffset :: (this: *btVertexBufferDescriptor) -> s32 #cpp_method #foreign bullet3 "?getVertexOffset@btVertexBufferDescriptor@@UEBAHXZ";

    /**
    * Return the vertex stride in number of floats between vertices.
    */
    virtual_getVertexStride :: (this: *btVertexBufferDescriptor) -> s32 #cpp_method #foreign bullet3 "?getVertexStride@btVertexBufferDescriptor@@UEBAHXZ";

    /**
    * Return the vertex offset in floats from the base pointer.
    */
    virtual_getNormalOffset :: (this: *btVertexBufferDescriptor) -> s32 #cpp_method #foreign bullet3 "?getNormalOffset@btVertexBufferDescriptor@@UEBAHXZ";

    /**
    * Return the vertex stride in number of floats between vertices.
    */
    virtual_getNormalStride :: (this: *btVertexBufferDescriptor) -> s32 #cpp_method #foreign bullet3 "?getNormalStride@btVertexBufferDescriptor@@UEBAHXZ";
}
btVertexBufferDescriptor_VTable :: struct #type_info_none {
    Destructor: (this: *btVertexBufferDescriptor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    hasVertexPositions: (this: *btVertexBufferDescriptor) -> bool #cpp_method;

    hasNormals: (this: *btVertexBufferDescriptor) -> bool #cpp_method;

    getBufferType: (this: *btVertexBufferDescriptor) -> btVertexBufferDescriptor.BufferTypes #cpp_method;

    getVertexOffset: (this: *btVertexBufferDescriptor) -> s32 #cpp_method;

    getVertexStride: (this: *btVertexBufferDescriptor) -> s32 #cpp_method;

    getNormalOffset: (this: *btVertexBufferDescriptor) -> s32 #cpp_method;

    getNormalStride: (this: *btVertexBufferDescriptor) -> s32 #cpp_method;
}

btVertexBufferDescriptor_Destructor :: inline (this: *btVertexBufferDescriptor, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btVertexBufferDescriptor_hasVertexPositions :: inline (this: *btVertexBufferDescriptor) -> bool { return this.vtable.hasVertexPositions(this); }

btVertexBufferDescriptor_hasNormals :: inline (this: *btVertexBufferDescriptor) -> bool { return this.vtable.hasNormals(this); }

btVertexBufferDescriptor_getBufferType :: inline (this: *btVertexBufferDescriptor) -> btVertexBufferDescriptor.BufferTypes { return this.vtable.getBufferType(this); }

btVertexBufferDescriptor_getVertexOffset :: inline (this: *btVertexBufferDescriptor) -> s32 { return this.vtable.getVertexOffset(this); }

btVertexBufferDescriptor_getVertexStride :: inline (this: *btVertexBufferDescriptor) -> s32 { return this.vtable.getVertexStride(this); }

btVertexBufferDescriptor_getNormalOffset :: inline (this: *btVertexBufferDescriptor) -> s32 { return this.vtable.getNormalOffset(this); }

btVertexBufferDescriptor_getNormalStride :: inline (this: *btVertexBufferDescriptor) -> s32 { return this.vtable.getNormalStride(this); }



btCPUVertexBufferDescriptor :: struct {
    #as using btvertexbufferdescriptor: btVertexBufferDescriptor;

    m_basePointer: *float;

    /**
    * vertexBasePointer is pointer to beginning of the buffer.
    * vertexOffset is the offset in floats to the first vertex.
    * vertexStride is the stride in floats between vertices.
    */
    Constructor :: (this: *btCPUVertexBufferDescriptor, basePointer: *float, vertexOffset: s32, vertexStride: s32) -> void #cpp_method #foreign bullet3 "??0btCPUVertexBufferDescriptor@@QEAA@PEAMHH@Z";

    /**
    * vertexBasePointer is pointer to beginning of the buffer.
    * vertexOffset is the offset in floats to the first vertex.
    * vertexStride is the stride in floats between vertices.
    */
    Constructor :: (this: *btCPUVertexBufferDescriptor, basePointer: *float, vertexOffset: s32, vertexStride: s32, normalOffset: s32, normalStride: s32) -> void #cpp_method #foreign bullet3 "??0btCPUVertexBufferDescriptor@@QEAA@PEAMHHHH@Z";
    #place btvertexbufferdescriptor; btcpuvertexbufferdescriptor_vtable: *btCPUVertexBufferDescriptor_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCPUVertexBufferDescriptor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCPUVertexBufferDescriptor@@UEAA@XZ";

    /**
    * Return the type of the vertex buffer descriptor.
    */
    virtual_getBufferType :: (this: *btCPUVertexBufferDescriptor) -> btVertexBufferDescriptor.BufferTypes #cpp_method #foreign bullet3 "?getBufferType@btCPUVertexBufferDescriptor@@UEBA?AW4BufferTypes@btVertexBufferDescriptor@@XZ";

    /**
    * Return the base pointer in memory to the first vertex.
    */
    virtual_getBasePointer :: (this: *btCPUVertexBufferDescriptor) -> *float #cpp_method #foreign bullet3 "?getBasePointer@btCPUVertexBufferDescriptor@@UEBAPEAMXZ";
}
btCPUVertexBufferDescriptor_VTable :: struct #type_info_none {
    using btvertexbufferdescriptor: btVertexBufferDescriptor_VTable;
    getBasePointer: (this: *btCPUVertexBufferDescriptor) -> *float #cpp_method;
}
btCPUVertexBufferDescriptor_getBasePointer :: inline (this: *btCPUVertexBufferDescriptor) -> *float { return this.btcpuvertexbufferdescriptor_vtable.getBasePointer(this); }

vtable :: (obj: *btCPUVertexBufferDescriptor) -> *btCPUVertexBufferDescriptor_VTable { return obj.btcpuvertexbufferdescriptor_vtable; }


btDefaultSoftBodySolver :: struct {
    #as using btsoftbodysolver: btSoftBodySolver;

    /** Variable to define whether we need to update solver constants on the next iteration */
    m_updateSolverConstants: bool;

    m_softBodySet:           btAlignedObjectArray(*btSoftBody);

    Constructor :: (this: *btDefaultSoftBodySolver) -> void #cpp_method #foreign bullet3 "??0btDefaultSoftBodySolver@@QEAA@XZ";
    #place btsoftbodysolver; btdefaultsoftbodysolver_vtable: *btDefaultSoftBodySolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDefaultSoftBodySolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDefaultSoftBodySolver@@UEAA@XZ";

    virtual_getSolverType :: (this: *btDefaultSoftBodySolver) -> btSoftBodySolver.SolverTypes #cpp_method #foreign bullet3 "?getSolverType@btDefaultSoftBodySolver@@UEBA?AW4SolverTypes@btSoftBodySolver@@XZ";

    virtual_checkInitialized :: (this: *btDefaultSoftBodySolver) -> bool #cpp_method #foreign bullet3 "?checkInitialized@btDefaultSoftBodySolver@@UEAA_NXZ";

    virtual_updateSoftBodies :: (this: *btDefaultSoftBodySolver) -> void #cpp_method #foreign bullet3 "?updateSoftBodies@btDefaultSoftBodySolver@@UEAAXXZ";

    virtual_optimize :: (this: *btDefaultSoftBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), forceUpdate := false) -> void #cpp_method #foreign bullet3 "?optimize@btDefaultSoftBodySolver@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@_N@Z";

    virtual_copyBackToSoftBodies :: (this: *btDefaultSoftBodySolver, bMove := true) -> void #cpp_method #foreign bullet3 "?copyBackToSoftBodies@btDefaultSoftBodySolver@@UEAAX_N@Z";

    virtual_solveConstraints :: (this: *btDefaultSoftBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?solveConstraints@btDefaultSoftBodySolver@@UEAAXM@Z";

    virtual_predictMotion :: (this: *btDefaultSoftBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?predictMotion@btDefaultSoftBodySolver@@UEAAXM@Z";

    virtual_copySoftBodyToVertexBuffer :: (this: *btDefaultSoftBodySolver, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) -> void #cpp_method #foreign bullet3 "?copySoftBodyToVertexBuffer@btDefaultSoftBodySolver@@UEAAXQEBVbtSoftBody@@PEAVbtVertexBufferDescriptor@@@Z";

    virtual_processCollision :: (this: *btDefaultSoftBodySolver, unknown0: *btSoftBody, unknown1: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?processCollision@btDefaultSoftBodySolver@@UEAAXPEAVbtSoftBody@@PEBUbtCollisionObjectWrapper@@@Z";

    virtual_processCollision :: (this: *btDefaultSoftBodySolver, unknown0: *btSoftBody, unknown1: *btSoftBody) -> void #cpp_method #foreign bullet3 "?processCollision@btDefaultSoftBodySolver@@UEAAXPEAVbtSoftBody@@0@Z";
}
btDefaultSoftBodySolver_VTable :: struct #type_info_none {
    using btsoftbodysolver: btSoftBodySolver_VTable;
    copySoftBodyToVertexBuffer: (this: *btDefaultSoftBodySolver, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) -> void #cpp_method;
}
btDefaultSoftBodySolver_copySoftBodyToVertexBuffer :: inline (this: *btDefaultSoftBodySolver, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) { this.btdefaultsoftbodysolver_vtable.copySoftBodyToVertexBuffer(this, softBody, vertexBuffer); }

vtable :: (obj: *btDefaultSoftBodySolver) -> *btDefaultSoftBodySolver_VTable { return obj.btdefaultsoftbodysolver_vtable; }


btDeformableLagrangianForceType :: enum s32 {
    GRAVITY_FORCE           :: 1;
    MASSSPRING_FORCE        :: 2;
    COROTATED_FORCE         :: 3;
    NEOHOOKEAN_FORCE        :: 4;
    LINEAR_ELASTICITY_FORCE :: 5;
    MOUSE_PICKING_FORCE     :: 6;

    BT_GRAVITY_FORCE           :: GRAVITY_FORCE;
    BT_MASSSPRING_FORCE        :: MASSSPRING_FORCE;
    BT_COROTATED_FORCE         :: COROTATED_FORCE;
    BT_NEOHOOKEAN_FORCE        :: NEOHOOKEAN_FORCE;
    BT_LINEAR_ELASTICITY_FORCE :: LINEAR_ELASTICITY_FORCE;
    BT_MOUSE_PICKING_FORCE     :: MOUSE_PICKING_FORCE;
}

btDeformableLagrangianForce :: struct {
    vtable: *btDeformableLagrangianForce_VTable;
    TVStack :: btAlignedObjectArray(btVector3);
    m_softBodies: btAlignedObjectArray(*btSoftBody);
    m_nodes:      *btAlignedObjectArray(*btSoftBody.Node);

    Constructor :: (this: *btDeformableLagrangianForce) -> void #cpp_method #foreign bullet3 "??0btDeformableLagrangianForce@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableLagrangianForce, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableLagrangianForce@@UEAA@XZ";

    virtual_addScaledHessian :: (this: *btDeformableLagrangianForce, scale: btScalar) -> void #cpp_method #foreign bullet3 "?addScaledHessian@btDeformableLagrangianForce@@UEAAXM@Z";

    virtual_reinitialize :: (this: *btDeformableLagrangianForce, nodeUpdated: bool) -> void #cpp_method #foreign bullet3 "?reinitialize@btDeformableLagrangianForce@@UEAAX_N@Z";

    // get number of nodes that have the force
    virtual_getNumNodes :: (this: *btDeformableLagrangianForce) -> s32 #cpp_method #foreign bullet3 "?getNumNodes@btDeformableLagrangianForce@@UEAAHXZ";

    // add a soft body to be affected by the particular lagrangian force
    virtual_addSoftBody :: (this: *btDeformableLagrangianForce, psb: *btSoftBody) -> void #cpp_method #foreign bullet3 "?addSoftBody@btDeformableLagrangianForce@@UEAAXPEAVbtSoftBody@@@Z";

    virtual_removeSoftBody :: (this: *btDeformableLagrangianForce, psb: *btSoftBody) -> void #cpp_method #foreign bullet3 "?removeSoftBody@btDeformableLagrangianForce@@UEAAXPEAVbtSoftBody@@@Z";

    virtual_setIndices :: (this: *btDeformableLagrangianForce, nodes: *btAlignedObjectArray(*btSoftBody.Node)) -> void #cpp_method #foreign bullet3 "?setIndices@btDeformableLagrangianForce@@UEAAXPEBV?$btAlignedObjectArray@PEAUNode@btSoftBody@@@@@Z";

    // Calculate the incremental deformable generated from the input dx
    virtual_Ds :: (this: *btDeformableLagrangianForce, id0: s32, id1: s32, id2: s32, id3: s32, dx: *TVStack) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?Ds@btDeformableLagrangianForce@@UEAA?AVbtMatrix3x3@@HHHHAEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // Calculate the incremental deformable generated from the current velocity
    virtual_DsFromVelocity :: (this: *btDeformableLagrangianForce, n0: *btSoftBody.Node, n1: *btSoftBody.Node, n2: *btSoftBody.Node, n3: *btSoftBody.Node) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?DsFromVelocity@btDeformableLagrangianForce@@UEAA?AVbtMatrix3x3@@PEBUNode@btSoftBody@@000@Z";

    // test for addScaledElasticForce function
    virtual_testDerivative :: (this: *btDeformableLagrangianForce) -> void #cpp_method #foreign bullet3 "?testDerivative@btDeformableLagrangianForce@@UEAAXXZ";

    // test for addScaledElasticForce function
    virtual_testHessian :: (this: *btDeformableLagrangianForce) -> void #cpp_method #foreign bullet3 "?testHessian@btDeformableLagrangianForce@@UEAAXXZ";

    //
    virtual_totalElasticEnergy :: (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalElasticEnergy@btDeformableLagrangianForce@@UEAANM@Z";

    //
    virtual_totalDampingEnergy :: (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalDampingEnergy@btDeformableLagrangianForce@@UEAANM@Z";

    // total Energy takes dt as input because certain energies depend on dt
    virtual_totalEnergy :: (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalEnergy@btDeformableLagrangianForce@@UEAANM@Z";
}
btDeformableLagrangianForce_VTable :: struct #type_info_none {
    Destructor: (this: *btDeformableLagrangianForce, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    addScaledForces: (this: *btDeformableLagrangianForce, scale: btScalar, force: *btDeformableLagrangianForce.TVStack) -> void #cpp_method;

    addScaledDampingForceDifferential: (this: *btDeformableLagrangianForce, scale: btScalar, dv: *btDeformableLagrangianForce.TVStack, df: *btDeformableLagrangianForce.TVStack) -> void #cpp_method;

    buildDampingForceDifferentialDiagonal: (this: *btDeformableLagrangianForce, scale: btScalar, diagA: *btDeformableLagrangianForce.TVStack) -> void #cpp_method;

    addScaledElasticForceDifferential: (this: *btDeformableLagrangianForce, scale: btScalar, dx: *btDeformableLagrangianForce.TVStack, df: *btDeformableLagrangianForce.TVStack) -> void #cpp_method;

    addScaledExplicitForce: (this: *btDeformableLagrangianForce, scale: btScalar, force: *btDeformableLagrangianForce.TVStack) -> void #cpp_method;

    addScaledDampingForce: (this: *btDeformableLagrangianForce, scale: btScalar, force: *btDeformableLagrangianForce.TVStack) -> void #cpp_method;

    addScaledHessian: (this: *btDeformableLagrangianForce, scale: btScalar) -> void #cpp_method;

    getForceType: (this: *btDeformableLagrangianForce) -> btDeformableLagrangianForceType #cpp_method;

    reinitialize: (this: *btDeformableLagrangianForce, nodeUpdated: bool) -> void #cpp_method;

    getNumNodes: (this: *btDeformableLagrangianForce) -> s32 #cpp_method;

    addSoftBody: (this: *btDeformableLagrangianForce, psb: *btSoftBody) -> void #cpp_method;

    removeSoftBody: (this: *btDeformableLagrangianForce, psb: *btSoftBody) -> void #cpp_method;

    setIndices: (this: *btDeformableLagrangianForce, nodes: *btAlignedObjectArray(*btSoftBody.Node)) -> void #cpp_method;

    Ds: (this: *btDeformableLagrangianForce, id0: s32, id1: s32, id2: s32, id3: s32, dx: *btDeformableLagrangianForce.TVStack) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod;

    DsFromVelocity: (this: *btDeformableLagrangianForce, n0: *btSoftBody.Node, n1: *btSoftBody.Node, n2: *btSoftBody.Node, n3: *btSoftBody.Node) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod;

    testDerivative: (this: *btDeformableLagrangianForce) -> void #cpp_method;

    testHessian: (this: *btDeformableLagrangianForce) -> void #cpp_method;

    totalElasticEnergy: (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 #cpp_method;

    totalDampingEnergy: (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 #cpp_method;

    totalEnergy: (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 #cpp_method;
}

btDeformableLagrangianForce_Destructor :: inline (this: *btDeformableLagrangianForce, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btDeformableLagrangianForce_addScaledForces :: inline (this: *btDeformableLagrangianForce, scale: btScalar, force: *btDeformableLagrangianForce.TVStack) { this.vtable.addScaledForces(this, scale, force); }

btDeformableLagrangianForce_addScaledDampingForceDifferential :: inline (this: *btDeformableLagrangianForce, scale: btScalar, dv: *btDeformableLagrangianForce.TVStack, df: *btDeformableLagrangianForce.TVStack) { this.vtable.addScaledDampingForceDifferential(this, scale, dv, df); }

btDeformableLagrangianForce_buildDampingForceDifferentialDiagonal :: inline (this: *btDeformableLagrangianForce, scale: btScalar, diagA: *btDeformableLagrangianForce.TVStack) { this.vtable.buildDampingForceDifferentialDiagonal(this, scale, diagA); }

btDeformableLagrangianForce_addScaledElasticForceDifferential :: inline (this: *btDeformableLagrangianForce, scale: btScalar, dx: *btDeformableLagrangianForce.TVStack, df: *btDeformableLagrangianForce.TVStack) { this.vtable.addScaledElasticForceDifferential(this, scale, dx, df); }

btDeformableLagrangianForce_addScaledExplicitForce :: inline (this: *btDeformableLagrangianForce, scale: btScalar, force: *btDeformableLagrangianForce.TVStack) { this.vtable.addScaledExplicitForce(this, scale, force); }

btDeformableLagrangianForce_addScaledDampingForce :: inline (this: *btDeformableLagrangianForce, scale: btScalar, force: *btDeformableLagrangianForce.TVStack) { this.vtable.addScaledDampingForce(this, scale, force); }

btDeformableLagrangianForce_addScaledHessian :: inline (this: *btDeformableLagrangianForce, scale: btScalar) { this.vtable.addScaledHessian(this, scale); }

btDeformableLagrangianForce_getForceType :: inline (this: *btDeformableLagrangianForce) -> btDeformableLagrangianForceType { return this.vtable.getForceType(this); }

btDeformableLagrangianForce_reinitialize :: inline (this: *btDeformableLagrangianForce, nodeUpdated: bool) { this.vtable.reinitialize(this, nodeUpdated); }

btDeformableLagrangianForce_getNumNodes :: inline (this: *btDeformableLagrangianForce) -> s32 { return this.vtable.getNumNodes(this); }

btDeformableLagrangianForce_addSoftBody :: inline (this: *btDeformableLagrangianForce, psb: *btSoftBody) { this.vtable.addSoftBody(this, psb); }

btDeformableLagrangianForce_removeSoftBody :: inline (this: *btDeformableLagrangianForce, psb: *btSoftBody) { this.vtable.removeSoftBody(this, psb); }

btDeformableLagrangianForce_setIndices :: inline (this: *btDeformableLagrangianForce, nodes: *btAlignedObjectArray(*btSoftBody.Node)) { this.vtable.setIndices(this, nodes); }

btDeformableLagrangianForce_Ds :: inline (this: *btDeformableLagrangianForce, id0: s32, id1: s32, id2: s32, id3: s32, dx: *btDeformableLagrangianForce.TVStack) -> btMatrix3x3 { return this.vtable.Ds(this, id0, id1, id2, id3, dx); }

btDeformableLagrangianForce_DsFromVelocity :: inline (this: *btDeformableLagrangianForce, n0: *btSoftBody.Node, n1: *btSoftBody.Node, n2: *btSoftBody.Node, n3: *btSoftBody.Node) -> btMatrix3x3 { return this.vtable.DsFromVelocity(this, n0, n1, n2, n3); }

btDeformableLagrangianForce_testDerivative :: inline (this: *btDeformableLagrangianForce) { this.vtable.testDerivative(this); }

btDeformableLagrangianForce_testHessian :: inline (this: *btDeformableLagrangianForce) { this.vtable.testHessian(this); }

btDeformableLagrangianForce_totalElasticEnergy :: inline (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 { return this.vtable.totalElasticEnergy(this, dt); }

btDeformableLagrangianForce_totalDampingEnergy :: inline (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 { return this.vtable.totalDampingEnergy(this, dt); }

btDeformableLagrangianForce_totalEnergy :: inline (this: *btDeformableLagrangianForce, dt: btScalar) -> float64 { return this.vtable.totalEnergy(this, dt); }



btDeformableMassSpringForce :: struct {
    #as btdeformablelagrangianforce: btDeformableLagrangianForce; // jai: no "using" to avoid name-clashes

    // If true, the damping force will be in the direction of the spring
    // If false, the damping force will be in the direction of the velocity
    m_momentum_conserving: bool;
    m_elasticStiffness:    btScalar;
    m_dampingStiffness:    btScalar;
    m_bendingStiffness:    btScalar;

    TVStack :: btAlignedObjectArray(btVector3);
    Constructor :: (this: *btDeformableMassSpringForce) -> void #cpp_method #foreign bullet3 "??0btDeformableMassSpringForce@@QEAA@XZ";

    Constructor :: (this: *btDeformableMassSpringForce, k: btScalar, d: btScalar, conserve_angular := true, bending_k: float64 = -1) -> void #cpp_method #foreign bullet3 "??0btDeformableMassSpringForce@@QEAA@MM_NN@Z";
    #place btdeformablelagrangianforce; btdeformablemassspringforce_vtable: *btDeformableMassSpringForce_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_addScaledForces :: (this: *btDeformableMassSpringForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledForces@btDeformableMassSpringForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledExplicitForce :: (this: *btDeformableMassSpringForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledExplicitForce@btDeformableMassSpringForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledDampingForce :: (this: *btDeformableMassSpringForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForce@btDeformableMassSpringForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledElasticForce :: (this: *btDeformableMassSpringForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForce@btDeformableMassSpringForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledDampingForceDifferential :: (this: *btDeformableMassSpringForce, scale: btScalar, dv: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForceDifferential@btDeformableMassSpringForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_buildDampingForceDifferentialDiagonal :: (this: *btDeformableMassSpringForce, scale: btScalar, diagA: *TVStack) -> void #cpp_method #foreign bullet3 "?buildDampingForceDifferentialDiagonal@btDeformableMassSpringForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_totalElasticEnergy :: (this: *btDeformableMassSpringForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalElasticEnergy@btDeformableMassSpringForce@@UEAANM@Z";

    virtual_totalDampingEnergy :: (this: *btDeformableMassSpringForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalDampingEnergy@btDeformableMassSpringForce@@UEAANM@Z";

    virtual_addScaledElasticForceDifferential :: (this: *btDeformableMassSpringForce, scale: btScalar, dx: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForceDifferential@btDeformableMassSpringForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_getForceType :: (this: *btDeformableMassSpringForce) -> btDeformableLagrangianForceType #cpp_method #foreign bullet3 "?getForceType@btDeformableMassSpringForce@@UEAA?AW4btDeformableLagrangianForceType@@XZ";
}
btDeformableMassSpringForce_VTable :: struct #type_info_none {
    using btdeformablelagrangianforce: btDeformableLagrangianForce_VTable;
    addScaledElasticForce: (this: *btDeformableMassSpringForce, scale: btScalar, force: *btDeformableMassSpringForce.TVStack) -> void #cpp_method;
}
btDeformableMassSpringForce_addScaledElasticForce :: inline (this: *btDeformableMassSpringForce, scale: btScalar, force: *btDeformableMassSpringForce.TVStack) { this.btdeformablemassspringforce_vtable.addScaledElasticForce(this, scale, force); }

vtable :: (obj: *btDeformableMassSpringForce) -> *btDeformableMassSpringForce_VTable { return obj.btdeformablemassspringforce_vtable; }


btDeformableGravityForce :: struct {
    #as btdeformablelagrangianforce: btDeformableLagrangianForce; // jai: no "using" to avoid name-clashes

    TVStack :: btAlignedObjectArray(btVector3);
    m_gravity: btVector3;

    Constructor :: (this: *btDeformableGravityForce, g: *btVector3) -> void #cpp_method #foreign bullet3 "??0btDeformableGravityForce@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btDeformableGravityForce, g: btVector3) #no_context {
        Constructor(this, *g);
    }
    #place btdeformablelagrangianforce; btdeformablegravityforce_vtable: *btDeformableGravityForce_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_addScaledForces :: (this: *btDeformableGravityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledForces@btDeformableGravityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledExplicitForce :: (this: *btDeformableGravityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledExplicitForce@btDeformableGravityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledDampingForce :: (this: *btDeformableGravityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForce@btDeformableGravityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledElasticForceDifferential :: (this: *btDeformableGravityForce, scale: btScalar, dx: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForceDifferential@btDeformableGravityForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_addScaledDampingForceDifferential :: (this: *btDeformableGravityForce, scale: btScalar, dv: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForceDifferential@btDeformableGravityForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_buildDampingForceDifferentialDiagonal :: (this: *btDeformableGravityForce, scale: btScalar, diagA: *TVStack) -> void #cpp_method #foreign bullet3 "?buildDampingForceDifferentialDiagonal@btDeformableGravityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledGravityForce :: (this: *btDeformableGravityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledGravityForce@btDeformableGravityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_getForceType :: (this: *btDeformableGravityForce) -> btDeformableLagrangianForceType #cpp_method #foreign bullet3 "?getForceType@btDeformableGravityForce@@UEAA?AW4btDeformableLagrangianForceType@@XZ";

    // the gravitational potential energy
    virtual_totalEnergy :: (this: *btDeformableGravityForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalEnergy@btDeformableGravityForce@@UEAANM@Z";
}
btDeformableGravityForce_VTable :: struct #type_info_none {
    using btdeformablelagrangianforce: btDeformableLagrangianForce_VTable;
    addScaledGravityForce: (this: *btDeformableGravityForce, scale: btScalar, force: *btDeformableGravityForce.TVStack) -> void #cpp_method;
}
btDeformableGravityForce_addScaledGravityForce :: inline (this: *btDeformableGravityForce, scale: btScalar, force: *btDeformableGravityForce.TVStack) { this.btdeformablegravityforce_vtable.addScaledGravityForce(this, scale, force); }

vtable :: (obj: *btDeformableGravityForce) -> *btDeformableGravityForce_VTable { return obj.btdeformablegravityforce_vtable; }


/**
* This class is used to compute the polar decomposition of a matrix. In
* general, the polar decomposition factorizes a matrix, A, into two parts: a
* unitary matrix (U) and a positive, semi-definite Hermitian matrix (H).
* However, in this particular implementation the original matrix, A, is
* required to be a square 3x3 matrix with real elements. This means that U will
* be an orthogonal matrix and H with be a positive-definite, symmetric matrix.
*/
btPolarDecomposition :: struct {
    /**
    * Creates an instance with optional parameters.
    *
    * @param tolerance     - the tolerance used to determine convergence of the
    *                        algorithm
    * @param maxIterations - the maximum number of iterations used to achieve
    *                        convergence
    */
    Constructor :: (this: *btPolarDecomposition, tolerance: btScalar, maxIterations: u32 = 16) -> void #cpp_method #foreign bullet3 "??0btPolarDecomposition@@QEAA@MI@Z";

    /**
    * Decomposes a matrix into orthogonal and symmetric, positive-definite
    * parts. If the number of iterations returned by this function is equal to
    * the maximum number of iterations, the algorithm has failed to converge.
    *
    * @param a - the original matrix
    * @param u - the resulting orthogonal matrix
    * @param h - the resulting symmetric matrix
    *
    * @return the number of iterations performed by the algorithm.
    */
    decompose :: (this: *btPolarDecomposition, a: *btMatrix3x3, u: *btMatrix3x3, h: *btMatrix3x3) -> u32 #cpp_method #foreign bullet3 "?decompose@btPolarDecomposition@@QEBAIAEBVbtMatrix3x3@@AEAV2@1@Z";
    decompose :: (this: *btPolarDecomposition, a: btMatrix3x3, u: *btMatrix3x3, h: *btMatrix3x3) -> u32 #no_context {
        return decompose(this, *a, u, h);
    }

    /**
    * Returns the maximum number of iterations that this algorithm will perform
    * to achieve convergence.
    *
    * @return maximum number of iterations
    */
    maxIterations :: (this: *btPolarDecomposition) -> u32 #cpp_method #foreign bullet3 "?maxIterations@btPolarDecomposition@@QEBAIXZ";

    m_tolerance:     btScalar;
    m_maxIterations: u32;
}

btDeformableCorotatedForce :: struct {
    #as btdeformablelagrangianforce: btDeformableLagrangianForce; // jai: no "using" to avoid name-clashes

    TVStack :: btAlignedObjectArray(btVector3);
    m_mu:     btScalar;
    m_lambda: btScalar;
    Constructor :: (this: *btDeformableCorotatedForce) -> void #cpp_method #foreign bullet3 "??0btDeformableCorotatedForce@@QEAA@XZ";

    Constructor :: (this: *btDeformableCorotatedForce, mu: btScalar, lambda: btScalar) -> void #cpp_method #foreign bullet3 "??0btDeformableCorotatedForce@@QEAA@MM@Z";

    firstPiola :: (this: *btDeformableCorotatedForce, F: *btMatrix3x3, P: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiola@btDeformableCorotatedForce@@QEAAXAEBVbtMatrix3x3@@AEAV2@@Z";
    firstPiola :: (this: *btDeformableCorotatedForce, F: btMatrix3x3, P: *btMatrix3x3) #no_context {
        firstPiola(this, *F, P);
    }
    #place btdeformablelagrangianforce; btdeformablecorotatedforce_vtable: *btDeformableCorotatedForce_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_addScaledForces :: (this: *btDeformableCorotatedForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledForces@btDeformableCorotatedForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledExplicitForce :: (this: *btDeformableCorotatedForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledExplicitForce@btDeformableCorotatedForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledDampingForce :: (this: *btDeformableCorotatedForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForce@btDeformableCorotatedForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledElasticForce :: (this: *btDeformableCorotatedForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForce@btDeformableCorotatedForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledElasticForceDifferential :: (this: *btDeformableCorotatedForce, scale: btScalar, dx: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForceDifferential@btDeformableCorotatedForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_addScaledDampingForceDifferential :: (this: *btDeformableCorotatedForce, scale: btScalar, dv: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForceDifferential@btDeformableCorotatedForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_buildDampingForceDifferentialDiagonal :: (this: *btDeformableCorotatedForce, scale: btScalar, diagA: *TVStack) -> void #cpp_method #foreign bullet3 "?buildDampingForceDifferentialDiagonal@btDeformableCorotatedForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_getForceType :: (this: *btDeformableCorotatedForce) -> btDeformableLagrangianForceType #cpp_method #foreign bullet3 "?getForceType@btDeformableCorotatedForce@@UEAA?AW4btDeformableLagrangianForceType@@XZ";
}
btDeformableCorotatedForce_VTable :: struct #type_info_none {
    using btdeformablelagrangianforce: btDeformableLagrangianForce_VTable;
    addScaledElasticForce: (this: *btDeformableCorotatedForce, scale: btScalar, force: *btDeformableCorotatedForce.TVStack) -> void #cpp_method;
}
btDeformableCorotatedForce_addScaledElasticForce :: inline (this: *btDeformableCorotatedForce, scale: btScalar, force: *btDeformableCorotatedForce.TVStack) { this.btdeformablecorotatedforce_vtable.addScaledElasticForce(this, scale, force); }

vtable :: (obj: *btDeformableCorotatedForce) -> *btDeformableCorotatedForce_VTable { return obj.btdeformablecorotatedforce_vtable; }


btDeformableMousePickingForce :: struct {
    #as btdeformablelagrangianforce: btDeformableLagrangianForce; // jai: no "using" to avoid name-clashes

    // If true, the damping force will be in the direction of the spring
    // If false, the damping force will be in the direction of the velocity
    m_elasticStiffness: btScalar;
    // If true, the damping force will be in the direction of the spring
    // If false, the damping force will be in the direction of the velocity
    m_dampingStiffness: btScalar;
    m_face:             *btSoftBody.Face;
    m_mouse_pos:        btVector3;
    m_maxForce:         btScalar;

    TVStack :: btAlignedObjectArray(btVector3);
    Constructor :: (this: *btDeformableMousePickingForce, k: btScalar, d: btScalar, face: *btSoftBody.Face, mouse_pos: *btVector3, maxForce: btScalar = 0.3) -> void #cpp_method #foreign bullet3 "??0btDeformableMousePickingForce@@QEAA@MMAEBUFace@btSoftBody@@AEBVbtVector3@@M@Z";
    Constructor :: (this: *btDeformableMousePickingForce, k: btScalar, d: btScalar, face: btSoftBody.Face, mouse_pos: btVector3, maxForce: btScalar = 0.3) #no_context {
        Constructor(this, k, d, *face, *mouse_pos, maxForce);
    }

    setMousePos :: (this: *btDeformableMousePickingForce, p: *btVector3) -> void #cpp_method #foreign bullet3 "?setMousePos@btDeformableMousePickingForce@@QEAAXAEBVbtVector3@@@Z";
    setMousePos :: (this: *btDeformableMousePickingForce, p: btVector3) #no_context {
        setMousePos(this, *p);
    }
    #place btdeformablelagrangianforce; btdeformablemousepickingforce_vtable: *btDeformableMousePickingForce_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_addScaledForces :: (this: *btDeformableMousePickingForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledForces@btDeformableMousePickingForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledExplicitForce :: (this: *btDeformableMousePickingForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledExplicitForce@btDeformableMousePickingForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledDampingForce :: (this: *btDeformableMousePickingForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForce@btDeformableMousePickingForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledElasticForce :: (this: *btDeformableMousePickingForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForce@btDeformableMousePickingForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledDampingForceDifferential :: (this: *btDeformableMousePickingForce, scale: btScalar, dv: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForceDifferential@btDeformableMousePickingForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_buildDampingForceDifferentialDiagonal :: (this: *btDeformableMousePickingForce, scale: btScalar, diagA: *TVStack) -> void #cpp_method #foreign bullet3 "?buildDampingForceDifferentialDiagonal@btDeformableMousePickingForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_totalElasticEnergy :: (this: *btDeformableMousePickingForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalElasticEnergy@btDeformableMousePickingForce@@UEAANM@Z";

    virtual_totalDampingEnergy :: (this: *btDeformableMousePickingForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalDampingEnergy@btDeformableMousePickingForce@@UEAANM@Z";

    virtual_addScaledElasticForceDifferential :: (this: *btDeformableMousePickingForce, scale: btScalar, dx: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForceDifferential@btDeformableMousePickingForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_getForceType :: (this: *btDeformableMousePickingForce) -> btDeformableLagrangianForceType #cpp_method #foreign bullet3 "?getForceType@btDeformableMousePickingForce@@UEAA?AW4btDeformableLagrangianForceType@@XZ";
}
btDeformableMousePickingForce_VTable :: struct #type_info_none {
    using btdeformablelagrangianforce: btDeformableLagrangianForce_VTable;
    addScaledElasticForce: (this: *btDeformableMousePickingForce, scale: btScalar, force: *btDeformableMousePickingForce.TVStack) -> void #cpp_method;
}
btDeformableMousePickingForce_addScaledElasticForce :: inline (this: *btDeformableMousePickingForce, scale: btScalar, force: *btDeformableMousePickingForce.TVStack) { this.btdeformablemousepickingforce_vtable.addScaledElasticForce(this, scale, force); }

vtable :: (obj: *btDeformableMousePickingForce) -> *btDeformableMousePickingForce_VTable { return obj.btdeformablemousepickingforce_vtable; }


//
// btSymMatrix
//
btSymMatrix :: struct(T: Type) {
    store: btAlignedObjectArray(T);
    dim:   s32;
}

//
// btSoftBodyCollisionShape
//
btSoftBodyCollisionShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    m_body: *btSoftBody;

    Constructor :: (this: *btSoftBodyCollisionShape, backptr: *btSoftBody) -> void #cpp_method #foreign bullet3 "??0btSoftBodyCollisionShape@@QEAA@PEAVbtSoftBody@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftBodyCollisionShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBodyCollisionShape@@UEAA@XZ";

    virtual_processAllTriangles :: (this: *btSoftBodyCollisionShape, unknown0: *btTriangleCallback, unknown1: *btVector3, unknown2: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btSoftBodyCollisionShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    ///getAabb returns the axis aligned bounding box in the coordinate frame of the given transform t.
    virtual_getAabb :: (this: *btSoftBodyCollisionShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btSoftBodyCollisionShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_setLocalScaling :: (this: *btSoftBodyCollisionShape, unknown0: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btSoftBodyCollisionShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getLocalScaling :: (this: *btSoftBodyCollisionShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btSoftBodyCollisionShape@@UEBAAEBVbtVector3@@XZ";

    virtual_calculateLocalInertia :: (this: *btSoftBodyCollisionShape, unknown0: btScalar, unknown1: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btSoftBodyCollisionShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btSoftBodyCollisionShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btSoftBodyCollisionShape@@UEBAPEBDXZ";
}

//
// btSoftClusterCollisionShape
//
btSoftClusterCollisionShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_cluster: *btSoftBody.Cluster;

    Constructor :: (this: *btSoftClusterCollisionShape, cluster: *btSoftBody.Cluster) -> void #cpp_method #foreign bullet3 "??0btSoftClusterCollisionShape@@QEAA@PEBUCluster@btSoftBody@@@Z";
    #place btconvexinternalshape; btsoftclustercollisionshape_vtable: *btSoftClusterCollisionShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btSoftClusterCollisionShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btSoftClusterCollisionShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btSoftClusterCollisionShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btSoftClusterCollisionShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    //notice that the vectors should be unit length
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btSoftClusterCollisionShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btSoftClusterCollisionShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btSoftClusterCollisionShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btSoftClusterCollisionShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getAabb :: (this: *btSoftClusterCollisionShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btSoftClusterCollisionShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_getShapeType :: (this: *btSoftClusterCollisionShape) -> s32 #cpp_method #foreign bullet3 "?getShapeType@btSoftClusterCollisionShape@@UEBAHXZ";

    //debugging
    virtual_getName :: (this: *btSoftClusterCollisionShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btSoftClusterCollisionShape@@UEBAPEBDXZ";

    virtual_setMargin :: (this: *btSoftClusterCollisionShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btSoftClusterCollisionShape@@UEAAXM@Z";

    virtual_getMargin :: (this: *btSoftClusterCollisionShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btSoftClusterCollisionShape@@UEBAMXZ";
}
btSoftClusterCollisionShape_VTable :: struct #type_info_none {
    using btconvexshape: btConvexShape_VTable;
    getShapeType: (this: *btSoftClusterCollisionShape) -> s32 #cpp_method;
}
btSoftClusterCollisionShape_getShapeType :: inline (this: *btSoftClusterCollisionShape) -> s32 { return this.btsoftclustercollisionshape_vtable.getShapeType(this); }

vtable :: (obj: *btSoftClusterCollisionShape) -> *btSoftClusterCollisionShape_VTable { return obj.btsoftclustercollisionshape_vtable; }


//
// btEigen : Extract eigen system,
// straitforward implementation of http://math.fullerton.edu/mathews/n2003/JacobiMethodMod.html
// outputs are NOT sorted.
//
btEigen :: struct {
    system :: (a: *btMatrix3x3, vectors: *btMatrix3x3, values: *btVector3 = null) -> s32 #foreign bullet3 "?system@btEigen@@SAHAEAVbtMatrix3x3@@PEAV2@PEAVbtVector3@@@Z";

    mulTPQ :: (a: *btMatrix3x3, c: btScalar, s: btScalar, p: s32, q: s32) -> void #foreign bullet3 "?mulTPQ@btEigen@@CAXAEAVbtMatrix3x3@@MMHH@Z";

    mulPQ :: (a: *btMatrix3x3, c: btScalar, s: btScalar, p: s32, q: s32) -> void #foreign bullet3 "?mulPQ@btEigen@@CAXAEAVbtMatrix3x3@@MMHH@Z";
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//
// btSoftColliders
//
btSoftColliders :: struct {
    //
    // ClusterBase
    //
    ClusterBase :: struct {
        #as using icollide: btDbvt.ICollide;

        erp:       btScalar;
        idt:       btScalar;
        m_margin:  btScalar;
        friction:  btScalar;
        threshold: btScalar;
    }

    //
    // CollideCL_RS
    //
    CollideCL_RS :: struct {
        #as using clusterbase: ClusterBase;

        psb:          *btSoftBody;
        m_colObjWrap: *btCollisionObjectWrapper;
    }

    //
    // CollideCL_SS
    //
    CollideCL_SS :: struct {
        #as using clusterbase: ClusterBase;

        bodies: [2] *btSoftBody;
    }

    //
    // CollideSDF_RS
    //
    CollideSDF_RS :: struct {
        #as using icollide: btDbvt.ICollide;

        psb:           *btSoftBody;
        m_colObj1Wrap: *btCollisionObjectWrapper;
        m_rigidBody:   *btRigidBody;
        dynmargin:     btScalar;
        stamargin:     btScalar;
    }

    //
    // CollideSDF_RD
    //
    CollideSDF_RD :: struct {
        #as using icollide: btDbvt.ICollide;

        psb:           *btSoftBody;
        m_colObj1Wrap: *btCollisionObjectWrapper;
        m_rigidBody:   *btRigidBody;
        dynmargin:     btScalar;
        stamargin:     btScalar;
    }

    //
    // CollideSDF_RDF
    //
    CollideSDF_RDF :: struct {
        #as using icollide: btDbvt.ICollide;

        psb:           *btSoftBody;
        m_colObj1Wrap: *btCollisionObjectWrapper;
        m_rigidBody:   *btRigidBody;
        dynmargin:     btScalar;
        stamargin:     btScalar;
    }

    //
    // CollideVF_SS
    //
    CollideVF_SS :: struct {
        #as using icollide: btDbvt.ICollide;

        psb: [2] *btSoftBody;
        mrg: btScalar;
    }

    //
    // CollideVF_DD
    //
    CollideVF_DD :: struct {
        #as using icollide: btDbvt.ICollide;

        psb:           [2] *btSoftBody;
        mrg:           btScalar;
        useFaceNormal: bool;
    }

    //
    // CollideFF_DD
    //
    CollideFF_DD :: struct {
        #as using icollide: btDbvt.ICollide;

        psb:           [2] *btSoftBody;
        mrg:           btScalar;
        useFaceNormal: bool;
    }

    CollideCCD :: struct {
        #as using icollide: btDbvt.ICollide;

        psb:           [2] *btSoftBody;
        dt:            btScalar;
        mrg:           btScalar;
        useFaceNormal: bool;
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

btDeformableLinearElasticityForce :: struct {
    #as btdeformablelagrangianforce: btDeformableLagrangianForce; // jai: no "using" to avoid name-clashes

    TVStack :: btAlignedObjectArray(btVector3);
    m_mu:            btScalar;
    m_lambda:        btScalar;
    m_E:             btScalar; // Young's modulus and Poisson ratio
    m_nu:            btScalar; // Young's modulus and Poisson ratio
    m_damping_alpha: btScalar;
    m_damping_beta:  btScalar;
    Constructor :: (this: *btDeformableLinearElasticityForce) -> void #cpp_method #foreign bullet3 "??0btDeformableLinearElasticityForce@@QEAA@XZ";

    Constructor :: (this: *btDeformableLinearElasticityForce, mu: btScalar, lambda: btScalar, damping_alpha: btScalar = 0.01, damping_beta: btScalar = 0.01) -> void #cpp_method #foreign bullet3 "??0btDeformableLinearElasticityForce@@QEAA@MMMM@Z";

    updateYoungsModulusAndPoissonRatio :: (this: *btDeformableLinearElasticityForce) -> void #cpp_method #foreign bullet3 "?updateYoungsModulusAndPoissonRatio@btDeformableLinearElasticityForce@@QEAAXXZ";

    updateLameParameters :: (this: *btDeformableLinearElasticityForce) -> void #cpp_method #foreign bullet3 "?updateLameParameters@btDeformableLinearElasticityForce@@QEAAXXZ";

    setYoungsModulus :: (this: *btDeformableLinearElasticityForce, E: btScalar) -> void #cpp_method #foreign bullet3 "?setYoungsModulus@btDeformableLinearElasticityForce@@QEAAXM@Z";

    setPoissonRatio :: (this: *btDeformableLinearElasticityForce, nu: btScalar) -> void #cpp_method #foreign bullet3 "?setPoissonRatio@btDeformableLinearElasticityForce@@QEAAXM@Z";

    setDamping :: (this: *btDeformableLinearElasticityForce, damping_alpha: btScalar, damping_beta: btScalar) -> void #cpp_method #foreign bullet3 "?setDamping@btDeformableLinearElasticityForce@@QEAAXMM@Z";

    setLameParameters :: (this: *btDeformableLinearElasticityForce, mu: btScalar, lambda: btScalar) -> void #cpp_method #foreign bullet3 "?setLameParameters@btDeformableLinearElasticityForce@@QEAAXMM@Z";

    elasticEnergyDensity :: (this: *btDeformableLinearElasticityForce, s: *btSoftBody.TetraScratch) -> float64 #cpp_method #foreign bullet3 "?elasticEnergyDensity@btDeformableLinearElasticityForce@@QEAANAEBUTetraScratch@btSoftBody@@@Z";
    elasticEnergyDensity :: (this: *btDeformableLinearElasticityForce, s: btSoftBody.TetraScratch) -> float64 #no_context {
        return elasticEnergyDensity(this, *s);
    }

    firstPiola :: (this: *btDeformableLinearElasticityForce, s: *btSoftBody.TetraScratch, P: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiola@btDeformableLinearElasticityForce@@QEAAXAEBUTetraScratch@btSoftBody@@AEAVbtMatrix3x3@@@Z";
    firstPiola :: (this: *btDeformableLinearElasticityForce, s: btSoftBody.TetraScratch, P: *btMatrix3x3) #no_context {
        firstPiola(this, *s, P);
    }

    // Let P be the first piola stress.
    // This function calculates the dP = dP/dF * dF
    firstPiolaDifferential :: (this: *btDeformableLinearElasticityForce, s: *btSoftBody.TetraScratch, dF: *btMatrix3x3, dP: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiolaDifferential@btDeformableLinearElasticityForce@@QEAAXAEBUTetraScratch@btSoftBody@@AEBVbtMatrix3x3@@AEAV4@@Z";
    firstPiolaDifferential :: (this: *btDeformableLinearElasticityForce, s: btSoftBody.TetraScratch, dF: btMatrix3x3, dP: *btMatrix3x3) #no_context {
        firstPiolaDifferential(this, *s, *dF, dP);
    }

    // Let Q be the damping stress.
    // This function calculates the dP = dQ/dF * dF
    firstPiolaDampingDifferential :: (this: *btDeformableLinearElasticityForce, s: *btSoftBody.TetraScratch, dF: *btMatrix3x3, dP: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiolaDampingDifferential@btDeformableLinearElasticityForce@@QEAAXAEBUTetraScratch@btSoftBody@@AEBVbtMatrix3x3@@AEAV4@@Z";
    firstPiolaDampingDifferential :: (this: *btDeformableLinearElasticityForce, s: btSoftBody.TetraScratch, dF: btMatrix3x3, dP: *btMatrix3x3) #no_context {
        firstPiolaDampingDifferential(this, *s, *dF, dP);
    }
    #place btdeformablelagrangianforce; btdeformablelinearelasticityforce_vtable: *btDeformableLinearElasticityForce_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_addScaledForces :: (this: *btDeformableLinearElasticityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledForces@btDeformableLinearElasticityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledExplicitForce :: (this: *btDeformableLinearElasticityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledExplicitForce@btDeformableLinearElasticityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // The damping matrix is calculated using the time n state as described in https://www.math.ucla.edu/~jteran/papers/GSSJT15.pdf to allow line search
    virtual_addScaledDampingForce :: (this: *btDeformableLinearElasticityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForce@btDeformableLinearElasticityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_totalElasticEnergy :: (this: *btDeformableLinearElasticityForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalElasticEnergy@btDeformableLinearElasticityForce@@UEAANM@Z";

    // The damping energy is formulated as in https://www.math.ucla.edu/~jteran/papers/GSSJT15.pdf to allow line search
    virtual_totalDampingEnergy :: (this: *btDeformableLinearElasticityForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalDampingEnergy@btDeformableLinearElasticityForce@@UEAANM@Z";

    virtual_addScaledElasticForce :: (this: *btDeformableLinearElasticityForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForce@btDeformableLinearElasticityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_buildDampingForceDifferentialDiagonal :: (this: *btDeformableLinearElasticityForce, scale: btScalar, diagA: *TVStack) -> void #cpp_method #foreign bullet3 "?buildDampingForceDifferentialDiagonal@btDeformableLinearElasticityForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // The damping matrix is calculated using the time n state as described in https://www.math.ucla.edu/~jteran/papers/GSSJT15.pdf to allow line search
    virtual_addScaledDampingForceDifferential :: (this: *btDeformableLinearElasticityForce, scale: btScalar, dv: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForceDifferential@btDeformableLinearElasticityForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_addScaledElasticForceDifferential :: (this: *btDeformableLinearElasticityForce, scale: btScalar, dx: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForceDifferential@btDeformableLinearElasticityForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_addScaledHessian :: (this: *btDeformableLinearElasticityForce, scale: btScalar) -> void #cpp_method #foreign bullet3 "?addScaledHessian@btDeformableLinearElasticityForce@@UEAAXM@Z";

    virtual_getForceType :: (this: *btDeformableLinearElasticityForce) -> btDeformableLagrangianForceType #cpp_method #foreign bullet3 "?getForceType@btDeformableLinearElasticityForce@@UEAA?AW4btDeformableLagrangianForceType@@XZ";
}
btDeformableLinearElasticityForce_VTable :: struct #type_info_none {
    using btdeformablelagrangianforce: btDeformableLagrangianForce_VTable;
    addScaledElasticForce: (this: *btDeformableLinearElasticityForce, scale: btScalar, force: *btDeformableLinearElasticityForce.TVStack) -> void #cpp_method;
}
btDeformableLinearElasticityForce_addScaledElasticForce :: inline (this: *btDeformableLinearElasticityForce, scale: btScalar, force: *btDeformableLinearElasticityForce.TVStack) { this.btdeformablelinearelasticityforce_vtable.addScaledElasticForce(this, scale, force); }

vtable :: (obj: *btDeformableLinearElasticityForce) -> *btDeformableLinearElasticityForce_VTable { return obj.btdeformablelinearelasticityforce_vtable; }


btMatrix2x2 :: struct {
    m_00: btScalar;
    m_01: btScalar;
    m_10: btScalar;
    m_11: btScalar;
    Constructor :: (this: *btMatrix2x2) -> void #cpp_method #foreign bullet3 "??0btMatrix2x2@@QEAA@XZ";

    CopyConstructor :: (this: *btMatrix2x2, other: *btMatrix2x2) -> void #cpp_method #foreign bullet3 "??0btMatrix2x2@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btMatrix2x2, other: btMatrix2x2) #no_context {
        CopyConstructor(this, *other);
    }

    setIdentity :: (this: *btMatrix2x2) -> void #cpp_method #foreign bullet3 "?setIdentity@btMatrix2x2@@QEAAXXZ";
}

/**
Class for givens rotation.
Row rotation G*A corresponds to something like
c -s  0
( s  c  0 ) A
0  0  1
Column rotation A G' corresponds to something like
c -s  0
A ( s  c  0 )
0  0  1

c and s are always computed so that
( c -s ) ( a )  =  ( * )
s  c     b       ( 0 )

Assume rowi<rowk.
*/
GivensRotation :: struct {
    rowi: s32;
    rowk: s32;
    c:    btScalar;
    s:    btScalar;
}

// This energy is as described in https://graphics.pixar.com/library/StableElasticity/paper.pdf
btDeformableNeoHookeanForce :: struct {
    #as btdeformablelagrangianforce: btDeformableLagrangianForce; // jai: no "using" to avoid name-clashes

    TVStack :: btAlignedObjectArray(btVector3);
    m_mu:          btScalar; // Lame Parameters
    m_lambda:      btScalar; // Lame Parameters
    m_E:           btScalar; // Young's modulus and Poisson ratio
    m_nu:          btScalar; // Young's modulus and Poisson ratio
    m_mu_damp:     btScalar;
    m_lambda_damp: btScalar;
    Constructor :: (this: *btDeformableNeoHookeanForce) -> void #cpp_method #foreign bullet3 "??0btDeformableNeoHookeanForce@@QEAA@XZ";

    Constructor :: (this: *btDeformableNeoHookeanForce, mu: btScalar, lambda: btScalar, damping: btScalar = 0.05) -> void #cpp_method #foreign bullet3 "??0btDeformableNeoHookeanForce@@QEAA@MMM@Z";

    updateYoungsModulusAndPoissonRatio :: (this: *btDeformableNeoHookeanForce) -> void #cpp_method #foreign bullet3 "?updateYoungsModulusAndPoissonRatio@btDeformableNeoHookeanForce@@QEAAXXZ";

    updateLameParameters :: (this: *btDeformableNeoHookeanForce) -> void #cpp_method #foreign bullet3 "?updateLameParameters@btDeformableNeoHookeanForce@@QEAAXXZ";

    setYoungsModulus :: (this: *btDeformableNeoHookeanForce, E: btScalar) -> void #cpp_method #foreign bullet3 "?setYoungsModulus@btDeformableNeoHookeanForce@@QEAAXM@Z";

    setPoissonRatio :: (this: *btDeformableNeoHookeanForce, nu: btScalar) -> void #cpp_method #foreign bullet3 "?setPoissonRatio@btDeformableNeoHookeanForce@@QEAAXM@Z";

    setDamping :: (this: *btDeformableNeoHookeanForce, damping: btScalar) -> void #cpp_method #foreign bullet3 "?setDamping@btDeformableNeoHookeanForce@@QEAAXM@Z";

    setLameParameters :: (this: *btDeformableNeoHookeanForce, mu: btScalar, lambda: btScalar) -> void #cpp_method #foreign bullet3 "?setLameParameters@btDeformableNeoHookeanForce@@QEAAXMM@Z";

    elasticEnergyDensity :: (this: *btDeformableNeoHookeanForce, s: *btSoftBody.TetraScratch) -> float64 #cpp_method #foreign bullet3 "?elasticEnergyDensity@btDeformableNeoHookeanForce@@QEAANAEBUTetraScratch@btSoftBody@@@Z";
    elasticEnergyDensity :: (this: *btDeformableNeoHookeanForce, s: btSoftBody.TetraScratch) -> float64 #no_context {
        return elasticEnergyDensity(this, *s);
    }

    firstPiola :: (this: *btDeformableNeoHookeanForce, s: *btSoftBody.TetraScratch, P: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiola@btDeformableNeoHookeanForce@@QEAAXAEBUTetraScratch@btSoftBody@@AEAVbtMatrix3x3@@@Z";
    firstPiola :: (this: *btDeformableNeoHookeanForce, s: btSoftBody.TetraScratch, P: *btMatrix3x3) #no_context {
        firstPiola(this, *s, P);
    }

    // Let P be the first piola stress.
    // This function calculates the dP = dP/dF * dF
    firstPiolaDifferential :: (this: *btDeformableNeoHookeanForce, s: *btSoftBody.TetraScratch, dF: *btMatrix3x3, dP: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiolaDifferential@btDeformableNeoHookeanForce@@QEAAXAEBUTetraScratch@btSoftBody@@AEBVbtMatrix3x3@@AEAV4@@Z";
    firstPiolaDifferential :: (this: *btDeformableNeoHookeanForce, s: btSoftBody.TetraScratch, dF: btMatrix3x3, dP: *btMatrix3x3) #no_context {
        firstPiolaDifferential(this, *s, *dF, dP);
    }

    // Let Q be the damping stress.
    // This function calculates the dP = dQ/dF * dF
    firstPiolaDampingDifferential :: (this: *btDeformableNeoHookeanForce, s: *btSoftBody.TetraScratch, dF: *btMatrix3x3, dP: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?firstPiolaDampingDifferential@btDeformableNeoHookeanForce@@QEAAXAEBUTetraScratch@btSoftBody@@AEBVbtMatrix3x3@@AEAV4@@Z";
    firstPiolaDampingDifferential :: (this: *btDeformableNeoHookeanForce, s: btSoftBody.TetraScratch, dF: btMatrix3x3, dP: *btMatrix3x3) #no_context {
        firstPiolaDampingDifferential(this, *s, *dF, dP);
    }

    DotProduct :: (this: *btDeformableNeoHookeanForce, A: *btMatrix3x3, B: *btMatrix3x3) -> btScalar #cpp_method #foreign bullet3 "?DotProduct@btDeformableNeoHookeanForce@@QEAAMAEBVbtMatrix3x3@@0@Z";
    DotProduct :: (this: *btDeformableNeoHookeanForce, A: btMatrix3x3, B: btMatrix3x3) -> btScalar #no_context {
        return DotProduct(this, *A, *B);
    }

    // Let C(A) be the cofactor of the matrix A
    // Let H = the derivative of C(A) with respect to A evaluated at F = A
    // This function calculates H*dF
    addScaledCofactorMatrixDifferential :: (this: *btDeformableNeoHookeanForce, F: *btMatrix3x3, dF: *btMatrix3x3, scale: btScalar, M: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?addScaledCofactorMatrixDifferential@btDeformableNeoHookeanForce@@QEAAXAEBVbtMatrix3x3@@0MAEAV2@@Z";
    addScaledCofactorMatrixDifferential :: (this: *btDeformableNeoHookeanForce, F: btMatrix3x3, dF: btMatrix3x3, scale: btScalar, M: *btMatrix3x3) #no_context {
        addScaledCofactorMatrixDifferential(this, *F, *dF, scale, M);
    }
    #place btdeformablelagrangianforce; btdeformableneohookeanforce_vtable: *btDeformableNeoHookeanForce_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_addScaledForces :: (this: *btDeformableNeoHookeanForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledForces@btDeformableNeoHookeanForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledExplicitForce :: (this: *btDeformableNeoHookeanForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledExplicitForce@btDeformableNeoHookeanForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // The damping matrix is calculated using the time n state as described in https://www.math.ucla.edu/~jteran/papers/GSSJT15.pdf to allow line search
    virtual_addScaledDampingForce :: (this: *btDeformableNeoHookeanForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForce@btDeformableNeoHookeanForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_totalElasticEnergy :: (this: *btDeformableNeoHookeanForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalElasticEnergy@btDeformableNeoHookeanForce@@UEAANM@Z";

    // The damping energy is formulated as in https://www.math.ucla.edu/~jteran/papers/GSSJT15.pdf to allow line search
    virtual_totalDampingEnergy :: (this: *btDeformableNeoHookeanForce, dt: btScalar) -> float64 #cpp_method #foreign bullet3 "?totalDampingEnergy@btDeformableNeoHookeanForce@@UEAANM@Z";

    virtual_addScaledElasticForce :: (this: *btDeformableNeoHookeanForce, scale: btScalar, force: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForce@btDeformableNeoHookeanForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // The damping matrix is calculated using the time n state as described in https://www.math.ucla.edu/~jteran/papers/GSSJT15.pdf to allow line search
    virtual_addScaledDampingForceDifferential :: (this: *btDeformableNeoHookeanForce, scale: btScalar, dv: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledDampingForceDifferential@btDeformableNeoHookeanForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_buildDampingForceDifferentialDiagonal :: (this: *btDeformableNeoHookeanForce, scale: btScalar, diagA: *TVStack) -> void #cpp_method #foreign bullet3 "?buildDampingForceDifferentialDiagonal@btDeformableNeoHookeanForce@@UEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    virtual_addScaledElasticForceDifferential :: (this: *btDeformableNeoHookeanForce, scale: btScalar, dx: *TVStack, df: *TVStack) -> void #cpp_method #foreign bullet3 "?addScaledElasticForceDifferential@btDeformableNeoHookeanForce@@UEAAXMAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";

    virtual_getForceType :: (this: *btDeformableNeoHookeanForce) -> btDeformableLagrangianForceType #cpp_method #foreign bullet3 "?getForceType@btDeformableNeoHookeanForce@@UEAA?AW4btDeformableLagrangianForceType@@XZ";
}
btDeformableNeoHookeanForce_VTable :: struct #type_info_none {
    using btdeformablelagrangianforce: btDeformableLagrangianForce_VTable;
    addScaledElasticForce: (this: *btDeformableNeoHookeanForce, scale: btScalar, force: *btDeformableNeoHookeanForce.TVStack) -> void #cpp_method;
}
btDeformableNeoHookeanForce_addScaledElasticForce :: inline (this: *btDeformableNeoHookeanForce, scale: btScalar, force: *btDeformableNeoHookeanForce.TVStack) { this.btdeformableneohookeanforce_vtable.addScaledElasticForce(this, scale, force); }

vtable :: (obj: *btDeformableNeoHookeanForce) -> *btDeformableNeoHookeanForce_VTable { return obj.btdeformableneohookeanforce_vtable; }


// btDeformableContactConstraint is an abstract class specifying the method that each type of contact constraint needs to implement
btDeformableContactConstraint :: struct {
    vtable: *btDeformableContactConstraint_VTable;
    // True if the friction is static
    // False if the friction is dynamic
    m_static:     bool;
    m_infoGlobal: *btContactSolverInfo;

    // normal of the contact
    m_normal:     btVector3;

    Constructor :: (this: *btDeformableContactConstraint, normal: *btVector3, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableContactConstraint@@QEAA@AEBVbtVector3@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableContactConstraint, normal: btVector3, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, *normal, *infoGlobal);
    }

    Constructor :: (this: *btDeformableContactConstraint, isStatic: bool, normal: *btVector3, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableContactConstraint@@QEAA@_NAEBVbtVector3@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableContactConstraint, isStatic: bool, normal: btVector3, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, isStatic, *normal, *infoGlobal);
    }

    Constructor :: (this: *btDeformableContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableContactConstraint@@QEAA@XZ";

    CopyConstructor :: (this: *btDeformableContactConstraint, other: *btDeformableContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableContactConstraint@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btDeformableContactConstraint, other: btDeformableContactConstraint) #no_context {
        CopyConstructor(this, *other);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableContactConstraint@@UEAA@XZ";
}
btDeformableContactConstraint_VTable :: struct #type_info_none {
    Destructor: (this: *btDeformableContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    solveConstraint: (this: *btDeformableContactConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method;

    getVa: (this: *btDeformableContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    getVb: (this: *btDeformableContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    getDv: (this: *btDeformableContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    applyImpulse: (this: *btDeformableContactConstraint, impulse: *btVector3) -> void #cpp_method;

    setPenetrationScale: (this: *btDeformableContactConstraint, scale: btScalar) -> void #cpp_method;
}

btDeformableContactConstraint_Destructor :: inline (this: *btDeformableContactConstraint, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btDeformableContactConstraint_solveConstraint :: inline (this: *btDeformableContactConstraint, infoGlobal: *btContactSolverInfo) -> btScalar { return this.vtable.solveConstraint(this, infoGlobal); }

btDeformableContactConstraint_getVa :: inline (this: *btDeformableContactConstraint) -> btVector3 { return this.vtable.getVa(this); }

btDeformableContactConstraint_getVb :: inline (this: *btDeformableContactConstraint) -> btVector3 { return this.vtable.getVb(this); }

btDeformableContactConstraint_getDv :: inline (this: *btDeformableContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 { return this.vtable.getDv(this, unknown0); }

btDeformableContactConstraint_applyImpulse :: inline (this: *btDeformableContactConstraint, impulse: *btVector3) { this.vtable.applyImpulse(this, impulse); }

btDeformableContactConstraint_setPenetrationScale :: inline (this: *btDeformableContactConstraint, scale: btScalar) { this.vtable.setPenetrationScale(this, scale); }



//
// Constraint that a certain node in the deformable objects cannot move
btDeformableStaticConstraint :: struct {
    #as using btdeformablecontactconstraint: btDeformableContactConstraint;

    m_node: *btSoftBody.Node;

    Constructor :: (this: *btDeformableStaticConstraint, node: *btSoftBody.Node, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableStaticConstraint@@QEAA@PEAUNode@btSoftBody@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableStaticConstraint, node: *btSoftBody.Node, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, node, *infoGlobal);
    }

    Constructor :: (this: *btDeformableStaticConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableStaticConstraint@@QEAA@XZ";
    CopyConstructor :: (this: *btDeformableStaticConstraint, other: *btDeformableStaticConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableStaticConstraint@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btDeformableStaticConstraint, other: btDeformableStaticConstraint) #no_context {
        CopyConstructor(this, *other);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableStaticConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableStaticConstraint@@UEAA@XZ";

    virtual_solveConstraint :: (this: *btDeformableStaticConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveConstraint@btDeformableStaticConstraint@@UEAAMAEBUbtContactSolverInfo@@@Z";

    virtual_getVa :: (this: *btDeformableStaticConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVa@btDeformableStaticConstraint@@UEBA?AVbtVector3@@XZ";

    virtual_getVb :: (this: *btDeformableStaticConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btDeformableStaticConstraint@@UEBA?AVbtVector3@@XZ";

    virtual_getDv :: (this: *btDeformableStaticConstraint, n: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btDeformableStaticConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    virtual_applyImpulse :: (this: *btDeformableStaticConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btDeformableStaticConstraint@@UEAAXAEBVbtVector3@@@Z";
    virtual_setPenetrationScale :: (this: *btDeformableStaticConstraint, scale: btScalar) -> void #cpp_method #foreign bullet3 "?setPenetrationScale@btDeformableStaticConstraint@@UEAAXM@Z";
}

//
// Anchor Constraint between rigid and deformable node
btDeformableNodeAnchorConstraint :: struct {
    #as using btdeformablecontactconstraint: btDeformableContactConstraint;

    m_anchor: *btSoftBody.DeformableNodeRigidAnchor;

    Constructor :: (this: *btDeformableNodeAnchorConstraint, c: *btSoftBody.DeformableNodeRigidAnchor, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableNodeAnchorConstraint@@QEAA@AEBVDeformableNodeRigidAnchor@btSoftBody@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableNodeAnchorConstraint, c: btSoftBody.DeformableNodeRigidAnchor, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, *c, *infoGlobal);
    }
    CopyConstructor :: (this: *btDeformableNodeAnchorConstraint, other: *btDeformableNodeAnchorConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableNodeAnchorConstraint@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btDeformableNodeAnchorConstraint, other: btDeformableNodeAnchorConstraint) #no_context {
        CopyConstructor(this, *other);
    }
    Constructor :: (this: *btDeformableNodeAnchorConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableNodeAnchorConstraint@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btDeformableNodeAnchorConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableNodeAnchorConstraint@@UEAA@XZ";

    virtual_solveConstraint :: (this: *btDeformableNodeAnchorConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveConstraint@btDeformableNodeAnchorConstraint@@UEAAMAEBUbtContactSolverInfo@@@Z";

    // object A is the rigid/multi body, and object B is the deformable node/face
    virtual_getVa :: (this: *btDeformableNodeAnchorConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVa@btDeformableNodeAnchorConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity of the deformable node in contact
    virtual_getVb :: (this: *btDeformableNodeAnchorConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btDeformableNodeAnchorConstraint@@UEBA?AVbtVector3@@XZ";
    virtual_getDv :: (this: *btDeformableNodeAnchorConstraint, n: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btDeformableNodeAnchorConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    virtual_applyImpulse :: (this: *btDeformableNodeAnchorConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btDeformableNodeAnchorConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_setPenetrationScale :: (this: *btDeformableNodeAnchorConstraint, scale: btScalar) -> void #cpp_method #foreign bullet3 "?setPenetrationScale@btDeformableNodeAnchorConstraint@@UEAAXM@Z";
}

//
// Constraint between rigid/multi body and deformable objects
btDeformableRigidContactConstraint :: struct {
    #as using btdeformablecontactconstraint: btDeformableContactConstraint;

    m_total_normal_dv:     btVector3;
    m_total_tangent_dv:    btVector3;
    m_penetration:         btScalar;
    m_total_split_impulse: btScalar;
    m_binding:             bool;
    m_contact:             *btSoftBody.DeformableRigidContact;

    Constructor :: (this: *btDeformableRigidContactConstraint, c: *btSoftBody.DeformableRigidContact, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableRigidContactConstraint@@QEAA@AEBVDeformableRigidContact@btSoftBody@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableRigidContactConstraint, c: btSoftBody.DeformableRigidContact, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, *c, *infoGlobal);
    }
    CopyConstructor :: (this: *btDeformableRigidContactConstraint, other: *btDeformableRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableRigidContactConstraint@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btDeformableRigidContactConstraint, other: btDeformableRigidContactConstraint) #no_context {
        CopyConstructor(this, *other);
    }
    Constructor :: (this: *btDeformableRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableRigidContactConstraint@@QEAA@XZ";

    solveSplitImpulse :: (this: *btDeformableRigidContactConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveSplitImpulse@btDeformableRigidContactConstraint@@QEAAMAEBUbtContactSolverInfo@@@Z";
    solveSplitImpulse :: (this: *btDeformableRigidContactConstraint, infoGlobal: btContactSolverInfo) -> btScalar #no_context {
        return solveSplitImpulse(this, *infoGlobal);
    }
    #place btdeformablecontactconstraint; btdeformablerigidcontactconstraint_vtable: *btDeformableRigidContactConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableRigidContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableRigidContactConstraint@@UEAA@XZ";

    // object A is the rigid/multi body, and object B is the deformable node/face
    virtual_getVa :: (this: *btDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVa@btDeformableRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the split impulse velocity of the rigid/multibdoy at the contaft
    virtual_getSplitVa :: (this: *btDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getSplitVa@btDeformableRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    virtual_solveConstraint :: (this: *btDeformableRigidContactConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveConstraint@btDeformableRigidContactConstraint@@UEAAMAEBUbtContactSolverInfo@@@Z";

    virtual_setPenetrationScale :: (this: *btDeformableRigidContactConstraint, scale: btScalar) -> void #cpp_method #foreign bullet3 "?setPenetrationScale@btDeformableRigidContactConstraint@@UEAAXM@Z";
}
btDeformableRigidContactConstraint_VTable :: struct #type_info_none {
    using btdeformablecontactconstraint: btDeformableContactConstraint_VTable;
    getSplitVb: (this: *btDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    getSplitVa: (this: *btDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;

    applySplitImpulse: (this: *btDeformableRigidContactConstraint, impulse: *btVector3) -> void #cpp_method;
}

btDeformableRigidContactConstraint_getSplitVb :: inline (this: *btDeformableRigidContactConstraint) -> btVector3 { return this.btdeformablerigidcontactconstraint_vtable.getSplitVb(this); }

btDeformableRigidContactConstraint_getSplitVa :: inline (this: *btDeformableRigidContactConstraint) -> btVector3 { return this.btdeformablerigidcontactconstraint_vtable.getSplitVa(this); }

btDeformableRigidContactConstraint_applySplitImpulse :: inline (this: *btDeformableRigidContactConstraint, impulse: *btVector3) { this.btdeformablerigidcontactconstraint_vtable.applySplitImpulse(this, impulse); }

vtable :: (obj: *btDeformableRigidContactConstraint) -> *btDeformableRigidContactConstraint_VTable { return obj.btdeformablerigidcontactconstraint_vtable; }


//
// Constraint between rigid/multi body and deformable objects nodes
btDeformableNodeRigidContactConstraint :: struct {
    #as using btdeformablerigidcontactconstraint: btDeformableRigidContactConstraint;

    // the deformable node in contact
    m_node: *btSoftBody.Node;

    Constructor :: (this: *btDeformableNodeRigidContactConstraint, contact: *btSoftBody.DeformableNodeRigidContact, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableNodeRigidContactConstraint@@QEAA@AEBVDeformableNodeRigidContact@btSoftBody@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableNodeRigidContactConstraint, contact: btSoftBody.DeformableNodeRigidContact, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, *contact, *infoGlobal);
    }
    CopyConstructor :: (this: *btDeformableNodeRigidContactConstraint, other: *btDeformableNodeRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableNodeRigidContactConstraint@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btDeformableNodeRigidContactConstraint, other: btDeformableNodeRigidContactConstraint) #no_context {
        CopyConstructor(this, *other);
    }
    Constructor :: (this: *btDeformableNodeRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableNodeRigidContactConstraint@@QEAA@XZ";

    // cast the contact to the desired type
    getContact :: (this: *btDeformableNodeRigidContactConstraint) -> *btSoftBody.DeformableNodeRigidContact #cpp_method #foreign bullet3 "?getContact@btDeformableNodeRigidContactConstraint@@QEBAPEBVDeformableNodeRigidContact@btSoftBody@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableNodeRigidContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableNodeRigidContactConstraint@@UEAA@XZ";

    // get the velocity of the deformable node in contact
    virtual_getVb :: (this: *btDeformableNodeRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the split impulse velocity of the deformable face at the contact point
    virtual_getSplitVb :: (this: *btDeformableNodeRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getSplitVb@btDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity change of the input soft body node in the constraint
    virtual_getDv :: (this: *btDeformableNodeRigidContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    virtual_applyImpulse :: (this: *btDeformableNodeRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btDeformableNodeRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_applySplitImpulse :: (this: *btDeformableNodeRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applySplitImpulse@btDeformableNodeRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";
}

//
// Constraint between rigid/multi body and deformable objects faces
btDeformableFaceRigidContactConstraint :: struct {
    #as using btdeformablerigidcontactconstraint: btDeformableRigidContactConstraint;

    m_face:              *btSoftBody.Face;
    m_useStrainLimiting: bool;
    Constructor :: (this: *btDeformableFaceRigidContactConstraint, contact: *btSoftBody.DeformableFaceRigidContact, infoGlobal: *btContactSolverInfo, useStrainLimiting: bool) -> void #cpp_method #foreign bullet3 "??0btDeformableFaceRigidContactConstraint@@QEAA@AEBVDeformableFaceRigidContact@btSoftBody@@AEBUbtContactSolverInfo@@_N@Z";
    Constructor :: (this: *btDeformableFaceRigidContactConstraint, contact: btSoftBody.DeformableFaceRigidContact, infoGlobal: btContactSolverInfo, useStrainLimiting: bool) #no_context {
        Constructor(this, *contact, *infoGlobal, useStrainLimiting);
    }
    CopyConstructor :: (this: *btDeformableFaceRigidContactConstraint, other: *btDeformableFaceRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableFaceRigidContactConstraint@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btDeformableFaceRigidContactConstraint, other: btDeformableFaceRigidContactConstraint) #no_context {
        CopyConstructor(this, *other);
    }
    Constructor :: (this: *btDeformableFaceRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableFaceRigidContactConstraint@@QEAA@XZ";

    // cast the contact to the desired type
    getContact :: (this: *btDeformableFaceRigidContactConstraint) -> *btSoftBody.DeformableFaceRigidContact #cpp_method #foreign bullet3 "?getContact@btDeformableFaceRigidContactConstraint@@QEBAPEBVDeformableFaceRigidContact@btSoftBody@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableFaceRigidContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableFaceRigidContactConstraint@@UEAA@XZ";

    // get the velocity of the deformable face at the contact point
    virtual_getVb :: (this: *btDeformableFaceRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btDeformableFaceRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the split impulse velocity of the deformable face at the contact point
    virtual_getSplitVb :: (this: *btDeformableFaceRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getSplitVb@btDeformableFaceRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity change of the input soft body node in the constraint
    virtual_getDv :: (this: *btDeformableFaceRigidContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btDeformableFaceRigidContactConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    virtual_applyImpulse :: (this: *btDeformableFaceRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btDeformableFaceRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_applySplitImpulse :: (this: *btDeformableFaceRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applySplitImpulse@btDeformableFaceRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";
}

//
// Constraint between  deformable objects faces and deformable objects nodes
btDeformableFaceNodeContactConstraint :: struct {
    #as using btdeformablecontactconstraint: btDeformableContactConstraint;

    m_node:             *btSoftBody.Node;
    m_face:             *btSoftBody.Face;
    m_contact:          *btSoftBody.DeformableFaceNodeContact;
    m_total_normal_dv:  btVector3;
    m_total_tangent_dv: btVector3;

    Constructor :: (this: *btDeformableFaceNodeContactConstraint, contact: *btSoftBody.DeformableFaceNodeContact, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0btDeformableFaceNodeContactConstraint@@QEAA@AEBUDeformableFaceNodeContact@btSoftBody@@AEBUbtContactSolverInfo@@@Z";
    Constructor :: (this: *btDeformableFaceNodeContactConstraint, contact: btSoftBody.DeformableFaceNodeContact, infoGlobal: btContactSolverInfo) #no_context {
        Constructor(this, *contact, *infoGlobal);
    }
    Constructor :: (this: *btDeformableFaceNodeContactConstraint) -> void #cpp_method #foreign bullet3 "??0btDeformableFaceNodeContactConstraint@@QEAA@XZ";

    // cast the contact to the desired type
    getContact :: (this: *btDeformableFaceNodeContactConstraint) -> *btSoftBody.DeformableFaceNodeContact #cpp_method #foreign bullet3 "?getContact@btDeformableFaceNodeContactConstraint@@QEBAPEBUDeformableFaceNodeContact@btSoftBody@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableFaceNodeContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableFaceNodeContactConstraint@@UEAA@XZ";

    virtual_solveConstraint :: (this: *btDeformableFaceNodeContactConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveConstraint@btDeformableFaceNodeContactConstraint@@UEAAMAEBUbtContactSolverInfo@@@Z";

    // get the velocity of the object A in the contact
    virtual_getVa :: (this: *btDeformableFaceNodeContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVa@btDeformableFaceNodeContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity of the object B in the contact
    virtual_getVb :: (this: *btDeformableFaceNodeContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btDeformableFaceNodeContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity change of the input soft body node in the constraint
    virtual_getDv :: (this: *btDeformableFaceNodeContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btDeformableFaceNodeContactConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    virtual_applyImpulse :: (this: *btDeformableFaceNodeContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btDeformableFaceNodeContactConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_setPenetrationScale :: (this: *btDeformableFaceNodeContactConstraint, scale: btScalar) -> void #cpp_method #foreign bullet3 "?setPenetrationScale@btDeformableFaceNodeContactConstraint@@UEAAXM@Z";
}

TwoInts :: struct {
    a: s32;
    b: s32;
}

// A helper vector type used for CG projections
btReducedVector :: struct {
    m_indices: btAlignedObjectArray(s32);
    m_vecs:    btAlignedObjectArray(btVector3);
    m_sz:      s32; // all m_indices value < m_sz

    Constructor :: (this: *btReducedVector) -> void #cpp_method #foreign bullet3 "??0btReducedVector@@QEAA@XZ";

    Constructor :: (this: *btReducedVector, sz: s32) -> void #cpp_method #foreign bullet3 "??0btReducedVector@@QEAA@H@Z";

    Constructor :: (this: *btReducedVector, sz: s32, indices: *btAlignedObjectArray(s32), vecs: *btAlignedObjectArray(btVector3)) -> void #cpp_method #foreign bullet3 "??0btReducedVector@@QEAA@HAEBV?$btAlignedObjectArray@H@@AEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    Constructor :: (this: *btReducedVector, sz: s32, indices: btAlignedObjectArray(s32), vecs: btAlignedObjectArray(btVector3)) #no_context {
        Constructor(this, sz, *indices, *vecs);
    }

    simplify :: (this: *btReducedVector) -> void #cpp_method #foreign bullet3 "?simplify@btReducedVector@@QEAAXXZ";

    dot :: (this: *btReducedVector, other: *btReducedVector) -> btScalar #cpp_method #foreign bullet3 "?dot@btReducedVector@@QEBAMAEBV1@@Z";
    dot :: (this: *btReducedVector, other: btReducedVector) -> btScalar #no_context {
        return dot(this, *other);
    }

    dot :: (this: *btReducedVector, other: *btAlignedObjectArray(btVector3)) -> btScalar #cpp_method #foreign bullet3 "?dot@btReducedVector@@QEBAMAEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    dot :: (this: *btReducedVector, other: btAlignedObjectArray(btVector3)) -> btScalar #no_context {
        return dot(this, *other);
    }

    length2 :: (this: *btReducedVector) -> btScalar #cpp_method #foreign bullet3 "?length2@btReducedVector@@QEBAMXZ";

    normalize :: (this: *btReducedVector) -> void #cpp_method #foreign bullet3 "?normalize@btReducedVector@@QEAAXXZ";

    // returns the projection of this onto other
    proj :: (this: *btReducedVector, other: *btReducedVector) -> btReducedVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?proj@btReducedVector@@QEBA?AV1@AEBV1@@Z";
    proj :: (this: *btReducedVector, other: btReducedVector) -> btReducedVector #no_context {
        return proj(this, *other);
    }

    testAdd :: (this: *btReducedVector) -> bool #cpp_method #foreign bullet3 "?testAdd@btReducedVector@@QEBA_NXZ";

    testMinus :: (this: *btReducedVector) -> bool #cpp_method #foreign bullet3 "?testMinus@btReducedVector@@QEBA_NXZ";

    testDot :: (this: *btReducedVector) -> bool #cpp_method #foreign bullet3 "?testDot@btReducedVector@@QEBA_NXZ";

    testMultiply :: (this: *btReducedVector) -> bool #cpp_method #foreign bullet3 "?testMultiply@btReducedVector@@QEBA_NXZ";

    test :: (this: *btReducedVector) -> void #cpp_method #foreign bullet3 "?test@btReducedVector@@QEBAXXZ";

    print :: (this: *btReducedVector) -> void #cpp_method #foreign bullet3 "?print@btReducedVector@@QEBAXXZ";

    sort :: (this: *btReducedVector) -> void #cpp_method #foreign bullet3 "?sort@btReducedVector@@QEAAXXZ";
}

operator+ :: (this: *btReducedVector, other: *btReducedVector) -> btReducedVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??HbtReducedVector@@QEAA?AV0@AEBV0@@Z";
operator+ :: (this: btReducedVector, other: btReducedVector) -> btReducedVector #no_context {
    return operator+(*this, *other);
}

operator- :: (this: *btReducedVector) -> btReducedVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtReducedVector@@QEAA?AV0@XZ";
operator- :: (this: btReducedVector) -> btReducedVector #no_context {
    return operator-(*this);
}

operator- :: (this: *btReducedVector, other: *btReducedVector) -> btReducedVector #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "??GbtReducedVector@@QEAA?AV0@AEBV0@@Z";
operator- :: (this: btReducedVector, other: btReducedVector) -> btReducedVector #no_context {
    return operator-(*this, *other);
}

operator== :: (this: *btReducedVector, other: *btReducedVector) -> bool #cpp_method #foreign bullet3 "??8btReducedVector@@QEBA_NAEBV0@@Z";
operator== :: (this: btReducedVector, other: btReducedVector) -> bool #no_context {
    return operator==(*this, *other);
}

operator!= :: (this: *btReducedVector, other: *btReducedVector) -> bool #cpp_method #foreign bullet3 "??9btReducedVector@@QEBA_NAEBV0@@Z";
operator!= :: (this: btReducedVector, other: btReducedVector) -> bool #no_context {
    return operator!=(*this, *other);
}

operator_assign :: (this: *btReducedVector, other: *btReducedVector) -> *btReducedVector #cpp_method #foreign bullet3 "??4btReducedVector@@QEAAAEAV0@AEBV0@@Z";
operator_assign :: (this: *btReducedVector, other: btReducedVector) -> *btReducedVector #no_context {
    return operator_assign(this, *other);
}

btModifiedGramSchmidt :: struct(TV: Type) {
    m_in:  btAlignedObjectArray(TV);
    m_out: btAlignedObjectArray(TV);
}

LagrangeMultiplier :: struct {
    m_num_constraints: s32; // Number of constraints
    m_num_nodes:       s32; // Number of nodes in these constraints
    m_weights:         [3] btScalar; // weights of the nodes involved, same size as m_num_nodes
    m_dirs:            [3] btVector3; // Constraint directions, same size of m_num_constraints;
    m_indices:         [3] s32; // indices of the nodes involved, same size as m_num_nodes;
}

btDeformableContactProjection :: struct {
    vtable: *btDeformableContactProjection_VTable;
    TVStack :: btAlignedObjectArray(btVector3);
    m_softBodies:            *btAlignedObjectArray(*btSoftBody);

    // all constraints involving face
    m_allFaceConstraints:    btAlignedObjectArray(*btDeformableContactConstraint);

    // map from node index to projection directions
    m_projectionsDict:       btHashMap(btHashInt, btAlignedObjectArray(btVector3));

    m_lagrangeMultipliers:   btAlignedObjectArray(LagrangeMultiplier);

    // map from node index to static constraint
    m_staticConstraints:     btAlignedObjectArray(btAlignedObjectArray(btDeformableStaticConstraint));

    // map from node index to node rigid constraint
    m_nodeRigidConstraints:  btAlignedObjectArray(btAlignedObjectArray(btDeformableNodeRigidContactConstraint));

    // map from node index to face rigid constraint
    m_faceRigidConstraints:  btAlignedObjectArray(btAlignedObjectArray(btDeformableFaceRigidContactConstraint));

    // map from node index to deformable constraint
    m_deformableConstraints: btAlignedObjectArray(btAlignedObjectArray(btDeformableFaceNodeContactConstraint));

    // map from node index to node anchor constraint
    m_nodeAnchorConstraints: btAlignedObjectArray(btAlignedObjectArray(btDeformableNodeAnchorConstraint));

    m_useStrainLimiting:     bool;

    Constructor :: (this: *btDeformableContactProjection, softBodies: *btAlignedObjectArray(*btSoftBody)) -> void #cpp_method #foreign bullet3 "??0btDeformableContactProjection@@QEAA@AEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@@Z";

    solveSplitImpulse :: (this: *btDeformableContactProjection, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveSplitImpulse@btDeformableContactProjection@@QEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";
    solveSplitImpulse :: (this: *btDeformableContactProjection, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: btContactSolverInfo) -> btScalar #no_context {
        return solveSplitImpulse(this, deformableBodies, numDeformableBodies, *infoGlobal);
    }

    checkConstraints :: (this: *btDeformableContactProjection, x: *TVStack) -> void #cpp_method #foreign bullet3 "?checkConstraints@btDeformableContactProjection@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    checkConstraints :: (this: *btDeformableContactProjection, x: TVStack) #no_context {
        checkConstraints(this, *x);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableContactProjection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableContactProjection@@UEAA@XZ";

    // apply the constraints to the rhs of the linear solve
    virtual_project :: (this: *btDeformableContactProjection, x: *TVStack) -> void #cpp_method #foreign bullet3 "?project@btDeformableContactProjection@@UEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // add friction force to the rhs of the linear solve
    virtual_applyDynamicFriction :: (this: *btDeformableContactProjection, f: *TVStack) -> void #cpp_method #foreign bullet3 "?applyDynamicFriction@btDeformableContactProjection@@UEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // update and solve the constraints
    virtual_update :: (this: *btDeformableContactProjection, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?update@btDeformableContactProjection@@UEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    // Add constraints to m_constraints. In addition, the constraints that each vertex own are recorded in m_constraintsDict.
    virtual_setConstraints :: (this: *btDeformableContactProjection, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setConstraints@btDeformableContactProjection@@UEAAXAEBUbtContactSolverInfo@@@Z";

    // Set up projections for each vertex by adding the projection direction to
    virtual_setProjection :: (this: *btDeformableContactProjection) -> void #cpp_method #foreign bullet3 "?setProjection@btDeformableContactProjection@@UEAAXXZ";

    virtual_reinitialize :: (this: *btDeformableContactProjection, nodeUpdated: bool) -> void #cpp_method #foreign bullet3 "?reinitialize@btDeformableContactProjection@@UEAAX_N@Z";

    virtual_setLagrangeMultiplier :: (this: *btDeformableContactProjection) -> void #cpp_method #foreign bullet3 "?setLagrangeMultiplier@btDeformableContactProjection@@UEAAXXZ";
}
btDeformableContactProjection_VTable :: struct #type_info_none {
    Destructor: (this: *btDeformableContactProjection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    project: (this: *btDeformableContactProjection, x: *btDeformableContactProjection.TVStack) -> void #cpp_method;

    applyDynamicFriction: (this: *btDeformableContactProjection, f: *btDeformableContactProjection.TVStack) -> void #cpp_method;

    update: (this: *btDeformableContactProjection, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method;

    setConstraints: (this: *btDeformableContactProjection, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    setProjection: (this: *btDeformableContactProjection) -> void #cpp_method;

    reinitialize: (this: *btDeformableContactProjection, nodeUpdated: bool) -> void #cpp_method;

    setLagrangeMultiplier: (this: *btDeformableContactProjection) -> void #cpp_method;
}

btDeformableContactProjection_Destructor :: inline (this: *btDeformableContactProjection, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btDeformableContactProjection_project :: inline (this: *btDeformableContactProjection, x: *btDeformableContactProjection.TVStack) { this.vtable.project(this, x); }

btDeformableContactProjection_applyDynamicFriction :: inline (this: *btDeformableContactProjection, f: *btDeformableContactProjection.TVStack) { this.vtable.applyDynamicFriction(this, f); }

btDeformableContactProjection_update :: inline (this: *btDeformableContactProjection, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar { return this.vtable.update(this, deformableBodies, numDeformableBodies, infoGlobal); }

btDeformableContactProjection_setConstraints :: inline (this: *btDeformableContactProjection, infoGlobal: *btContactSolverInfo) { this.vtable.setConstraints(this, infoGlobal); }

btDeformableContactProjection_setProjection :: inline (this: *btDeformableContactProjection) { this.vtable.setProjection(this); }

btDeformableContactProjection_reinitialize :: inline (this: *btDeformableContactProjection, nodeUpdated: bool) { this.vtable.reinitialize(this, nodeUpdated); }

btDeformableContactProjection_setLagrangeMultiplier :: inline (this: *btDeformableContactProjection) { this.vtable.setLagrangeMultiplier(this); }



Preconditioner :: struct {
    vtable: *Preconditioner_VTable;
    TVStack :: btAlignedObjectArray(btVector3);

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *Preconditioner, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1Preconditioner@@UEAA@XZ";
}
Preconditioner_VTable :: struct #type_info_none {
    operator_parens: (this: *Preconditioner, x: *Preconditioner.TVStack, b: *Preconditioner.TVStack) -> void #cpp_method;
    // operator_parens :: (this: Preconditioner, x: Preconditioner.TVStack, b: *Preconditioner.TVStack) #no_context {
    //     operator_parens(*this, *x, b);
    // }
    reinitialize: (this: *Preconditioner, nodeUpdated: bool) -> void #cpp_method;
    Destructor: (this: *Preconditioner, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}

Preconditioner_operator_parens :: inline (this: *Preconditioner, x: *Preconditioner.TVStack, b: *Preconditioner.TVStack) { this.vtable.operator_parens(this, x, b); }
Preconditioner_reinitialize :: inline (this: *Preconditioner, nodeUpdated: bool) { this.vtable.reinitialize(this, nodeUpdated); }
Preconditioner_Destructor :: inline (this: *Preconditioner, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



DefaultPreconditioner :: struct {
    #as using preconditioner: Preconditioner;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_operator_parens :: (this: *DefaultPreconditioner, x: *Preconditioner.TVStack, b: *Preconditioner.TVStack) -> void #cpp_method #foreign bullet3 "??RDefaultPreconditioner@@UEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV1@@Z";
    // operator_parens :: (this: DefaultPreconditioner, x: Preconditioner.TVStack, b: *Preconditioner.TVStack) #no_context {
    //     operator_parens(*this, *x, b);
    // }

    virtual_reinitialize :: (this: *DefaultPreconditioner, nodeUpdated: bool) -> void #cpp_method #foreign bullet3 "?reinitialize@DefaultPreconditioner@@UEAAX_N@Z";

    virtual_Destructor :: (this: *DefaultPreconditioner, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1DefaultPreconditioner@@UEAA@XZ";
}

MassPreconditioner :: struct {
    #as using preconditioner: Preconditioner;

    m_inv_mass:   btAlignedObjectArray(btScalar);
    m_softBodies: *btAlignedObjectArray(*btSoftBody);

    Constructor :: (this: *MassPreconditioner, softBodies: *btAlignedObjectArray(*btSoftBody)) -> void #cpp_method #foreign bullet3 "??0MassPreconditioner@@QEAA@AEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@@Z";
    Constructor :: (this: *MassPreconditioner, softBodies: btAlignedObjectArray(*btSoftBody)) #no_context {
        Constructor(this, *softBodies);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_reinitialize :: (this: *MassPreconditioner, nodeUpdated: bool) -> void #cpp_method #foreign bullet3 "?reinitialize@MassPreconditioner@@UEAAX_N@Z";

    virtual_operator_parens :: (this: *MassPreconditioner, x: *Preconditioner.TVStack, b: *Preconditioner.TVStack) -> void #cpp_method #foreign bullet3 "??RMassPreconditioner@@UEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV1@@Z";
    // operator_parens :: (this: MassPreconditioner, x: Preconditioner.TVStack, b: *Preconditioner.TVStack) #no_context {
    //     operator_parens(*this, *x, b);
    // }
}

KKTPreconditioner :: struct {
    #as using preconditioner: Preconditioner;

    m_softBodies:  *btAlignedObjectArray(*btSoftBody);
    m_projections: *btDeformableContactProjection;
    m_lf:          *btAlignedObjectArray(*btDeformableLagrangianForce);
    m_inv_A:       Preconditioner.TVStack;
    m_inv_S:       Preconditioner.TVStack;
    m_dt:          *btScalar;
    m_implicit:    *bool;

    Constructor :: (this: *KKTPreconditioner, softBodies: *btAlignedObjectArray(*btSoftBody), projections: *btDeformableContactProjection, lf: *btAlignedObjectArray(*btDeformableLagrangianForce), dt: *btScalar, implicit: *bool) -> void #cpp_method #foreign bullet3 "??0KKTPreconditioner@@QEAA@AEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@AEBVbtDeformableContactProjection@@AEBV?$btAlignedObjectArray@PEAVbtDeformableLagrangianForce@@@@AEBMAEB_N@Z";
    Constructor :: (this: *KKTPreconditioner, softBodies: btAlignedObjectArray(*btSoftBody), projections: btDeformableContactProjection, lf: btAlignedObjectArray(*btDeformableLagrangianForce), dt: btScalar, implicit: bool) #no_context {
        Constructor(this, *softBodies, *projections, *lf, *dt, *implicit);
    }

    buildDiagonalA :: (this: *KKTPreconditioner, diagA: *Preconditioner.TVStack) -> void #cpp_method #foreign bullet3 "?buildDiagonalA@KKTPreconditioner@@QEBAXAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    buildDiagonalS :: (this: *KKTPreconditioner, inv_A: *Preconditioner.TVStack, diagS: *Preconditioner.TVStack) -> void #cpp_method #foreign bullet3 "?buildDiagonalS@KKTPreconditioner@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";
    buildDiagonalS :: (this: *KKTPreconditioner, inv_A: Preconditioner.TVStack, diagS: *Preconditioner.TVStack) #no_context {
        buildDiagonalS(this, *inv_A, diagS);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_reinitialize :: (this: *KKTPreconditioner, nodeUpdated: bool) -> void #cpp_method #foreign bullet3 "?reinitialize@KKTPreconditioner@@UEAAX_N@Z";

    virtual_operator_parens :: (this: *KKTPreconditioner, x: *Preconditioner.TVStack, b: *Preconditioner.TVStack) -> void #cpp_method #foreign bullet3 "??RKKTPreconditioner@@UEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV1@@Z";
    // operator_parens :: (this: KKTPreconditioner, x: Preconditioner.TVStack, b: *Preconditioner.TVStack) #no_context {
    //     operator_parens(*this, *x, b);
    // }
}

btDeformableBackwardEulerObjective :: struct {
    vtable: *btDeformableBackwardEulerObjective_VTable;
    _ :: enum s32 {
        Mass_preconditioner :: 0;
        KKT_preconditioner  :: 1;
    }

    TVStack :: btAlignedObjectArray(btVector3);
    m_dt:                 btScalar;
    m_lf:                 btAlignedObjectArray(*btDeformableLagrangianForce);
    m_softBodies:         *btAlignedObjectArray(*btSoftBody);
    m_preconditioner:     *Preconditioner;
    m_projection:         btDeformableContactProjection;
    m_backupVelocity:     *TVStack;
    m_nodes:              btAlignedObjectArray(*btSoftBody.Node);
    m_implicit:           bool;
    m_massPreconditioner: *MassPreconditioner;
    m_KKTPreconditioner:  *KKTPreconditioner;

    Constructor :: (this: *btDeformableBackwardEulerObjective, softBodies: *btAlignedObjectArray(*btSoftBody), backup_v: *TVStack) -> void #cpp_method #foreign bullet3 "??0btDeformableBackwardEulerObjective@@QEAA@AEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@AEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    Constructor :: (this: *btDeformableBackwardEulerObjective, softBodies: *btAlignedObjectArray(*btSoftBody), backup_v: TVStack) #no_context {
        Constructor(this, softBodies, *backup_v);
    }

    initialize :: (this: *btDeformableBackwardEulerObjective) -> void #cpp_method #foreign bullet3 "?initialize@btDeformableBackwardEulerObjective@@QEAAXXZ";

    // compute the rhs for CG solve, i.e, add the dt scaled implicit force to residual
    computeResidual :: (this: *btDeformableBackwardEulerObjective, dt: btScalar, residual: *TVStack) -> void #cpp_method #foreign bullet3 "?computeResidual@btDeformableBackwardEulerObjective@@QEAAXMAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // add explicit force to the velocity
    applyExplicitForce :: (this: *btDeformableBackwardEulerObjective, force: *TVStack) -> void #cpp_method #foreign bullet3 "?applyExplicitForce@btDeformableBackwardEulerObjective@@QEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // apply force to velocity and optionally reset the force to zero
    applyForce :: (this: *btDeformableBackwardEulerObjective, force: *TVStack, setZero: bool) -> void #cpp_method #foreign bullet3 "?applyForce@btDeformableBackwardEulerObjective@@QEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@_N@Z";

    // compute the norm of the residual
    computeNorm :: (this: *btDeformableBackwardEulerObjective, residual: *TVStack) -> btScalar #cpp_method #foreign bullet3 "?computeNorm@btDeformableBackwardEulerObjective@@QEBAMAEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    computeNorm :: (this: *btDeformableBackwardEulerObjective, residual: TVStack) -> btScalar #no_context {
        return computeNorm(this, *residual);
    }

    // perform A*x = b
    multiply :: (this: *btDeformableBackwardEulerObjective, x: *TVStack, b: *TVStack) -> void #cpp_method #foreign bullet3 "?multiply@btDeformableBackwardEulerObjective@@QEBAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";
    multiply :: (this: *btDeformableBackwardEulerObjective, x: TVStack, b: *TVStack) #no_context {
        multiply(this, *x, b);
    }

    // set initial guess for CG solve
    initialGuess :: (this: *btDeformableBackwardEulerObjective, dv: *TVStack, residual: *TVStack) -> void #cpp_method #foreign bullet3 "?initialGuess@btDeformableBackwardEulerObjective@@QEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@AEBV2@@Z";
    initialGuess :: (this: *btDeformableBackwardEulerObjective, dv: *TVStack, residual: TVStack) #no_context {
        initialGuess(this, dv, *residual);
    }

    // reset data structure and reset dt
    reinitialize :: (this: *btDeformableBackwardEulerObjective, nodeUpdated: bool, dt: btScalar) -> void #cpp_method #foreign bullet3 "?reinitialize@btDeformableBackwardEulerObjective@@QEAAX_NM@Z";

    setDt :: (this: *btDeformableBackwardEulerObjective, dt: btScalar) -> void #cpp_method #foreign bullet3 "?setDt@btDeformableBackwardEulerObjective@@QEAAXM@Z";

    // add friction force to residual
    applyDynamicFriction :: (this: *btDeformableBackwardEulerObjective, r: *TVStack) -> void #cpp_method #foreign bullet3 "?applyDynamicFriction@btDeformableBackwardEulerObjective@@QEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // add dv to velocity
    updateVelocity :: (this: *btDeformableBackwardEulerObjective, dv: *TVStack) -> void #cpp_method #foreign bullet3 "?updateVelocity@btDeformableBackwardEulerObjective@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@@Z";
    updateVelocity :: (this: *btDeformableBackwardEulerObjective, dv: TVStack) #no_context {
        updateVelocity(this, *dv);
    }

    //set constraints as projections
    setConstraints :: (this: *btDeformableBackwardEulerObjective, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setConstraints@btDeformableBackwardEulerObjective@@QEAAXAEBUbtContactSolverInfo@@@Z";
    setConstraints :: (this: *btDeformableBackwardEulerObjective, infoGlobal: btContactSolverInfo) #no_context {
        setConstraints(this, *infoGlobal);
    }

    // update the projections and project the residual
    project :: (this: *btDeformableBackwardEulerObjective, r: *TVStack) -> void #cpp_method #foreign bullet3 "?project@btDeformableBackwardEulerObjective@@QEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@@Z";

    // perform precondition M^(-1) x = b
    precondition :: (this: *btDeformableBackwardEulerObjective, x: *TVStack, b: *TVStack) -> void #cpp_method #foreign bullet3 "?precondition@btDeformableBackwardEulerObjective@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";
    precondition :: (this: *btDeformableBackwardEulerObjective, x: TVStack, b: *TVStack) #no_context {
        precondition(this, *x, b);
    }

    getIndices :: (this: *btDeformableBackwardEulerObjective) -> *btAlignedObjectArray(*btSoftBody.Node) #cpp_method #foreign bullet3 "?getIndices@btDeformableBackwardEulerObjective@@QEBAPEBV?$btAlignedObjectArray@PEAUNode@btSoftBody@@@@XZ";

    setImplicit :: (this: *btDeformableBackwardEulerObjective, implicit: bool) -> void #cpp_method #foreign bullet3 "?setImplicit@btDeformableBackwardEulerObjective@@QEAAX_N@Z";

    // Calculate the total potential energy in the system
    totalEnergy :: (this: *btDeformableBackwardEulerObjective, dt: btScalar) -> btScalar #cpp_method #foreign bullet3 "?totalEnergy@btDeformableBackwardEulerObjective@@QEAAMM@Z";

    addLagrangeMultiplier :: (this: *btDeformableBackwardEulerObjective, vec: *TVStack, extended_vec: *TVStack) -> void #cpp_method #foreign bullet3 "?addLagrangeMultiplier@btDeformableBackwardEulerObjective@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";
    addLagrangeMultiplier :: (this: *btDeformableBackwardEulerObjective, vec: TVStack, extended_vec: *TVStack) #no_context {
        addLagrangeMultiplier(this, *vec, extended_vec);
    }

    addLagrangeMultiplierRHS :: (this: *btDeformableBackwardEulerObjective, residual: *TVStack, m_dv: *TVStack, extended_residual: *TVStack) -> void #cpp_method #foreign bullet3 "?addLagrangeMultiplierRHS@btDeformableBackwardEulerObjective@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@0AEAV2@@Z";
    addLagrangeMultiplierRHS :: (this: *btDeformableBackwardEulerObjective, residual: TVStack, m_dv: TVStack, extended_residual: *TVStack) #no_context {
        addLagrangeMultiplierRHS(this, *residual, *m_dv, extended_residual);
    }

    calculateContactForce :: (this: *btDeformableBackwardEulerObjective, dv: *TVStack, rhs: *TVStack, f: *TVStack) -> void #cpp_method #foreign bullet3 "?calculateContactForce@btDeformableBackwardEulerObjective@@QEAAXAEBV?$btAlignedObjectArray@VbtVector3@@@@0AEAV2@@Z";
    calculateContactForce :: (this: *btDeformableBackwardEulerObjective, dv: TVStack, rhs: TVStack, f: *TVStack) #no_context {
        calculateContactForce(this, *dv, *rhs, f);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableBackwardEulerObjective, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableBackwardEulerObjective@@UEAA@XZ";

    // reindex all the vertices
    virtual_updateId :: (this: *btDeformableBackwardEulerObjective) -> void #cpp_method #foreign bullet3 "?updateId@btDeformableBackwardEulerObjective@@UEAAXXZ";
}
btDeformableBackwardEulerObjective_VTable :: struct #type_info_none {
    Destructor: (this: *btDeformableBackwardEulerObjective, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    updateId: (this: *btDeformableBackwardEulerObjective) -> void #cpp_method;
}

btDeformableBackwardEulerObjective_Destructor :: inline (this: *btDeformableBackwardEulerObjective, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btDeformableBackwardEulerObjective_updateId :: inline (this: *btDeformableBackwardEulerObjective) { this.vtable.updateId(this); }



btMultiBodyConstraintSolver :: struct {
    #as using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver;

    m_multiBodyNonContactConstraints:               btMultiBodyConstraintArray;

    m_multiBodyNormalContactConstraints:            btMultiBodyConstraintArray;
    m_multiBodyFrictionContactConstraints:          btMultiBodyConstraintArray;
    m_multiBodyTorsionalFrictionContactConstraints: btMultiBodyConstraintArray;
    m_multiBodySpinningFrictionContactConstraints:  btMultiBodyConstraintArray;

    m_data:                                         btMultiBodyJacobianData;

    //temp storage for multi body constraints for a specific island/group called by 'solveGroup'
    m_tmpMultiBodyConstraints:                      **btMultiBodyConstraint;
    m_tmpNumMultiBodyConstraints:                   s32;

    resolveSingleConstraintRowGeneric :: (this: *btMultiBodyConstraintSolver, c: *btMultiBodySolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveSingleConstraintRowGeneric@btMultiBodyConstraintSolver@@IEAAMAEBUbtMultiBodySolverConstraint@@@Z";
    resolveSingleConstraintRowGeneric :: (this: *btMultiBodyConstraintSolver, c: btMultiBodySolverConstraint) -> btScalar #no_context {
        return resolveSingleConstraintRowGeneric(this, *c);
    }

    //solve 2 friction directions and clamp against the implicit friction cone
    resolveConeFrictionConstraintRows :: (this: *btMultiBodyConstraintSolver, cA1: *btMultiBodySolverConstraint, cB: *btMultiBodySolverConstraint) -> btScalar #cpp_method #foreign bullet3 "?resolveConeFrictionConstraintRows@btMultiBodyConstraintSolver@@IEAAMAEBUbtMultiBodySolverConstraint@@0@Z";
    resolveConeFrictionConstraintRows :: (this: *btMultiBodyConstraintSolver, cA1: btMultiBodySolverConstraint, cB: btMultiBodySolverConstraint) -> btScalar #no_context {
        return resolveConeFrictionConstraintRows(this, *cA1, *cB);
    }

    addMultiBodyFrictionConstraint :: (this: *btMultiBodyConstraintSolver, normalAxis: *btVector3, appliedImpulse: *btScalar, manifold: *btPersistentManifold, frictionIndex: s32, cp: *btManifoldPoint, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: *btContactSolverInfo, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> *btMultiBodySolverConstraint #cpp_method #foreign bullet3 "?addMultiBodyFrictionConstraint@btMultiBodyConstraintSolver@@IEAAAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@AEBMPEAVbtPersistentManifold@@HAEAVbtManifoldPoint@@PEAVbtCollisionObject@@4MAEBUbtContactSolverInfo@@MM@Z";
    addMultiBodyFrictionConstraint :: (this: *btMultiBodyConstraintSolver, normalAxis: btVector3, appliedImpulse: btScalar, manifold: *btPersistentManifold, frictionIndex: s32, cp: *btManifoldPoint, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: btContactSolverInfo, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> *btMultiBodySolverConstraint #no_context {
        return addMultiBodyFrictionConstraint(this, *normalAxis, *appliedImpulse, manifold, frictionIndex, cp, colObj0, colObj1, relaxation, *infoGlobal, desiredVelocity, cfmSlip);
    }

    addMultiBodyTorsionalFrictionConstraint :: (this: *btMultiBodyConstraintSolver, normalAxis: *btVector3, manifold: *btPersistentManifold, frictionIndex: s32, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: *btContactSolverInfo, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> *btMultiBodySolverConstraint #cpp_method #foreign bullet3 "?addMultiBodyTorsionalFrictionConstraint@btMultiBodyConstraintSolver@@IEAAAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@PEAVbtPersistentManifold@@HAEAVbtManifoldPoint@@MPEAVbtCollisionObject@@3MAEBUbtContactSolverInfo@@MM@Z";
    addMultiBodyTorsionalFrictionConstraint :: (this: *btMultiBodyConstraintSolver, normalAxis: btVector3, manifold: *btPersistentManifold, frictionIndex: s32, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: btContactSolverInfo, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> *btMultiBodySolverConstraint #no_context {
        return addMultiBodyTorsionalFrictionConstraint(this, *normalAxis, manifold, frictionIndex, cp, combinedTorsionalFriction, colObj0, colObj1, relaxation, *infoGlobal, desiredVelocity, cfmSlip);
    }

    addMultiBodySpinningFrictionConstraint :: (this: *btMultiBodyConstraintSolver, normalAxis: *btVector3, manifold: *btPersistentManifold, frictionIndex: s32, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: *btContactSolverInfo, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> *btMultiBodySolverConstraint #cpp_method #foreign bullet3 "?addMultiBodySpinningFrictionConstraint@btMultiBodyConstraintSolver@@IEAAAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@PEAVbtPersistentManifold@@HAEAVbtManifoldPoint@@MPEAVbtCollisionObject@@3MAEBUbtContactSolverInfo@@MM@Z";
    addMultiBodySpinningFrictionConstraint :: (this: *btMultiBodyConstraintSolver, normalAxis: btVector3, manifold: *btPersistentManifold, frictionIndex: s32, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, colObj0: *btCollisionObject, colObj1: *btCollisionObject, relaxation: btScalar, infoGlobal: btContactSolverInfo, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> *btMultiBodySolverConstraint #no_context {
        return addMultiBodySpinningFrictionConstraint(this, *normalAxis, manifold, frictionIndex, cp, combinedTorsionalFriction, colObj0, colObj1, relaxation, *infoGlobal, desiredVelocity, cfmSlip);
    }

    setupMultiBodyContactConstraint :: (this: *btMultiBodyConstraintSolver, solverConstraint: *btMultiBodySolverConstraint, contactNormal: *btVector3, appliedImpulse: *btScalar, cp: *btManifoldPoint, infoGlobal: *btContactSolverInfo, relaxation: *btScalar, isFriction: bool, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> void #cpp_method #foreign bullet3 "?setupMultiBodyContactConstraint@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@AEBMAEAVbtManifoldPoint@@AEBUbtContactSolverInfo@@AEAM_NMM@Z";
    setupMultiBodyContactConstraint :: (this: *btMultiBodyConstraintSolver, solverConstraint: *btMultiBodySolverConstraint, contactNormal: btVector3, appliedImpulse: btScalar, cp: *btManifoldPoint, infoGlobal: btContactSolverInfo, relaxation: *btScalar, isFriction: bool, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) #no_context {
        setupMultiBodyContactConstraint(this, solverConstraint, *contactNormal, *appliedImpulse, cp, *infoGlobal, relaxation, isFriction, desiredVelocity, cfmSlip);
    }

    //either rolling or spinning friction
    setupMultiBodyTorsionalFrictionConstraint :: (this: *btMultiBodyConstraintSolver, solverConstraint: *btMultiBodySolverConstraint, contactNormal: *btVector3, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, infoGlobal: *btContactSolverInfo, relaxation: *btScalar, isFriction: bool, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) -> void #cpp_method #foreign bullet3 "?setupMultiBodyTorsionalFrictionConstraint@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@AEBVbtVector3@@AEAVbtManifoldPoint@@MAEBUbtContactSolverInfo@@AEAM_NMM@Z";
    setupMultiBodyTorsionalFrictionConstraint :: (this: *btMultiBodyConstraintSolver, solverConstraint: *btMultiBodySolverConstraint, contactNormal: btVector3, cp: *btManifoldPoint, combinedTorsionalFriction: btScalar, infoGlobal: btContactSolverInfo, relaxation: *btScalar, isFriction: bool, desiredVelocity: btScalar = 0, cfmSlip: btScalar = 0) #no_context {
        setupMultiBodyTorsionalFrictionConstraint(this, solverConstraint, *contactNormal, cp, combinedTorsionalFriction, *infoGlobal, relaxation, isFriction, desiredVelocity, cfmSlip);
    }

    convertMultiBodyContact :: (this: *btMultiBodyConstraintSolver, manifold: *btPersistentManifold, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertMultiBodyContact@btMultiBodyConstraintSolver@@IEAAXPEAVbtPersistentManifold@@AEBUbtContactSolverInfo@@@Z";
    convertMultiBodyContact :: (this: *btMultiBodyConstraintSolver, manifold: *btPersistentManifold, infoGlobal: btContactSolverInfo) #no_context {
        convertMultiBodyContact(this, manifold, *infoGlobal);
    }

    applyDeltaVee :: (this: *btMultiBodyConstraintSolver, deltaV: *btScalar, impulse: btScalar, velocityIndex: s32, ndof: s32) -> void #cpp_method #foreign bullet3 "?applyDeltaVee@btMultiBodyConstraintSolver@@IEAAXPEAMMHH@Z";
    writeBackSolverBodyToMultiBody :: (this: *btMultiBodyConstraintSolver, constraint: *btMultiBodySolverConstraint, deltaTime: btScalar) -> void #cpp_method #foreign bullet3 "?writeBackSolverBodyToMultiBody@btMultiBodyConstraintSolver@@IEAAXAEAUbtMultiBodySolverConstraint@@M@Z";
    #place btsequentialimpulseconstraintsolver; btmultibodyconstraintsolver_vtable: *btMultiBodyConstraintSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_convertContacts :: (this: *btMultiBodyConstraintSolver, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertContacts@btMultiBodyConstraintSolver@@MEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z";

    virtual_solveGroupCacheFriendlySetup :: (this: *btMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@btMultiBodyConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    //	virtual btScalar solveGroupCacheFriendlyIterations(btCollisionObject** bodies,int numBodies,btPersistentManifold** manifoldPtr, int numManifolds,btTypedConstraint** constraints,int numConstraints,const btContactSolverInfo& infoGlobal,btIDebugDraw* debugDrawer);
    virtual_solveSingleIteration :: (this: *btMultiBodyConstraintSolver, iteration: s32, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveSingleIteration@btMultiBodyConstraintSolver@@MEAAMHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    ///this method should not be called, it was just used during porting/integration of Featherstone btMultiBody, providing backwards compatibility but no support for btMultiBodyConstraint (only contact constraints)
    virtual_solveGroup :: (this: *btMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> btScalar #cpp_method #foreign bullet3 "?solveGroup@btMultiBodyConstraintSolver@@UEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z";
    virtual_solveGroupCacheFriendlyFinish :: (this: *btMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyFinish@btMultiBodyConstraintSolver@@UEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    virtual_solveMultiBodyGroup :: (this: *btMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, multiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?solveMultiBodyGroup@btMultiBodyConstraintSolver@@UEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HPEAPEAVbtMultiBodyConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z";
}
btMultiBodyConstraintSolver_VTable :: struct #type_info_none {
    using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver_VTable;
    solveMultiBodyGroup: (this: *btMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, multiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> void #cpp_method;
}
btMultiBodyConstraintSolver_solveMultiBodyGroup :: inline (this: *btMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, multiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) { this.btmultibodyconstraintsolver_vtable.solveMultiBodyGroup(this, bodies, numBodies, manifold, numManifolds, constraints, numConstraints, multiBodyConstraints, numMultiBodyConstraints, info, debugDrawer, dispatcher); }

vtable :: (obj: *btMultiBodyConstraintSolver) -> *btMultiBodyConstraintSolver_VTable { return obj.btmultibodyconstraintsolver_vtable; }



btElement :: struct {
    m_id: s32;
    m_sz: s32;
}

///UnionFind calculates connected subsets
// Implements weighted Quick Union with path compression
// optimization: could use short ints instead of ints (halving memory, would limit the number of rigid bodies to 64k, sounds reasonable)
btUnionFind :: struct {
    m_elements: btAlignedObjectArray(btElement);

    Constructor :: (this: *btUnionFind) -> void #cpp_method #foreign bullet3 "??0btUnionFind@@QEAA@XZ";
    Destructor :: (this: *btUnionFind) -> void #cpp_method #foreign bullet3 "??1btUnionFind@@QEAA@XZ";

    //this is a special operation, destroying the content of btUnionFind.
    //it sorts the elements, based on island id, in order to make it easy to iterate over islands
    sortIslands :: (this: *btUnionFind) -> void #cpp_method #foreign bullet3 "?sortIslands@btUnionFind@@QEAAXXZ";

    reset :: (this: *btUnionFind, N: s32) -> void #cpp_method #foreign bullet3 "?reset@btUnionFind@@QEAAXH@Z";

    getNumElements :: (this: *btUnionFind) -> s32 #cpp_method #foreign bullet3 "?getNumElements@btUnionFind@@QEBAHXZ";

    isRoot :: (this: *btUnionFind, x: s32) -> bool #cpp_method #foreign bullet3 "?isRoot@btUnionFind@@QEBA_NH@Z";

    getElement :: (this: *btUnionFind, index: s32) -> *btElement #cpp_method #foreign bullet3 "?getElement@btUnionFind@@QEAAAEAUbtElement@@H@Z";

    getElement_1 :: (this: /*const*/ *btUnionFind, index: s32) -> *btElement #cpp_method #foreign bullet3 "?getElement@btUnionFind@@QEBAAEBUbtElement@@H@Z";

    allocate :: (this: *btUnionFind, N: s32) -> void #cpp_method #foreign bullet3 "?allocate@btUnionFind@@QEAAXH@Z";
    Free :: (this: *btUnionFind) -> void #cpp_method #foreign bullet3 "?Free@btUnionFind@@QEAAXXZ";

    find :: (this: *btUnionFind, p: s32, q: s32) -> s32 #cpp_method #foreign bullet3 "?find@btUnionFind@@QEAAHHH@Z";

    unite :: (this: *btUnionFind, p: s32, q: s32) -> void #cpp_method #foreign bullet3 "?unite@btUnionFind@@QEAAXHH@Z";

    find :: (this: *btUnionFind, x: s32) -> s32 #cpp_method #foreign bullet3 "?find@btUnionFind@@QEAAHH@Z";
}

///SimulationIslandManager creates and handles simulation islands, using btUnionFind
btSimulationIslandManager :: struct {
    vtable: *btSimulationIslandManager_VTable;
    m_unionFind:      btUnionFind;

    m_islandmanifold: btAlignedObjectArray(*btPersistentManifold);
    m_islandBodies:   btAlignedObjectArray(*btCollisionObject);

    m_splitIslands:   bool;

    Constructor :: (this: *btSimulationIslandManager) -> void #cpp_method #foreign bullet3 "??0btSimulationIslandManager@@QEAA@XZ";

    initUnionFind :: (this: *btSimulationIslandManager, n: s32) -> void #cpp_method #foreign bullet3 "?initUnionFind@btSimulationIslandManager@@QEAAXH@Z";

    getUnionFind :: (this: *btSimulationIslandManager) -> *btUnionFind #cpp_method #foreign bullet3 "?getUnionFind@btSimulationIslandManager@@QEAAAEAVbtUnionFind@@XZ";

    findUnions :: (this: *btSimulationIslandManager, dispatcher: *btDispatcher, colWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?findUnions@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@@Z";

    IslandCallback :: struct {
        vtable: *IslandCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *IslandCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1IslandCallback@btSimulationIslandManager@@UEAA@XZ";
    }
    IslandCallback_VTable :: struct #type_info_none {
        Destructor: (this: *IslandCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        processIsland: (this: *IslandCallback, bodies: **btCollisionObject, numBodies: s32, manifolds: **btPersistentManifold, numManifolds: s32, islandId: s32) -> void #cpp_method;
    }

    IslandCallback_Destructor :: inline (this: *IslandCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    IslandCallback_processIsland :: inline (this: *IslandCallback, bodies: **btCollisionObject, numBodies: s32, manifolds: **btPersistentManifold, numManifolds: s32, islandId: s32) { this.vtable.processIsland(this, bodies, numBodies, manifolds, numManifolds, islandId); }



    buildAndProcessIslands :: (this: *btSimulationIslandManager, dispatcher: *btDispatcher, collisionWorld: *btCollisionWorld, callback: *IslandCallback) -> void #cpp_method #foreign bullet3 "?buildAndProcessIslands@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@PEAUIslandCallback@1@@Z";

    buildIslands :: (this: *btSimulationIslandManager, dispatcher: *btDispatcher, colWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?buildIslands@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@@Z";

    processIslands :: (this: *btSimulationIslandManager, dispatcher: *btDispatcher, collisionWorld: *btCollisionWorld, callback: *IslandCallback) -> void #cpp_method #foreign bullet3 "?processIslands@btSimulationIslandManager@@QEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@PEAUIslandCallback@1@@Z";

    getSplitIslands :: (this: *btSimulationIslandManager) -> bool #cpp_method #foreign bullet3 "?getSplitIslands@btSimulationIslandManager@@QEAA_NXZ";

    setSplitIslands :: (this: *btSimulationIslandManager, doSplitIslands: bool) -> void #cpp_method #foreign bullet3 "?setSplitIslands@btSimulationIslandManager@@QEAAX_N@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSimulationIslandManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSimulationIslandManager@@UEAA@XZ";

    virtual_updateActivationState :: (this: *btSimulationIslandManager, colWorld: *btCollisionWorld, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?updateActivationState@btSimulationIslandManager@@UEAAXPEAVbtCollisionWorld@@PEAVbtDispatcher@@@Z";
    virtual_storeIslandActivationState :: (this: *btSimulationIslandManager, world: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?storeIslandActivationState@btSimulationIslandManager@@UEAAXPEAVbtCollisionWorld@@@Z";
}
btSimulationIslandManager_VTable :: struct #type_info_none {
    Destructor: (this: *btSimulationIslandManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    updateActivationState: (this: *btSimulationIslandManager, colWorld: *btCollisionWorld, dispatcher: *btDispatcher) -> void #cpp_method;
    storeIslandActivationState: (this: *btSimulationIslandManager, world: *btCollisionWorld) -> void #cpp_method;
}

btSimulationIslandManager_Destructor :: inline (this: *btSimulationIslandManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btSimulationIslandManager_updateActivationState :: inline (this: *btSimulationIslandManager, colWorld: *btCollisionWorld, dispatcher: *btDispatcher) { this.vtable.updateActivationState(this, colWorld, dispatcher); }
btSimulationIslandManager_storeIslandActivationState :: inline (this: *btSimulationIslandManager, world: *btCollisionWorld) { this.vtable.storeIslandActivationState(this, world); }



btSortConstraintOnIslandPredicate2 :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

btSortMultiBodyConstraintOnIslandPredicate :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

MultiBodyInplaceSolverIslandCallback :: struct {
    #as using islandcallback: btSimulationIslandManager.IslandCallback;

    m_solverInfo:                 *btContactSolverInfo;
    m_solver:                     *btMultiBodyConstraintSolver;
    m_multiBodySortedConstraints: **btMultiBodyConstraint;
    m_numMultiBodyConstraints:    s32;

    m_sortedConstraints:          **btTypedConstraint;
    m_numConstraints:             s32;
    m_debugDrawer:                *btIDebugDraw;
    m_dispatcher:                 *btDispatcher;

    m_bodies:                     btAlignedObjectArray(*btCollisionObject);
    m_softBodies:                 btAlignedObjectArray(*btCollisionObject);
    m_manifolds:                  btAlignedObjectArray(*btPersistentManifold);
    m_constraints:                btAlignedObjectArray(*btTypedConstraint);
    m_multiBodyConstraints:       btAlignedObjectArray(*btMultiBodyConstraint);

    m_islandAnalyticsData:        btAlignedObjectArray(btSolverAnalyticsData);

    Constructor :: (this: *MultiBodyInplaceSolverIslandCallback, solver: *btMultiBodyConstraintSolver, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "??0MultiBodyInplaceSolverIslandCallback@@QEAA@PEAVbtMultiBodyConstraintSolver@@PEAVbtDispatcher@@@Z";

    setMultiBodyConstraintSolver :: (this: *MultiBodyInplaceSolverIslandCallback, solver: *btMultiBodyConstraintSolver) -> void #cpp_method #foreign bullet3 "?setMultiBodyConstraintSolver@MultiBodyInplaceSolverIslandCallback@@QEAAXPEAVbtMultiBodyConstraintSolver@@@Z";
    #place islandcallback; multibodyinplacesolverislandcallback_vtable: *MultiBodyInplaceSolverIslandCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_setup :: (this: *MultiBodyInplaceSolverIslandCallback, solverInfo: *btContactSolverInfo, sortedConstraints: **btTypedConstraint, numConstraints: s32, sortedMultiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?setup@MultiBodyInplaceSolverIslandCallback@@UEAAXPEAUbtContactSolverInfo@@PEAPEAVbtTypedConstraint@@HPEAPEAVbtMultiBodyConstraint@@HPEAVbtIDebugDraw@@@Z";

    virtual_processIsland :: (this: *MultiBodyInplaceSolverIslandCallback, bodies: **btCollisionObject, numBodies: s32, manifolds: **btPersistentManifold, numManifolds: s32, islandId: s32) -> void #cpp_method #foreign bullet3 "?processIsland@MultiBodyInplaceSolverIslandCallback@@UEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HH@Z";

    virtual_processConstraints :: (this: *MultiBodyInplaceSolverIslandCallback, islandId: s32 = -1) -> void #cpp_method #foreign bullet3 "?processConstraints@MultiBodyInplaceSolverIslandCallback@@UEAAXH@Z";
}
MultiBodyInplaceSolverIslandCallback_VTable :: struct #type_info_none {
    using islandcallback: IslandCallback_VTable;
    setup: (this: *MultiBodyInplaceSolverIslandCallback, solverInfo: *btContactSolverInfo, sortedConstraints: **btTypedConstraint, numConstraints: s32, sortedMultiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, debugDrawer: *btIDebugDraw) -> void #cpp_method;

    processConstraints: (this: *MultiBodyInplaceSolverIslandCallback, islandId: s32 = -1) -> void #cpp_method;
}

MultiBodyInplaceSolverIslandCallback_setup :: inline (this: *MultiBodyInplaceSolverIslandCallback, solverInfo: *btContactSolverInfo, sortedConstraints: **btTypedConstraint, numConstraints: s32, sortedMultiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, debugDrawer: *btIDebugDraw) { this.multibodyinplacesolverislandcallback_vtable.setup(this, solverInfo, sortedConstraints, numConstraints, sortedMultiBodyConstraints, numMultiBodyConstraints, debugDrawer); }

MultiBodyInplaceSolverIslandCallback_processConstraints :: inline (this: *MultiBodyInplaceSolverIslandCallback, islandId: s32 = -1) { this.multibodyinplacesolverislandcallback_vtable.processConstraints(this, islandId); }

vtable :: (obj: *MultiBodyInplaceSolverIslandCallback) -> *MultiBodyInplaceSolverIslandCallback_VTable { return obj.multibodyinplacesolverislandcallback_vtable; }


operator_assign :: (this: *MultiBodyInplaceSolverIslandCallback, other: *MultiBodyInplaceSolverIslandCallback) -> *MultiBodyInplaceSolverIslandCallback #cpp_method #foreign bullet3 "??4MultiBodyInplaceSolverIslandCallback@@QEAAAEAU0@AEBU0@@Z";
operator_assign :: (this: *MultiBodyInplaceSolverIslandCallback, other: MultiBodyInplaceSolverIslandCallback) -> *MultiBodyInplaceSolverIslandCallback #no_context {
    return operator_assign(this, *other);
}

///The btMultiBodyDynamicsWorld adds Featherstone multi body dynamics to Bullet
///This implementation is still preliminary/experimental.
btMultiBodyDynamicsWorld :: struct {
    #as using btdiscretedynamicsworld: btDiscreteDynamicsWorld;

    m_multiBodies:                   btAlignedObjectArray(*btMultiBody);
    m_multiBodyConstraints:          btAlignedObjectArray(*btMultiBodyConstraint);
    m_sortedMultiBodyConstraints:    btAlignedObjectArray(*btMultiBodyConstraint);
    m_multiBodyConstraintSolver:     *btMultiBodyConstraintSolver;
    m_solverMultiBodyIslandCallback: *MultiBodyInplaceSolverIslandCallback;

    //cached data to avoid memory allocations
    m_scratch_world_to_local:        btAlignedObjectArray(btQuaternion);
    m_scratch_local_origin:          btAlignedObjectArray(btVector3);
    m_scratch_world_to_local1:       btAlignedObjectArray(btQuaternion);
    m_scratch_local_origin1:         btAlignedObjectArray(btVector3);
    m_scratch_r:                     btAlignedObjectArray(btScalar);
    m_scratch_v:                     btAlignedObjectArray(btVector3);
    m_scratch_m:                     btAlignedObjectArray(btMatrix3x3);

    Constructor :: (this: *btMultiBodyDynamicsWorld, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, constraintSolver: *btMultiBodyConstraintSolver, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btMultiBodyDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtMultiBodyConstraintSolver@@PEAVbtCollisionConfiguration@@@Z";

    getMultiBody :: (this: *btMultiBodyDynamicsWorld, mbIndex: s32) -> *btMultiBody #cpp_method #foreign bullet3 "?getMultiBody@btMultiBodyDynamicsWorld@@QEAAPEAVbtMultiBody@@H@Z";

    getMultiBody_1 :: (this: /*const*/ *btMultiBodyDynamicsWorld, mbIndex: s32) -> *btMultiBody #cpp_method #foreign bullet3 "?getMultiBody@btMultiBodyDynamicsWorld@@QEBAPEBVbtMultiBody@@H@Z";

    integrateMultiBodyTransforms :: (this: *btMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateMultiBodyTransforms@btMultiBodyDynamicsWorld@@QEAAXM@Z";
    predictMultiBodyTransforms :: (this: *btMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictMultiBodyTransforms@btMultiBodyDynamicsWorld@@QEAAXM@Z";

    forwardKinematics :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?forwardKinematics@btMultiBodyDynamicsWorld@@QEAAXXZ";

    buildIslands :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?buildIslands@btMultiBodyDynamicsWorld@@QEAAXXZ";
    #place btdiscretedynamicsworld; btmultibodydynamicsworld_vtable: *btMultiBodyDynamicsWorld_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_calculateSimulationIslands :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?calculateSimulationIslands@btMultiBodyDynamicsWorld@@MEAAXXZ";
    virtual_updateActivationState :: (this: *btMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateActivationState@btMultiBodyDynamicsWorld@@MEAAXM@Z";

    virtual_serializeMultiBodies :: (this: *btMultiBodyDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeMultiBodies@btMultiBodyDynamicsWorld@@MEAAXPEAVbtSerializer@@@Z";

    virtual_Destructor :: (this: *btMultiBodyDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyDynamicsWorld@@UEAA@XZ";

    virtual_solveConstraints :: (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solveConstraints@btMultiBodyDynamicsWorld@@UEAAXAEAUbtContactSolverInfo@@@Z";

    virtual_addMultiBody :: (this: *btMultiBodyDynamicsWorld, body: *btMultiBody, group: s32 = xx CollisionFilterGroups.DefaultFilter, mask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method #foreign bullet3 "?addMultiBody@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBody@@HH@Z";

    virtual_removeMultiBody :: (this: *btMultiBodyDynamicsWorld, body: *btMultiBody) -> void #cpp_method #foreign bullet3 "?removeMultiBody@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBody@@@Z";

    virtual_getNumMultibodies :: (this: *btMultiBodyDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getNumMultibodies@btMultiBodyDynamicsWorld@@UEBAHXZ";

    virtual_addMultiBodyConstraint :: (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) -> void #cpp_method #foreign bullet3 "?addMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraint@@@Z";

    virtual_getNumMultiBodyConstraints :: (this: *btMultiBodyDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getNumMultiBodyConstraints@btMultiBodyDynamicsWorld@@UEBAHXZ";

    virtual_getMultiBodyConstraint :: (this: *btMultiBodyDynamicsWorld, constraintIndex: s32) -> *btMultiBodyConstraint #cpp_method #foreign bullet3 "?getMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAPEAVbtMultiBodyConstraint@@H@Z";

    virtual_getMultiBodyConstraint_1 :: (this: /*const*/ *btMultiBodyDynamicsWorld, constraintIndex: s32) -> *btMultiBodyConstraint #cpp_method #foreign bullet3 "?getMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEBAPEBVbtMultiBodyConstraint@@H@Z";

    virtual_removeMultiBodyConstraint :: (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) -> void #cpp_method #foreign bullet3 "?removeMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraint@@@Z";

    virtual_integrateTransforms :: (this: *btMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateTransforms@btMultiBodyDynamicsWorld@@UEAAXM@Z";

    virtual_predictUnconstraintMotion :: (this: *btMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btMultiBodyDynamicsWorld@@UEAAXM@Z";
    virtual_debugDrawWorld :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btMultiBodyDynamicsWorld@@UEAAXXZ";

    virtual_debugDrawMultiBodyConstraint :: (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) -> void #cpp_method #foreign bullet3 "?debugDrawMultiBodyConstraint@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraint@@@Z";

    virtual_clearForces :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?clearForces@btMultiBodyDynamicsWorld@@UEAAXXZ";
    virtual_clearMultiBodyConstraintForces :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?clearMultiBodyConstraintForces@btMultiBodyDynamicsWorld@@UEAAXXZ";
    virtual_clearMultiBodyForces :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?clearMultiBodyForces@btMultiBodyDynamicsWorld@@UEAAXXZ";
    virtual_applyGravity :: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?applyGravity@btMultiBodyDynamicsWorld@@UEAAXXZ";

    virtual_serialize :: (this: *btMultiBodyDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serialize@btMultiBodyDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z";
    virtual_setMultiBodyConstraintSolver :: (this: *btMultiBodyDynamicsWorld, solver: *btMultiBodyConstraintSolver) -> void #cpp_method #foreign bullet3 "?setMultiBodyConstraintSolver@btMultiBodyDynamicsWorld@@UEAAXPEAVbtMultiBodyConstraintSolver@@@Z";
    virtual_setConstraintSolver :: (this: *btMultiBodyDynamicsWorld, solver: *btConstraintSolver) -> void #cpp_method #foreign bullet3 "?setConstraintSolver@btMultiBodyDynamicsWorld@@UEAAXPEAVbtConstraintSolver@@@Z";
    virtual_getAnalyticsData :: (this: *btMultiBodyDynamicsWorld, m_islandAnalyticsData: *btAlignedObjectArray(btSolverAnalyticsData)) -> void #cpp_method #foreign bullet3 "?getAnalyticsData@btMultiBodyDynamicsWorld@@UEBAXAEAV?$btAlignedObjectArray@UbtSolverAnalyticsData@@@@@Z";

    virtual_solveExternalForces :: (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solveExternalForces@btMultiBodyDynamicsWorld@@UEAAXAEAUbtContactSolverInfo@@@Z";
    virtual_solveInternalConstraints :: (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solveInternalConstraints@btMultiBodyDynamicsWorld@@UEAAXAEAUbtContactSolverInfo@@@Z";

    virtual_saveKinematicState :: (this: *btMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?saveKinematicState@btMultiBodyDynamicsWorld@@UEAAXM@Z";
}
btMultiBodyDynamicsWorld_VTable :: struct #type_info_none {
    using btdiscretedynamicsworld: btDiscreteDynamicsWorld_VTable;
    serializeMultiBodies: (this: *btMultiBodyDynamicsWorld, serializer: *btSerializer) -> void #cpp_method;

    addMultiBody: (this: *btMultiBodyDynamicsWorld, body: *btMultiBody, group: s32 = xx CollisionFilterGroups.DefaultFilter, mask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method;

    removeMultiBody: (this: *btMultiBodyDynamicsWorld, body: *btMultiBody) -> void #cpp_method;

    getNumMultibodies: (this: *btMultiBodyDynamicsWorld) -> s32 #cpp_method;

    addMultiBodyConstraint: (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) -> void #cpp_method;

    getNumMultiBodyConstraints: (this: *btMultiBodyDynamicsWorld) -> s32 #cpp_method;

    getMultiBodyConstraint_1: (this: /*const*/ *btMultiBodyDynamicsWorld, constraintIndex: s32) -> *btMultiBodyConstraint #cpp_method;

    getMultiBodyConstraint: (this: *btMultiBodyDynamicsWorld, constraintIndex: s32) -> *btMultiBodyConstraint #cpp_method;

    removeMultiBodyConstraint: (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) -> void #cpp_method;

    debugDrawMultiBodyConstraint: (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) -> void #cpp_method;

    clearMultiBodyConstraintForces: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method;
    clearMultiBodyForces: (this: *btMultiBodyDynamicsWorld) -> void #cpp_method;

    setMultiBodyConstraintSolver: (this: *btMultiBodyDynamicsWorld, solver: *btMultiBodyConstraintSolver) -> void #cpp_method;

    getAnalyticsData: (this: *btMultiBodyDynamicsWorld, m_islandAnalyticsData: *btAlignedObjectArray(btSolverAnalyticsData)) -> void #cpp_method;

    solveExternalForces: (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method;
    solveInternalConstraints: (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) -> void #cpp_method;
}

btMultiBodyDynamicsWorld_serializeMultiBodies :: inline (this: *btMultiBodyDynamicsWorld, serializer: *btSerializer) { this.btmultibodydynamicsworld_vtable.serializeMultiBodies(this, serializer); }

btMultiBodyDynamicsWorld_addMultiBody :: inline (this: *btMultiBodyDynamicsWorld, body: *btMultiBody, group: s32 = xx CollisionFilterGroups.DefaultFilter, mask: s32 = xx CollisionFilterGroups.AllFilter) { this.btmultibodydynamicsworld_vtable.addMultiBody(this, body, group, mask); }

btMultiBodyDynamicsWorld_removeMultiBody :: inline (this: *btMultiBodyDynamicsWorld, body: *btMultiBody) { this.btmultibodydynamicsworld_vtable.removeMultiBody(this, body); }

btMultiBodyDynamicsWorld_getNumMultibodies :: inline (this: *btMultiBodyDynamicsWorld) -> s32 { return this.btmultibodydynamicsworld_vtable.getNumMultibodies(this); }

btMultiBodyDynamicsWorld_addMultiBodyConstraint :: inline (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) { this.btmultibodydynamicsworld_vtable.addMultiBodyConstraint(this, constraint); }

btMultiBodyDynamicsWorld_getNumMultiBodyConstraints :: inline (this: *btMultiBodyDynamicsWorld) -> s32 { return this.btmultibodydynamicsworld_vtable.getNumMultiBodyConstraints(this); }

btMultiBodyDynamicsWorld_getMultiBodyConstraint_1 :: inline (this: /*const*/ *btMultiBodyDynamicsWorld, constraintIndex: s32) -> *btMultiBodyConstraint { return this.btmultibodydynamicsworld_vtable.getMultiBodyConstraint_1(this, constraintIndex); }

btMultiBodyDynamicsWorld_getMultiBodyConstraint :: inline (this: *btMultiBodyDynamicsWorld, constraintIndex: s32) -> *btMultiBodyConstraint { return this.btmultibodydynamicsworld_vtable.getMultiBodyConstraint(this, constraintIndex); }

btMultiBodyDynamicsWorld_removeMultiBodyConstraint :: inline (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) { this.btmultibodydynamicsworld_vtable.removeMultiBodyConstraint(this, constraint); }

btMultiBodyDynamicsWorld_debugDrawMultiBodyConstraint :: inline (this: *btMultiBodyDynamicsWorld, constraint: *btMultiBodyConstraint) { this.btmultibodydynamicsworld_vtable.debugDrawMultiBodyConstraint(this, constraint); }

btMultiBodyDynamicsWorld_clearMultiBodyConstraintForces :: inline (this: *btMultiBodyDynamicsWorld) { this.btmultibodydynamicsworld_vtable.clearMultiBodyConstraintForces(this); }
btMultiBodyDynamicsWorld_clearMultiBodyForces :: inline (this: *btMultiBodyDynamicsWorld) { this.btmultibodydynamicsworld_vtable.clearMultiBodyForces(this); }

btMultiBodyDynamicsWorld_setMultiBodyConstraintSolver :: inline (this: *btMultiBodyDynamicsWorld, solver: *btMultiBodyConstraintSolver) { this.btmultibodydynamicsworld_vtable.setMultiBodyConstraintSolver(this, solver); }

btMultiBodyDynamicsWorld_getAnalyticsData :: inline (this: *btMultiBodyDynamicsWorld, m_islandAnalyticsData: *btAlignedObjectArray(btSolverAnalyticsData)) { this.btmultibodydynamicsworld_vtable.getAnalyticsData(this, m_islandAnalyticsData); }

btMultiBodyDynamicsWorld_solveExternalForces :: inline (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) { this.btmultibodydynamicsworld_vtable.solveExternalForces(this, solverInfo); }
btMultiBodyDynamicsWorld_solveInternalConstraints :: inline (this: *btMultiBodyDynamicsWorld, solverInfo: *btContactSolverInfo) { this.btmultibodydynamicsworld_vtable.solveInternalConstraints(this, solverInfo); }

vtable :: (obj: *btMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld_VTable { return obj.btmultibodydynamicsworld_vtable; }


btSoftBodyArray :: btAlignedObjectArray(*btSoftBody);

btSoftMultiBodyDynamicsWorld :: struct {
    #as using btmultibodydynamicsworld: btMultiBodyDynamicsWorld;

    m_softBodies:      btSoftBodyArray;
    m_drawFlags:       s32;
    m_drawNodeTree:    bool;
    m_drawFaceTree:    bool;
    m_drawClusterTree: bool;
    m_sbi:             btSoftBodyWorldInfo;

    ///Solver classes that encapsulate multiple soft bodies for solving
    m_softBodySolver:  *btSoftBodySolver;
    m_ownsSolver:      bool;

    solveSoftBodiesConstraints :: (this: *btSoftMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?solveSoftBodiesConstraints@btSoftMultiBodyDynamicsWorld@@IEAAXM@Z";

    serializeSoftBodies :: (this: *btSoftMultiBodyDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSoftBodies@btSoftMultiBodyDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z";

    Constructor :: (this: *btSoftMultiBodyDynamicsWorld, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, constraintSolver: *btMultiBodyConstraintSolver, collisionConfiguration: *btCollisionConfiguration, softBodySolver: *btSoftBodySolver = null) -> void #cpp_method #foreign bullet3 "??0btSoftMultiBodyDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtMultiBodyConstraintSolver@@PEAVbtCollisionConfiguration@@PEAVbtSoftBodySolver@@@Z";

    addSoftBody :: (this: *btSoftMultiBodyDynamicsWorld, body: *btSoftBody, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method #foreign bullet3 "?addSoftBody@btSoftMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@HH@Z";

    removeSoftBody :: (this: *btSoftMultiBodyDynamicsWorld, body: *btSoftBody) -> void #cpp_method #foreign bullet3 "?removeSoftBody@btSoftMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@@Z";

    getDrawFlags :: (this: *btSoftMultiBodyDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getDrawFlags@btSoftMultiBodyDynamicsWorld@@QEBAHXZ";
    setDrawFlags :: (this: *btSoftMultiBodyDynamicsWorld, f: s32) -> void #cpp_method #foreign bullet3 "?setDrawFlags@btSoftMultiBodyDynamicsWorld@@QEAAXH@Z";

    getWorldInfo :: (this: *btSoftMultiBodyDynamicsWorld) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btSoftMultiBodyDynamicsWorld@@QEAAAEAUbtSoftBodyWorldInfo@@XZ";

    getWorldInfo_1 :: (this: /*const*/ *btSoftMultiBodyDynamicsWorld) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btSoftMultiBodyDynamicsWorld@@QEBAAEBUbtSoftBodyWorldInfo@@XZ";

    getSoftBodyArray :: (this: *btSoftMultiBodyDynamicsWorld) -> *btSoftBodyArray #cpp_method #foreign bullet3 "?getSoftBodyArray@btSoftMultiBodyDynamicsWorld@@QEAAAEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@XZ";

    getSoftBodyArray_1 :: (this: /*const*/ *btSoftMultiBodyDynamicsWorld) -> *btSoftBodyArray #cpp_method #foreign bullet3 "?getSoftBodyArray@btSoftMultiBodyDynamicsWorld@@QEBAAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@XZ";

    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// This allows more customization.
    rayTestSingle :: (rayFromTrans: *btTransform, rayToTrans: *btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: *btTransform, resultCallback: *btCollisionWorld.RayResultCallback) -> void #foreign bullet3 "?rayTestSingle@btSoftMultiBodyDynamicsWorld@@SAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@btCollisionWorld@@@Z";
    rayTestSingle :: (rayFromTrans: btTransform, rayToTrans: btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: btTransform, resultCallback: *btCollisionWorld.RayResultCallback) #no_context {
        rayTestSingle(*rayFromTrans, *rayToTrans, collisionObject, collisionShape, *colObjWorldTransform, resultCallback);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_predictUnconstraintMotion :: (this: *btSoftMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btSoftMultiBodyDynamicsWorld@@MEAAXM@Z";

    virtual_internalSingleStepSimulation :: (this: *btSoftMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?internalSingleStepSimulation@btSoftMultiBodyDynamicsWorld@@MEAAXM@Z";

    virtual_Destructor :: (this: *btSoftMultiBodyDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftMultiBodyDynamicsWorld@@UEAA@XZ";

    virtual_debugDrawWorld :: (this: *btSoftMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btSoftMultiBodyDynamicsWorld@@UEAAXXZ";

    ///removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btDiscreteDynamicsWorld::removeCollisionObject
    virtual_removeCollisionObject :: (this: *btSoftMultiBodyDynamicsWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCollisionObject@btSoftMultiBodyDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_getWorldType :: (this: *btSoftMultiBodyDynamicsWorld) -> btDynamicsWorldType #cpp_method #foreign bullet3 "?getWorldType@btSoftMultiBodyDynamicsWorld@@UEBA?AW4btDynamicsWorldType@@XZ";

    virtual_rayTest :: (this: *btSoftMultiBodyDynamicsWorld, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btSoftMultiBodyDynamicsWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z";

    virtual_serialize :: (this: *btSoftMultiBodyDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serialize@btSoftMultiBodyDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z";
}

// btDeformableMultiBodyConstraintSolver extendsn btMultiBodyConstraintSolver to solve for the contact among rigid/multibody and deformable bodies. Notice that the following constraints
// 1. rigid/multibody against rigid/multibody
// 2. rigid/multibody against deforamble
// 3. deformable against deformable
// 4. deformable self collision
// 5. joint constraints
// are all coupled in this solve.
btDeformableMultiBodyConstraintSolver :: struct {
    #as using btmultibodyconstraintsolver: btMultiBodyConstraintSolver;

    m_deformableSolver: *btDeformableBodySolver;

    // write the velocity of the the solver body to the underlying rigid body
    solverBodyWriteBack :: (this: *btDeformableMultiBodyConstraintSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solverBodyWriteBack@btDeformableMultiBodyConstraintSolver@@IEAAXAEBUbtContactSolverInfo@@@Z";
    solverBodyWriteBack :: (this: *btDeformableMultiBodyConstraintSolver, infoGlobal: btContactSolverInfo) #no_context {
        solverBodyWriteBack(this, *infoGlobal);
    }

    // write the velocity of the underlying rigid body to the the the solver body
    writeToSolverBody :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?writeToSolverBody@btDeformableMultiBodyConstraintSolver@@IEAAXPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";
    writeToSolverBody :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: btContactSolverInfo) #no_context {
        writeToSolverBody(this, bodies, numBodies, *infoGlobal);
    }

    // let each deformable body knows which solver body is in constact
    pairDeformableAndSolverBody :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?pairDeformableAndSolverBody@btDeformableMultiBodyConstraintSolver@@IEAAXPEAPEAVbtCollisionObject@@HHAEBUbtContactSolverInfo@@@Z";
    pairDeformableAndSolverBody :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, numDeformableBodies: s32, infoGlobal: btContactSolverInfo) #no_context {
        pairDeformableAndSolverBody(this, bodies, numBodies, numDeformableBodies, *infoGlobal);
    }

    setDeformableSolver :: (this: *btDeformableMultiBodyConstraintSolver, deformableSolver: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?setDeformableSolver@btDeformableMultiBodyConstraintSolver@@QEAAXPEAVbtDeformableBodySolver@@@Z";
    #place btmultibodyconstraintsolver; btdeformablemultibodyconstraintsolver_vtable: *btDeformableMultiBodyConstraintSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveGroupCacheFriendlySplitImpulseIterations :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySplitImpulseIterations@btDeformableMultiBodyConstraintSolver@@MEAAXPEAPEAVbtCollisionObject@@H0HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_solveDeformableGroupIterations :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveDeformableGroupIterations@btDeformableMultiBodyConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@H0HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_solveDeformableBodyGroup :: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, multiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?solveDeformableBodyGroup@btDeformableMultiBodyConstraintSolver@@UEAAXPEAPEAVbtCollisionObject@@H0HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HPEAPEAVbtMultiBodyConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z";
}
btDeformableMultiBodyConstraintSolver_VTable :: struct #type_info_none {
    using btmultibodyconstraintsolver: btMultiBodyConstraintSolver_VTable;
    solveGroupCacheFriendlySplitImpulseIterations_1: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: /*const reference*/ *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> void #cpp_method;

    solveDeformableGroupIterations: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method;

    solveDeformableBodyGroup: (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, multiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> void #cpp_method;
}

btDeformableMultiBodyConstraintSolver_solveGroupCacheFriendlySplitImpulseIterations_1 :: inline (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: /*const reference*/ *btContactSolverInfo, debugDrawer: *btIDebugDraw) { this.btdeformablemultibodyconstraintsolver_vtable.solveGroupCacheFriendlySplitImpulseIterations_1(this, bodies, numBodies, deformableBodies, numDeformableBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer); }

btDeformableMultiBodyConstraintSolver_solveDeformableGroupIterations :: inline (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar { return this.btdeformablemultibodyconstraintsolver_vtable.solveDeformableGroupIterations(this, bodies, numBodies, deformableBodies, numDeformableBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal, debugDrawer); }

btDeformableMultiBodyConstraintSolver_solveDeformableBodyGroup :: inline (this: *btDeformableMultiBodyConstraintSolver, bodies: **btCollisionObject, numBodies: s32, deformableBodies: **btCollisionObject, numDeformableBodies: s32, manifold: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, multiBodyConstraints: **btMultiBodyConstraint, numMultiBodyConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) { this.btdeformablemultibodyconstraintsolver_vtable.solveDeformableBodyGroup(this, bodies, numBodies, deformableBodies, numDeformableBodies, manifold, numManifolds, constraints, numConstraints, multiBodyConstraints, numMultiBodyConstraints, info, debugDrawer, dispatcher); }

vtable :: (obj: *btDeformableMultiBodyConstraintSolver) -> *btDeformableMultiBodyConstraintSolver_VTable { return obj.btdeformablemultibodyconstraintsolver_vtable; }



/* fDrawFlags															*/
fDrawFlags :: struct {
    _ :: enum s32 {
        Nodes       :: 1;
        Links       :: 2;
        Faces       :: 4;
        Tetras      :: 8;
        Normals     :: 16;
        Contacts    :: 32;
        Anchors     :: 64;
        Notes       :: 128;
        Clusters    :: 256;
        NodeTree    :: 512;
        FaceTree    :: 1024;
        ClusterTree :: 2048;
        Joints      :: 4096;

        Std         :: 4302;
        StdTetra    :: 4306;
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

btSoftBodyHelpers :: struct {
    /* Draw body															*/
    Draw :: (psb: *btSoftBody, idraw: *btIDebugDraw, drawflags: s32 = xx _.Std) -> void #foreign bullet3 "?Draw@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@H@Z";

    /* Draw body infos														*/
    DrawInfos :: (psb: *btSoftBody, idraw: *btIDebugDraw, masses: bool, areas: bool, stress: bool) -> void #foreign bullet3 "?DrawInfos@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@_N22@Z";

    /* Draw node tree														*/
    DrawNodeTree :: (psb: *btSoftBody, idraw: *btIDebugDraw, mindepth: s32 = 0, maxdepth: s32 = -1) -> void #foreign bullet3 "?DrawNodeTree@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@HH@Z";

    /* Draw face tree														*/
    DrawFaceTree :: (psb: *btSoftBody, idraw: *btIDebugDraw, mindepth: s32 = 0, maxdepth: s32 = -1) -> void #foreign bullet3 "?DrawFaceTree@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@HH@Z";

    /* Draw cluster tree													*/
    DrawClusterTree :: (psb: *btSoftBody, idraw: *btIDebugDraw, mindepth: s32 = 0, maxdepth: s32 = -1) -> void #foreign bullet3 "?DrawClusterTree@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@HH@Z";

    /* Draw rigid frame														*/
    DrawFrame :: (psb: *btSoftBody, idraw: *btIDebugDraw) -> void #foreign bullet3 "?DrawFrame@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@PEAVbtIDebugDraw@@@Z";

    /* Create a rope														*/
    CreateRope :: (worldInfo: *btSoftBodyWorldInfo, from: *btVector3, to: *btVector3, res: s32, fixeds: s32) -> *btSoftBody #foreign bullet3 "?CreateRope@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@1HH@Z";
    CreateRope :: (worldInfo: *btSoftBodyWorldInfo, from: btVector3, to: btVector3, res: s32, fixeds: s32) -> *btSoftBody #no_context {
        return CreateRope(worldInfo, *from, *to, res, fixeds);
    }

    /* Create a patch														*/
    CreatePatch :: (worldInfo: *btSoftBodyWorldInfo, corner00: *btVector3, corner10: *btVector3, corner01: *btVector3, corner11: *btVector3, resx: s32, resy: s32, fixeds: s32, gendiags: bool, perturbation: btScalar = 0.0) -> *btSoftBody #foreign bullet3 "?CreatePatch@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@111HHH_NM@Z";
    CreatePatch :: (worldInfo: *btSoftBodyWorldInfo, corner00: btVector3, corner10: btVector3, corner01: btVector3, corner11: btVector3, resx: s32, resy: s32, fixeds: s32, gendiags: bool, perturbation: btScalar = 0.0) -> *btSoftBody #no_context {
        return CreatePatch(worldInfo, *corner00, *corner10, *corner01, *corner11, resx, resy, fixeds, gendiags, perturbation);
    }

    /* Create a patch with UV Texture Coordinates	*/
    CreatePatchUV :: (worldInfo: *btSoftBodyWorldInfo, corner00: *btVector3, corner10: *btVector3, corner01: *btVector3, corner11: *btVector3, resx: s32, resy: s32, fixeds: s32, gendiags: bool, tex_coords: *float = null) -> *btSoftBody #foreign bullet3 "?CreatePatchUV@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@111HHH_NPEAM@Z";
    CreatePatchUV :: (worldInfo: *btSoftBodyWorldInfo, corner00: btVector3, corner10: btVector3, corner01: btVector3, corner11: btVector3, resx: s32, resy: s32, fixeds: s32, gendiags: bool, tex_coords: *float = null) -> *btSoftBody #no_context {
        return CreatePatchUV(worldInfo, *corner00, *corner10, *corner01, *corner11, resx, resy, fixeds, gendiags, tex_coords);
    }

    CalculateUV :: (resx: s32, resy: s32, ix: s32, iy: s32, id: s32) -> float #foreign bullet3 "?CalculateUV@btSoftBodyHelpers@@SAMHHHHH@Z";

    /* Create an ellipsoid													*/
    CreateEllipsoid :: (worldInfo: *btSoftBodyWorldInfo, center: *btVector3, radius: *btVector3, res: s32) -> *btSoftBody #foreign bullet3 "?CreateEllipsoid@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@AEBVbtVector3@@1H@Z";
    CreateEllipsoid :: (worldInfo: *btSoftBodyWorldInfo, center: btVector3, radius: btVector3, res: s32) -> *btSoftBody #no_context {
        return CreateEllipsoid(worldInfo, *center, *radius, res);
    }

    /* Create from trimesh													*/
    CreateFromTriMesh :: (worldInfo: *btSoftBodyWorldInfo, vertices: *btScalar, triangles: *s32, ntriangles: s32, randomizeConstraints := true) -> *btSoftBody #foreign bullet3 "?CreateFromTriMesh@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBMPEBHH_N@Z";

    /* Create from convex-hull												*/
    CreateFromConvexHull :: (worldInfo: *btSoftBodyWorldInfo, vertices: *btVector3, nvertices: s32, randomizeConstraints := true) -> *btSoftBody #foreign bullet3 "?CreateFromConvexHull@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBVbtVector3@@H_N@Z";

    /* Export TetGen compatible .smesh file									*/
    //	static void				ExportAsSMeshFile(	btSoftBody* psb,
    //												const char* filename);
    /* Create from TetGen .ele, .face, .node files							*/
    //	static btSoftBody*		CreateFromTetGenFile(	btSoftBodyWorldInfo& worldInfo,
    //													const char* ele,
    //													const char* face,
    //													const char* node,
    //													bool bfacelinks,
    //													bool btetralinks,
    //													bool bfacesfromtetras);
    /* Create from TetGen .ele, .face, .node data							*/
    CreateFromTetGenData :: (worldInfo: *btSoftBodyWorldInfo, ele: *u8, face: *u8, node: *u8, bfacelinks: bool, btetralinks: bool, bfacesfromtetras: bool) -> *btSoftBody #foreign bullet3 "?CreateFromTetGenData@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBD11_N22@Z";

    CreateFromVtkFile :: (worldInfo: *btSoftBodyWorldInfo, vtk_file: *u8) -> *btSoftBody #foreign bullet3 "?CreateFromVtkFile@btSoftBodyHelpers@@SAPEAVbtSoftBody@@AEAUbtSoftBodyWorldInfo@@PEBD@Z";

    writeObj :: (file: *u8, psb: *btSoftBody) -> void #foreign bullet3 "?writeObj@btSoftBodyHelpers@@SAXPEBDPEBVbtSoftBody@@@Z";

    writeState :: (file: *u8, psb: *btSoftBody) -> void #foreign bullet3 "?writeState@btSoftBodyHelpers@@SAXPEBDPEBVbtSoftBody@@@Z";

    //this code cannot be here, dependency on example code are not allowed
    //static std::string loadDeformableState(btAlignedObjectArray<btVector3>& qs, btAlignedObjectArray<btVector3>& vs, const char* filename, CommonFileIOInterface* fileIO);
    getBarycentricWeights :: (a: *btVector3, b: *btVector3, c: *btVector3, d: *btVector3, p: *btVector3, bary: *btVector4) -> void #foreign bullet3 "?getBarycentricWeights@btSoftBodyHelpers@@SAXAEBVbtVector3@@0000AEAVbtVector4@@@Z";
    getBarycentricWeights :: (a: btVector3, b: btVector3, c: btVector3, d: btVector3, p: btVector3, bary: *btVector4) #no_context {
        getBarycentricWeights(*a, *b, *c, *d, *p, bary);
    }

    getBarycentricWeights :: (a: *btVector3, b: *btVector3, c: *btVector3, p: *btVector3, bary: *btVector4) -> void #foreign bullet3 "?getBarycentricWeights@btSoftBodyHelpers@@SAXAEBVbtVector3@@000AEAVbtVector4@@@Z";
    getBarycentricWeights :: (a: btVector3, b: btVector3, c: btVector3, p: btVector3, bary: *btVector4) #no_context {
        getBarycentricWeights(*a, *b, *c, *p, bary);
    }

    interpolateBarycentricWeights :: (psb: *btSoftBody) -> void #foreign bullet3 "?interpolateBarycentricWeights@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@@Z";

    extrapolateBarycentricWeights :: (psb: *btSoftBody) -> void #foreign bullet3 "?extrapolateBarycentricWeights@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@@Z";

    generateBoundaryFaces :: (psb: *btSoftBody) -> void #foreign bullet3 "?generateBoundaryFaces@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@@Z";

    duplicateFaces :: (filename: *u8, psb: *btSoftBody) -> void #foreign bullet3 "?duplicateFaces@btSoftBodyHelpers@@SAXPEBDPEBVbtSoftBody@@@Z";

    /// Sort the list of links to move link calculations that are dependent upon earlier
    /// ones as far as possible away from the calculation of those values
    /// This tends to make adjacent loop iterations not dependent upon one another,
    /// so out-of-order processors can execute instructions from multiple iterations at once
    ReoptimizeLinkOrder :: (psb: *btSoftBody) -> void #foreign bullet3 "?ReoptimizeLinkOrder@btSoftBodyHelpers@@SAXPEAVbtSoftBody@@@Z";
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

btDeformableMultiBodyDynamicsWorld :: struct {
    #as using btmultibodydynamicsworld: btMultiBodyDynamicsWorld;

    TVStack :: btAlignedObjectArray(btVector3);

    ///Solver classes that encapsulate multiple deformable bodies for solving
    m_deformableBodySolver:               *btDeformableBodySolver;
    m_softBodies:                         btSoftBodyArray;
    m_drawFlags:                          s32;
    m_drawNodeTree:                       bool;
    m_drawFaceTree:                       bool;
    m_drawClusterTree:                    bool;
    m_sbi:                                btSoftBodyWorldInfo;
    m_internalTime:                       btScalar;
    m_ccdIterations:                      s32;
    m_implicit:                           bool;
    m_lineSearch:                         bool;
    m_useProjection:                      bool;
    m_solverDeformableBodyIslandCallback: *DeformableBodyInplaceSolverIslandCallback;

    btSolverCallback :: #type (time: btScalar, world: *btDeformableMultiBodyDynamicsWorld) -> void #c_call;
    m_solverCallback:                     btSolverCallback;

    positionCorrection :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?positionCorrection@btDeformableMultiBodyDynamicsWorld@@IEAAXM@Z";

    solveConstraints :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?solveConstraints@btDeformableMultiBodyDynamicsWorld@@IEAAXM@Z";

    clearGravity :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?clearGravity@btDeformableMultiBodyDynamicsWorld@@IEAAXXZ";

    Constructor :: (this: *btDeformableMultiBodyDynamicsWorld, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, constraintSolver: *btDeformableMultiBodyConstraintSolver, collisionConfiguration: *btCollisionConfiguration, deformableBodySolver: *btDeformableBodySolver = null) -> void #cpp_method #foreign bullet3 "??0btDeformableMultiBodyDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtDeformableMultiBodyConstraintSolver@@PEAVbtCollisionConfiguration@@PEAVbtDeformableBodySolver@@@Z";

    setSolverCallback :: (this: *btDeformableMultiBodyDynamicsWorld, cb: btSolverCallback) -> void #cpp_method #foreign bullet3 "?setSolverCallback@btDeformableMultiBodyDynamicsWorld@@QEAAXP6AXMPEAV1@@Z@Z";

    getSoftBodyArray :: (this: *btDeformableMultiBodyDynamicsWorld) -> *btSoftBodyArray #cpp_method #foreign bullet3 "?getSoftBodyArray@btDeformableMultiBodyDynamicsWorld@@QEAAAEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@XZ";

    getSoftBodyArray_1 :: (this: /*const*/ *btDeformableMultiBodyDynamicsWorld) -> *btSoftBodyArray #cpp_method #foreign bullet3 "?getSoftBodyArray@btDeformableMultiBodyDynamicsWorld@@QEBAAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@XZ";

    getWorldInfo :: (this: *btDeformableMultiBodyDynamicsWorld) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btDeformableMultiBodyDynamicsWorld@@QEAAAEAUbtSoftBodyWorldInfo@@XZ";

    getWorldInfo_1 :: (this: /*const*/ *btDeformableMultiBodyDynamicsWorld) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btDeformableMultiBodyDynamicsWorld@@QEBAAEBUbtSoftBodyWorldInfo@@XZ";

    reinitialize :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?reinitialize@btDeformableMultiBodyDynamicsWorld@@QEAAXM@Z";

    applyRigidBodyGravity :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?applyRigidBodyGravity@btDeformableMultiBodyDynamicsWorld@@QEAAXM@Z";

    beforeSolverCallbacks :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?beforeSolverCallbacks@btDeformableMultiBodyDynamicsWorld@@QEAAXM@Z";

    afterSolverCallbacks :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?afterSolverCallbacks@btDeformableMultiBodyDynamicsWorld@@QEAAXM@Z";

    addForce :: (this: *btDeformableMultiBodyDynamicsWorld, psb: *btSoftBody, force: *btDeformableLagrangianForce) -> void #cpp_method #foreign bullet3 "?addForce@btDeformableMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@PEAVbtDeformableLagrangianForce@@@Z";

    removeForce :: (this: *btDeformableMultiBodyDynamicsWorld, psb: *btSoftBody, force: *btDeformableLagrangianForce) -> void #cpp_method #foreign bullet3 "?removeForce@btDeformableMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@PEAVbtDeformableLagrangianForce@@@Z";

    removeSoftBodyForce :: (this: *btDeformableMultiBodyDynamicsWorld, psb: *btSoftBody) -> void #cpp_method #foreign bullet3 "?removeSoftBodyForce@btDeformableMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@@Z";

    removeSoftBody :: (this: *btDeformableMultiBodyDynamicsWorld, body: *btSoftBody) -> void #cpp_method #foreign bullet3 "?removeSoftBody@btDeformableMultiBodyDynamicsWorld@@QEAAXPEAVbtSoftBody@@@Z";

    getDrawFlags :: (this: *btDeformableMultiBodyDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getDrawFlags@btDeformableMultiBodyDynamicsWorld@@QEBAHXZ";
    setDrawFlags :: (this: *btDeformableMultiBodyDynamicsWorld, f: s32) -> void #cpp_method #foreign bullet3 "?setDrawFlags@btDeformableMultiBodyDynamicsWorld@@QEAAXH@Z";

    setupConstraints :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?setupConstraints@btDeformableMultiBodyDynamicsWorld@@QEAAXXZ";

    performDeformableCollisionDetection :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?performDeformableCollisionDetection@btDeformableMultiBodyDynamicsWorld@@QEAAXXZ";

    solveContactConstraints :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?solveContactConstraints@btDeformableMultiBodyDynamicsWorld@@QEAAXXZ";

    sortConstraints :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?sortConstraints@btDeformableMultiBodyDynamicsWorld@@QEAAXXZ";

    softBodySelfCollision :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?softBodySelfCollision@btDeformableMultiBodyDynamicsWorld@@QEAAXXZ";

    setImplicit :: (this: *btDeformableMultiBodyDynamicsWorld, implicit: bool) -> void #cpp_method #foreign bullet3 "?setImplicit@btDeformableMultiBodyDynamicsWorld@@QEAAX_N@Z";

    setLineSearch :: (this: *btDeformableMultiBodyDynamicsWorld, lineSearch: bool) -> void #cpp_method #foreign bullet3 "?setLineSearch@btDeformableMultiBodyDynamicsWorld@@QEAAX_N@Z";

    setUseProjection :: (this: *btDeformableMultiBodyDynamicsWorld, useProjection: bool) -> void #cpp_method #foreign bullet3 "?setUseProjection@btDeformableMultiBodyDynamicsWorld@@QEAAX_N@Z";

    applyRepulsionForce :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?applyRepulsionForce@btDeformableMultiBodyDynamicsWorld@@QEAAXM@Z";

    performGeometricCollisions :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?performGeometricCollisions@btDeformableMultiBodyDynamicsWorld@@QEAAXM@Z";

    btDeformableSingleRayCallback :: struct {
        #as using btbroadphaseraycallback: btBroadphaseRayCallback;

        m_rayFromWorld:   btVector3;
        m_rayToWorld:     btVector3;
        m_rayFromTrans:   btTransform;
        m_rayToTrans:     btTransform;
        m_hitNormal:      btVector3;

        m_world:          *btDeformableMultiBodyDynamicsWorld;
        m_resultCallback: *btCollisionWorld.RayResultCallback;
    }

    rayTestSingle :: (this: *btDeformableMultiBodyDynamicsWorld, rayFromTrans: *btTransform, rayToTrans: *btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: *btTransform, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTestSingle@btDeformableMultiBodyDynamicsWorld@@QEBAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@btCollisionWorld@@@Z";
    rayTestSingle :: (this: *btDeformableMultiBodyDynamicsWorld, rayFromTrans: btTransform, rayToTrans: btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: btTransform, resultCallback: *btCollisionWorld.RayResultCallback) #no_context {
        rayTestSingle(this, *rayFromTrans, *rayToTrans, collisionObject, collisionShape, *colObjWorldTransform, resultCallback);
    }
    #place btmultibodydynamicsworld; btdeformablemultibodydynamicsworld_vtable: *btDeformableMultiBodyDynamicsWorld_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_internalSingleStepSimulation :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?internalSingleStepSimulation@btDeformableMultiBodyDynamicsWorld@@MEAAXM@Z";

    virtual_integrateTransforms :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateTransforms@btDeformableMultiBodyDynamicsWorld@@MEAAXM@Z";

    virtual_updateActivationState :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?updateActivationState@btDeformableMultiBodyDynamicsWorld@@MEAAXM@Z";

    virtual_stepSimulation :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar, maxSubSteps: s32 = 1, fixedTimeStep: btScalar) -> s32 #cpp_method #foreign bullet3 "?stepSimulation@btDeformableMultiBodyDynamicsWorld@@UEAAHMHM@Z";

    virtual_debugDrawWorld :: (this: *btDeformableMultiBodyDynamicsWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btDeformableMultiBodyDynamicsWorld@@UEAAXXZ";

    virtual_Destructor :: (this: *btDeformableMultiBodyDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableMultiBodyDynamicsWorld@@UEAA@XZ";

    virtual_getMultiBodyDynamicsWorld :: (this: *btDeformableMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld #cpp_method #foreign bullet3 "?getMultiBodyDynamicsWorld@btDeformableMultiBodyDynamicsWorld@@UEAAPEAVbtMultiBodyDynamicsWorld@@XZ";

    virtual_getMultiBodyDynamicsWorld_1 :: (this: /*const*/ *btDeformableMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld #cpp_method #foreign bullet3 "?getMultiBodyDynamicsWorld@btDeformableMultiBodyDynamicsWorld@@UEBAPEBVbtMultiBodyDynamicsWorld@@XZ";

    virtual_getWorldType :: (this: *btDeformableMultiBodyDynamicsWorld) -> btDynamicsWorldType #cpp_method #foreign bullet3 "?getWorldType@btDeformableMultiBodyDynamicsWorld@@UEBA?AW4btDynamicsWorldType@@XZ";

    virtual_predictUnconstraintMotion :: (this: *btDeformableMultiBodyDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btDeformableMultiBodyDynamicsWorld@@UEAAXM@Z";

    virtual_addSoftBody :: (this: *btDeformableMultiBodyDynamicsWorld, body: *btSoftBody, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method #foreign bullet3 "?addSoftBody@btDeformableMultiBodyDynamicsWorld@@UEAAXPEAVbtSoftBody@@HH@Z";

    virtual_setGravity :: (this: *btDeformableMultiBodyDynamicsWorld, gravity: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btDeformableMultiBodyDynamicsWorld@@UEAAXAEBVbtVector3@@@Z";

    virtual_removeCollisionObject :: (this: *btDeformableMultiBodyDynamicsWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCollisionObject@btDeformableMultiBodyDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_rayTest :: (this: *btDeformableMultiBodyDynamicsWorld, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btDeformableMultiBodyDynamicsWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z";
}
btDeformableMultiBodyDynamicsWorld_VTable :: struct #type_info_none {
    using btmultibodydynamicsworld: btMultiBodyDynamicsWorld_VTable;
    getMultiBodyDynamicsWorld_1: (this: /*const*/ *btDeformableMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld #cpp_method;

    getMultiBodyDynamicsWorld: (this: *btDeformableMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld #cpp_method;

    addSoftBody: (this: *btDeformableMultiBodyDynamicsWorld, body: *btSoftBody, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method;
}

btDeformableMultiBodyDynamicsWorld_getMultiBodyDynamicsWorld_1 :: inline (this: /*const*/ *btDeformableMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld { return this.btdeformablemultibodydynamicsworld_vtable.getMultiBodyDynamicsWorld_1(this); }

btDeformableMultiBodyDynamicsWorld_getMultiBodyDynamicsWorld :: inline (this: *btDeformableMultiBodyDynamicsWorld) -> *btMultiBodyDynamicsWorld { return this.btdeformablemultibodydynamicsworld_vtable.getMultiBodyDynamicsWorld(this); }

btDeformableMultiBodyDynamicsWorld_addSoftBody :: inline (this: *btDeformableMultiBodyDynamicsWorld, body: *btSoftBody, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) { this.btdeformablemultibodydynamicsworld_vtable.addSoftBody(this, body, collisionFilterGroup, collisionFilterMask); }

vtable :: (obj: *btDeformableMultiBodyDynamicsWorld) -> *btDeformableMultiBodyDynamicsWorld_VTable { return obj.btdeformablemultibodydynamicsworld_vtable; }


// class btDeformableBackwardEulerObjective;
// class btDeformableMultiBodyDynamicsWorld;
btDeformableBodySolver :: struct {
    #as using btsoftbodysolver: btSoftBodySolver;

    TVStack :: btAlignedObjectArray(btVector3);

    m_numNodes:            s32; // total number of deformable body nodes
    m_dv:                  TVStack; // v_{n+1} - v_n
    m_backup_dv:           TVStack; // backed up dv
    m_ddv:                 TVStack; // incremental dv
    m_residual:            TVStack; // rhs of the linear solve
    m_softBodies:          btAlignedObjectArray(*btSoftBody); // all deformable bodies
    m_backupVelocity:      TVStack; // backed up v, equals v_n for implicit, equals v_{n+1}^* for explicit
    m_dt:                  btScalar; // dt
    m_cg:                  btConjugateGradient(btDeformableBackwardEulerObjective); // CG solver
    m_cr:                  btConjugateResidual(btDeformableBackwardEulerObjective); // CR solver
    m_implicit:            bool; // use implicit scheme if true, explicit scheme if false
    m_maxNewtonIterations: s32; // max number of newton iterations
    m_newtonTolerance:     btScalar; // stop newton iterations if f(x) < m_newtonTolerance
    m_lineSearch:          bool; // If true, use newton's method with line search under implicit scheme
    m_reducedSolver:       bool; // flag for reduced soft body solver

    // handles data related to objective function
    m_objective:           *btDeformableBackwardEulerObjective;
    m_useProjection:       bool;

    Constructor :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "??0btDeformableBodySolver@@QEAA@XZ";

    // move to temporary position x_{n+1}^* = x_n + dt * v_{n+1}^*
    // x_{n+1}^* is stored in m_q
    predictDeformableMotion :: (this: *btDeformableBodySolver, psb: *btSoftBody, dt: btScalar) -> void #cpp_method #foreign bullet3 "?predictDeformableMotion@btDeformableBodySolver@@QEAAXPEAVbtSoftBody@@M@Z";

    // save the current velocity to m_backupVelocity
    backupVelocity :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?backupVelocity@btDeformableBodySolver@@QEAAXXZ";

    // set the current velocity to that backed up in m_backupVelocity
    revertVelocity :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?revertVelocity@btDeformableBodySolver@@QEAAXXZ";

    // set velocity to m_dv + m_backupVelocity
    updateVelocity :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?updateVelocity@btDeformableBodySolver@@QEAAXXZ";

    // update the node count
    updateNodes :: (this: *btDeformableBodySolver) -> bool #cpp_method #foreign bullet3 "?updateNodes@btDeformableBodySolver@@QEAA_NXZ";

    // calculate the change in dv resulting from the momentum solve
    computeStep :: (this: *btDeformableBodySolver, ddv: *TVStack, residual: *TVStack) -> void #cpp_method #foreign bullet3 "?computeStep@btDeformableBodySolver@@QEAAXAEAV?$btAlignedObjectArray@VbtVector3@@@@AEBV2@@Z";
    computeStep :: (this: *btDeformableBodySolver, ddv: *TVStack, residual: TVStack) #no_context {
        computeStep(this, ddv, *residual);
    }

    // calculate the change in dv resulting from the momentum solve when line search is turned on
    computeDescentStep :: (this: *btDeformableBodySolver, ddv: *TVStack, residual: *TVStack, verbose := false) -> btScalar #cpp_method #foreign bullet3 "?computeDescentStep@btDeformableBodySolver@@QEAAMAEAV?$btAlignedObjectArray@VbtVector3@@@@AEBV2@_N@Z";
    computeDescentStep :: (this: *btDeformableBodySolver, ddv: *TVStack, residual: TVStack, verbose := false) -> btScalar #no_context {
        return computeDescentStep(this, ddv, *residual, verbose);
    }

    // If true, implicit time stepping scheme is used.
    // Otherwise, explicit time stepping scheme is used
    setImplicit :: (this: *btDeformableBodySolver, implicit: bool) -> void #cpp_method #foreign bullet3 "?setImplicit@btDeformableBodySolver@@QEAAX_N@Z";

    // If true, newton's method with line search is used when implicit time stepping scheme is turned on
    setLineSearch :: (this: *btDeformableBodySolver, lineSearch: bool) -> void #cpp_method #foreign bullet3 "?setLineSearch@btDeformableBodySolver@@QEAAX_N@Z";

    // set temporary position x^* = x_n + dt * v
    // update the deformation gradient at position x^*
    updateState :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?updateState@btDeformableBodySolver@@QEAAXXZ";

    // set dv = dv + scale * ddv
    updateDv :: (this: *btDeformableBodySolver, scale: btScalar = 1) -> void #cpp_method #foreign bullet3 "?updateDv@btDeformableBodySolver@@QEAAXM@Z";

    // set temporary position x^* = x_n + dt * v^*
    updateTempPosition :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?updateTempPosition@btDeformableBodySolver@@QEAAXXZ";

    // save the current dv to m_backup_dv;
    backupDv :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?backupDv@btDeformableBodySolver@@QEAAXXZ";

    // set dv to the backed-up value
    revertDv :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?revertDv@btDeformableBodySolver@@QEAAXXZ";

    // set dv = dv + scale * ddv
    // set v^* = v_n + dv
    // set temporary position x^* = x_n + dt * v^*
    // update the deformation gradient at position x^*
    updateEnergy :: (this: *btDeformableBodySolver, scale: btScalar) -> void #cpp_method #foreign bullet3 "?updateEnergy@btDeformableBodySolver@@QEAAXM@Z";

    // calculates the appropriately scaled kinetic energy in the system, which is
    // 1/2 * dv^T * M * dv
    // used in line search
    kineticEnergy :: (this: *btDeformableBodySolver) -> btScalar #cpp_method #foreign bullet3 "?kineticEnergy@btDeformableBodySolver@@QEAAMXZ";
    #place btsoftbodysolver; btdeformablebodysolver_vtable: *btDeformableBodySolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btDeformableBodySolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDeformableBodySolver@@UEAA@XZ";

    virtual_getSolverType :: (this: *btDeformableBodySolver) -> btSoftBodySolver.SolverTypes #cpp_method #foreign bullet3 "?getSolverType@btDeformableBodySolver@@UEBA?AW4SolverTypes@btSoftBodySolver@@XZ";

    // update soft body normals
    virtual_updateSoftBodies :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?updateSoftBodies@btDeformableBodySolver@@UEAAXXZ";

    virtual_solveContactConstraints :: (this: *btDeformableBodySolver, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveContactConstraints@btDeformableBodySolver@@UEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    // solve the momentum equation
    virtual_solveDeformableConstraints :: (this: *btDeformableBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?solveDeformableConstraints@btDeformableBodySolver@@UEAAXM@Z";

    // set gravity (get from deformable world)
    virtual_setGravity :: (this: *btDeformableBodySolver, gravity: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btDeformableBodySolver@@UEAAXAEBVbtVector3@@@Z";

    // resize/clear data structures
    virtual_reinitialize :: (this: *btDeformableBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), dt: btScalar) -> void #cpp_method #foreign bullet3 "?reinitialize@btDeformableBodySolver@@UEAAXAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@M@Z";

    // set up contact constraints
    virtual_setConstraints :: (this: *btDeformableBodySolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setConstraints@btDeformableBodySolver@@UEAAXAEBUbtContactSolverInfo@@@Z";

    // add in elastic forces and gravity to obtain v_{n+1}^* and calls predictDeformableMotion
    virtual_predictMotion :: (this: *btDeformableBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?predictMotion@btDeformableBodySolver@@UEAAXM@Z";

    // set m_dv and m_backupVelocity to desired value to prepare for momentum solve
    virtual_setupDeformableSolve :: (this: *btDeformableBodySolver, implicit: bool) -> void #cpp_method #foreign bullet3 "?setupDeformableSolve@btDeformableBodySolver@@UEAAX_N@Z";

    virtual_copySoftBodyToVertexBuffer :: (this: *btDeformableBodySolver, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) -> void #cpp_method #foreign bullet3 "?copySoftBodyToVertexBuffer@btDeformableBodySolver@@UEAAXQEBVbtSoftBody@@PEAVbtVertexBufferDescriptor@@@Z";

    // process collision between deformable and rigid
    virtual_processCollision :: (this: *btDeformableBodySolver, softBody: *btSoftBody, collisionObjectWrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?processCollision@btDeformableBodySolver@@UEAAXPEAVbtSoftBody@@PEBUbtCollisionObjectWrapper@@@Z";

    // process collision between deformable and deformable
    virtual_processCollision :: (this: *btDeformableBodySolver, softBody: *btSoftBody, otherSoftBody: *btSoftBody) -> void #cpp_method #foreign bullet3 "?processCollision@btDeformableBodySolver@@UEAAXPEAVbtSoftBody@@0@Z";

    // add explicit force to the velocity in the objective class
    virtual_applyExplicitForce :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?applyExplicitForce@btDeformableBodySolver@@UEAAXXZ";

    // execute position/velocity update and apply anchor constraints in the integrateTransforms from the Dynamics world
    virtual_applyTransforms :: (this: *btDeformableBodySolver, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?applyTransforms@btDeformableBodySolver@@UEAAXM@Z";

    virtual_setStrainLimiting :: (this: *btDeformableBodySolver, opt: bool) -> void #cpp_method #foreign bullet3 "?setStrainLimiting@btDeformableBodySolver@@UEAAX_N@Z";

    virtual_setPreconditioner :: (this: *btDeformableBodySolver, opt: s32) -> void #cpp_method #foreign bullet3 "?setPreconditioner@btDeformableBodySolver@@UEAAXH@Z";

    virtual_getLagrangianForceArray :: (this: *btDeformableBodySolver) -> *btAlignedObjectArray(*btDeformableLagrangianForce) #cpp_method #foreign bullet3 "?getLagrangianForceArray@btDeformableBodySolver@@UEAAPEAV?$btAlignedObjectArray@PEAVbtDeformableLagrangianForce@@@@XZ";

    virtual_getIndices :: (this: *btDeformableBodySolver) -> *btAlignedObjectArray(*btSoftBody.Node) #cpp_method #foreign bullet3 "?getIndices@btDeformableBodySolver@@UEAAPEBV?$btAlignedObjectArray@PEAUNode@btSoftBody@@@@XZ";

    virtual_setProjection :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?setProjection@btDeformableBodySolver@@UEAAXXZ";

    virtual_setLagrangeMultiplier :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?setLagrangeMultiplier@btDeformableBodySolver@@UEAAXXZ";

    virtual_isReducedSolver :: (this: *btDeformableBodySolver) -> bool #cpp_method #foreign bullet3 "?isReducedSolver@btDeformableBodySolver@@UEAA_NXZ";

    virtual_deformableBodyInternalWriteBack :: (this: *btDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?deformableBodyInternalWriteBack@btDeformableBodySolver@@UEAAXXZ";

    // unused functions
    virtual_optimize :: (this: *btDeformableBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), forceUpdate := false) -> void #cpp_method #foreign bullet3 "?optimize@btDeformableBodySolver@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@_N@Z";
    virtual_solveConstraints :: (this: *btDeformableBodySolver, dt: btScalar) -> void #cpp_method #foreign bullet3 "?solveConstraints@btDeformableBodySolver@@UEAAXM@Z";
    virtual_checkInitialized :: (this: *btDeformableBodySolver) -> bool #cpp_method #foreign bullet3 "?checkInitialized@btDeformableBodySolver@@UEAA_NXZ";
    virtual_copyBackToSoftBodies :: (this: *btDeformableBodySolver, bMove := true) -> void #cpp_method #foreign bullet3 "?copyBackToSoftBodies@btDeformableBodySolver@@UEAAX_N@Z";
}
btDeformableBodySolver_VTable :: struct #type_info_none {
    using btsoftbodysolver: btSoftBodySolver_VTable;
    solveContactConstraints: (this: *btDeformableBodySolver, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method;

    solveDeformableConstraints: (this: *btDeformableBodySolver, solverdt: btScalar) -> void #cpp_method;

    setGravity: (this: *btDeformableBodySolver, gravity: *btVector3) -> void #cpp_method;

    reinitialize: (this: *btDeformableBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), dt: btScalar) -> void #cpp_method;

    setConstraints: (this: *btDeformableBodySolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    setupDeformableSolve: (this: *btDeformableBodySolver, implicit: bool) -> void #cpp_method;

    copySoftBodyToVertexBuffer: (this: *btDeformableBodySolver, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) -> void #cpp_method;

    applyExplicitForce: (this: *btDeformableBodySolver) -> void #cpp_method;

    applyTransforms: (this: *btDeformableBodySolver, timeStep: btScalar) -> void #cpp_method;

    setStrainLimiting: (this: *btDeformableBodySolver, opt: bool) -> void #cpp_method;

    setPreconditioner: (this: *btDeformableBodySolver, opt: s32) -> void #cpp_method;

    getLagrangianForceArray: (this: *btDeformableBodySolver) -> *btAlignedObjectArray(*btDeformableLagrangianForce) #cpp_method;

    getIndices: (this: *btDeformableBodySolver) -> *btAlignedObjectArray(*btSoftBody.Node) #cpp_method;

    setProjection: (this: *btDeformableBodySolver) -> void #cpp_method;

    setLagrangeMultiplier: (this: *btDeformableBodySolver) -> void #cpp_method;

    isReducedSolver: (this: *btDeformableBodySolver) -> bool #cpp_method;

    deformableBodyInternalWriteBack: (this: *btDeformableBodySolver) -> void #cpp_method;
}

btDeformableBodySolver_solveContactConstraints :: inline (this: *btDeformableBodySolver, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar { return this.btdeformablebodysolver_vtable.solveContactConstraints(this, deformableBodies, numDeformableBodies, infoGlobal); }

btDeformableBodySolver_solveDeformableConstraints :: inline (this: *btDeformableBodySolver, solverdt: btScalar) { this.btdeformablebodysolver_vtable.solveDeformableConstraints(this, solverdt); }

btDeformableBodySolver_setGravity :: inline (this: *btDeformableBodySolver, gravity: *btVector3) { this.btdeformablebodysolver_vtable.setGravity(this, gravity); }

btDeformableBodySolver_reinitialize :: inline (this: *btDeformableBodySolver, softBodies: *btAlignedObjectArray(*btSoftBody), dt: btScalar) { this.btdeformablebodysolver_vtable.reinitialize(this, softBodies, dt); }

btDeformableBodySolver_setConstraints :: inline (this: *btDeformableBodySolver, infoGlobal: *btContactSolverInfo) { this.btdeformablebodysolver_vtable.setConstraints(this, infoGlobal); }

btDeformableBodySolver_setupDeformableSolve :: inline (this: *btDeformableBodySolver, implicit: bool) { this.btdeformablebodysolver_vtable.setupDeformableSolve(this, implicit); }

btDeformableBodySolver_copySoftBodyToVertexBuffer :: inline (this: *btDeformableBodySolver, softBody: *btSoftBody, vertexBuffer: *btVertexBufferDescriptor) { this.btdeformablebodysolver_vtable.copySoftBodyToVertexBuffer(this, softBody, vertexBuffer); }

btDeformableBodySolver_applyExplicitForce :: inline (this: *btDeformableBodySolver) { this.btdeformablebodysolver_vtable.applyExplicitForce(this); }

btDeformableBodySolver_applyTransforms :: inline (this: *btDeformableBodySolver, timeStep: btScalar) { this.btdeformablebodysolver_vtable.applyTransforms(this, timeStep); }

btDeformableBodySolver_setStrainLimiting :: inline (this: *btDeformableBodySolver, opt: bool) { this.btdeformablebodysolver_vtable.setStrainLimiting(this, opt); }

btDeformableBodySolver_setPreconditioner :: inline (this: *btDeformableBodySolver, opt: s32) { this.btdeformablebodysolver_vtable.setPreconditioner(this, opt); }

btDeformableBodySolver_getLagrangianForceArray :: inline (this: *btDeformableBodySolver) -> *btAlignedObjectArray(*btDeformableLagrangianForce) { return this.btdeformablebodysolver_vtable.getLagrangianForceArray(this); }

btDeformableBodySolver_getIndices :: inline (this: *btDeformableBodySolver) -> *btAlignedObjectArray(*btSoftBody.Node) { return this.btdeformablebodysolver_vtable.getIndices(this); }

btDeformableBodySolver_setProjection :: inline (this: *btDeformableBodySolver) { this.btdeformablebodysolver_vtable.setProjection(this); }

btDeformableBodySolver_setLagrangeMultiplier :: inline (this: *btDeformableBodySolver) { this.btdeformablebodysolver_vtable.setLagrangeMultiplier(this); }

btDeformableBodySolver_isReducedSolver :: inline (this: *btDeformableBodySolver) -> bool { return this.btdeformablebodysolver_vtable.isReducedSolver(this); }

btDeformableBodySolver_deformableBodyInternalWriteBack :: inline (this: *btDeformableBodySolver) { this.btdeformablebodysolver_vtable.deformableBodyInternalWriteBack(this); }

vtable :: (obj: *btDeformableBodySolver) -> *btDeformableBodySolver_VTable { return obj.btdeformablebodysolver_vtable; }


btTriIndex :: struct {
    m_PartIdTriangleIndex: s32;
    m_childShape:          *btCollisionShape;

    Constructor :: (this: *btTriIndex, partId: s32, triangleIndex: s32, shape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "??0btTriIndex@@QEAA@HHPEAVbtCollisionShape@@@Z";

    getTriangleIndex :: (this: *btTriIndex) -> s32 #cpp_method #foreign bullet3 "?getTriangleIndex@btTriIndex@@QEBAHXZ";

    getPartId :: (this: *btTriIndex) -> s32 #cpp_method #foreign bullet3 "?getPartId@btTriIndex@@QEBAHXZ";

    getUid :: (this: *btTriIndex) -> s32 #cpp_method #foreign bullet3 "?getUid@btTriIndex@@QEBAHXZ";
}

///For each triangle in the concave mesh that overlaps with the AABB of a soft body (m_softBody), processTriangle is called.
btSoftBodyTriangleCallback :: struct {
    #as using bttrianglecallback: btTriangleCallback;

    m_softBody:                *btSoftBody;
    m_triBody:                 *btCollisionObject;

    m_aabbMin:                 btVector3;
    m_aabbMax:                 btVector3;

    m_resultOut:               *btManifoldResult;

    m_dispatcher:              *btDispatcher;
    m_dispatchInfoPtr:         *btDispatcherInfo;
    m_collisionMarginTriangle: btScalar;

    m_shapeCache:              btHashMap(btHashKey(btTriIndex), btTriIndex);

    m_triangleCount:           s32;

    //	btPersistentManifold*	m_manifoldPtr;
    Constructor :: (this: *btSoftBodyTriangleCallback, dispatcher: *btDispatcher, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btSoftBodyTriangleCallback@@QEAA@PEAVbtDispatcher@@PEBUbtCollisionObjectWrapper@@1_N@Z";

    setTimeStepAndCounters :: (this: *btSoftBodyTriangleCallback, collisionMarginTriangle: btScalar, triObjWrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?setTimeStepAndCounters@btSoftBodyTriangleCallback@@QEAAXMPEBUbtCollisionObjectWrapper@@AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";
    setTimeStepAndCounters :: (this: *btSoftBodyTriangleCallback, collisionMarginTriangle: btScalar, triObjWrap: *btCollisionObjectWrapper, dispatchInfo: btDispatcherInfo, resultOut: *btManifoldResult) #no_context {
        setTimeStepAndCounters(this, collisionMarginTriangle, triObjWrap, *dispatchInfo, resultOut);
    }

    clearCache :: (this: *btSoftBodyTriangleCallback) -> void #cpp_method #foreign bullet3 "?clearCache@btSoftBodyTriangleCallback@@QEAAXXZ";

    getAabbMin :: (this: *btSoftBodyTriangleCallback) -> *btVector3 #cpp_method #foreign bullet3 "?getAabbMin@btSoftBodyTriangleCallback@@QEBAAEBVbtVector3@@XZ";

    getAabbMax :: (this: *btSoftBodyTriangleCallback) -> *btVector3 #cpp_method #foreign bullet3 "?getAabbMax@btSoftBodyTriangleCallback@@QEBAAEBVbtVector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftBodyTriangleCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBodyTriangleCallback@@UEAA@XZ";

    virtual_processTriangle :: (this: *btSoftBodyTriangleCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method #foreign bullet3 "?processTriangle@btSoftBodyTriangleCallback@@UEAAXPEAVbtVector3@@HH@Z";
}

/// btSoftBodyConcaveCollisionAlgorithm  supports collision between soft body shapes and (concave) trianges meshes.
btSoftBodyConcaveCollisionAlgorithm :: struct {
    #as using btcollisionalgorithm: btCollisionAlgorithm;

    m_isSwapped:                  bool;

    m_btSoftBodyTriangleCallback: btSoftBodyTriangleCallback;

    Constructor :: (this: *btSoftBodyConcaveCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btSoftBodyConcaveCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z";
    Constructor :: (this: *btSoftBodyConcaveCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) #no_context {
        Constructor(this, *ci, body0Wrap, body1Wrap, isSwapped);
    }

    clearCache :: (this: *btSoftBodyConcaveCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?clearCache@btSoftBodyConcaveCollisionAlgorithm@@QEAAXXZ";

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    SwappedCreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftBodyConcaveCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBodyConcaveCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btSoftBodyConcaveCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btSoftBodyConcaveCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btSoftBodyConcaveCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btSoftBodyConcaveCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btSoftBodyConcaveCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btSoftBodyConcaveCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

SoftBodyMaterialData :: struct {
    m_linearStiffness:  float;
    m_angularStiffness: float;
    m_volumeStiffness:  float;
    m_flags:            s32;
}

SoftBodyNodeData :: struct {
    m_material:         *SoftBodyMaterialData;
    m_position:         btVector3FloatData;
    m_previousPosition: btVector3FloatData;
    m_velocity:         btVector3FloatData;
    m_accumulatedForce: btVector3FloatData;
    m_normal:           btVector3FloatData;
    m_inverseMass:      float;
    m_area:             float;
    m_attach:           s32;
    m_pad:              s32;
}

SoftBodyLinkData :: struct {
    m_material:    *SoftBodyMaterialData;
    m_nodeIndices: [2] s32; // Node pointers
    m_restLength:  float; // Rest length
    m_bbending:    s32; // Bending link
}

SoftBodyFaceData :: struct {
    m_normal:      btVector3FloatData; // Normal
    m_material:    *SoftBodyMaterialData;
    m_nodeIndices: [3] s32; // Node pointers
    m_restArea:    float; // Rest area
}

SoftBodyTetraData :: struct {
    m_c0:          [4] btVector3FloatData; // gradients
    m_material:    *SoftBodyMaterialData;
    m_nodeIndices: [4] s32; // Node pointers
    m_restVolume:  float; // Rest volume
    m_c1:          float; // (4*kVST)/(im0+im1+im2+im3)
    m_c2:          float; // m_c1/sum(|g0..3|^2)
    m_pad:         s32;
}

SoftRigidAnchorData :: struct {
    m_c0:         btMatrix3x3FloatData; // Impulse matrix
    m_c1:         btVector3FloatData; // Relative anchor
    m_localFrame: btVector3FloatData; // Anchor position in body space
    m_rigidBody:  *btRigidBodyFloatData;
    m_nodeIndex:  s32; // Node pointer
    m_c2:         float; // ima*dt
}

SoftBodyConfigData :: struct {
    m_aeroModel:                      s32; // Aerodynamic model (default: V_Point)
    m_baumgarte:                      float; // Velocities correction factor (Baumgarte)
    m_damping:                        float; // Damping coefficient [0,1]
    m_drag:                           float; // Drag coefficient [0,+inf]
    m_lift:                           float; // Lift coefficient [0,+inf]
    m_pressure:                       float; // Pressure coefficient [-inf,+inf]
    m_volume:                         float; // Volume conversation coefficient [0,+inf]
    m_dynamicFriction:                float; // Dynamic friction coefficient [0,1]
    m_poseMatch:                      float; // Pose matching coefficient [0,1]
    m_rigidContactHardness:           float; // Rigid contacts hardness [0,1]
    m_kineticContactHardness:         float; // Kinetic contacts hardness [0,1]
    m_softContactHardness:            float; // Soft contacts hardness [0,1]
    m_anchorHardness:                 float; // Anchors hardness [0,1]
    m_softRigidClusterHardness:       float; // Soft vs rigid hardness [0,1] (cluster only)
    m_softKineticClusterHardness:     float; // Soft vs kinetic hardness [0,1] (cluster only)
    m_softSoftClusterHardness:        float; // Soft vs soft hardness [0,1] (cluster only)
    m_softRigidClusterImpulseSplit:   float; // Soft vs rigid impulse split [0,1] (cluster only)
    m_softKineticClusterImpulseSplit: float; // Soft vs rigid impulse split [0,1] (cluster only)
    m_softSoftClusterImpulseSplit:    float; // Soft vs rigid impulse split [0,1] (cluster only)
    m_maxVolume:                      float; // Maximum volume ratio for pose
    m_timeScale:                      float; // Time scale
    m_velocityIterations:             s32; // Velocities solver iterations
    m_positionIterations:             s32; // Positions solver iterations
    m_driftIterations:                s32; // Drift solver iterations
    m_clusterIterations:              s32; // Cluster solver iterations
    m_collisionFlags:                 s32; // Collisions flags
}

SoftBodyPoseData :: struct {
    m_rot:          btMatrix3x3FloatData; // Rotation
    m_scale:        btMatrix3x3FloatData; // Scale
    m_aqq:          btMatrix3x3FloatData; // Base scaling
    m_com:          btVector3FloatData; // COM

    m_positions:    *btVector3FloatData; // Reference positions
    m_weights:      *float; // Weights
    m_numPositions: s32;
    m_numWeigts:    s32;

    m_bvolume:      s32; // Is valid
    m_bframe:       s32; // Is frame
    m_restVolume:   float; // Rest volume
    m_pad:          s32;
}

SoftBodyClusterData :: struct {
    m_framexform:                 btTransformFloatData;
    m_locii:                      btMatrix3x3FloatData;
    m_invwi:                      btMatrix3x3FloatData;
    m_com:                        btVector3FloatData;
    m_vimpulses:                  [2] btVector3FloatData;
    m_dimpulses:                  [2] btVector3FloatData;
    m_lv:                         btVector3FloatData;
    m_av:                         btVector3FloatData;

    m_framerefs:                  *btVector3FloatData;
    m_nodeIndices:                *s32;
    m_masses:                     *float;

    m_numFrameRefs:               s32;
    m_numNodes:                   s32;
    m_numMasses:                  s32;

    m_idmass:                     float;
    m_imass:                      float;
    m_nvimpulses:                 s32;
    m_ndimpulses:                 s32;
    m_ndamping:                   float;
    m_ldamping:                   float;
    m_adamping:                   float;
    m_matching:                   float;
    m_maxSelfCollisionImpulse:    float;
    m_selfCollisionImpulseFactor: float;
    m_containsAnchor:             s32;
    m_collide:                    s32;
    m_clusterIndex:               s32;
}

btSoftJointBodyType :: enum s32 {
    SOFT_BODY_CLUSTER :: 1;
    RIGID_BODY        :: 2;
    COLLISION_OBJECT  :: 3;

    BT_JOINT_SOFT_BODY_CLUSTER :: SOFT_BODY_CLUSTER;
    BT_JOINT_RIGID_BODY        :: RIGID_BODY;
    BT_JOINT_COLLISION_OBJECT  :: COLLISION_OBJECT;
}

btSoftBodyJointData :: struct {
    m_bodyA:       *void;
    m_bodyB:       *void;
    m_refs:        [2] btVector3FloatData;
    m_cfm:         float;
    m_erp:         float;
    m_split:       float;
    m_delete:      s32;
    m_relPosition: [2] btVector3FloatData; //linear
    m_bodyAtype:   s32;
    m_bodyBtype:   s32;
    m_jointType:   s32;
    m_pad:         s32;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btSoftBodyFloatData :: struct {
    m_collisionObjectData: btCollisionObjectFloatData;

    m_pose:                *SoftBodyPoseData;
    m_materials:           **SoftBodyMaterialData;
    m_nodes:               *SoftBodyNodeData;
    m_links:               *SoftBodyLinkData;
    m_faces:               *SoftBodyFaceData;
    m_tetrahedra:          *SoftBodyTetraData;
    m_anchors:             *SoftRigidAnchorData;
    m_clusters:            *SoftBodyClusterData;
    m_joints:              *btSoftBodyJointData;

    m_numMaterials:        s32;
    m_numNodes:            s32;
    m_numLinks:            s32;
    m_numFaces:            s32;
    m_numTetrahedra:       s32;
    m_numAnchors:          s32;
    m_numClusters:         s32;
    m_numJoints:           s32;
    m_config:              SoftBodyConfigData;
}

///btSoftBodyRigidBodyCollisionConfiguration add softbody interaction on top of btDefaultCollisionConfiguration
btSoftBodyRigidBodyCollisionConfiguration :: struct {
    #as using btdefaultcollisionconfiguration: btDefaultCollisionConfiguration;

    //default CreationFunctions, filling the m_doubleDispatch table
    m_softSoftCreateFunc:                *btCollisionAlgorithmCreateFunc;
    m_softRigidConvexCreateFunc:         *btCollisionAlgorithmCreateFunc;
    m_swappedSoftRigidConvexCreateFunc:  *btCollisionAlgorithmCreateFunc;
    m_softRigidConcaveCreateFunc:        *btCollisionAlgorithmCreateFunc;
    m_swappedSoftRigidConcaveCreateFunc: *btCollisionAlgorithmCreateFunc;

    Constructor :: (this: *btSoftBodyRigidBodyCollisionConfiguration, constructionInfo: *btDefaultCollisionConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btSoftBodyRigidBodyCollisionConfiguration@@QEAA@AEBUbtDefaultCollisionConstructionInfo@@@Z";
    Constructor :: (this: *btSoftBodyRigidBodyCollisionConfiguration, constructionInfo: btDefaultCollisionConstructionInfo = btDefaultCollisionConstructionInfo.{}) #no_context {
        Constructor(this, *constructionInfo);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftBodyRigidBodyCollisionConfiguration, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftBodyRigidBodyCollisionConfiguration@@UEAA@XZ";

    ///creation of soft-soft and soft-rigid, and otherwise fallback to base class implementation
    virtual_getCollisionAlgorithmCreateFunc :: (this: *btSoftBodyRigidBodyCollisionConfiguration, proxyType0: s32, proxyType1: s32) -> *btCollisionAlgorithmCreateFunc #cpp_method #foreign bullet3 "?getCollisionAlgorithmCreateFunc@btSoftBodyRigidBodyCollisionConfiguration@@UEAAPEAUbtCollisionAlgorithmCreateFunc@@HH@Z";
}

/// btSoftRigidCollisionAlgorithm  provides collision detection between btSoftBody and btRigidBody
btSoftRigidCollisionAlgorithm :: struct {
    #as using btcollisionalgorithm: btCollisionAlgorithm;

    ///for rigid versus soft (instead of soft versus rigid), we use this swapped boolean
    m_isSwapped: bool;

    Constructor :: (this: *btSoftRigidCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, col0: *btCollisionObjectWrapper, col1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btSoftRigidCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_N@Z";
    Constructor :: (this: *btSoftRigidCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, col0: *btCollisionObjectWrapper, col1Wrap: *btCollisionObjectWrapper, isSwapped: bool) #no_context {
        Constructor(this, mf, *ci, col0, col1Wrap, isSwapped);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSoftRigidCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftRigidCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btSoftRigidCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btSoftRigidCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btSoftRigidCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btSoftRigidCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btSoftRigidCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btSoftRigidCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

btSoftRigidDynamicsWorld :: struct {
    #as using btdiscretedynamicsworld: btDiscreteDynamicsWorld;

    m_softBodies:      btSoftBodyArray;
    m_drawFlags:       s32;
    m_drawNodeTree:    bool;
    m_drawFaceTree:    bool;
    m_drawClusterTree: bool;
    m_sbi:             btSoftBodyWorldInfo;

    ///Solver classes that encapsulate multiple soft bodies for solving
    m_softBodySolver:  *btSoftBodySolver;
    m_ownsSolver:      bool;

    solveSoftBodiesConstraints :: (this: *btSoftRigidDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?solveSoftBodiesConstraints@btSoftRigidDynamicsWorld@@IEAAXM@Z";

    serializeSoftBodies :: (this: *btSoftRigidDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serializeSoftBodies@btSoftRigidDynamicsWorld@@IEAAXPEAVbtSerializer@@@Z";

    Constructor :: (this: *btSoftRigidDynamicsWorld, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, constraintSolver: *btConstraintSolver, collisionConfiguration: *btCollisionConfiguration, softBodySolver: *btSoftBodySolver = null) -> void #cpp_method #foreign bullet3 "??0btSoftRigidDynamicsWorld@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@PEAVbtSoftBodySolver@@@Z";

    addSoftBody :: (this: *btSoftRigidDynamicsWorld, body: *btSoftBody, collisionFilterGroup: s32 = xx CollisionFilterGroups.DefaultFilter, collisionFilterMask: s32 = xx CollisionFilterGroups.AllFilter) -> void #cpp_method #foreign bullet3 "?addSoftBody@btSoftRigidDynamicsWorld@@QEAAXPEAVbtSoftBody@@HH@Z";

    removeSoftBody :: (this: *btSoftRigidDynamicsWorld, body: *btSoftBody) -> void #cpp_method #foreign bullet3 "?removeSoftBody@btSoftRigidDynamicsWorld@@QEAAXPEAVbtSoftBody@@@Z";

    getDrawFlags :: (this: *btSoftRigidDynamicsWorld) -> s32 #cpp_method #foreign bullet3 "?getDrawFlags@btSoftRigidDynamicsWorld@@QEBAHXZ";
    setDrawFlags :: (this: *btSoftRigidDynamicsWorld, f: s32) -> void #cpp_method #foreign bullet3 "?setDrawFlags@btSoftRigidDynamicsWorld@@QEAAXH@Z";

    getWorldInfo :: (this: *btSoftRigidDynamicsWorld) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btSoftRigidDynamicsWorld@@QEAAAEAUbtSoftBodyWorldInfo@@XZ";

    getWorldInfo_1 :: (this: /*const*/ *btSoftRigidDynamicsWorld) -> *btSoftBodyWorldInfo #cpp_method #foreign bullet3 "?getWorldInfo@btSoftRigidDynamicsWorld@@QEBAAEBUbtSoftBodyWorldInfo@@XZ";

    getSoftBodyArray :: (this: *btSoftRigidDynamicsWorld) -> *btSoftBodyArray #cpp_method #foreign bullet3 "?getSoftBodyArray@btSoftRigidDynamicsWorld@@QEAAAEAV?$btAlignedObjectArray@PEAVbtSoftBody@@@@XZ";

    getSoftBodyArray_1 :: (this: /*const*/ *btSoftRigidDynamicsWorld) -> *btSoftBodyArray #cpp_method #foreign bullet3 "?getSoftBodyArray@btSoftRigidDynamicsWorld@@QEBAAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@XZ";

    /// rayTestSingle performs a raycast call and calls the resultCallback. It is used internally by rayTest.
    /// In a future implementation, we consider moving the ray test as a virtual method in btCollisionShape.
    /// This allows more customization.
    rayTestSingle :: (rayFromTrans: *btTransform, rayToTrans: *btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: *btTransform, resultCallback: *btCollisionWorld.RayResultCallback) -> void #foreign bullet3 "?rayTestSingle@btSoftRigidDynamicsWorld@@SAXAEBVbtTransform@@0PEAVbtCollisionObject@@PEBVbtCollisionShape@@0AEAURayResultCallback@btCollisionWorld@@@Z";
    rayTestSingle :: (rayFromTrans: btTransform, rayToTrans: btTransform, collisionObject: *btCollisionObject, collisionShape: *btCollisionShape, colObjWorldTransform: btTransform, resultCallback: *btCollisionWorld.RayResultCallback) #no_context {
        rayTestSingle(*rayFromTrans, *rayToTrans, collisionObject, collisionShape, *colObjWorldTransform, resultCallback);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_predictUnconstraintMotion :: (this: *btSoftRigidDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btSoftRigidDynamicsWorld@@MEAAXM@Z";

    virtual_internalSingleStepSimulation :: (this: *btSoftRigidDynamicsWorld, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?internalSingleStepSimulation@btSoftRigidDynamicsWorld@@MEAAXM@Z";

    virtual_Destructor :: (this: *btSoftRigidDynamicsWorld, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftRigidDynamicsWorld@@UEAA@XZ";

    virtual_debugDrawWorld :: (this: *btSoftRigidDynamicsWorld) -> void #cpp_method #foreign bullet3 "?debugDrawWorld@btSoftRigidDynamicsWorld@@UEAAXXZ";

    ///removeCollisionObject will first check if it is a rigid body, if so call removeRigidBody otherwise call btDiscreteDynamicsWorld::removeCollisionObject
    virtual_removeCollisionObject :: (this: *btSoftRigidDynamicsWorld, collisionObject: *btCollisionObject) -> void #cpp_method #foreign bullet3 "?removeCollisionObject@btSoftRigidDynamicsWorld@@UEAAXPEAVbtCollisionObject@@@Z";

    virtual_getWorldType :: (this: *btSoftRigidDynamicsWorld) -> btDynamicsWorldType #cpp_method #foreign bullet3 "?getWorldType@btSoftRigidDynamicsWorld@@UEBA?AW4btDynamicsWorldType@@XZ";

    virtual_rayTest :: (this: *btSoftRigidDynamicsWorld, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btSoftRigidDynamicsWorld@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z";

    virtual_serialize :: (this: *btSoftRigidDynamicsWorld, serializer: *btSerializer) -> void #cpp_method #foreign bullet3 "?serialize@btSoftRigidDynamicsWorld@@UEAAXPEAVbtSerializer@@@Z";
}

///collision detection between two btSoftBody shapes
btSoftSoftCollisionAlgorithm :: struct {
    #as using btcollisionalgorithm: btCollisionAlgorithm;

    m_ownManifold: bool;
    m_manifoldPtr: *btPersistentManifold;

    //	btSoftBody*	m_softBody0;
    //	btSoftBody*	m_softBody1;
    Constructor :: (this: *btSoftSoftCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btSoftSoftCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btSoftSoftCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    Constructor :: (this: *btSoftSoftCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btSoftSoftCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z";
    Constructor :: (this: *btSoftSoftCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processCollision :: (this: *btSoftSoftCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btSoftSoftCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btSoftSoftCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btSoftSoftCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btSoftSoftCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btSoftSoftCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";

    virtual_Destructor :: (this: *btSoftSoftCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSoftSoftCollisionAlgorithm@@UEAA@XZ";
}

DeformableBodyInplaceSolverIslandCallback :: struct {
    #as using multibodyinplacesolverislandcallback: MultiBodyInplaceSolverIslandCallback;

    m_deformableSolver: *btDeformableMultiBodyConstraintSolver;

    Constructor :: (this: *DeformableBodyInplaceSolverIslandCallback, solver: *btDeformableMultiBodyConstraintSolver, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "??0DeformableBodyInplaceSolverIslandCallback@@QEAA@PEAVbtDeformableMultiBodyConstraintSolver@@PEAVbtDispatcher@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processConstraints :: (this: *DeformableBodyInplaceSolverIslandCallback, islandId: s32 = -1) -> void #cpp_method #foreign bullet3 "?processConstraints@DeformableBodyInplaceSolverIslandCallback@@UEAAXH@Z";
}

/* scalar types  */
cl_char :: s8;
cl_uchar :: u8;
cl_short :: s16;
cl_ushort :: u16;
cl_int :: s32;
cl_uint :: u32;
cl_long :: s64;
cl_ulong :: u64;

cl_half :: u16;
cl_float :: float;
cl_double :: float64;

/* Mirror types to GL types. Mirror types allow us to avoid deciding which headers to load based on whether we are using GL or GLES here. */
cl_GLuint :: u32;
cl_GLint :: s32;
cl_GLenum :: u32;

/* ---- cl_charn ---- */
cl_char2 :: union {
    s: [2] cl_char;

    struct {
        x: cl_char;
        y: cl_char;
    }

    struct {
        s0: cl_char;
        s1: cl_char;
    }

    struct {
        lo: cl_char;
        hi: cl_char;
    }
}

cl_char4 :: union {
    s: [4] cl_char;

    struct {
        x: cl_char;
        y: cl_char;
        z: cl_char;
        w: cl_char;
    }

    struct {
        s0: cl_char;
        s1: cl_char;
        s2: cl_char;
        s3: cl_char;
    }

    struct {
        lo: cl_char2;
        hi: cl_char2;
    }
}

/* cl_char3 is identical in size, alignment and behavior to cl_char4. See section 6.1.5. */
cl_char3 :: cl_char4;

cl_char8 :: union {
    s: [8] cl_char;

    struct {
        x: cl_char;
        y: cl_char;
        z: cl_char;
        w: cl_char;
    }

    struct {
        s0: cl_char;
        s1: cl_char;
        s2: cl_char;
        s3: cl_char;
        s4: cl_char;
        s5: cl_char;
        s6: cl_char;
        s7: cl_char;
    }

    struct {
        lo: cl_char4;
        hi: cl_char4;
    }
}

cl_char16 :: union {
    s: [16] cl_char;

    struct {
        x:         cl_char;
        y:         cl_char;
        z:         cl_char;
        w:         cl_char;
        __spacer4: cl_char;
        __spacer5: cl_char;
        __spacer6: cl_char;
        __spacer7: cl_char;
        __spacer8: cl_char;
        __spacer9: cl_char;
        sa:        cl_char;
        sb:        cl_char;
        sc:        cl_char;
        sd:        cl_char;
        se:        cl_char;
        sf:        cl_char;
    }

    struct {
        s0:  cl_char;
        s1:  cl_char;
        s2:  cl_char;
        s3:  cl_char;
        s4:  cl_char;
        s5:  cl_char;
        s6:  cl_char;
        s7:  cl_char;
        _s8: cl_char;
        s9:  cl_char;
        sA:  cl_char;
        sB:  cl_char;
        sC:  cl_char;
        sD:  cl_char;
        sE:  cl_char;
        sF:  cl_char;
    }

    struct {
        lo: cl_char8;
        hi: cl_char8;
    }
}

/* ---- cl_ucharn ---- */
cl_uchar2 :: union {
    s: [2] cl_uchar;

    struct {
        x: cl_uchar;
        y: cl_uchar;
    }

    struct {
        s0: cl_uchar;
        s1: cl_uchar;
    }

    struct {
        lo: cl_uchar;
        hi: cl_uchar;
    }
}

cl_uchar4 :: union {
    s: [4] cl_uchar;

    struct {
        x: cl_uchar;
        y: cl_uchar;
        z: cl_uchar;
        w: cl_uchar;
    }

    struct {
        s0: cl_uchar;
        s1: cl_uchar;
        s2: cl_uchar;
        s3: cl_uchar;
    }

    struct {
        lo: cl_uchar2;
        hi: cl_uchar2;
    }
}

/* cl_uchar3 is identical in size, alignment and behavior to cl_uchar4. See section 6.1.5. */
cl_uchar3 :: cl_uchar4;

cl_uchar8 :: union {
    s: [8] cl_uchar;

    struct {
        x: cl_uchar;
        y: cl_uchar;
        z: cl_uchar;
        w: cl_uchar;
    }

    struct {
        s0: cl_uchar;
        s1: cl_uchar;
        s2: cl_uchar;
        s3: cl_uchar;
        s4: cl_uchar;
        s5: cl_uchar;
        s6: cl_uchar;
        s7: cl_uchar;
    }

    struct {
        lo: cl_uchar4;
        hi: cl_uchar4;
    }
}

cl_uchar16 :: union {
    s: [16] cl_uchar;

    struct {
        x:         cl_uchar;
        y:         cl_uchar;
        z:         cl_uchar;
        w:         cl_uchar;
        __spacer4: cl_uchar;
        __spacer5: cl_uchar;
        __spacer6: cl_uchar;
        __spacer7: cl_uchar;
        __spacer8: cl_uchar;
        __spacer9: cl_uchar;
        sa:        cl_uchar;
        sb:        cl_uchar;
        sc:        cl_uchar;
        sd:        cl_uchar;
        se:        cl_uchar;
        sf:        cl_uchar;
    }

    struct {
        s0:  cl_uchar;
        s1:  cl_uchar;
        s2:  cl_uchar;
        s3:  cl_uchar;
        s4:  cl_uchar;
        s5:  cl_uchar;
        s6:  cl_uchar;
        s7:  cl_uchar;
        _s8: cl_uchar;
        s9:  cl_uchar;
        sA:  cl_uchar;
        sB:  cl_uchar;
        sC:  cl_uchar;
        sD:  cl_uchar;
        sE:  cl_uchar;
        sF:  cl_uchar;
    }

    struct {
        lo: cl_uchar8;
        hi: cl_uchar8;
    }
}

/* ---- cl_shortn ---- */
cl_short2 :: union {
    s: [2] cl_short;

    struct {
        x: cl_short;
        y: cl_short;
    }

    struct {
        s0: cl_short;
        s1: cl_short;
    }

    struct {
        lo: cl_short;
        hi: cl_short;
    }
}

cl_short4 :: union {
    s: [4] cl_short;

    struct {
        x: cl_short;
        y: cl_short;
        z: cl_short;
        w: cl_short;
    }

    struct {
        s0: cl_short;
        s1: cl_short;
        s2: cl_short;
        s3: cl_short;
    }

    struct {
        lo: cl_short2;
        hi: cl_short2;
    }
}

/* cl_short3 is identical in size, alignment and behavior to cl_short4. See section 6.1.5. */
cl_short3 :: cl_short4;

cl_short8 :: union {
    s: [8] cl_short;

    struct {
        x: cl_short;
        y: cl_short;
        z: cl_short;
        w: cl_short;
    }

    struct {
        s0: cl_short;
        s1: cl_short;
        s2: cl_short;
        s3: cl_short;
        s4: cl_short;
        s5: cl_short;
        s6: cl_short;
        s7: cl_short;
    }

    struct {
        lo: cl_short4;
        hi: cl_short4;
    }
}

cl_short16 :: union {
    s: [16] cl_short;

    struct {
        x:         cl_short;
        y:         cl_short;
        z:         cl_short;
        w:         cl_short;
        __spacer4: cl_short;
        __spacer5: cl_short;
        __spacer6: cl_short;
        __spacer7: cl_short;
        __spacer8: cl_short;
        __spacer9: cl_short;
        sa:        cl_short;
        sb:        cl_short;
        sc:        cl_short;
        sd:        cl_short;
        se:        cl_short;
        sf:        cl_short;
    }

    struct {
        s0:  cl_short;
        s1:  cl_short;
        s2:  cl_short;
        s3:  cl_short;
        s4:  cl_short;
        s5:  cl_short;
        s6:  cl_short;
        s7:  cl_short;
        _s8: cl_short;
        s9:  cl_short;
        sA:  cl_short;
        sB:  cl_short;
        sC:  cl_short;
        sD:  cl_short;
        sE:  cl_short;
        sF:  cl_short;
    }

    struct {
        lo: cl_short8;
        hi: cl_short8;
    }
}

/* ---- cl_ushortn ---- */
cl_ushort2 :: union {
    s: [2] cl_ushort;

    struct {
        x: cl_ushort;
        y: cl_ushort;
    }

    struct {
        s0: cl_ushort;
        s1: cl_ushort;
    }

    struct {
        lo: cl_ushort;
        hi: cl_ushort;
    }
}

cl_ushort4 :: union {
    s: [4] cl_ushort;

    struct {
        x: cl_ushort;
        y: cl_ushort;
        z: cl_ushort;
        w: cl_ushort;
    }

    struct {
        s0: cl_ushort;
        s1: cl_ushort;
        s2: cl_ushort;
        s3: cl_ushort;
    }

    struct {
        lo: cl_ushort2;
        hi: cl_ushort2;
    }
}

/* cl_ushort3 is identical in size, alignment and behavior to cl_ushort4. See section 6.1.5. */
cl_ushort3 :: cl_ushort4;

cl_ushort8 :: union {
    s: [8] cl_ushort;

    struct {
        x: cl_ushort;
        y: cl_ushort;
        z: cl_ushort;
        w: cl_ushort;
    }

    struct {
        s0: cl_ushort;
        s1: cl_ushort;
        s2: cl_ushort;
        s3: cl_ushort;
        s4: cl_ushort;
        s5: cl_ushort;
        s6: cl_ushort;
        s7: cl_ushort;
    }

    struct {
        lo: cl_ushort4;
        hi: cl_ushort4;
    }
}

cl_ushort16 :: union {
    s: [16] cl_ushort;

    struct {
        x:         cl_ushort;
        y:         cl_ushort;
        z:         cl_ushort;
        w:         cl_ushort;
        __spacer4: cl_ushort;
        __spacer5: cl_ushort;
        __spacer6: cl_ushort;
        __spacer7: cl_ushort;
        __spacer8: cl_ushort;
        __spacer9: cl_ushort;
        sa:        cl_ushort;
        sb:        cl_ushort;
        sc:        cl_ushort;
        sd:        cl_ushort;
        se:        cl_ushort;
        sf:        cl_ushort;
    }

    struct {
        s0:  cl_ushort;
        s1:  cl_ushort;
        s2:  cl_ushort;
        s3:  cl_ushort;
        s4:  cl_ushort;
        s5:  cl_ushort;
        s6:  cl_ushort;
        s7:  cl_ushort;
        _s8: cl_ushort;
        s9:  cl_ushort;
        sA:  cl_ushort;
        sB:  cl_ushort;
        sC:  cl_ushort;
        sD:  cl_ushort;
        sE:  cl_ushort;
        sF:  cl_ushort;
    }

    struct {
        lo: cl_ushort8;
        hi: cl_ushort8;
    }
}

/* ---- cl_intn ---- */
cl_int2 :: union {
    s: [2] cl_int;

    struct {
        x: cl_int;
        y: cl_int;
    }

    struct {
        s0: cl_int;
        s1: cl_int;
    }

    struct {
        lo: cl_int;
        hi: cl_int;
    }
}

cl_int4 :: union {
    s: [4] cl_int;

    struct {
        x: cl_int;
        y: cl_int;
        z: cl_int;
        w: cl_int;
    }

    struct {
        s0: cl_int;
        s1: cl_int;
        s2: cl_int;
        s3: cl_int;
    }

    struct {
        lo: cl_int2;
        hi: cl_int2;
    }
}

/* cl_int3 is identical in size, alignment and behavior to cl_int4. See section 6.1.5. */
cl_int3 :: cl_int4;

cl_int8 :: union {
    s: [8] cl_int;

    struct {
        x: cl_int;
        y: cl_int;
        z: cl_int;
        w: cl_int;
    }

    struct {
        s0: cl_int;
        s1: cl_int;
        s2: cl_int;
        s3: cl_int;
        s4: cl_int;
        s5: cl_int;
        s6: cl_int;
        s7: cl_int;
    }

    struct {
        lo: cl_int4;
        hi: cl_int4;
    }
}

cl_int16 :: union {
    s: [16] cl_int;

    struct {
        x:         cl_int;
        y:         cl_int;
        z:         cl_int;
        w:         cl_int;
        __spacer4: cl_int;
        __spacer5: cl_int;
        __spacer6: cl_int;
        __spacer7: cl_int;
        __spacer8: cl_int;
        __spacer9: cl_int;
        sa:        cl_int;
        sb:        cl_int;
        sc:        cl_int;
        sd:        cl_int;
        se:        cl_int;
        sf:        cl_int;
    }

    struct {
        s0:  cl_int;
        s1:  cl_int;
        s2:  cl_int;
        s3:  cl_int;
        s4:  cl_int;
        s5:  cl_int;
        s6:  cl_int;
        s7:  cl_int;
        _s8: cl_int;
        s9:  cl_int;
        sA:  cl_int;
        sB:  cl_int;
        sC:  cl_int;
        sD:  cl_int;
        sE:  cl_int;
        sF:  cl_int;
    }

    struct {
        lo: cl_int8;
        hi: cl_int8;
    }
}

/* ---- cl_uintn ---- */
cl_uint2 :: union {
    s: [2] cl_uint;

    struct {
        x: cl_uint;
        y: cl_uint;
    }

    struct {
        s0: cl_uint;
        s1: cl_uint;
    }

    struct {
        lo: cl_uint;
        hi: cl_uint;
    }
}

cl_uint4 :: union {
    s: [4] cl_uint;

    struct {
        x: cl_uint;
        y: cl_uint;
        z: cl_uint;
        w: cl_uint;
    }

    struct {
        s0: cl_uint;
        s1: cl_uint;
        s2: cl_uint;
        s3: cl_uint;
    }

    struct {
        lo: cl_uint2;
        hi: cl_uint2;
    }
}

/* cl_uint3 is identical in size, alignment and behavior to cl_uint4. See section 6.1.5. */
cl_uint3 :: cl_uint4;

cl_uint8 :: union {
    s: [8] cl_uint;

    struct {
        x: cl_uint;
        y: cl_uint;
        z: cl_uint;
        w: cl_uint;
    }

    struct {
        s0: cl_uint;
        s1: cl_uint;
        s2: cl_uint;
        s3: cl_uint;
        s4: cl_uint;
        s5: cl_uint;
        s6: cl_uint;
        s7: cl_uint;
    }

    struct {
        lo: cl_uint4;
        hi: cl_uint4;
    }
}

cl_uint16 :: union {
    s: [16] cl_uint;

    struct {
        x:         cl_uint;
        y:         cl_uint;
        z:         cl_uint;
        w:         cl_uint;
        __spacer4: cl_uint;
        __spacer5: cl_uint;
        __spacer6: cl_uint;
        __spacer7: cl_uint;
        __spacer8: cl_uint;
        __spacer9: cl_uint;
        sa:        cl_uint;
        sb:        cl_uint;
        sc:        cl_uint;
        sd:        cl_uint;
        se:        cl_uint;
        sf:        cl_uint;
    }

    struct {
        s0:  cl_uint;
        s1:  cl_uint;
        s2:  cl_uint;
        s3:  cl_uint;
        s4:  cl_uint;
        s5:  cl_uint;
        s6:  cl_uint;
        s7:  cl_uint;
        _s8: cl_uint;
        s9:  cl_uint;
        sA:  cl_uint;
        sB:  cl_uint;
        sC:  cl_uint;
        sD:  cl_uint;
        sE:  cl_uint;
        sF:  cl_uint;
    }

    struct {
        lo: cl_uint8;
        hi: cl_uint8;
    }
}

/* ---- cl_longn ---- */
cl_long2 :: union {
    s: [2] cl_long;

    struct {
        x: cl_long;
        y: cl_long;
    }

    struct {
        s0: cl_long;
        s1: cl_long;
    }

    struct {
        lo: cl_long;
        hi: cl_long;
    }
}

cl_long4 :: union {
    s: [4] cl_long;

    struct {
        x: cl_long;
        y: cl_long;
        z: cl_long;
        w: cl_long;
    }

    struct {
        s0: cl_long;
        s1: cl_long;
        s2: cl_long;
        s3: cl_long;
    }

    struct {
        lo: cl_long2;
        hi: cl_long2;
    }
}

/* cl_long3 is identical in size, alignment and behavior to cl_long4. See section 6.1.5. */
cl_long3 :: cl_long4;

cl_long8 :: union {
    s: [8] cl_long;

    struct {
        x: cl_long;
        y: cl_long;
        z: cl_long;
        w: cl_long;
    }

    struct {
        s0: cl_long;
        s1: cl_long;
        s2: cl_long;
        s3: cl_long;
        s4: cl_long;
        s5: cl_long;
        s6: cl_long;
        s7: cl_long;
    }

    struct {
        lo: cl_long4;
        hi: cl_long4;
    }
}

cl_long16 :: union {
    s: [16] cl_long;

    struct {
        x:         cl_long;
        y:         cl_long;
        z:         cl_long;
        w:         cl_long;
        __spacer4: cl_long;
        __spacer5: cl_long;
        __spacer6: cl_long;
        __spacer7: cl_long;
        __spacer8: cl_long;
        __spacer9: cl_long;
        sa:        cl_long;
        sb:        cl_long;
        sc:        cl_long;
        sd:        cl_long;
        se:        cl_long;
        sf:        cl_long;
    }

    struct {
        s0:  cl_long;
        s1:  cl_long;
        s2:  cl_long;
        s3:  cl_long;
        s4:  cl_long;
        s5:  cl_long;
        s6:  cl_long;
        s7:  cl_long;
        _s8: cl_long;
        s9:  cl_long;
        sA:  cl_long;
        sB:  cl_long;
        sC:  cl_long;
        sD:  cl_long;
        sE:  cl_long;
        sF:  cl_long;
    }

    struct {
        lo: cl_long8;
        hi: cl_long8;
    }
}

/* ---- cl_ulongn ---- */
cl_ulong2 :: union {
    s: [2] cl_ulong;

    struct {
        x: cl_ulong;
        y: cl_ulong;
    }

    struct {
        s0: cl_ulong;
        s1: cl_ulong;
    }

    struct {
        lo: cl_ulong;
        hi: cl_ulong;
    }
}

cl_ulong4 :: union {
    s: [4] cl_ulong;

    struct {
        x: cl_ulong;
        y: cl_ulong;
        z: cl_ulong;
        w: cl_ulong;
    }

    struct {
        s0: cl_ulong;
        s1: cl_ulong;
        s2: cl_ulong;
        s3: cl_ulong;
    }

    struct {
        lo: cl_ulong2;
        hi: cl_ulong2;
    }
}

/* cl_ulong3 is identical in size, alignment and behavior to cl_ulong4. See section 6.1.5. */
cl_ulong3 :: cl_ulong4;

cl_ulong8 :: union {
    s: [8] cl_ulong;

    struct {
        x: cl_ulong;
        y: cl_ulong;
        z: cl_ulong;
        w: cl_ulong;
    }

    struct {
        s0: cl_ulong;
        s1: cl_ulong;
        s2: cl_ulong;
        s3: cl_ulong;
        s4: cl_ulong;
        s5: cl_ulong;
        s6: cl_ulong;
        s7: cl_ulong;
    }

    struct {
        lo: cl_ulong4;
        hi: cl_ulong4;
    }
}

cl_ulong16 :: union {
    s: [16] cl_ulong;

    struct {
        x:         cl_ulong;
        y:         cl_ulong;
        z:         cl_ulong;
        w:         cl_ulong;
        __spacer4: cl_ulong;
        __spacer5: cl_ulong;
        __spacer6: cl_ulong;
        __spacer7: cl_ulong;
        __spacer8: cl_ulong;
        __spacer9: cl_ulong;
        sa:        cl_ulong;
        sb:        cl_ulong;
        sc:        cl_ulong;
        sd:        cl_ulong;
        se:        cl_ulong;
        sf:        cl_ulong;
    }

    struct {
        s0:  cl_ulong;
        s1:  cl_ulong;
        s2:  cl_ulong;
        s3:  cl_ulong;
        s4:  cl_ulong;
        s5:  cl_ulong;
        s6:  cl_ulong;
        s7:  cl_ulong;
        _s8: cl_ulong;
        s9:  cl_ulong;
        sA:  cl_ulong;
        sB:  cl_ulong;
        sC:  cl_ulong;
        sD:  cl_ulong;
        sE:  cl_ulong;
        sF:  cl_ulong;
    }

    struct {
        lo: cl_ulong8;
        hi: cl_ulong8;
    }
}

/* --- cl_floatn ---- */
cl_float2 :: union {
    s: [2] cl_float;

    struct {
        x: cl_float;
        y: cl_float;
    }

    struct {
        s0: cl_float;
        s1: cl_float;
    }

    struct {
        lo: cl_float;
        hi: cl_float;
    }
}

cl_float4 :: union {
    s: [4] cl_float;

    struct {
        x: cl_float;
        y: cl_float;
        z: cl_float;
        w: cl_float;
    }

    struct {
        s0: cl_float;
        s1: cl_float;
        s2: cl_float;
        s3: cl_float;
    }

    struct {
        lo: cl_float2;
        hi: cl_float2;
    }
}

/* cl_float3 is identical in size, alignment and behavior to cl_float4. See section 6.1.5. */
cl_float3 :: cl_float4;

cl_float8 :: union {
    s: [8] cl_float;

    struct {
        x: cl_float;
        y: cl_float;
        z: cl_float;
        w: cl_float;
    }

    struct {
        s0: cl_float;
        s1: cl_float;
        s2: cl_float;
        s3: cl_float;
        s4: cl_float;
        s5: cl_float;
        s6: cl_float;
        s7: cl_float;
    }

    struct {
        lo: cl_float4;
        hi: cl_float4;
    }
}

cl_float16 :: union {
    s: [16] cl_float;

    struct {
        x:         cl_float;
        y:         cl_float;
        z:         cl_float;
        w:         cl_float;
        __spacer4: cl_float;
        __spacer5: cl_float;
        __spacer6: cl_float;
        __spacer7: cl_float;
        __spacer8: cl_float;
        __spacer9: cl_float;
        sa:        cl_float;
        sb:        cl_float;
        sc:        cl_float;
        sd:        cl_float;
        se:        cl_float;
        sf:        cl_float;
    }

    struct {
        s0:  cl_float;
        s1:  cl_float;
        s2:  cl_float;
        s3:  cl_float;
        s4:  cl_float;
        s5:  cl_float;
        s6:  cl_float;
        s7:  cl_float;
        _s8: cl_float;
        s9:  cl_float;
        sA:  cl_float;
        sB:  cl_float;
        sC:  cl_float;
        sD:  cl_float;
        sE:  cl_float;
        sF:  cl_float;
    }

    struct {
        lo: cl_float8;
        hi: cl_float8;
    }
}

/* --- cl_doublen ---- */
cl_double2 :: union {
    s: [2] cl_double;

    struct {
        x: cl_double;
        y: cl_double;
    }

    struct {
        s0: cl_double;
        s1: cl_double;
    }

    struct {
        lo: cl_double;
        hi: cl_double;
    }
}

cl_double4 :: union {
    s: [4] cl_double;

    struct {
        x: cl_double;
        y: cl_double;
        z: cl_double;
        w: cl_double;
    }

    struct {
        s0: cl_double;
        s1: cl_double;
        s2: cl_double;
        s3: cl_double;
    }

    struct {
        lo: cl_double2;
        hi: cl_double2;
    }
}

/* cl_double3 is identical in size, alignment and behavior to cl_double4. See section 6.1.5. */
cl_double3 :: cl_double4;

cl_double8 :: union {
    s: [8] cl_double;

    struct {
        x: cl_double;
        y: cl_double;
        z: cl_double;
        w: cl_double;
    }

    struct {
        s0: cl_double;
        s1: cl_double;
        s2: cl_double;
        s3: cl_double;
        s4: cl_double;
        s5: cl_double;
        s6: cl_double;
        s7: cl_double;
    }

    struct {
        lo: cl_double4;
        hi: cl_double4;
    }
}

cl_double16 :: union {
    s: [16] cl_double;

    struct {
        x:         cl_double;
        y:         cl_double;
        z:         cl_double;
        w:         cl_double;
        __spacer4: cl_double;
        __spacer5: cl_double;
        __spacer6: cl_double;
        __spacer7: cl_double;
        __spacer8: cl_double;
        __spacer9: cl_double;
        sa:        cl_double;
        sb:        cl_double;
        sc:        cl_double;
        sd:        cl_double;
        se:        cl_double;
        sf:        cl_double;
    }

    struct {
        s0:  cl_double;
        s1:  cl_double;
        s2:  cl_double;
        s3:  cl_double;
        s4:  cl_double;
        s5:  cl_double;
        s6:  cl_double;
        s7:  cl_double;
        _s8: cl_double;
        s9:  cl_double;
        sA:  cl_double;
        sB:  cl_double;
        sC:  cl_double;
        sD:  cl_double;
        sE:  cl_double;
        sF:  cl_double;
    }

    struct {
        lo: cl_double8;
        hi: cl_double8;
    }
}

_cl_platform_id :: struct {}
//  CL.h contents
/******************************************************************************/
cl_platform_id :: *_cl_platform_id;
_cl_device_id :: struct {}
cl_device_id :: *_cl_device_id;
_cl_context :: struct {}
cl_context :: *_cl_context;
_cl_command_queue :: struct {}
cl_command_queue :: *_cl_command_queue;
_cl_mem :: struct {}
cl_mem :: *_cl_mem;
_cl_program :: struct {}
cl_program :: *_cl_program;
_cl_kernel :: struct {}
cl_kernel :: *_cl_kernel;
_cl_event :: struct {}
cl_event :: *_cl_event;
_cl_sampler :: struct {}
cl_sampler :: *_cl_sampler;

cl_bool :: cl_uint;
cl_bitfield :: cl_ulong;
cl_device_type :: cl_bitfield;
cl_platform_info :: cl_uint;
cl_device_info :: cl_uint;
cl_device_fp_config :: cl_bitfield;
cl_device_mem_cache_type :: cl_uint;
cl_device_local_mem_type :: cl_uint;
cl_device_exec_capabilities :: cl_bitfield;
cl_command_queue_properties :: cl_bitfield;

cl_context_properties :: intptr_t;
cl_context_info :: cl_uint;
cl_command_queue_info :: cl_uint;
cl_channel_order :: cl_uint;
cl_channel_type :: cl_uint;
cl_mem_flags :: cl_bitfield;
cl_mem_object_type :: cl_uint;
cl_mem_info :: cl_uint;
cl_image_info :: cl_uint;
cl_buffer_create_type :: cl_uint;
cl_addressing_mode :: cl_uint;
cl_filter_mode :: cl_uint;
cl_sampler_info :: cl_uint;
cl_map_flags :: cl_bitfield;
cl_program_info :: cl_uint;
cl_program_build_info :: cl_uint;
cl_build_status :: cl_int;
cl_kernel_info :: cl_uint;
cl_kernel_work_group_info :: cl_uint;
cl_event_info :: cl_uint;
cl_command_type :: cl_uint;
cl_profiling_info :: cl_uint;

_cl_image_format :: struct {
    image_channel_order:     cl_channel_order;
    image_channel_data_type: cl_channel_type;
}

cl_image_format :: _cl_image_format;

_cl_buffer_region :: struct {
    origin: size_t;
    size:   size_t;
}

cl_buffer_region :: _cl_buffer_region;

/* Platform API */
PFNCLGETPLATFORMIDS :: #type (unknown0: cl_uint, unknown1: *cl_platform_id, unknown2: *cl_uint) -> cl_int #c_call;

PFNCLGETPLATFORMINFO :: #type (unknown0: cl_platform_id, unknown1: cl_platform_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

/* Device APIs */
PFNCLGETDEVICEIDS :: #type (unknown0: cl_platform_id, unknown1: cl_device_type, unknown2: cl_uint, unknown3: *cl_device_id, unknown4: *cl_uint) -> cl_int #c_call;

PFNCLGETDEVICEINFO :: #type (unknown0: cl_device_id, unknown1: cl_device_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

// Context APIs
PFNCLCREATECONTEXT :: #type (unknown0: *cl_context_properties, unknown1: cl_uint, unknown2: *cl_device_id, unknown3: #type (unknown0: *u8, unknown1: *void, unknown2: size_t, unknown3: *void) -> void #c_call, unknown4: *void, unknown5: *cl_int) -> cl_context #c_call;

PFNCLCREATECONTEXTFROMTYPE :: #type (unknown0: *cl_context_properties, unknown1: cl_device_type, unknown2: #type (unknown0: *u8, unknown1: *void, unknown2: size_t, unknown3: *void) -> void #c_call, unknown3: *void, unknown4: *cl_int) -> cl_context #c_call;

PFNCLRETAINCONTEXT :: #type (unknown0: cl_context) -> cl_int #c_call;

PFNCLRELEASECONTEXT :: #type (unknown0: cl_context) -> cl_int #c_call;

PFNCLGETCONTEXTINFO :: #type (unknown0: cl_context, unknown1: cl_context_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

/* Command Queue APIs */
PFNCLCREATECOMMANDQUEUE :: #type (unknown0: cl_context, unknown1: cl_device_id, unknown2: cl_command_queue_properties, unknown3: *cl_int) -> cl_command_queue #c_call;

PFNCLRETAINCOMMANDQUEUE :: #type (unknown0: cl_command_queue) -> cl_int #c_call;

PFNCLRELEASECOMMANDQUEUE :: #type (unknown0: cl_command_queue) -> cl_int #c_call;

PFNCLGETCOMMANDQUEUEINFO :: #type (unknown0: cl_command_queue, unknown1: cl_command_queue_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

PFNCLSETCOMMANDQUEUEPROPERTY :: #type (unknown0: cl_command_queue, unknown1: cl_command_queue_properties, unknown2: cl_bool, unknown3: *cl_command_queue_properties) -> cl_int #c_call;

/* Memory Object APIs */
PFNCLCREATEBUFFER :: #type (unknown0: cl_context, unknown1: cl_mem_flags, unknown2: size_t, unknown3: *void, unknown4: *cl_int) -> cl_mem #c_call;

PFNCLCREATESUBBUFFER :: #type (unknown0: cl_mem, unknown1: cl_mem_flags, unknown2: cl_buffer_create_type, unknown3: *void, unknown4: *cl_int) -> cl_mem #c_call;

PFNCLCREATEIMAGE2D :: #type (unknown0: cl_context, unknown1: cl_mem_flags, unknown2: *cl_image_format, unknown3: size_t, unknown4: size_t, unknown5: size_t, unknown6: *void, unknown7: *cl_int) -> cl_mem #c_call;

PFNCLCREATEIMAGE3D :: #type (unknown0: cl_context, unknown1: cl_mem_flags, unknown2: *cl_image_format, unknown3: size_t, unknown4: size_t, unknown5: size_t, unknown6: size_t, unknown7: size_t, unknown8: *void, unknown9: *cl_int) -> cl_mem #c_call;

PFNCLRETAINMEMOBJECT :: #type (unknown0: cl_mem) -> cl_int #c_call;

PFNCLRELEASEMEMOBJECT :: #type (unknown0: cl_mem) -> cl_int #c_call;

PFNCLGETSUPPORTEDIMAGEFORMATS :: #type (unknown0: cl_context, unknown1: cl_mem_flags, unknown2: cl_mem_object_type, unknown3: cl_uint, unknown4: *cl_image_format, unknown5: *cl_uint) -> cl_int #c_call;

PFNCLGETMEMOBJECTINFO :: #type (unknown0: cl_mem, unknown1: cl_mem_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

PFNCLGETIMAGEINFO :: #type (unknown0: cl_mem, unknown1: cl_image_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

PFNCLSETMEMOBJECTDESTRUCTORCALLBACK :: #type (unknown0: cl_mem, unknown1: #type (unknown0: cl_mem, unknown1: *void) -> void #c_call, unknown2: *void) -> cl_int #c_call;

/* Sampler APIs  */
PFNCLCREATESAMPLER :: #type (unknown0: cl_context, unknown1: cl_bool, unknown2: cl_addressing_mode, unknown3: cl_filter_mode, unknown4: *cl_int) -> cl_sampler #c_call;

PFNCLRETAINSAMPLER :: #type (unknown0: cl_sampler) -> cl_int #c_call;

PFNCLRELEASESAMPLER :: #type (unknown0: cl_sampler) -> cl_int #c_call;

PFNCLGETSAMPLERINFO :: #type (unknown0: cl_sampler, unknown1: cl_sampler_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

/* Program Object APIs  */
PFNCLCREATEPROGRAMWITHSOURCE :: #type (unknown0: cl_context, unknown1: cl_uint, unknown2: **u8, unknown3: *size_t, unknown4: *cl_int) -> cl_program #c_call;

PFNCLCREATEPROGRAMWITHBINARY :: #type (unknown0: cl_context, unknown1: cl_uint, unknown2: *cl_device_id, unknown3: *size_t, unknown4: **u8, unknown5: *cl_int, unknown6: *cl_int) -> cl_program #c_call;

PFNCLRETAINPROGRAM :: #type (unknown0: cl_program) -> cl_int #c_call;

PFNCLRELEASEPROGRAM :: #type (unknown0: cl_program) -> cl_int #c_call;

PFNCLBUILDPROGRAM :: #type (unknown0: cl_program, unknown1: cl_uint, unknown2: *cl_device_id, unknown3: *u8, unknown4: #type (unknown0: cl_program, unknown1: *void) -> void #c_call, unknown5: *void) -> cl_int #c_call;

PFNCLUNLOADCOMPILER :: #type () -> cl_int #c_call;

PFNCLGETPROGRAMINFO :: #type (unknown0: cl_program, unknown1: cl_program_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

PFNCLGETPROGRAMBUILDINFO :: #type (unknown0: cl_program, unknown1: cl_device_id, unknown2: cl_program_build_info, unknown3: size_t, unknown4: *void, unknown5: *size_t) -> cl_int #c_call;

/* Kernel Object APIs */
PFNCLCREATEKERNEL :: #type (unknown0: cl_program, unknown1: *u8, unknown2: *cl_int) -> cl_kernel #c_call;

PFNCLCREATEKERNELSINPROGRAM :: #type (unknown0: cl_program, unknown1: cl_uint, unknown2: *cl_kernel, unknown3: *cl_uint) -> cl_int #c_call;

PFNCLRETAINKERNEL :: #type (unknown0: cl_kernel) -> cl_int #c_call;

PFNCLRELEASEKERNEL :: #type (unknown0: cl_kernel) -> cl_int #c_call;

PFNCLSETKERNELARG :: #type (unknown0: cl_kernel, unknown1: cl_uint, unknown2: size_t, unknown3: *void) -> cl_int #c_call;

PFNCLGETKERNELINFO :: #type (unknown0: cl_kernel, unknown1: cl_kernel_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

PFNCLGETKERNELWORKGROUPINFO :: #type (unknown0: cl_kernel, unknown1: cl_device_id, unknown2: cl_kernel_work_group_info, unknown3: size_t, unknown4: *void, unknown5: *size_t) -> cl_int #c_call;

// Event Object APIs
PFNCLWAITFOREVENTS :: #type (unknown0: cl_uint, unknown1: *cl_event) -> cl_int #c_call;

PFNCLGETEVENTINFO :: #type (unknown0: cl_event, unknown1: cl_event_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

PFNCLCREATEUSEREVENT :: #type (unknown0: cl_context, unknown1: *cl_int) -> cl_event #c_call;

PFNCLRETAINEVENT :: #type (unknown0: cl_event) -> cl_int #c_call;

PFNCLRELEASEEVENT :: #type (unknown0: cl_event) -> cl_int #c_call;

PFNCLSETUSEREVENTSTATUS :: #type (unknown0: cl_event, unknown1: cl_int) -> cl_int #c_call;

PFNCLSETEVENTCALLBACK :: #type (unknown0: cl_event, unknown1: cl_int, unknown2: #type (unknown0: cl_event, unknown1: cl_int, unknown2: *void) -> void #c_call, unknown3: *void) -> cl_int #c_call;

/* Profiling APIs  */
PFNCLGETEVENTPROFILINGINFO :: #type (unknown0: cl_event, unknown1: cl_profiling_info, unknown2: size_t, unknown3: *void, unknown4: *size_t) -> cl_int #c_call;

// Flush and Finish APIs
PFNCLFLUSH :: #type (unknown0: cl_command_queue) -> cl_int #c_call;

PFNCLFINISH :: #type (unknown0: cl_command_queue) -> cl_int #c_call;

/* Enqueued Commands APIs */
PFNCLENQUEUEREADBUFFER :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: size_t, unknown4: size_t, unknown5: *void, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEREADBUFFERRECT :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: *size_t, unknown4: *size_t, unknown5: *size_t, unknown6: size_t, unknown7: size_t, unknown8: size_t, unknown9: size_t, unknown10: *void, unknown11: cl_uint, unknown12: *cl_event, unknown13: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEWRITEBUFFER :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: size_t, unknown4: size_t, unknown5: *void, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEWRITEBUFFERRECT :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: *size_t, unknown4: *size_t, unknown5: *size_t, unknown6: size_t, unknown7: size_t, unknown8: size_t, unknown9: size_t, unknown10: *void, unknown11: cl_uint, unknown12: *cl_event, unknown13: *cl_event) -> cl_int #c_call;

PFNCLENQUEUECOPYBUFFER :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_mem, unknown3: size_t, unknown4: size_t, unknown5: size_t, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUECOPYBUFFERRECT :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_mem, unknown3: *size_t, unknown4: *size_t, unknown5: *size_t, unknown6: size_t, unknown7: size_t, unknown8: size_t, unknown9: size_t, unknown10: cl_uint, unknown11: *cl_event, unknown12: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEREADIMAGE :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: *size_t, unknown4: *size_t, unknown5: size_t, unknown6: size_t, unknown7: *void, unknown8: cl_uint, unknown9: *cl_event, unknown10: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEWRITEIMAGE :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: *size_t, unknown4: *size_t, unknown5: size_t, unknown6: size_t, unknown7: *void, unknown8: cl_uint, unknown9: *cl_event, unknown10: *cl_event) -> cl_int #c_call;

PFNCLENQUEUECOPYIMAGE :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_mem, unknown3: *size_t, unknown4: *size_t, unknown5: *size_t, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUECOPYIMAGETOBUFFER :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_mem, unknown3: *size_t, unknown4: *size_t, unknown5: size_t, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUECOPYBUFFERTOIMAGE :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_mem, unknown3: size_t, unknown4: *size_t, unknown5: *size_t, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEMAPBUFFER :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: cl_map_flags, unknown4: size_t, unknown5: size_t, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event, unknown9: *cl_int) -> *void #c_call;

PFNCLENQUEUEMAPIMAGE :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: cl_bool, unknown3: cl_map_flags, unknown4: *size_t, unknown5: *size_t, unknown6: *size_t, unknown7: *size_t, unknown8: cl_uint, unknown9: *cl_event, unknown10: *cl_event, unknown11: *cl_int) -> *void #c_call;

PFNCLENQUEUEUNMAPMEMOBJECT :: #type (unknown0: cl_command_queue, unknown1: cl_mem, unknown2: *void, unknown3: cl_uint, unknown4: *cl_event, unknown5: *cl_event) -> cl_int #c_call;

PFNCLENQUEUENDRANGEKERNEL :: #type (unknown0: cl_command_queue, unknown1: cl_kernel, unknown2: cl_uint, unknown3: *size_t, unknown4: *size_t, unknown5: *size_t, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUETASK :: #type (unknown0: cl_command_queue, unknown1: cl_kernel, unknown2: cl_uint, unknown3: *cl_event, unknown4: *cl_event) -> cl_int #c_call;

PFNCLENQUEUENATIVEKERNEL :: #type (unknown0: cl_command_queue, user_func: #type (unknown0: *void) -> void #c_call, unknown1: *void, unknown2: size_t, unknown3: cl_uint, unknown4: *cl_mem, unknown5: **void, unknown6: cl_uint, unknown7: *cl_event, unknown8: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEMARKER :: #type (unknown0: cl_command_queue, unknown1: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEWAITFOREVENTS :: #type (unknown0: cl_command_queue, unknown1: cl_uint, unknown2: *cl_event) -> cl_int #c_call;

PFNCLENQUEUEBARRIER :: #type (unknown0: cl_command_queue) -> cl_int #c_call;

// Extension function access
//
// Returns the extension function address for the given function name,
// or NULL if a valid function can not be found.  The client must
// check to make sure the address is not NULL, before using or
// calling the returned function address.
//
PFNCLGETEXTENSIONFUNCTIONADDRESS :: #type (unknown0: *u8) -> *void #c_call;

//  Variables holding function entry points
__clewGetPlatformIDs: PFNCLGETPLATFORMIDS;
__clewGetPlatformInfo: PFNCLGETPLATFORMINFO;
__clewGetDeviceIDs: PFNCLGETDEVICEIDS;
__clewGetDeviceInfo: PFNCLGETDEVICEINFO;
__clewCreateContext: PFNCLCREATECONTEXT;
__clewCreateContextFromType: PFNCLCREATECONTEXTFROMTYPE;
__clewRetainContext: PFNCLRETAINCONTEXT;
__clewReleaseContext: PFNCLRELEASECONTEXT;
__clewGetContextInfo: PFNCLGETCONTEXTINFO;
__clewCreateCommandQueue: PFNCLCREATECOMMANDQUEUE;
__clewRetainCommandQueue: PFNCLRETAINCOMMANDQUEUE;
__clewReleaseCommandQueue: PFNCLRELEASECOMMANDQUEUE;
__clewGetCommandQueueInfo: PFNCLGETCOMMANDQUEUEINFO;

__clewCreateBuffer: PFNCLCREATEBUFFER;
__clewCreateSubBuffer: PFNCLCREATESUBBUFFER;
__clewCreateImage2D: PFNCLCREATEIMAGE2D;
__clewCreateImage3D: PFNCLCREATEIMAGE3D;
__clewRetainMemObject: PFNCLRETAINMEMOBJECT;
__clewReleaseMemObject: PFNCLRELEASEMEMOBJECT;
__clewGetSupportedImageFormats: PFNCLGETSUPPORTEDIMAGEFORMATS;
__clewGetMemObjectInfo: PFNCLGETMEMOBJECTINFO;
__clewGetImageInfo: PFNCLGETIMAGEINFO;
__clewSetMemObjectDestructorCallback: PFNCLSETMEMOBJECTDESTRUCTORCALLBACK;
__clewCreateSampler: PFNCLCREATESAMPLER;
__clewRetainSampler: PFNCLRETAINSAMPLER;
__clewReleaseSampler: PFNCLRELEASESAMPLER;
__clewGetSamplerInfo: PFNCLGETSAMPLERINFO;
__clewCreateProgramWithSource: PFNCLCREATEPROGRAMWITHSOURCE;
__clewCreateProgramWithBinary: PFNCLCREATEPROGRAMWITHBINARY;
__clewRetainProgram: PFNCLRETAINPROGRAM;
__clewReleaseProgram: PFNCLRELEASEPROGRAM;
__clewBuildProgram: PFNCLBUILDPROGRAM;
__clewUnloadCompiler: PFNCLUNLOADCOMPILER;
__clewGetProgramInfo: PFNCLGETPROGRAMINFO;
__clewGetProgramBuildInfo: PFNCLGETPROGRAMBUILDINFO;
__clewCreateKernel: PFNCLCREATEKERNEL;
__clewCreateKernelsInProgram: PFNCLCREATEKERNELSINPROGRAM;
__clewRetainKernel: PFNCLRETAINKERNEL;
__clewReleaseKernel: PFNCLRELEASEKERNEL;
__clewSetKernelArg: PFNCLSETKERNELARG;
__clewGetKernelInfo: PFNCLGETKERNELINFO;
__clewGetKernelWorkGroupInfo: PFNCLGETKERNELWORKGROUPINFO;
__clewWaitForEvents: PFNCLWAITFOREVENTS;
__clewGetEventInfo: PFNCLGETEVENTINFO;
__clewCreateUserEvent: PFNCLCREATEUSEREVENT;
__clewRetainEvent: PFNCLRETAINEVENT;
__clewReleaseEvent: PFNCLRELEASEEVENT;
__clewSetUserEventStatus: PFNCLSETUSEREVENTSTATUS;
__clewSetEventCallback: PFNCLSETEVENTCALLBACK;
__clewGetEventProfilingInfo: PFNCLGETEVENTPROFILINGINFO;
__clewFlush: PFNCLFLUSH;
__clewFinish: PFNCLFINISH;
__clewEnqueueReadBuffer: PFNCLENQUEUEREADBUFFER;
__clewEnqueueReadBufferRect: PFNCLENQUEUEREADBUFFERRECT;
__clewEnqueueWriteBuffer: PFNCLENQUEUEWRITEBUFFER;
__clewEnqueueWriteBufferRect: PFNCLENQUEUEWRITEBUFFERRECT;
__clewEnqueueCopyBuffer: PFNCLENQUEUECOPYBUFFER;
__clewEnqueueCopyBufferRect: PFNCLENQUEUECOPYBUFFERRECT;
__clewEnqueueReadImage: PFNCLENQUEUEREADIMAGE;
__clewEnqueueWriteImage: PFNCLENQUEUEWRITEIMAGE;
__clewEnqueueCopyImage: PFNCLENQUEUECOPYIMAGE;
__clewEnqueueCopyImageToBuffer: PFNCLENQUEUECOPYIMAGETOBUFFER;
__clewEnqueueCopyBufferToImage: PFNCLENQUEUECOPYBUFFERTOIMAGE;
__clewEnqueueMapBuffer: PFNCLENQUEUEMAPBUFFER;
__clewEnqueueMapImage: PFNCLENQUEUEMAPIMAGE;
__clewEnqueueUnmapMemObject: PFNCLENQUEUEUNMAPMEMOBJECT;
__clewEnqueueNDRangeKernel: PFNCLENQUEUENDRANGEKERNEL;
__clewEnqueueTask: PFNCLENQUEUETASK;
__clewEnqueueNativeKernel: PFNCLENQUEUENATIVEKERNEL;
__clewEnqueueMarker: PFNCLENQUEUEMARKER;
__clewEnqueueWaitForEvents: PFNCLENQUEUEWAITFOREVENTS;
__clewEnqueueBarrier: PFNCLENQUEUEBARRIER;
__clewGetExtensionFunctionAddress: PFNCLGETEXTENSIONFUNCTIONADDRESS;

TUIntArray :: btAlignedObjectArray(u32);

HullResult :: struct {
    Constructor :: (this: *HullResult) -> void #cpp_method #foreign bullet3 "??0HullResult@@QEAA@XZ";

    mPolygons:          bool; // true if indices represents polygons, false indices are triangles
    mNumOutputVertices: u32; // number of vertices in the output hull
    m_OutputVertices:   btAlignedObjectArray(btVector3); // array of vertices
    mNumFaces:          u32; // the number of faces produced
    mNumIndices:        u32; // the total number of indices
    m_Indices:          btAlignedObjectArray(u32); // pointer to indices.
}

HullFlag :: enum s32 {
    TRIANGLES     :: 1;
    REVERSE_ORDER :: 2;
    DEFAULT       :: 1;

    QF_TRIANGLES     :: TRIANGLES;
    QF_REVERSE_ORDER :: REVERSE_ORDER;
    QF_DEFAULT       :: DEFAULT;
}

HullDesc :: struct {
    Constructor :: (this: *HullDesc) -> void #cpp_method #foreign bullet3 "??0HullDesc@@QEAA@XZ";

    Constructor :: (this: *HullDesc, flag: HullFlag, vcount: u32, vertices: *btVector3, stride: u32 = 16) -> void #cpp_method #foreign bullet3 "??0HullDesc@@QEAA@W4HullFlag@@IPEBVbtVector3@@I@Z";

    HasHullFlag :: (this: *HullDesc, flag: HullFlag) -> bool #cpp_method #foreign bullet3 "?HasHullFlag@HullDesc@@QEBA_NW4HullFlag@@@Z";

    SetHullFlag :: (this: *HullDesc, flag: HullFlag) -> void #cpp_method #foreign bullet3 "?SetHullFlag@HullDesc@@QEAAXW4HullFlag@@@Z";

    ClearHullFlag :: (this: *HullDesc, flag: HullFlag) -> void #cpp_method #foreign bullet3 "?ClearHullFlag@HullDesc@@QEAAXW4HullFlag@@@Z";

    mFlags:         u32; // flags to use when generating the convex hull.
    mVcount:        u32; // number of vertices in the input point cloud
    mVertices:      *btVector3; // the array of vertices.
    mVertexStride:  u32; // the stride of each vertex, in bytes.
    mNormalEpsilon: btScalar; // the epsilon for removing duplicates.  This is a normalized value, if normalized bit is on.
    mMaxVertices:   u32; // maximum number of vertices to be considered for the hull!
    mMaxFaces:      u32;
}

HullError :: enum s32 {
    OK   :: 0;
    FAIL :: 1;

    QE_OK   :: OK;
    QE_FAIL :: FAIL;
}

btPlane :: struct {
    normal: btVector3;
    dist:   btScalar; // distance below origin - the D from plane equasion Ax+By+Cz+D=0
    Constructor :: (this: *btPlane, n: *btVector3, d: btScalar) -> void #cpp_method #foreign bullet3 "??0btPlane@@QEAA@AEBVbtVector3@@M@Z";
    Constructor :: (this: *btPlane, n: btVector3, d: btScalar) #no_context {
        Constructor(this, *n, d);
    }
    Constructor :: (this: *btPlane) -> void #cpp_method #foreign bullet3 "??0btPlane@@QEAA@XZ";
}

ConvexH :: struct {
    HalfEdge :: struct {
        ea: s16; // the other half of the edge (index into edges list)
        v:  u8; // the vertex at the start of this edge (index into vertices list)
        p:  u8; // the facet on which this edge lies (index into facets list)
    }

    Constructor :: (this: *ConvexH) -> void #cpp_method #foreign bullet3 "??0ConvexH@@QEAA@XZ";

    Destructor :: (this: *ConvexH) -> void #cpp_method #foreign bullet3 "??1ConvexH@@QEAA@XZ";

    vertices: btAlignedObjectArray(btVector3);
    edges:    btAlignedObjectArray(HalfEdge);
    facets:   btAlignedObjectArray(btPlane);
    Constructor :: (this: *ConvexH, vertices_size: s32, edges_size: s32, facets_size: s32) -> void #cpp_method #foreign bullet3 "??0ConvexH@@QEAA@HHH@Z";
}

int4 :: struct {
    x: s32;
    y: s32;
    z: s32;
    w: s32;
    Constructor :: (this: *int4) -> void #cpp_method #foreign bullet3 "??0int4@@QEAA@XZ";
    Constructor :: (this: *int4, _x: s32, _y: s32, _z: s32, _w: s32) -> void #cpp_method #foreign bullet3 "??0int4@@QEAA@HHHH@Z";
}

operator[] :: (this: /*const*/ *int4, i: s32) -> *s32 #cpp_method #foreign bullet3 "??Aint4@@QEBAAEBHH@Z";
operator[] :: (this: int4, i: s32) -> *s32 #no_context {
    return operator[](*this, i);
}
operator_brackets_1 :: (this: *int4, i: s32) -> *s32 #cpp_method #foreign bullet3 "??Aint4@@QEAAAEAHH@Z";
operator_brackets_1 :: (this: int4, i: s32) -> *s32 #no_context {
    return operator_brackets_1(*this, i);
}

PHullResult :: struct {
    Constructor :: (this: *PHullResult) -> void #cpp_method #foreign bullet3 "??0PHullResult@@QEAA@XZ";

    mVcount:     u32;
    mIndexCount: u32;
    mFaceCount:  u32;
    mVertices:   *btVector3;
    m_Indices:   TUIntArray;
}

///The HullLibrary class can create a convex hull from a collection of vertices, using the ComputeHull method.
///The btShapeHull class uses this HullLibrary to create a approximate convex mesh given a general (non-polyhedral) convex shape.
HullLibrary :: struct {
    btHullTriangle :: struct {}
    m_tris:               btAlignedObjectArray(*btHullTriangle);

    m_vertexIndexMapping: btAlignedObjectArray(s32);

    CreateConvexHull :: (this: *HullLibrary, desc: *HullDesc, result: *HullResult) -> HullError #cpp_method #foreign bullet3 "?CreateConvexHull@HullLibrary@@QEAA?AW4HullError@@AEBVHullDesc@@AEAVHullResult@@@Z";
    CreateConvexHull :: (this: *HullLibrary, desc: HullDesc, result: *HullResult) -> HullError #no_context {
        return CreateConvexHull(this, *desc, result);
    }

    ReleaseResult :: (this: *HullLibrary, result: *HullResult) -> HullError #cpp_method #foreign bullet3 "?ReleaseResult@HullLibrary@@QEAA?AW4HullError@@AEAVHullResult@@@Z";

    ComputeHull :: (this: *HullLibrary, vcount: u32, vertices: *btVector3, result: *PHullResult, vlimit: u32) -> bool #cpp_method #foreign bullet3 "?ComputeHull@HullLibrary@@AEAA_NIPEBVbtVector3@@AEAVPHullResult@@I@Z";

    allocateTriangle :: (this: *HullLibrary, a: s32, b: s32, c: s32) -> *btHullTriangle #cpp_method #foreign bullet3 "?allocateTriangle@HullLibrary@@AEAAPEAVbtHullTriangle@@HHH@Z";
    deAllocateTriangle :: (this: *HullLibrary, unknown0: *btHullTriangle) -> void #cpp_method #foreign bullet3 "?deAllocateTriangle@HullLibrary@@AEAAXPEAVbtHullTriangle@@@Z";
    b2bfix :: (this: *HullLibrary, s: *btHullTriangle, t: *btHullTriangle) -> void #cpp_method #foreign bullet3 "?b2bfix@HullLibrary@@AEAAXPEAVbtHullTriangle@@0@Z";

    removeb2b :: (this: *HullLibrary, s: *btHullTriangle, t: *btHullTriangle) -> void #cpp_method #foreign bullet3 "?removeb2b@HullLibrary@@AEAAXPEAVbtHullTriangle@@0@Z";

    checkit :: (this: *HullLibrary, t: *btHullTriangle) -> void #cpp_method #foreign bullet3 "?checkit@HullLibrary@@AEAAXPEAVbtHullTriangle@@@Z";

    extrudable :: (this: *HullLibrary, epsilon: btScalar) -> *btHullTriangle #cpp_method #foreign bullet3 "?extrudable@HullLibrary@@AEAAPEAVbtHullTriangle@@M@Z";

    calchull :: (this: *HullLibrary, verts: *btVector3, verts_count: s32, tris_out: *TUIntArray, tris_count: *s32, vlimit: s32) -> s32 #cpp_method #foreign bullet3 "?calchull@HullLibrary@@AEAAHPEAVbtVector3@@HAEAV?$btAlignedObjectArray@I@@AEAHH@Z";

    calchullgen :: (this: *HullLibrary, verts: *btVector3, verts_count: s32, vlimit: s32) -> s32 #cpp_method #foreign bullet3 "?calchullgen@HullLibrary@@AEAAHPEAVbtVector3@@HH@Z";

    FindSimplex :: (this: *HullLibrary, verts: *btVector3, verts_count: s32, allow: *btAlignedObjectArray(s32)) -> int4 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?FindSimplex@HullLibrary@@AEAA?AVint4@@PEAVbtVector3@@HAEAV?$btAlignedObjectArray@H@@@Z";

    extrude :: (this: *HullLibrary, t0: *btHullTriangle, v: s32) -> void #cpp_method #foreign bullet3 "?extrude@HullLibrary@@AEAAXPEAVbtHullTriangle@@H@Z";

    //BringOutYourDead (John Ratcliff): When you create a convex hull you hand it a large input set of vertices forming a 'point cloud'.
    //After the hull is generated it give you back a set of polygon faces which index the *original* point cloud.
    //The thing is, often times, there are many 'dead vertices' in the point cloud that are on longer referenced by the hull.
    //The routine 'BringOutYourDead' find only the referenced vertices, copies them to an new buffer, and re-indexes the hull so that it is a minimal representation.
    BringOutYourDead :: (this: *HullLibrary, verts: *btVector3, vcount: u32, overts: *btVector3, ocount: *u32, indices: *u32, indexcount: u32) -> void #cpp_method #foreign bullet3 "?BringOutYourDead@HullLibrary@@AEAAXPEBVbtVector3@@IPEAV2@AEAIPEAII@Z";

    CleanupVertices :: (this: *HullLibrary, svcount: u32, svertices: *btVector3, stride: u32, vcount: *u32, vertices: *btVector3, normalepsilon: btScalar, scale: *btVector3) -> bool #cpp_method #foreign bullet3 "?CleanupVertices@HullLibrary@@AEAA_NIPEBVbtVector3@@IAEAIPEAV2@MAEAV2@@Z";
}

/// Convex hull implementation based on Preparata and Hong
/// See http://code.google.com/p/bullet/issues/detail?id=275
/// Ole Kniemeyer, MAXON Computer GmbH
btConvexHullComputer :: struct {
    compute :: (this: *btConvexHullComputer, coords: *void, doubleCoords: bool, stride: s32, count: s32, shrink: btScalar, shrinkClamp: btScalar) -> btScalar #cpp_method #foreign bullet3 "?compute@btConvexHullComputer@@AEAAMPEBX_NHHMM@Z";

    Edge :: struct {
        next:         s32;
        reverse:      s32;
        targetVertex: s32;
    }

    // Vertices of the output hull
    vertices:              btAlignedObjectArray(btVector3);

    // The original vertex index in the input coords array
    original_vertex_index: btAlignedObjectArray(s32);

    // Edges of the output hull
    edges:                 btAlignedObjectArray(Edge);

    // Faces of the convex hull. Each entry is an index into the "edges" array pointing to an edge of the face. Faces are planar n-gons
    faces:                 btAlignedObjectArray(s32);

    /*
    Compute convex hull of "count" vertices stored in "coords". "stride" is the difference in bytes
    between the addresses of consecutive vertices. If "shrink" is positive, the convex hull is shrunken
    by that amount (each face is moved by "shrink" length units towards the center along its normal).
    If "shrinkClamp" is positive, "shrink" is clamped to not exceed "shrinkClamp * innerRadius", where "innerRadius"
    is the minimum distance of a face to the center of the convex hull.
    
    The returned value is the amount by which the hull has been shrunken. If it is negative, the amount was so large
    that the resulting convex hull is empty.
    
    The output convex hull can be found in the member variables "vertices", "edges", "faces".
    */
    compute :: (this: *btConvexHullComputer, coords: *float, stride: s32, count: s32, shrink: btScalar, shrinkClamp: btScalar) -> btScalar #cpp_method #foreign bullet3 "?compute@btConvexHullComputer@@QEAAMPEBMHHMM@Z";

    // same as above, but double precision
    compute :: (this: *btConvexHullComputer, coords: *float64, stride: s32, count: s32, shrink: btScalar, shrinkClamp: btScalar) -> btScalar #cpp_method #foreign bullet3 "?compute@btConvexHullComputer@@QEAAMPEBNHHMM@Z";
}

///Rudimentary btCpuFeatureUtility for CPU features: only report the features that Bullet actually uses (SSE4/FMA3, NEON_HPFP)
///We assume SSE2 in case BT_USE_SSE2 is defined in LinearMath/btScalar.h
btCpuFeatureUtility :: struct {
    btCpuFeature :: enum s32 {
        FMA3      :: 1;
        SSE4_1    :: 2;
        NEON_HPFP :: 4;

        CPU_FEATURE_FMA3      :: FMA3;
        CPU_FEATURE_SSE4_1    :: SSE4_1;
        CPU_FEATURE_NEON_HPFP :: NEON_HPFP;
    }

    getCpuFeatures :: () -> s32 #foreign bullet3 "?getCpuFeatures@btCpuFeatureUtility@@SAHXZ";
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///The btGeometryUtil helper class provides a few methods to convert between plane equations and vertices.
btGeometryUtil :: struct {
    getPlaneEquationsFromVertices :: (vertices: *btAlignedObjectArray(btVector3), planeEquationsOut: *btAlignedObjectArray(btVector3)) -> void #foreign bullet3 "?getPlaneEquationsFromVertices@btGeometryUtil@@SAXAEAV?$btAlignedObjectArray@VbtVector3@@@@0@Z";

    getVerticesFromPlaneEquations :: (planeEquations: *btAlignedObjectArray(btVector3), verticesOut: *btAlignedObjectArray(btVector3)) -> void #foreign bullet3 "?getVerticesFromPlaneEquations@btGeometryUtil@@SAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@@Z";
    getVerticesFromPlaneEquations :: (planeEquations: btAlignedObjectArray(btVector3), verticesOut: *btAlignedObjectArray(btVector3)) #no_context {
        getVerticesFromPlaneEquations(*planeEquations, verticesOut);
    }

    isPointInsidePlanes :: (planeEquations: *btAlignedObjectArray(btVector3), point: *btVector3, margin: btScalar) -> bool #foreign bullet3 "?isPointInsidePlanes@btGeometryUtil@@SA_NAEBV?$btAlignedObjectArray@VbtVector3@@@@AEBVbtVector3@@M@Z";
    isPointInsidePlanes :: (planeEquations: btAlignedObjectArray(btVector3), point: btVector3, margin: btScalar) -> bool #no_context {
        return isPointInsidePlanes(*planeEquations, *point, margin);
    }

    areVerticesBehindPlane :: (planeNormal: *btVector3, vertices: *btAlignedObjectArray(btVector3), margin: btScalar) -> bool #foreign bullet3 "?areVerticesBehindPlane@btGeometryUtil@@SA_NAEBVbtVector3@@AEBV?$btAlignedObjectArray@VbtVector3@@@@M@Z";
    areVerticesBehindPlane :: (planeNormal: btVector3, vertices: btAlignedObjectArray(btVector3), margin: btScalar) -> bool #no_context {
        return areVerticesBehindPlane(*planeNormal, *vertices, margin);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

GrahamVector3 :: struct {
    #as using btvector3: btVector3;

    Constructor :: (this: *GrahamVector3, org: *btVector3, orgIndex: s32) -> void #cpp_method #foreign bullet3 "??0GrahamVector3@@QEAA@AEBVbtVector3@@H@Z";
    Constructor :: (this: *GrahamVector3, org: btVector3, orgIndex: s32) #no_context {
        Constructor(this, *org, orgIndex);
    }

    m_angle:    btScalar;
    m_orgIndex: s32;
}

btAngleCompareFunc :: struct {
    m_anchor: btVector3;
    Constructor :: (this: *btAngleCompareFunc, anchor: *btVector3) -> void #cpp_method #foreign bullet3 "??0btAngleCompareFunc@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btAngleCompareFunc, anchor: btVector3) #no_context {
        Constructor(this, *anchor);
    }
}

btGEN_Link :: struct {
    m_next: *btGEN_Link;
    m_prev: *btGEN_Link;
}

btGEN_List :: struct {
    m_head: btGEN_Link;
    m_tail: btGEN_Link;
}

btIntSortPredicate :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

btVectorX :: struct(T: Type) {
    m_storage: btAlignedObjectArray(T);
}

/*
template <typename T>
void setElem(btMatrixX<T>& mat, int row, int col, T val)
{
mat.setElem(row,col,val);
}
*/
btMatrixX :: struct(T: Type) {
    m_rows:                s32;
    m_cols:                s32;
    m_operations:          s32;
    m_resizeOperations:    s32;
    m_setElemOperations:   s32;

    m_storage:             btAlignedObjectArray(T);
    m_rowNonZeroElements1: btAlignedObjectArray(btAlignedObjectArray(s32));
}

btMatrixXf :: btMatrixX(float);
btVectorXf :: btVectorX(float);

btMatrixXd :: btMatrixX(float64);
btVectorXd :: btVectorX(float64);

///The btBlock class is an internal structure for the btStackAlloc memory allocator.
btBlock :: struct {
    previous: *btBlock;
    address:  *u8;
}

///The StackAlloc class provides some fast stack-based memory allocator (LIFO last-in first-out)
btStackAlloc :: struct {
    Constructor :: (this: *btStackAlloc, size: u32) -> void #cpp_method #foreign bullet3 "??0btStackAlloc@@QEAA@I@Z";

    Destructor :: (this: *btStackAlloc) -> void #cpp_method #foreign bullet3 "??1btStackAlloc@@QEAA@XZ";

    create :: (this: *btStackAlloc, size: u32) -> void #cpp_method #foreign bullet3 "?create@btStackAlloc@@QEAAXI@Z";

    destroy :: (this: *btStackAlloc) -> void #cpp_method #foreign bullet3 "?destroy@btStackAlloc@@QEAAXXZ";

    getAvailableMemory :: (this: *btStackAlloc) -> s32 #cpp_method #foreign bullet3 "?getAvailableMemory@btStackAlloc@@QEBAHXZ";

    allocate :: (this: *btStackAlloc, size: u32) -> *u8 #cpp_method #foreign bullet3 "?allocate@btStackAlloc@@QEAAPEAEI@Z";

    beginBlock :: (this: *btStackAlloc) -> *btBlock #cpp_method #foreign bullet3 "?beginBlock@btStackAlloc@@QEAAPEAUbtBlock@@XZ";

    endBlock :: (this: *btStackAlloc, block: *btBlock) -> void #cpp_method #foreign bullet3 "?endBlock@btStackAlloc@@QEAAXPEAUbtBlock@@@Z";

    ctor :: (this: *btStackAlloc) -> void #cpp_method #foreign bullet3 "?ctor@btStackAlloc@@AEAAXXZ";

    data:      *u8;
    totalsize: u32;
    usedsize:  u32;
    current:   *btBlock;
    ischild:   bool;
}

b3BroadphaseAabbCallback :: struct {
    vtable: *b3BroadphaseAabbCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *b3BroadphaseAabbCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3BroadphaseAabbCallback@@UEAA@XZ";
}
b3BroadphaseAabbCallback_VTable :: struct #type_info_none {
    Destructor: (this: *b3BroadphaseAabbCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    process: (this: *b3BroadphaseAabbCallback, proxy: *b3BroadphaseProxy) -> bool #cpp_method;
}

b3BroadphaseAabbCallback_Destructor :: inline (this: *b3BroadphaseAabbCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
b3BroadphaseAabbCallback_process :: inline (this: *b3BroadphaseAabbCallback, proxy: *b3BroadphaseProxy) -> bool { return this.vtable.process(this, proxy); }



b3BroadphaseRayCallback :: struct {
    #as using b3broadphaseaabbcallback: b3BroadphaseAabbCallback;

    ///added some cached data to accelerate ray-AABB tests
    m_rayDirectionInverse: b3Vector3 #align 8;
    m_signs:               [3] u32;
    m_lambda_max:          b3Scalar;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3BroadphaseRayCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3BroadphaseRayCallback@@UEAA@XZ";
}

/* b3DbvtAabbMm			*/
b3DbvtAabbMm :: struct {
    Center :: (this: *b3DbvtAabbMm) -> b3Vector3 #cpp_method #foreign bullet3 "?Center@b3DbvtAabbMm@@QEBA?AVb3Vector3@@XZ";
    Lengths :: (this: *b3DbvtAabbMm) -> b3Vector3 #cpp_method #foreign bullet3 "?Lengths@b3DbvtAabbMm@@QEBA?AVb3Vector3@@XZ";
    Extents :: (this: *b3DbvtAabbMm) -> b3Vector3 #cpp_method #foreign bullet3 "?Extents@b3DbvtAabbMm@@QEBA?AVb3Vector3@@XZ";
    Mins :: (this: *b3DbvtAabbMm) -> *b3Vector3 #cpp_method #foreign bullet3 "?Mins@b3DbvtAabbMm@@QEBAAEBVb3Vector3@@XZ";
    Maxs :: (this: *b3DbvtAabbMm) -> *b3Vector3 #cpp_method #foreign bullet3 "?Maxs@b3DbvtAabbMm@@QEBAAEBVb3Vector3@@XZ";

    //
    FromCE :: (c: *b3Vector3, e: *b3Vector3) -> b3DbvtAabbMm #foreign bullet3 "?FromCE@b3DbvtAabbMm@@SA?AU1@AEBVb3Vector3@@0@Z";
    FromCE :: (c: b3Vector3, e: b3Vector3) -> b3DbvtAabbMm #no_context {
        return FromCE(*c, *e);
    }

    //
    FromCR :: (c: *b3Vector3, r: b3Scalar) -> b3DbvtAabbMm #foreign bullet3 "?FromCR@b3DbvtAabbMm@@SA?AU1@AEBVb3Vector3@@M@Z";
    FromCR :: (c: b3Vector3, r: b3Scalar) -> b3DbvtAabbMm #no_context {
        return FromCR(*c, r);
    }

    //
    FromMM :: (mi: *b3Vector3, mx: *b3Vector3) -> b3DbvtAabbMm #foreign bullet3 "?FromMM@b3DbvtAabbMm@@SA?AU1@AEBVb3Vector3@@0@Z";
    FromMM :: (mi: b3Vector3, mx: b3Vector3) -> b3DbvtAabbMm #no_context {
        return FromMM(*mi, *mx);
    }

    //
    FromPoints :: (pts: *b3Vector3, n: s32) -> b3DbvtAabbMm #foreign bullet3 "?FromPoints@b3DbvtAabbMm@@SA?AU1@PEBVb3Vector3@@H@Z";

    //
    FromPoints :: (ppts: **b3Vector3, n: s32) -> b3DbvtAabbMm #foreign bullet3 "?FromPoints@b3DbvtAabbMm@@SA?AU1@PEAPEBVb3Vector3@@H@Z";

    //
    Expand :: (this: *b3DbvtAabbMm, e: *b3Vector3) -> void #cpp_method #foreign bullet3 "?Expand@b3DbvtAabbMm@@QEAAXAEBVb3Vector3@@@Z";
    Expand :: (this: *b3DbvtAabbMm, e: b3Vector3) #no_context {
        Expand(this, *e);
    }

    //
    SignedExpand :: (this: *b3DbvtAabbMm, e: *b3Vector3) -> void #cpp_method #foreign bullet3 "?SignedExpand@b3DbvtAabbMm@@QEAAXAEBVb3Vector3@@@Z";
    SignedExpand :: (this: *b3DbvtAabbMm, e: b3Vector3) #no_context {
        SignedExpand(this, *e);
    }

    //
    Contain :: (this: *b3DbvtAabbMm, a: *b3DbvtAabbMm) -> bool #cpp_method #foreign bullet3 "?Contain@b3DbvtAabbMm@@QEBA_NAEBU1@@Z";
    Contain :: (this: *b3DbvtAabbMm, a: b3DbvtAabbMm) -> bool #no_context {
        return Contain(this, *a);
    }

    //
    Classify :: (this: *b3DbvtAabbMm, n: *b3Vector3, o: b3Scalar, s: s32) -> s32 #cpp_method #foreign bullet3 "?Classify@b3DbvtAabbMm@@QEBAHAEBVb3Vector3@@MH@Z";
    Classify :: (this: *b3DbvtAabbMm, n: b3Vector3, o: b3Scalar, s: s32) -> s32 #no_context {
        return Classify(this, *n, o, s);
    }

    //
    ProjectMinimum :: (this: *b3DbvtAabbMm, v: *b3Vector3, signs: u32) -> b3Scalar #cpp_method #foreign bullet3 "?ProjectMinimum@b3DbvtAabbMm@@QEBAMAEBVb3Vector3@@I@Z";
    ProjectMinimum :: (this: *b3DbvtAabbMm, v: b3Vector3, signs: u32) -> b3Scalar #no_context {
        return ProjectMinimum(this, *v, signs);
    }

    tMins :: (this: *b3DbvtAabbMm) -> *b3Vector3 #cpp_method #foreign bullet3 "?tMins@b3DbvtAabbMm@@QEAAAEAVb3Vector3@@XZ";
    tMaxs :: (this: *b3DbvtAabbMm) -> *b3Vector3 #cpp_method #foreign bullet3 "?tMaxs@b3DbvtAabbMm@@QEAAAEAVb3Vector3@@XZ";

    //
    AddSpan :: (this: *b3DbvtAabbMm, d: *b3Vector3, smi: *b3Scalar, smx: *b3Scalar) -> void #cpp_method #foreign bullet3 "?AddSpan@b3DbvtAabbMm@@AEBAXAEBVb3Vector3@@AEAM1@Z";
    AddSpan :: (this: *b3DbvtAabbMm, d: b3Vector3, smi: *b3Scalar, smx: *b3Scalar) #no_context {
        AddSpan(this, *d, smi, smx);
    }

    mi: b3Vector3;
    mx: b3Vector3;
}

// Types
b3DbvtVolume :: b3DbvtAabbMm;

/* b3DbvtNode				*/
b3DbvtNode :: struct {
    volume: b3DbvtVolume;
    parent: *b3DbvtNode;
    isleaf :: (this: *b3DbvtNode) -> bool #cpp_method #foreign bullet3 "?isleaf@b3DbvtNode@@QEBA_NXZ";
    isinternal :: (this: *b3DbvtNode) -> bool #cpp_method #foreign bullet3 "?isinternal@b3DbvtNode@@QEBA_NXZ";
    union {
        childs:    [2] *b3DbvtNode;
        data:      *void;
        dataAsInt: s32;
    }
}

///The b3DynamicBvh class implements a fast dynamic bounding volume tree based on axis aligned bounding boxes (aabb tree).
///This b3DynamicBvh is used for soft body collision detection and for the b3DynamicBvhBroadphase. It has a fast insert, remove and update of nodes.
///Unlike the b3QuantizedBvh, nodes can be dynamically moved around, which allows for change in topology of the underlying data structure.
b3DynamicBvh :: struct {
    /* Stack element	*/
    sStkNN :: struct {
        a: *b3DbvtNode;
        b: *b3DbvtNode;
        Constructor :: (this: *sStkNN) -> void #cpp_method #foreign bullet3 "??0sStkNN@b3DynamicBvh@@QEAA@XZ";
        Constructor :: (this: *sStkNN, na: *b3DbvtNode, nb: *b3DbvtNode) -> void #cpp_method #foreign bullet3 "??0sStkNN@b3DynamicBvh@@QEAA@PEBUb3DbvtNode@@0@Z";
    }

    sStkNP :: struct {
        node: *b3DbvtNode;
        mask: s32;
        Constructor :: (this: *sStkNP, n: *b3DbvtNode, m: u32) -> void #cpp_method #foreign bullet3 "??0sStkNP@b3DynamicBvh@@QEAA@PEBUb3DbvtNode@@I@Z";
    }

    sStkNPS :: struct {
        node:  *b3DbvtNode;
        mask:  s32;
        value: b3Scalar;
        Constructor :: (this: *sStkNPS) -> void #cpp_method #foreign bullet3 "??0sStkNPS@b3DynamicBvh@@QEAA@XZ";
        Constructor :: (this: *sStkNPS, n: *b3DbvtNode, m: u32, v: b3Scalar) -> void #cpp_method #foreign bullet3 "??0sStkNPS@b3DynamicBvh@@QEAA@PEBUb3DbvtNode@@IM@Z";
    }

    sStkCLN :: struct {
        node:   *b3DbvtNode;
        parent: *b3DbvtNode;
        Constructor :: (this: *sStkCLN, n: *b3DbvtNode, p: *b3DbvtNode) -> void #cpp_method #foreign bullet3 "??0sStkCLN@b3DynamicBvh@@QEAA@PEBUb3DbvtNode@@PEAU2@@Z";
    }

    /* ICollide	*/
    ICollide :: struct {
        Process :: (this: *ICollide, unknown0: *b3DbvtNode, unknown1: *b3DbvtNode) -> void #cpp_method #foreign bullet3 "?Process@ICollide@b3DynamicBvh@@QEAAXPEBUb3DbvtNode@@0@Z";
        Process :: (this: *ICollide, unknown0: *b3DbvtNode) -> void #cpp_method #foreign bullet3 "?Process@ICollide@b3DynamicBvh@@QEAAXPEBUb3DbvtNode@@@Z";
        Process :: (this: *ICollide, n: *b3DbvtNode, unknown0: b3Scalar) -> void #cpp_method #foreign bullet3 "?Process@ICollide@b3DynamicBvh@@QEAAXPEBUb3DbvtNode@@M@Z";
        Descent :: (this: *ICollide, unknown0: *b3DbvtNode) -> bool #cpp_method #foreign bullet3 "?Descent@ICollide@b3DynamicBvh@@QEAA_NPEBUb3DbvtNode@@@Z";
        AllLeaves :: (this: *ICollide, unknown0: *b3DbvtNode) -> bool #cpp_method #foreign bullet3 "?AllLeaves@ICollide@b3DynamicBvh@@QEAA_NPEBUb3DbvtNode@@@Z";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /* IWriter	*/
    IWriter :: struct {
        vtable: *IWriter_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *IWriter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1IWriter@b3DynamicBvh@@UEAA@XZ";
    }
    IWriter_VTable :: struct #type_info_none {
        Destructor: (this: *IWriter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        Prepare: (this: *IWriter, root: *b3DbvtNode, numnodes: s32) -> void #cpp_method;
        WriteNode: (this: *IWriter, unknown0: *b3DbvtNode, index: s32, parent: s32, child0: s32, child1: s32) -> void #cpp_method;
        WriteLeaf: (this: *IWriter, unknown0: *b3DbvtNode, index: s32, parent: s32) -> void #cpp_method;
    }

    IWriter_Destructor :: inline (this: *IWriter, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    IWriter_Prepare :: inline (this: *IWriter, root: *b3DbvtNode, numnodes: s32) { this.vtable.Prepare(this, root, numnodes); }
    IWriter_WriteNode :: inline (this: *IWriter, unknown0: *b3DbvtNode, index: s32, parent: s32, child0: s32, child1: s32) { this.vtable.WriteNode(this, unknown0, index, parent, child0, child1); }
    IWriter_WriteLeaf :: inline (this: *IWriter, unknown0: *b3DbvtNode, index: s32, parent: s32) { this.vtable.WriteLeaf(this, unknown0, index, parent); }



    /* IClone	*/
    IClone :: struct {
        vtable: *IClone_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *IClone, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1IClone@b3DynamicBvh@@UEAA@XZ";
        virtual_CloneLeaf :: (this: *IClone, unknown0: *b3DbvtNode) -> void #cpp_method #foreign bullet3 "?CloneLeaf@IClone@b3DynamicBvh@@UEAAXPEAUb3DbvtNode@@@Z";
    }
    IClone_VTable :: struct #type_info_none {
        Destructor: (this: *IClone, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        CloneLeaf: (this: *IClone, unknown0: *b3DbvtNode) -> void #cpp_method;
    }

    IClone_Destructor :: inline (this: *IClone, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    IClone_CloneLeaf :: inline (this: *IClone, unknown0: *b3DbvtNode) { this.vtable.CloneLeaf(this, unknown0); }



    // Constants
    B3 :: enum s32 {
        SIMPLE_STACKSIZE :: 64;
        DOUBLE_STACKSIZE :: 128;

        B3_SIMPLE_STACKSIZE :: SIMPLE_STACKSIZE;
        B3_DOUBLE_STACKSIZE :: DOUBLE_STACKSIZE;
    }

    // Fields
    m_root:         *b3DbvtNode;
    m_free:         *b3DbvtNode;
    m_lkhd:         s32;
    m_leaves:       s32;
    m_opath:        u32;

    m_stkStack:     b3AlignedObjectArray(sStkNN);
    m_rayTestStack: b3AlignedObjectArray(*b3DbvtNode);

    // Methods
    Constructor :: (this: *b3DynamicBvh) -> void #cpp_method #foreign bullet3 "??0b3DynamicBvh@@QEAA@XZ";
    Destructor :: (this: *b3DynamicBvh) -> void #cpp_method #foreign bullet3 "??1b3DynamicBvh@@QEAA@XZ";
    clear :: (this: *b3DynamicBvh) -> void #cpp_method #foreign bullet3 "?clear@b3DynamicBvh@@QEAAXXZ";
    empty :: (this: *b3DynamicBvh) -> bool #cpp_method #foreign bullet3 "?empty@b3DynamicBvh@@QEBA_NXZ";
    optimizeBottomUp :: (this: *b3DynamicBvh) -> void #cpp_method #foreign bullet3 "?optimizeBottomUp@b3DynamicBvh@@QEAAXXZ";
    optimizeTopDown :: (this: *b3DynamicBvh, bu_treshold: s32 = 128) -> void #cpp_method #foreign bullet3 "?optimizeTopDown@b3DynamicBvh@@QEAAXH@Z";
    optimizeIncremental :: (this: *b3DynamicBvh, passes: s32) -> void #cpp_method #foreign bullet3 "?optimizeIncremental@b3DynamicBvh@@QEAAXH@Z";
    insert :: (this: *b3DynamicBvh, box: *b3DbvtVolume, data: *void) -> *b3DbvtNode #cpp_method #foreign bullet3 "?insert@b3DynamicBvh@@QEAAPEAUb3DbvtNode@@AEBUb3DbvtAabbMm@@PEAX@Z";
    insert :: (this: *b3DynamicBvh, box: b3DbvtVolume, data: *void) -> *b3DbvtNode #no_context {
        return insert(this, *box, data);
    }
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, lookahead: s32 = -1) -> void #cpp_method #foreign bullet3 "?update@b3DynamicBvh@@QEAAXPEAUb3DbvtNode@@H@Z";
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, volume: *b3DbvtVolume) -> void #cpp_method #foreign bullet3 "?update@b3DynamicBvh@@QEAAXPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@@Z";
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, volume: *b3DbvtVolume, velocity: *b3Vector3, margin: b3Scalar) -> bool #cpp_method #foreign bullet3 "?update@b3DynamicBvh@@QEAA_NPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@AEBVb3Vector3@@M@Z";
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, volume: *b3DbvtVolume, velocity: b3Vector3, margin: b3Scalar) -> bool #no_context {
        return update(this, leaf, volume, *velocity, margin);
    }
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, volume: *b3DbvtVolume, velocity: *b3Vector3) -> bool #cpp_method #foreign bullet3 "?update@b3DynamicBvh@@QEAA_NPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@AEBVb3Vector3@@@Z";
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, volume: *b3DbvtVolume, velocity: b3Vector3) -> bool #no_context {
        return update(this, leaf, volume, *velocity);
    }
    update :: (this: *b3DynamicBvh, leaf: *b3DbvtNode, volume: *b3DbvtVolume, margin: b3Scalar) -> bool #cpp_method #foreign bullet3 "?update@b3DynamicBvh@@QEAA_NPEAUb3DbvtNode@@AEAUb3DbvtAabbMm@@M@Z";
    _remove :: (this: *b3DynamicBvh, leaf: *b3DbvtNode) -> void #cpp_method #foreign bullet3 "?remove@b3DynamicBvh@@QEAAXPEAUb3DbvtNode@@@Z";
    write :: (this: *b3DynamicBvh, iwriter: *IWriter) -> void #cpp_method #foreign bullet3 "?write@b3DynamicBvh@@QEBAXPEAUIWriter@1@@Z";
    clone :: (this: *b3DynamicBvh, dest: *b3DynamicBvh, iclone: *IClone = null) -> void #cpp_method #foreign bullet3 "?clone@b3DynamicBvh@@QEBAXAEAU1@PEAUIClone@1@@Z";
    maxdepth :: (node: *b3DbvtNode) -> s32 #foreign bullet3 "?maxdepth@b3DynamicBvh@@SAHPEBUb3DbvtNode@@@Z";
    countLeaves :: (node: *b3DbvtNode) -> s32 #foreign bullet3 "?countLeaves@b3DynamicBvh@@SAHPEBUb3DbvtNode@@@Z";
    extractLeaves :: (node: *b3DbvtNode, leaves: *b3AlignedObjectArray(*b3DbvtNode)) -> void #foreign bullet3 "?extractLeaves@b3DynamicBvh@@SAXPEBUb3DbvtNode@@AEAV?$b3AlignedObjectArray@PEBUb3DbvtNode@@@@@Z";

    benchmark :: () -> void #foreign bullet3 "?benchmark@b3DynamicBvh@@SAXXZ";

    // Helpers
    nearest :: (i: *s32, a: *sStkNPS, v: b3Scalar, l: s32, h: s32) -> s32 #foreign bullet3 "?nearest@b3DynamicBvh@@SAHPEBHPEBUsStkNPS@1@MHH@Z";

    allocate :: (ifree: *b3AlignedObjectArray(s32), stock: *b3AlignedObjectArray(sStkNPS), value: *sStkNPS) -> s32 #foreign bullet3 "?allocate@b3DynamicBvh@@SAHAEAV?$b3AlignedObjectArray@H@@AEAV?$b3AlignedObjectArray@UsStkNPS@b3DynamicBvh@@@@AEBUsStkNPS@1@@Z";
    allocate :: (ifree: *b3AlignedObjectArray(s32), stock: *b3AlignedObjectArray(sStkNPS), value: sStkNPS) -> s32 #no_context {
        return allocate(ifree, stock, *value);
    }

    //
    CopyConstructor :: (this: *b3DynamicBvh, unknown0: *b3DynamicBvh) -> void #cpp_method #foreign bullet3 "??0b3DynamicBvh@@AEAA@AEBU0@@Z";
    CopyConstructor :: (this: *b3DynamicBvh, unknown0: b3DynamicBvh) #no_context {
        CopyConstructor(this, *unknown0);
    }
}

b3UnsignedInt2 :: struct {
    union {
        struct {
            x: u32;
            y: u32;
        }

        struct {
            s: [2] u32;
        }
    }
}

b3Int2 :: struct {
    union {
        struct {
            x: s32;
            y: s32;
        }

        struct {
            s: [2] s32;
        }
    }
}

b3Dispatcher :: struct {}

b3UnsignedInt4 :: struct {
    union {
        struct {
            x: u32;
            y: u32;
            z: u32;
            w: u32;
        }

        struct {
            s: [4] u32;
        }
    }
}


b3Int4 :: struct {
    union {
        struct {
            x: s32;
            y: s32;
            z: s32;
            w: s32;
        }

        struct {
            s: [4] s32;
        }
    }
}


b3BroadphasePair :: b3Int4;

/*struct b3BroadphasePair : public b3Int4
{
explicit b3BroadphasePair(){}

};
*/
b3BroadphasePairSortPredicate :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

b3BroadphasePairArray :: b3AlignedObjectArray(b3BroadphasePair);

b3OverlapCallback :: struct {
    vtable: *b3OverlapCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *b3OverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3OverlapCallback@@UEAA@XZ";
}
b3OverlapCallback_VTable :: struct #type_info_none {
    Destructor: (this: *b3OverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    processOverlap: (this: *b3OverlapCallback, pair: *b3BroadphasePair) -> bool #cpp_method;
}

b3OverlapCallback_Destructor :: inline (this: *b3OverlapCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3OverlapCallback_processOverlap :: inline (this: *b3OverlapCallback, pair: *b3BroadphasePair) -> bool { return this.vtable.processOverlap(this, pair); }



b3OverlapFilterCallback :: struct {
    vtable: *b3OverlapFilterCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *b3OverlapFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3OverlapFilterCallback@@UEAA@XZ";
}
b3OverlapFilterCallback_VTable :: struct #type_info_none {
    Destructor: (this: *b3OverlapFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    needBroadphaseCollision: (this: *b3OverlapFilterCallback, proxy0: s32, proxy1: s32) -> bool #cpp_method;
}

b3OverlapFilterCallback_Destructor :: inline (this: *b3OverlapFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3OverlapFilterCallback_needBroadphaseCollision :: inline (this: *b3OverlapFilterCallback, proxy0: s32, proxy1: s32) -> bool { return this.vtable.needBroadphaseCollision(this, proxy0, proxy1); }



///The b3OverlappingPairCache provides an interface for overlapping pair management (add, remove, storage), used by the b3BroadphaseInterface broadphases.
///The b3HashedOverlappingPairCache and b3SortedOverlappingPairCache classes are two implementations.
b3OverlappingPairCache :: struct {
    vtable: *b3OverlappingPairCache_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *b3OverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3OverlappingPairCache@@UEAA@XZ";
}
b3OverlappingPairCache_VTable :: struct #type_info_none {
    Destructor: (this: *b3OverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getOverlappingPairArrayPtr_1: (this: /*const*/ *b3OverlappingPairCache) -> *b3BroadphasePair #cpp_method;

    getOverlappingPairArrayPtr: (this: *b3OverlappingPairCache) -> *b3BroadphasePair #cpp_method;

    getOverlappingPairArray: (this: *b3OverlappingPairCache) -> *b3BroadphasePairArray #cpp_method;

    cleanOverlappingPair: (this: *b3OverlappingPairCache, pair: *b3BroadphasePair, dispatcher: *b3Dispatcher) -> void #cpp_method;

    getNumOverlappingPairs: (this: *b3OverlappingPairCache) -> s32 #cpp_method;

    cleanProxyFromPairs: (this: *b3OverlappingPairCache, proxy: s32, dispatcher: *b3Dispatcher) -> void #cpp_method;

    setOverlapFilterCallback: (this: *b3OverlappingPairCache, callback: *b3OverlapFilterCallback) -> void #cpp_method;

    processAllOverlappingPairs: (this: *b3OverlappingPairCache, unknown0: *b3OverlapCallback, dispatcher: *b3Dispatcher) -> void #cpp_method;

    findPair: (this: *b3OverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method;

    hasDeferredRemoval: (this: *b3OverlappingPairCache) -> bool #cpp_method;

    addOverlappingPair: (this: *b3OverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method;
    removeOverlappingPair: (this: *b3OverlappingPairCache, proxy0: s32, proxy1: s32, dispatcher: *b3Dispatcher) -> *void #cpp_method;
    removeOverlappingPairsContainingProxy: (this: *b3OverlappingPairCache, unknown0: s32, unknown1: *b3Dispatcher) -> void #cpp_method;

    sortOverlappingPairs: (this: *b3OverlappingPairCache, dispatcher: *b3Dispatcher) -> void #cpp_method;
}

b3OverlappingPairCache_Destructor :: inline (this: *b3OverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3OverlappingPairCache_getOverlappingPairArrayPtr_1 :: inline (this: /*const*/ *b3OverlappingPairCache) -> *b3BroadphasePair { return this.vtable.getOverlappingPairArrayPtr_1(this); }

b3OverlappingPairCache_getOverlappingPairArrayPtr :: inline (this: *b3OverlappingPairCache) -> *b3BroadphasePair { return this.vtable.getOverlappingPairArrayPtr(this); }

b3OverlappingPairCache_getOverlappingPairArray :: inline (this: *b3OverlappingPairCache) -> *b3BroadphasePairArray { return this.vtable.getOverlappingPairArray(this); }

b3OverlappingPairCache_cleanOverlappingPair :: inline (this: *b3OverlappingPairCache, pair: *b3BroadphasePair, dispatcher: *b3Dispatcher) { this.vtable.cleanOverlappingPair(this, pair, dispatcher); }

b3OverlappingPairCache_getNumOverlappingPairs :: inline (this: *b3OverlappingPairCache) -> s32 { return this.vtable.getNumOverlappingPairs(this); }

b3OverlappingPairCache_cleanProxyFromPairs :: inline (this: *b3OverlappingPairCache, proxy: s32, dispatcher: *b3Dispatcher) { this.vtable.cleanProxyFromPairs(this, proxy, dispatcher); }

b3OverlappingPairCache_setOverlapFilterCallback :: inline (this: *b3OverlappingPairCache, callback: *b3OverlapFilterCallback) { this.vtable.setOverlapFilterCallback(this, callback); }

b3OverlappingPairCache_processAllOverlappingPairs :: inline (this: *b3OverlappingPairCache, unknown0: *b3OverlapCallback, dispatcher: *b3Dispatcher) { this.vtable.processAllOverlappingPairs(this, unknown0, dispatcher); }

b3OverlappingPairCache_findPair :: inline (this: *b3OverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair { return this.vtable.findPair(this, proxy0, proxy1); }

b3OverlappingPairCache_hasDeferredRemoval :: inline (this: *b3OverlappingPairCache) -> bool { return this.vtable.hasDeferredRemoval(this); }

b3OverlappingPairCache_addOverlappingPair :: inline (this: *b3OverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair { return this.vtable.addOverlappingPair(this, proxy0, proxy1); }
b3OverlappingPairCache_removeOverlappingPair :: inline (this: *b3OverlappingPairCache, proxy0: s32, proxy1: s32, dispatcher: *b3Dispatcher) -> *void { return this.vtable.removeOverlappingPair(this, proxy0, proxy1, dispatcher); }
b3OverlappingPairCache_removeOverlappingPairsContainingProxy :: inline (this: *b3OverlappingPairCache, unknown0: s32, unknown1: *b3Dispatcher) { this.vtable.removeOverlappingPairsContainingProxy(this, unknown0, unknown1); }

b3OverlappingPairCache_sortOverlappingPairs :: inline (this: *b3OverlappingPairCache, dispatcher: *b3Dispatcher) { this.vtable.sortOverlappingPairs(this, dispatcher); }



/// Hash-space based Pair Cache, thanks to Erin Catto, Box2D, http://www.box2d.org, and Pierre Terdiman, Codercorner, http://codercorner.com
b3HashedOverlappingPairCache :: struct {
    #as using b3overlappingpaircache: b3OverlappingPairCache;

    m_overlappingPairArray:  b3BroadphasePairArray;
    m_overlapFilterCallback: *b3OverlapFilterCallback;

    //	bool		m_blockedForChanges;
    Constructor :: (this: *b3HashedOverlappingPairCache) -> void #cpp_method #foreign bullet3 "??0b3HashedOverlappingPairCache@@QEAA@XZ";

    needsBroadphaseCollision :: (this: *b3HashedOverlappingPairCache, proxy0: s32, proxy1: s32) -> bool #cpp_method #foreign bullet3 "?needsBroadphaseCollision@b3HashedOverlappingPairCache@@QEBA_NHH@Z";

    getOverlappingPairArray :: (this: /*const*/ *b3HashedOverlappingPairCache) -> *b3BroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@b3HashedOverlappingPairCache@@QEBAAEBV?$b3AlignedObjectArray@Ub3Int4@@@@XZ";

    GetCount :: (this: *b3HashedOverlappingPairCache) -> s32 #cpp_method #foreign bullet3 "?GetCount@b3HashedOverlappingPairCache@@QEBAHXZ";

    //	b3BroadphasePair* GetPairs() { return m_pairs; }
    getOverlapFilterCallback :: (this: *b3HashedOverlappingPairCache) -> *b3OverlapFilterCallback #cpp_method #foreign bullet3 "?getOverlapFilterCallback@b3HashedOverlappingPairCache@@QEAAPEAUb3OverlapFilterCallback@@XZ";

    internalAddPair :: (this: *b3HashedOverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?internalAddPair@b3HashedOverlappingPairCache@@AEAAPEAUb3Int4@@HH@Z";

    growTables :: (this: *b3HashedOverlappingPairCache) -> void #cpp_method #foreign bullet3 "?growTables@b3HashedOverlappingPairCache@@AEAAXXZ";

    equalsPair :: (this: *b3HashedOverlappingPairCache, pair: *b3BroadphasePair, proxyId1: s32, proxyId2: s32) -> bool #cpp_method #foreign bullet3 "?equalsPair@b3HashedOverlappingPairCache@@AEAA_NAEBUb3Int4@@HH@Z";
    equalsPair :: (this: *b3HashedOverlappingPairCache, pair: b3BroadphasePair, proxyId1: s32, proxyId2: s32) -> bool #no_context {
        return equalsPair(this, *pair, proxyId1, proxyId2);
    }

    /*
    // Thomas Wang's hash, see: http://www.concentric.net/~Ttwang/tech/inthash.htm
    // This assumes proxyId1 and proxyId2 are 16-bit.
    B3_FORCE_INLINE int getHash(int proxyId1, int proxyId2)
    {
    int key = (proxyId2 << 16) | proxyId1;
    key = ~key + (key << 15);
    key = key ^ (key >> 12);
    key = key + (key << 2);
    key = key ^ (key >> 4);
    key = key * 2057;
    key = key ^ (key >> 16);
    return key;
    }
    */
    getHash :: (this: *b3HashedOverlappingPairCache, proxyId1: u32, proxyId2: u32) -> u32 #cpp_method #foreign bullet3 "?getHash@b3HashedOverlappingPairCache@@AEAAIII@Z";

    internalFindPair :: (this: *b3HashedOverlappingPairCache, proxy0: s32, proxy1: s32, hash: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?internalFindPair@b3HashedOverlappingPairCache@@AEAAPEAUb3Int4@@HHH@Z";

    m_hashTable:             b3AlignedObjectArray(s32);
    m_next:                  b3AlignedObjectArray(s32);

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3HashedOverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3HashedOverlappingPairCache@@UEAA@XZ";

    virtual_removeOverlappingPairsContainingProxy :: (this: *b3HashedOverlappingPairCache, proxy: s32, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@b3HashedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z";

    virtual_removeOverlappingPair :: (this: *b3HashedOverlappingPairCache, proxy0: s32, proxy1: s32, dispatcher: *b3Dispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@b3HashedOverlappingPairCache@@UEAAPEAXHHPEAVb3Dispatcher@@@Z";

    // Add a pair and return the new pair. If the pair already exists,
    // no new pair is created and the old one is returned.
    virtual_addOverlappingPair :: (this: *b3HashedOverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@b3HashedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z";

    virtual_cleanProxyFromPairs :: (this: *b3HashedOverlappingPairCache, proxy: s32, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?cleanProxyFromPairs@b3HashedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z";

    virtual_processAllOverlappingPairs :: (this: *b3HashedOverlappingPairCache, unknown0: *b3OverlapCallback, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@b3HashedOverlappingPairCache@@UEAAXPEAUb3OverlapCallback@@PEAVb3Dispatcher@@@Z";

    virtual_getOverlappingPairArrayPtr :: (this: *b3HashedOverlappingPairCache) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@b3HashedOverlappingPairCache@@UEAAPEAUb3Int4@@XZ";

    virtual_getOverlappingPairArrayPtr_1 :: (this: /*const*/ *b3HashedOverlappingPairCache) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@b3HashedOverlappingPairCache@@UEBAPEBUb3Int4@@XZ";

    virtual_getOverlappingPairArray_1 :: (this: *b3HashedOverlappingPairCache) -> *b3BroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@b3HashedOverlappingPairCache@@UEAAAEAV?$b3AlignedObjectArray@Ub3Int4@@@@XZ";

    virtual_cleanOverlappingPair :: (this: *b3HashedOverlappingPairCache, pair: *b3BroadphasePair, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?cleanOverlappingPair@b3HashedOverlappingPairCache@@UEAAXAEAUb3Int4@@PEAVb3Dispatcher@@@Z";

    virtual_findPair :: (this: *b3HashedOverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?findPair@b3HashedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z";

    virtual_setOverlapFilterCallback :: (this: *b3HashedOverlappingPairCache, callback: *b3OverlapFilterCallback) -> void #cpp_method #foreign bullet3 "?setOverlapFilterCallback@b3HashedOverlappingPairCache@@UEAAXPEAUb3OverlapFilterCallback@@@Z";

    virtual_getNumOverlappingPairs :: (this: *b3HashedOverlappingPairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@b3HashedOverlappingPairCache@@UEBAHXZ";

    virtual_hasDeferredRemoval :: (this: *b3HashedOverlappingPairCache) -> bool #cpp_method #foreign bullet3 "?hasDeferredRemoval@b3HashedOverlappingPairCache@@EEAA_NXZ";

    /*	virtual	void	setInternalGhostPairCallback(b3OverlappingPairCallback* ghostPairCallback)
    {
    m_ghostPairCallback = ghostPairCallback;
    }
    */
    virtual_sortOverlappingPairs :: (this: *b3HashedOverlappingPairCache, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?sortOverlappingPairs@b3HashedOverlappingPairCache@@EEAAXPEAVb3Dispatcher@@@Z";
}

///b3SortedOverlappingPairCache maintains the objects with overlapping AABB
///Typically managed by the Broadphase, Axis3Sweep or b3SimpleBroadphase
b3SortedOverlappingPairCache :: struct {
    #as using b3overlappingpaircache: b3OverlappingPairCache;

    //avoid brute-force finding all the time
    m_overlappingPairArray:  b3BroadphasePairArray;

    //during the dispatch, check that user doesn't destroy/create proxy
    m_blockedForChanges:     bool;

    ///by default, do the removal during the pair traversal
    m_hasDeferredRemoval:    bool;

    //if set, use the callback instead of the built in filter in needBroadphaseCollision
    m_overlapFilterCallback: *b3OverlapFilterCallback;

    //		b3OverlappingPairCallback*	m_ghostPairCallback;
    Constructor :: (this: *b3SortedOverlappingPairCache) -> void #cpp_method #foreign bullet3 "??0b3SortedOverlappingPairCache@@QEAA@XZ";

    needsBroadphaseCollision :: (this: *b3SortedOverlappingPairCache, proxy0: s32, proxy1: s32) -> bool #cpp_method #foreign bullet3 "?needsBroadphaseCollision@b3SortedOverlappingPairCache@@QEBA_NHH@Z";

    getOverlappingPairArray :: (this: /*const*/ *b3SortedOverlappingPairCache) -> *b3BroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@b3SortedOverlappingPairCache@@QEBAAEBV?$b3AlignedObjectArray@Ub3Int4@@@@XZ";

    getOverlapFilterCallback :: (this: *b3SortedOverlappingPairCache) -> *b3OverlapFilterCallback #cpp_method #foreign bullet3 "?getOverlapFilterCallback@b3SortedOverlappingPairCache@@QEAAPEAUb3OverlapFilterCallback@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3SortedOverlappingPairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3SortedOverlappingPairCache@@UEAA@XZ";

    virtual_processAllOverlappingPairs :: (this: *b3SortedOverlappingPairCache, unknown0: *b3OverlapCallback, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@b3SortedOverlappingPairCache@@UEAAXPEAUb3OverlapCallback@@PEAVb3Dispatcher@@@Z";

    virtual_removeOverlappingPair :: (this: *b3SortedOverlappingPairCache, proxy0: s32, proxy1: s32, dispatcher: *b3Dispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@b3SortedOverlappingPairCache@@UEAAPEAXHHPEAVb3Dispatcher@@@Z";

    virtual_cleanOverlappingPair :: (this: *b3SortedOverlappingPairCache, pair: *b3BroadphasePair, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?cleanOverlappingPair@b3SortedOverlappingPairCache@@UEAAXAEAUb3Int4@@PEAVb3Dispatcher@@@Z";

    virtual_addOverlappingPair :: (this: *b3SortedOverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@b3SortedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z";

    virtual_findPair :: (this: *b3SortedOverlappingPairCache, proxy0: s32, proxy1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?findPair@b3SortedOverlappingPairCache@@UEAAPEAUb3Int4@@HH@Z";

    virtual_cleanProxyFromPairs :: (this: *b3SortedOverlappingPairCache, proxy: s32, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?cleanProxyFromPairs@b3SortedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z";

    virtual_removeOverlappingPairsContainingProxy :: (this: *b3SortedOverlappingPairCache, proxy: s32, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@b3SortedOverlappingPairCache@@UEAAXHPEAVb3Dispatcher@@@Z";

    virtual_getOverlappingPairArray_1 :: (this: *b3SortedOverlappingPairCache) -> *b3BroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@b3SortedOverlappingPairCache@@UEAAAEAV?$b3AlignedObjectArray@Ub3Int4@@@@XZ";

    virtual_getOverlappingPairArrayPtr :: (this: *b3SortedOverlappingPairCache) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@b3SortedOverlappingPairCache@@UEAAPEAUb3Int4@@XZ";

    virtual_getOverlappingPairArrayPtr_1 :: (this: /*const*/ *b3SortedOverlappingPairCache) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@b3SortedOverlappingPairCache@@UEBAPEBUb3Int4@@XZ";

    virtual_getNumOverlappingPairs :: (this: *b3SortedOverlappingPairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@b3SortedOverlappingPairCache@@UEBAHXZ";

    virtual_setOverlapFilterCallback :: (this: *b3SortedOverlappingPairCache, callback: *b3OverlapFilterCallback) -> void #cpp_method #foreign bullet3 "?setOverlapFilterCallback@b3SortedOverlappingPairCache@@UEAAXPEAUb3OverlapFilterCallback@@@Z";

    virtual_hasDeferredRemoval :: (this: *b3SortedOverlappingPairCache) -> bool #cpp_method #foreign bullet3 "?hasDeferredRemoval@b3SortedOverlappingPairCache@@UEAA_NXZ";

    /*		virtual	void	setInternalGhostPairCallback(b3OverlappingPairCallback* ghostPairCallback)
    {
    m_ghostPairCallback = ghostPairCallback;
    }
    */
    virtual_sortOverlappingPairs :: (this: *b3SortedOverlappingPairCache, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?sortOverlappingPairs@b3SortedOverlappingPairCache@@UEAAXPEAVb3Dispatcher@@@Z";
}

///b3NullPairCache skips add/removal of overlapping pairs. Userful for benchmarking and unit testing.
b3NullPairCache :: struct {
    #as using b3overlappingpaircache: b3OverlappingPairCache;

    m_overlappingPairArray: b3BroadphasePairArray;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getOverlappingPairArrayPtr :: (this: *b3NullPairCache) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@b3NullPairCache@@UEAAPEAUb3Int4@@XZ";

    virtual_getOverlappingPairArrayPtr_1 :: (this: /*const*/ *b3NullPairCache) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@b3NullPairCache@@UEBAPEBUb3Int4@@XZ";

    virtual_getOverlappingPairArray :: (this: *b3NullPairCache) -> *b3BroadphasePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@b3NullPairCache@@UEAAAEAV?$b3AlignedObjectArray@Ub3Int4@@@@XZ";

    virtual_cleanOverlappingPair :: (this: *b3NullPairCache, unknown0: *b3BroadphasePair, unknown1: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?cleanOverlappingPair@b3NullPairCache@@UEAAXAEAUb3Int4@@PEAVb3Dispatcher@@@Z";

    virtual_getNumOverlappingPairs :: (this: *b3NullPairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@b3NullPairCache@@UEBAHXZ";

    virtual_cleanProxyFromPairs :: (this: *b3NullPairCache, unknown0: s32, unknown1: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?cleanProxyFromPairs@b3NullPairCache@@UEAAXHPEAVb3Dispatcher@@@Z";

    virtual_setOverlapFilterCallback :: (this: *b3NullPairCache, unknown0: *b3OverlapFilterCallback) -> void #cpp_method #foreign bullet3 "?setOverlapFilterCallback@b3NullPairCache@@UEAAXPEAUb3OverlapFilterCallback@@@Z";

    virtual_processAllOverlappingPairs :: (this: *b3NullPairCache, unknown0: *b3OverlapCallback, unknown1: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?processAllOverlappingPairs@b3NullPairCache@@UEAAXPEAUb3OverlapCallback@@PEAVb3Dispatcher@@@Z";

    virtual_findPair :: (this: *b3NullPairCache, unknown0: s32, unknown1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?findPair@b3NullPairCache@@UEAAPEAUb3Int4@@HH@Z";

    virtual_hasDeferredRemoval :: (this: *b3NullPairCache) -> bool #cpp_method #foreign bullet3 "?hasDeferredRemoval@b3NullPairCache@@UEAA_NXZ";

    //	virtual	void	setInternalGhostPairCallback(b3OverlappingPairCallback* /* ghostPairCallback */)
    //	{
    //
    //	}
    virtual_addOverlappingPair :: (this: *b3NullPairCache, unknown0: s32, unknown1: s32) -> *b3BroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@b3NullPairCache@@UEAAPEAUb3Int4@@HH@Z";

    virtual_removeOverlappingPair :: (this: *b3NullPairCache, unknown0: s32, unknown1: s32, unknown2: *b3Dispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@b3NullPairCache@@UEAAPEAXHHPEAVb3Dispatcher@@@Z";

    virtual_removeOverlappingPairsContainingProxy :: (this: *b3NullPairCache, unknown0: s32, unknown1: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@b3NullPairCache@@UEAAXHPEAVb3Dispatcher@@@Z";

    virtual_sortOverlappingPairs :: (this: *b3NullPairCache, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?sortOverlappingPairs@b3NullPairCache@@UEAAXPEAVb3Dispatcher@@@Z";
}

b3BroadphaseProxy :: struct {
    ///optional filtering to cull potential collisions
    CollisionFilterGroups :: enum s32 {
        DefaultFilter   :: 1;
        StaticFilter    :: 2;
        KinematicFilter :: 4;
        DebrisFilter    :: 8;
        SensorTrigger   :: 16;
        CharacterFilter :: 32;
        AllFilter       :: -1;
    }

    //Usually the client b3CollisionObject or Rigidbody class
    m_clientObject:         *void;
    m_collisionFilterGroup: s32;
    m_collisionFilterMask:  s32;
    m_uniqueId:             s32; //m_uniqueId is introduced for paircache. could get rid of this, by calculating the address offset etc.

    m_aabbMin:              b3Vector3;
    m_aabbMax:              b3Vector3;

    getUid :: (this: *b3BroadphaseProxy) -> s32 #cpp_method #foreign bullet3 "?getUid@b3BroadphaseProxy@@QEBAHXZ";

    //used for memory pools
    Constructor :: (this: *b3BroadphaseProxy) -> void #cpp_method #foreign bullet3 "??0b3BroadphaseProxy@@QEAA@XZ";

    Constructor :: (this: *b3BroadphaseProxy, aabbMin: *b3Vector3, aabbMax: *b3Vector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> void #cpp_method #foreign bullet3 "??0b3BroadphaseProxy@@QEAA@AEBVb3Vector3@@0PEAXHH@Z";
    Constructor :: (this: *b3BroadphaseProxy, aabbMin: b3Vector3, aabbMax: b3Vector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) #no_context {
        Constructor(this, *aabbMin, *aabbMax, userPtr, collisionFilterGroup, collisionFilterMask);
    }
}


//
// b3DbvtProxy
//
b3DbvtProxy :: struct {
    #as using b3broadphaseproxy: b3BroadphaseProxy;

    /* Fields		*/
    //b3DbvtAabbMm	aabb;
    leaf:  *b3DbvtNode;
    links: [2] *b3DbvtProxy;
    stage: s32;

    /* ctor			*/
    Constructor :: (this: *b3DbvtProxy) -> void #cpp_method #foreign bullet3 "??0b3DbvtProxy@@QEAA@XZ";
    Constructor :: (this: *b3DbvtProxy, aabbMin: *b3Vector3, aabbMax: *b3Vector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> void #cpp_method #foreign bullet3 "??0b3DbvtProxy@@QEAA@AEBVb3Vector3@@0PEAXHH@Z";
    Constructor :: (this: *b3DbvtProxy, aabbMin: b3Vector3, aabbMax: b3Vector3, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) #no_context {
        Constructor(this, *aabbMin, *aabbMax, userPtr, collisionFilterGroup, collisionFilterMask);
    }
}

b3DbvtProxyArray :: b3AlignedObjectArray(*b3DbvtProxy);

///The b3DynamicBvhBroadphase implements a broadphase using two dynamic AABB bounding volume hierarchies/trees (see b3DynamicBvh).
///One tree is used for static/non-moving objects, and another tree is used for dynamic objects. Objects can move from one tree to the other.
///This is a very fast broadphase, especially for very dynamic worlds where many objects are moving. Its insert/add and remove of objects is generally faster than the sweep and prune broadphases b3AxisSweep3 and b332BitAxisSweep3.
b3DynamicBvhBroadphase :: struct {
    vtable: *b3DynamicBvhBroadphase_VTable;
    /* Config		*/
    anon_enum_10 :: enum s32 {
        DYNAMIC_SET :: 0;
        FIXED_SET   :: 1;
        STAGECOUNT  :: 2;
    }

    m_sets:             [2] b3DynamicBvh; // Dbvt sets
    m_stageRoots:       [3] *b3DbvtProxy; // Stages list

    m_proxies:          b3AlignedObjectArray(b3DbvtProxy);
    m_paircache:        *b3OverlappingPairCache; // Pair cache
    m_prediction:       b3Scalar; // Velocity prediction
    m_stageCurrent:     s32; // Current stage
    m_fupdates:         s32; // % of fixed updates per frame
    m_dupdates:         s32; // % of dynamic updates per frame
    m_cupdates:         s32; // % of cleanup updates per frame
    m_newpairs:         s32; // Number of pairs created
    m_fixedleft:        s32; // Fixed optimization left
    m_updates_call:     u32; // Number of updates call
    m_updates_done:     u32; // Number of updates done
    m_updates_ratio:    b3Scalar; // m_updates_done/m_updates_call
    m_pid:              s32; // Parse id
    m_cid:              s32; // Cleanup index
    m_releasepaircache: bool; // Release pair cache on delete
    m_deferedcollide:   bool; // Defere dynamic/static collision to collide call
    m_needcleanup:      bool; // Need to run cleanup?

    /* Methods		*/
    Constructor :: (this: *b3DynamicBvhBroadphase, proxyCapacity: s32, paircache: *b3OverlappingPairCache = null) -> void #cpp_method #foreign bullet3 "??0b3DynamicBvhBroadphase@@QEAA@HPEAVb3OverlappingPairCache@@@Z";

    collide :: (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?collide@b3DynamicBvhBroadphase@@QEAAXPEAVb3Dispatcher@@@Z";
    optimize :: (this: *b3DynamicBvhBroadphase) -> void #cpp_method #foreign bullet3 "?optimize@b3DynamicBvhBroadphase@@QEAAXXZ";

    /* b3BroadphaseInterface Implementation	*/
    createProxy :: (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3, objectIndex: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> *b3BroadphaseProxy #cpp_method #foreign bullet3 "?createProxy@b3DynamicBvhBroadphase@@QEAAPEAUb3BroadphaseProxy@@AEBVb3Vector3@@0HPEAXHH@Z";
    createProxy :: (this: *b3DynamicBvhBroadphase, aabbMin: b3Vector3, aabbMax: b3Vector3, objectIndex: s32, userPtr: *void, collisionFilterGroup: s32, collisionFilterMask: s32) -> *b3BroadphaseProxy #no_context {
        return createProxy(this, *aabbMin, *aabbMax, objectIndex, userPtr, collisionFilterGroup, collisionFilterMask);
    }

    performDeferredRemoval :: (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?performDeferredRemoval@b3DynamicBvhBroadphase@@QEAAXPEAVb3Dispatcher@@@Z";

    setVelocityPrediction :: (this: *b3DynamicBvhBroadphase, prediction: b3Scalar) -> void #cpp_method #foreign bullet3 "?setVelocityPrediction@b3DynamicBvhBroadphase@@QEAAXM@Z";

    getVelocityPrediction :: (this: *b3DynamicBvhBroadphase) -> b3Scalar #cpp_method #foreign bullet3 "?getVelocityPrediction@b3DynamicBvhBroadphase@@QEBAMXZ";

    ///this setAabbForceUpdate is similar to setAabb but always forces the aabb update.
    ///it is not part of the b3BroadphaseInterface but specific to b3DynamicBvhBroadphase.
    ///it bypasses certain optimizations that prevent aabb updates (when the aabb shrinks), see
    ///http://code.google.com/p/bullet/issues/detail?id=223
    setAabbForceUpdate :: (this: *b3DynamicBvhBroadphase, absproxy: *b3BroadphaseProxy, aabbMin: *b3Vector3, aabbMax: *b3Vector3, unknown0: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?setAabbForceUpdate@b3DynamicBvhBroadphase@@QEAAXPEAUb3BroadphaseProxy@@AEBVb3Vector3@@1PEAVb3Dispatcher@@@Z";
    setAabbForceUpdate :: (this: *b3DynamicBvhBroadphase, absproxy: *b3BroadphaseProxy, aabbMin: b3Vector3, aabbMax: b3Vector3, unknown0: *b3Dispatcher) #no_context {
        setAabbForceUpdate(this, absproxy, *aabbMin, *aabbMax, unknown0);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3DynamicBvhBroadphase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3DynamicBvhBroadphase@@UEAA@XZ";

    virtual_destroyProxy :: (this: *b3DynamicBvhBroadphase, proxy: *b3BroadphaseProxy, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?destroyProxy@b3DynamicBvhBroadphase@@UEAAXPEAUb3BroadphaseProxy@@PEAVb3Dispatcher@@@Z";
    virtual_setAabb :: (this: *b3DynamicBvhBroadphase, objectId: s32, aabbMin: *b3Vector3, aabbMax: *b3Vector3, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?setAabb@b3DynamicBvhBroadphase@@UEAAXHAEBVb3Vector3@@0PEAVb3Dispatcher@@@Z";
    virtual_rayTest :: (this: *b3DynamicBvhBroadphase, rayFrom: *b3Vector3, rayTo: *b3Vector3, rayCallback: *b3BroadphaseRayCallback, aabbMin: *b3Vector3, aabbMax: *b3Vector3) -> void #cpp_method #foreign bullet3 "?rayTest@b3DynamicBvhBroadphase@@UEAAXAEBVb3Vector3@@0AEAUb3BroadphaseRayCallback@@00@Z";
    virtual_aabbTest :: (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3, callback: *b3BroadphaseAabbCallback) -> void #cpp_method #foreign bullet3 "?aabbTest@b3DynamicBvhBroadphase@@UEAAXAEBVb3Vector3@@0AEAUb3BroadphaseAabbCallback@@@Z";

    //virtual void					getAabb(b3BroadphaseProxy* proxy,b3Vector3& aabbMin, b3Vector3& aabbMax ) const;
    virtual_getAabb :: (this: *b3DynamicBvhBroadphase, objectId: s32, aabbMin: *b3Vector3, aabbMax: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getAabb@b3DynamicBvhBroadphase@@UEBAXHAEAVb3Vector3@@0@Z";
    virtual_calculateOverlappingPairs :: (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher = null) -> void #cpp_method #foreign bullet3 "?calculateOverlappingPairs@b3DynamicBvhBroadphase@@UEAAXPEAVb3Dispatcher@@@Z";
    virtual_getOverlappingPairCache :: (this: *b3DynamicBvhBroadphase) -> *b3OverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@b3DynamicBvhBroadphase@@UEAAPEAVb3OverlappingPairCache@@XZ";
    virtual_getOverlappingPairCache_1 :: (this: /*const*/ *b3DynamicBvhBroadphase) -> *b3OverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@b3DynamicBvhBroadphase@@UEBAPEBVb3OverlappingPairCache@@XZ";
    virtual_getBroadphaseAabb :: (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getBroadphaseAabb@b3DynamicBvhBroadphase@@UEBAXAEAVb3Vector3@@0@Z";
    virtual_printStats :: (this: *b3DynamicBvhBroadphase) -> void #cpp_method #foreign bullet3 "?printStats@b3DynamicBvhBroadphase@@UEAAXXZ";

    ///reset broadphase internal structures, to ensure determinism/reproducability
    virtual_resetPool :: (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher) -> void #cpp_method #foreign bullet3 "?resetPool@b3DynamicBvhBroadphase@@UEAAXPEAVb3Dispatcher@@@Z";
}
b3DynamicBvhBroadphase_VTable :: struct #type_info_none {
    Destructor: (this: *b3DynamicBvhBroadphase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    destroyProxy: (this: *b3DynamicBvhBroadphase, proxy: *b3BroadphaseProxy, dispatcher: *b3Dispatcher) -> void #cpp_method;
    setAabb: (this: *b3DynamicBvhBroadphase, objectId: s32, aabbMin: *b3Vector3, aabbMax: *b3Vector3, dispatcher: *b3Dispatcher) -> void #cpp_method;
    rayTest: (this: *b3DynamicBvhBroadphase, rayFrom: *b3Vector3, rayTo: *b3Vector3, rayCallback: *b3BroadphaseRayCallback, aabbMin: *b3Vector3, aabbMax: *b3Vector3) -> void #cpp_method;
    aabbTest: (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3, callback: *b3BroadphaseAabbCallback) -> void #cpp_method;

    getAabb: (this: *b3DynamicBvhBroadphase, objectId: s32, aabbMin: *b3Vector3, aabbMax: *b3Vector3) -> void #cpp_method;
    calculateOverlappingPairs: (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher = null) -> void #cpp_method;

    getOverlappingPairCache_1: (this: /*const*/ *b3DynamicBvhBroadphase) -> *b3OverlappingPairCache #cpp_method;

    getOverlappingPairCache: (this: *b3DynamicBvhBroadphase) -> *b3OverlappingPairCache #cpp_method;

    getBroadphaseAabb: (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3) -> void #cpp_method;
    printStats: (this: *b3DynamicBvhBroadphase) -> void #cpp_method;

    resetPool: (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher) -> void #cpp_method;
}

b3DynamicBvhBroadphase_Destructor :: inline (this: *b3DynamicBvhBroadphase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3DynamicBvhBroadphase_destroyProxy :: inline (this: *b3DynamicBvhBroadphase, proxy: *b3BroadphaseProxy, dispatcher: *b3Dispatcher) { this.vtable.destroyProxy(this, proxy, dispatcher); }
b3DynamicBvhBroadphase_setAabb :: inline (this: *b3DynamicBvhBroadphase, objectId: s32, aabbMin: *b3Vector3, aabbMax: *b3Vector3, dispatcher: *b3Dispatcher) { this.vtable.setAabb(this, objectId, aabbMin, aabbMax, dispatcher); }
b3DynamicBvhBroadphase_rayTest :: inline (this: *b3DynamicBvhBroadphase, rayFrom: *b3Vector3, rayTo: *b3Vector3, rayCallback: *b3BroadphaseRayCallback, aabbMin: *b3Vector3, aabbMax: *b3Vector3) { this.vtable.rayTest(this, rayFrom, rayTo, rayCallback, aabbMin, aabbMax); }
b3DynamicBvhBroadphase_aabbTest :: inline (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3, callback: *b3BroadphaseAabbCallback) { this.vtable.aabbTest(this, aabbMin, aabbMax, callback); }

b3DynamicBvhBroadphase_getAabb :: inline (this: *b3DynamicBvhBroadphase, objectId: s32, aabbMin: *b3Vector3, aabbMax: *b3Vector3) { this.vtable.getAabb(this, objectId, aabbMin, aabbMax); }
b3DynamicBvhBroadphase_calculateOverlappingPairs :: inline (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher = null) { this.vtable.calculateOverlappingPairs(this, dispatcher); }

b3DynamicBvhBroadphase_getOverlappingPairCache_1 :: inline (this: /*const*/ *b3DynamicBvhBroadphase) -> *b3OverlappingPairCache { return this.vtable.getOverlappingPairCache_1(this); }

b3DynamicBvhBroadphase_getOverlappingPairCache :: inline (this: *b3DynamicBvhBroadphase) -> *b3OverlappingPairCache { return this.vtable.getOverlappingPairCache(this); }

b3DynamicBvhBroadphase_getBroadphaseAabb :: inline (this: *b3DynamicBvhBroadphase, aabbMin: *b3Vector3, aabbMax: *b3Vector3) { this.vtable.getBroadphaseAabb(this, aabbMin, aabbMax); }
b3DynamicBvhBroadphase_printStats :: inline (this: *b3DynamicBvhBroadphase) { this.vtable.printStats(this); }

b3DynamicBvhBroadphase_resetPool :: inline (this: *b3DynamicBvhBroadphase, dispatcher: *b3Dispatcher) { this.vtable.resetPool(this, dispatcher); }



b3Config :: struct {
    m_maxConvexBodies:          s32;
    m_maxConvexShapes:          s32;
    m_maxBroadphasePairs:       s32;
    m_maxContactCapacity:       s32;
    m_compoundPairCapacity:     s32;

    m_maxVerticesPerFace:       s32;
    m_maxFacesPerShape:         s32;
    m_maxConvexVertices:        s32;
    m_maxConvexIndices:         s32;
    m_maxConvexUniqueEdges:     s32;

    m_maxCompoundChildShapes:   s32;

    m_maxTriConvexPairCapacity: s32;

    Constructor :: (this: *b3Config) -> void #cpp_method #foreign bullet3 "??0b3Config@@QEAA@XZ";
}

MyTest :: struct {
    bla: s32;
}

b3Contact4Data_t :: b3Contact4Data;

b3Contact4Data :: struct {
    m_worldPosB:            [4] b3Vector3;

    m_worldNormalOnB:       b3Vector3; //	w: m_nPoints
    m_restituitionCoeffCmp: u16;
    m_frictionCoeffCmp:     u16;
    m_batchIdx:             s32;
    m_bodyAPtrAndSignBit:   s32; //x:m_bodyAPtr, y:m_bodyBPtr
    m_bodyBPtrAndSignBit:   s32;

    m_childIndexA:          s32;
    m_childIndexB:          s32;
    m_unused1:              s32;
    m_unused2:              s32;
}

b3Contact4 :: struct {
    #as using b3contact4data: b3Contact4Data;

    getBodyA :: (this: *b3Contact4) -> s32 #cpp_method #foreign bullet3 "?getBodyA@b3Contact4@@QEBAHXZ";
    getBodyB :: (this: *b3Contact4) -> s32 #cpp_method #foreign bullet3 "?getBodyB@b3Contact4@@QEBAHXZ";
    isBodyAFixed :: (this: *b3Contact4) -> bool #cpp_method #foreign bullet3 "?isBodyAFixed@b3Contact4@@QEBA_NXZ";
    isBodyBFixed :: (this: *b3Contact4) -> bool #cpp_method #foreign bullet3 "?isBodyBFixed@b3Contact4@@QEBA_NXZ";

    //	todo. make it safer
    getBatchIdx :: (this: *b3Contact4) -> *s32 #cpp_method #foreign bullet3 "?getBatchIdx@b3Contact4@@QEAAAEAHXZ";
    getBatchIdx_1 :: (this: /*const*/ *b3Contact4) -> *s32 #cpp_method #foreign bullet3 "?getBatchIdx@b3Contact4@@QEBAAEBHXZ";
    getRestituitionCoeff :: (this: *b3Contact4) -> float #cpp_method #foreign bullet3 "?getRestituitionCoeff@b3Contact4@@QEBAMXZ";
    setRestituitionCoeff :: (this: *b3Contact4, c: float) -> void #cpp_method #foreign bullet3 "?setRestituitionCoeff@b3Contact4@@QEAAXM@Z";

    getFrictionCoeff :: (this: *b3Contact4) -> float #cpp_method #foreign bullet3 "?getFrictionCoeff@b3Contact4@@QEBAMXZ";
    setFrictionCoeff :: (this: *b3Contact4, c: float) -> void #cpp_method #foreign bullet3 "?setFrictionCoeff@b3Contact4@@QEAAXM@Z";

    //float& getNPoints() { return m_worldNormal[3]; }
    getNPoints :: (this: *b3Contact4) -> s32 #cpp_method #foreign bullet3 "?getNPoints@b3Contact4@@QEBAHXZ";

    getPenetration :: (this: *b3Contact4, idx: s32) -> float #cpp_method #foreign bullet3 "?getPenetration@b3Contact4@@QEBAMH@Z";

    isInvalid :: (this: *b3Contact4) -> bool #cpp_method #foreign bullet3 "?isInvalid@b3Contact4@@QEBA_NXZ";
}


b3MyFace :: struct {
    m_indices: b3AlignedObjectArray(s32);
    m_plane:   [4] b3Scalar;
}

b3ConvexUtility :: struct {
    vtable: *b3ConvexUtility_VTable;
    m_localCenter: b3Vector3 #align 8;
    m_extents:     b3Vector3;
    mC:            b3Vector3;
    mE:            b3Vector3;
    m_radius:      b3Scalar;

    m_vertices:    b3AlignedObjectArray(b3Vector3);
    m_faces:       b3AlignedObjectArray(b3MyFace);
    m_uniqueEdges: b3AlignedObjectArray(b3Vector3);

    Constructor :: (this: *b3ConvexUtility) -> void #cpp_method #foreign bullet3 "??0b3ConvexUtility@@QEAA@XZ";

    initializePolyhedralFeatures :: (this: *b3ConvexUtility, orgVertices: *b3Vector3, numVertices: s32, mergeCoplanarTriangles := true) -> bool #cpp_method #foreign bullet3 "?initializePolyhedralFeatures@b3ConvexUtility@@QEAA_NPEBVb3Vector3@@H_N@Z";

    initialize :: (this: *b3ConvexUtility) -> void #cpp_method #foreign bullet3 "?initialize@b3ConvexUtility@@QEAAXXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3ConvexUtility, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3ConvexUtility@@UEAA@XZ";
}
b3ConvexUtility_VTable :: struct #type_info_none {
    Destructor: (this: *b3ConvexUtility, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
b3ConvexUtility_Destructor :: inline (this: *b3ConvexUtility, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }




b3ShapeTypes :: enum s32 {
    SHAPE_HEIGHT_FIELD             :: 1;

    SHAPE_CONVEX_HULL              :: 3;
    SHAPE_PLANE                    :: 4;
    SHAPE_CONCAVE_TRIMESH          :: 5;
    SHAPE_COMPOUND_OF_CONVEX_HULLS :: 6;
    SHAPE_SPHERE                   :: 7;
    MAX_NUM_SHAPE_TYPES            :: 8;
}

b3Collidable_t :: b3Collidable;

b3Collidable :: struct {
    union {
        m_numChildShapes: s32;
        m_bvhIndex:       s32;
    }

    union {
        m_radius:           float;
        m_compoundBvhIndex: s32;
    }

    m_shapeType: s32;
    union {
        m_shapeIndex: s32;
        m_height:     float;
    }
}

b3GpuChildShape_t :: b3GpuChildShape;
b3GpuChildShape :: struct {
    m_childPosition:    b3Vector3;
    m_childOrientation: b3Quaternion;
    union {
        m_shapeIndex:  s32; //used for SHAPE_COMPOUND_OF_CONVEX_HULLS
        m_capsuleAxis: s32;
    }

    union {
        m_radius:         float; //used for childshape of SHAPE_COMPOUND_OF_SPHERES or SHAPE_COMPOUND_OF_CAPSULES
        m_numChildShapes: s32; //used for compound shape
    }

    union {
        m_height:               float; //used for childshape of SHAPE_COMPOUND_OF_CAPSULES
        m_collidableShapeIndex: s32;
    }

    m_shapeType:        s32;
}

b3CompoundOverlappingPair :: struct {
    m_bodyIndexA:       s32;
    m_bodyIndexB:       s32;

    //	int	m_pairType;
    m_childShapeIndexA: s32;
    m_childShapeIndexB: s32;
}

b3Aabb_t :: b3Aabb;

b3Aabb :: struct {
    union {
        m_min:        [4] float;
        m_minVec:     b3Vector3;
        m_minIndices: [4] s32;
    }

    union {
        m_max:              [4] float;
        m_maxVec:           b3Vector3;
        m_signedMaxIndices: [4] s32;
    }
}

b3RigidBodyData_t :: b3RigidBodyData;

b3RigidBodyData :: struct {
    m_pos:               b3Vector3;
    m_quat:              b3Quaternion;
    m_linVel:            b3Vector3;
    m_angVel:            b3Vector3;

    m_collidableIdx:     s32;
    m_invMass:           float;
    m_restituitionCoeff: float;
    m_frictionCoeff:     float;
}

b3InertiaData_t :: b3InertiaData;

b3InertiaData :: struct {
    m_invInertiaWorld: b3Matrix3x3;
    m_initInvInertia:  b3Matrix3x3;
}

b3CpuNarrowPhase :: struct {
    vtable: *b3CpuNarrowPhase_VTable;
    b3CpuNarrowPhaseInternalData :: struct {}
    m_data:                           *b3CpuNarrowPhaseInternalData;
    m_acceleratedCompanionShapeIndex: s32;
    m_planeBodyIndex:                 s32;
    m_static0Index:                   s32;

    registerConvexHullShapeInternal :: (this: *b3CpuNarrowPhase, convexPtr: *b3ConvexUtility, col: *b3Collidable) -> s32 #cpp_method #foreign bullet3 "?registerConvexHullShapeInternal@b3CpuNarrowPhase@@IEAAHPEAVb3ConvexUtility@@AEAUb3Collidable@@@Z";

    Constructor :: (this: *b3CpuNarrowPhase, config: *b3Config) -> void #cpp_method #foreign bullet3 "??0b3CpuNarrowPhase@@QEAA@AEBUb3Config@@@Z";
    Constructor :: (this: *b3CpuNarrowPhase, config: b3Config) #no_context {
        Constructor(this, *config);
    }

    //do they need to be merged?
    registerConvexHullShape :: (this: *b3CpuNarrowPhase, utilPtr: *b3ConvexUtility) -> s32 #cpp_method #foreign bullet3 "?registerConvexHullShape@b3CpuNarrowPhase@@QEAAHPEAVb3ConvexUtility@@@Z";
    registerConvexHullShape :: (this: *b3CpuNarrowPhase, vertices: *float, strideInBytes: s32, numVertices: s32, scaling: *float) -> s32 #cpp_method #foreign bullet3 "?registerConvexHullShape@b3CpuNarrowPhase@@QEAAHPEBMHH0@Z";

    /*const struct b3Contact4* getContactsCPU() const;
    
    
    int	getNumContactsGpu() const;
    */
    getContacts :: (this: *b3CpuNarrowPhase) -> *b3AlignedObjectArray(b3Contact4Data) #cpp_method #foreign bullet3 "?getContacts@b3CpuNarrowPhase@@QEBAAEBV?$b3AlignedObjectArray@Ub3Contact4Data@@@@XZ";

    allocateCollidable :: (this: *b3CpuNarrowPhase) -> s32 #cpp_method #foreign bullet3 "?allocateCollidable@b3CpuNarrowPhase@@QEAAHXZ";

    getStatic0Index :: (this: *b3CpuNarrowPhase) -> s32 #cpp_method #foreign bullet3 "?getStatic0Index@b3CpuNarrowPhase@@QEBAHXZ";

    getCollidableCpu :: (this: *b3CpuNarrowPhase, collidableIndex: s32) -> *b3Collidable #cpp_method #foreign bullet3 "?getCollidableCpu@b3CpuNarrowPhase@@QEAAAEAUb3Collidable@@H@Z";
    getCollidableCpu_1 :: (this: /*const*/ *b3CpuNarrowPhase, collidableIndex: s32) -> *b3Collidable #cpp_method #foreign bullet3 "?getCollidableCpu@b3CpuNarrowPhase@@QEBAAEBUb3Collidable@@H@Z";

    getInternalData :: (this: *b3CpuNarrowPhase) -> *b3CpuNarrowPhaseInternalData #cpp_method #foreign bullet3 "?getInternalData@b3CpuNarrowPhase@@QEBAPEBUb3CpuNarrowPhaseInternalData@@XZ";

    getLocalSpaceAabb :: (this: *b3CpuNarrowPhase, collidableIndex: s32) -> *b3Aabb #cpp_method #foreign bullet3 "?getLocalSpaceAabb@b3CpuNarrowPhase@@QEBAAEBUb3Aabb@@H@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3CpuNarrowPhase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3CpuNarrowPhase@@UEAA@XZ";

    //virtual void computeContacts(cl_mem broadphasePairs, int numBroadphasePairs, cl_mem aabbsWorldSpace, int numObjects);
    virtual_computeContacts :: (this: *b3CpuNarrowPhase, pairs: *b3AlignedObjectArray(b3Int4), aabbsWorldSpace: *b3AlignedObjectArray(b3Aabb), bodies: *b3AlignedObjectArray(b3RigidBodyData)) -> void #cpp_method #foreign bullet3 "?computeContacts@b3CpuNarrowPhase@@UEAAXAEAV?$b3AlignedObjectArray@Ub3Int4@@@@AEAV?$b3AlignedObjectArray@Ub3Aabb@@@@AEAV?$b3AlignedObjectArray@Ub3RigidBodyData@@@@@Z";
}
b3CpuNarrowPhase_VTable :: struct #type_info_none {
    Destructor: (this: *b3CpuNarrowPhase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    computeContacts: (this: *b3CpuNarrowPhase, pairs: *b3AlignedObjectArray(b3Int4), aabbsWorldSpace: *b3AlignedObjectArray(b3Aabb), bodies: *b3AlignedObjectArray(b3RigidBodyData)) -> void #cpp_method;
}

b3CpuNarrowPhase_Destructor :: inline (this: *b3CpuNarrowPhase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3CpuNarrowPhase_computeContacts :: inline (this: *b3CpuNarrowPhase, pairs: *b3AlignedObjectArray(b3Int4), aabbsWorldSpace: *b3AlignedObjectArray(b3Aabb), bodies: *b3AlignedObjectArray(b3RigidBodyData)) { this.vtable.computeContacts(this, pairs, aabbsWorldSpace, bodies); }



b3SolverMode :: enum s32 {
    RANDMIZE_ORDER                                :: 1;
    FRICTION_SEPARATE                             :: 2;
    USE_WARMSTARTING                              :: 4;
    USE_2_FRICTION_DIRECTIONS                     :: 16;
    ENABLE_FRICTION_DIRECTION_CACHING             :: 32;
    DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION :: 64;
    CACHE_FRIENDLY                                :: 128;
    SIMD                                          :: 256;
    INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS   :: 512;
    ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS         :: 1024;

    B3_SOLVER_RANDMIZE_ORDER                                :: RANDMIZE_ORDER;
    B3_SOLVER_FRICTION_SEPARATE                             :: FRICTION_SEPARATE;
    B3_SOLVER_USE_WARMSTARTING                              :: USE_WARMSTARTING;
    B3_SOLVER_USE_2_FRICTION_DIRECTIONS                     :: USE_2_FRICTION_DIRECTIONS;
    B3_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING             :: ENABLE_FRICTION_DIRECTION_CACHING;
    B3_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION :: DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
    B3_SOLVER_CACHE_FRIENDLY                                :: CACHE_FRIENDLY;
    B3_SOLVER_SIMD                                          :: SIMD;
    B3_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS   :: INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
    B3_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS         :: ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
}

b3ContactSolverInfoData :: struct {
    m_tau:                                b3Scalar;
    m_damping:                            b3Scalar; //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
    m_friction:                           b3Scalar;
    m_timeStep:                           b3Scalar;
    m_restitution:                        b3Scalar;
    m_numIterations:                      s32;
    m_maxErrorReduction:                  b3Scalar;
    m_sor:                                b3Scalar;
    m_erp:                                b3Scalar; //used as Baumgarte factor
    m_erp2:                               b3Scalar; //used in Split Impulse
    m_globalCfm:                          b3Scalar; //constraint force mixing
    m_splitImpulse:                       s32;
    m_splitImpulsePenetrationThreshold:   b3Scalar;
    m_splitImpulseTurnErp:                b3Scalar;
    m_linearSlop:                         b3Scalar;
    m_warmstartingFactor:                 b3Scalar;

    m_solverMode:                         s32;
    m_restingContactRestitutionThreshold: s32;
    m_minimumSolverBatchSize:             s32;
    m_maxGyroscopicForce:                 b3Scalar;
    m_singleAxisRollingFrictionThreshold: b3Scalar;
}

b3ContactSolverInfo :: struct {
    #as using b3contactsolverinfodata: b3ContactSolverInfoData;

    Constructor :: (this: *b3ContactSolverInfo) -> void #cpp_method #foreign bullet3 "??0b3ContactSolverInfo@@QEAA@XZ";
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
b3ContactSolverInfoDoubleData :: struct {
    m_tau:                                float64;
    m_damping:                            float64; //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
    m_friction:                           float64;
    m_timeStep:                           float64;
    m_restitution:                        float64;
    m_maxErrorReduction:                  float64;
    m_sor:                                float64;
    m_erp:                                float64; //used as Baumgarte factor
    m_erp2:                               float64; //used in Split Impulse
    m_globalCfm:                          float64; //constraint force mixing
    m_splitImpulsePenetrationThreshold:   float64;
    m_splitImpulseTurnErp:                float64;
    m_linearSlop:                         float64;
    m_warmstartingFactor:                 float64;
    m_maxGyroscopicForce:                 float64;
    m_singleAxisRollingFrictionThreshold: float64;

    m_numIterations:                      s32;
    m_solverMode:                         s32;
    m_restingContactRestitutionThreshold: s32;
    m_minimumSolverBatchSize:             s32;
    m_splitImpulse:                       s32;
    m_padding:                            [4] u8;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
b3ContactSolverInfoFloatData :: struct {
    m_tau:                                float;
    m_damping:                            float; //global non-contact constraint damping, can be locally overridden by constraints during 'getInfo2'.
    m_friction:                           float;
    m_timeStep:                           float;

    m_restitution:                        float;
    m_maxErrorReduction:                  float;
    m_sor:                                float;
    m_erp:                                float; //used as Baumgarte factor

    m_erp2:                               float; //used in Split Impulse
    m_globalCfm:                          float; //constraint force mixing
    m_splitImpulsePenetrationThreshold:   float;
    m_splitImpulseTurnErp:                float;

    m_linearSlop:                         float;
    m_warmstartingFactor:                 float;
    m_maxGyroscopicForce:                 float;
    m_singleAxisRollingFrictionThreshold: float;

    m_numIterations:                      s32;
    m_solverMode:                         s32;
    m_restingContactRestitutionThreshold: s32;
    m_minimumSolverBatchSize:             s32;

    m_splitImpulse:                       s32;
    m_padding:                            [4] u8;
}

///The b3SolverBody is an internal datastructure for the constraint solver. Only necessary data is packed to increase cache coherence/performance.
b3SolverBody :: struct {
    m_worldTransform:       b3Transform;
    m_deltaLinearVelocity:  b3Vector3;
    m_deltaAngularVelocity: b3Vector3;
    m_angularFactor:        b3Vector3;
    m_linearFactor:         b3Vector3;
    m_invMass:              b3Vector3;
    m_pushVelocity:         b3Vector3;
    m_turnVelocity:         b3Vector3;
    m_linearVelocity:       b3Vector3;
    m_angularVelocity:      b3Vector3;

    union {
        m_originalBody:      *void;
        m_originalBodyIndex: s32;
    }

    padding:                [3] s32;

    setWorldTransform :: (this: *b3SolverBody, worldTransform: *b3Transform) -> void #cpp_method #foreign bullet3 "?setWorldTransform@b3SolverBody@@QEAAXAEBVb3Transform@@@Z";
    setWorldTransform :: (this: *b3SolverBody, worldTransform: b3Transform) #no_context {
        setWorldTransform(this, *worldTransform);
    }

    getWorldTransform :: (this: *b3SolverBody) -> *b3Transform #cpp_method #foreign bullet3 "?getWorldTransform@b3SolverBody@@QEBAAEBVb3Transform@@XZ";

    getVelocityInLocalPointObsolete :: (this: *b3SolverBody, rel_pos: *b3Vector3, velocity: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getVelocityInLocalPointObsolete@b3SolverBody@@QEBAXAEBVb3Vector3@@AEAV2@@Z";
    getVelocityInLocalPointObsolete :: (this: *b3SolverBody, rel_pos: b3Vector3, velocity: *b3Vector3) #no_context {
        getVelocityInLocalPointObsolete(this, *rel_pos, velocity);
    }

    getAngularVelocity :: (this: *b3SolverBody, angVel: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getAngularVelocity@b3SolverBody@@QEBAXAEAVb3Vector3@@@Z";

    //Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
    applyImpulse :: (this: *b3SolverBody, linearComponent: *b3Vector3, angularComponent: *b3Vector3, impulseMagnitude: b3Scalar) -> void #cpp_method #foreign bullet3 "?applyImpulse@b3SolverBody@@QEAAXAEBVb3Vector3@@0M@Z";
    applyImpulse :: (this: *b3SolverBody, linearComponent: b3Vector3, angularComponent: b3Vector3, impulseMagnitude: b3Scalar) #no_context {
        applyImpulse(this, *linearComponent, *angularComponent, impulseMagnitude);
    }

    internalApplyPushImpulse :: (this: *b3SolverBody, linearComponent: *b3Vector3, angularComponent: *b3Vector3, impulseMagnitude: b3Scalar) -> void #cpp_method #foreign bullet3 "?internalApplyPushImpulse@b3SolverBody@@QEAAXAEBVb3Vector3@@0M@Z";
    internalApplyPushImpulse :: (this: *b3SolverBody, linearComponent: b3Vector3, angularComponent: b3Vector3, impulseMagnitude: b3Scalar) #no_context {
        internalApplyPushImpulse(this, *linearComponent, *angularComponent, impulseMagnitude);
    }

    getDeltaLinearVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?getDeltaLinearVelocity@b3SolverBody@@QEBAAEBVb3Vector3@@XZ";

    getDeltaAngularVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?getDeltaAngularVelocity@b3SolverBody@@QEBAAEBVb3Vector3@@XZ";

    getPushVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?getPushVelocity@b3SolverBody@@QEBAAEBVb3Vector3@@XZ";

    getTurnVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?getTurnVelocity@b3SolverBody@@QEBAAEBVb3Vector3@@XZ";

    ////////////////////////////////////////////////
    ///some internal methods, don't use them
    internalGetDeltaLinearVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?internalGetDeltaLinearVelocity@b3SolverBody@@QEAAAEAVb3Vector3@@XZ";

    internalGetDeltaAngularVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?internalGetDeltaAngularVelocity@b3SolverBody@@QEAAAEAVb3Vector3@@XZ";

    internalGetAngularFactor :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?internalGetAngularFactor@b3SolverBody@@QEBAAEBVb3Vector3@@XZ";

    internalGetInvMass :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?internalGetInvMass@b3SolverBody@@QEBAAEBVb3Vector3@@XZ";

    internalSetInvMass :: (this: *b3SolverBody, invMass: *b3Vector3) -> void #cpp_method #foreign bullet3 "?internalSetInvMass@b3SolverBody@@QEAAXAEBVb3Vector3@@@Z";
    internalSetInvMass :: (this: *b3SolverBody, invMass: b3Vector3) #no_context {
        internalSetInvMass(this, *invMass);
    }

    internalGetPushVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?internalGetPushVelocity@b3SolverBody@@QEAAAEAVb3Vector3@@XZ";

    internalGetTurnVelocity :: (this: *b3SolverBody) -> *b3Vector3 #cpp_method #foreign bullet3 "?internalGetTurnVelocity@b3SolverBody@@QEAAAEAVb3Vector3@@XZ";

    internalGetVelocityInLocalPointObsolete :: (this: *b3SolverBody, rel_pos: *b3Vector3, velocity: *b3Vector3) -> void #cpp_method #foreign bullet3 "?internalGetVelocityInLocalPointObsolete@b3SolverBody@@QEBAXAEBVb3Vector3@@AEAV2@@Z";
    internalGetVelocityInLocalPointObsolete :: (this: *b3SolverBody, rel_pos: b3Vector3, velocity: *b3Vector3) #no_context {
        internalGetVelocityInLocalPointObsolete(this, *rel_pos, velocity);
    }

    internalGetAngularVelocity :: (this: *b3SolverBody, angVel: *b3Vector3) -> void #cpp_method #foreign bullet3 "?internalGetAngularVelocity@b3SolverBody@@QEBAXAEAVb3Vector3@@@Z";

    //Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position
    internalApplyImpulse :: (this: *b3SolverBody, linearComponent: *b3Vector3, angularComponent: *b3Vector3, impulseMagnitude: b3Scalar) -> void #cpp_method #foreign bullet3 "?internalApplyImpulse@b3SolverBody@@QEAAXAEBVb3Vector3@@0M@Z";
    internalApplyImpulse :: (this: *b3SolverBody, linearComponent: b3Vector3, angularComponent: b3Vector3, impulseMagnitude: b3Scalar) #no_context {
        internalApplyImpulse(this, *linearComponent, *angularComponent, impulseMagnitude);
    }

    writebackVelocity :: (this: *b3SolverBody) -> void #cpp_method #foreign bullet3 "?writebackVelocity@b3SolverBody@@QEAAXXZ";

    writebackVelocityAndTransform :: (this: *b3SolverBody, timeStep: b3Scalar, splitImpulseTurnErp: b3Scalar) -> void #cpp_method #foreign bullet3 "?writebackVelocityAndTransform@b3SolverBody@@QEAAXMM@Z";
}


///1D constraint along a normal axis between bodyA and bodyB. It can be combined to solve contact and friction constraints.
b3SolverConstraint :: struct {
    m_relpos1CrossNormal:          b3Vector3;
    m_contactNormal:               b3Vector3;

    m_relpos2CrossNormal:          b3Vector3;

    //b3Vector3		m_contactNormal2;//usually m_contactNormal2 == -m_contactNormal
    m_angularComponentA:           b3Vector3;
    m_angularComponentB:           b3Vector3;

    m_appliedPushImpulse:          b3Scalar;
    m_appliedImpulse:              b3Scalar;
    m_padding1:                    s32;
    m_padding2:                    s32;
    m_friction:                    b3Scalar;
    m_jacDiagABInv:                b3Scalar;
    m_rhs:                         b3Scalar;
    m_cfm:                         b3Scalar;

    m_lowerLimit:                  b3Scalar;
    m_upperLimit:                  b3Scalar;
    m_rhsPenetration:              b3Scalar;
    union {
        m_originalContactPoint: *void;
        m_unusedPadding4:       b3Scalar;
    }

    m_overrideNumSolverIterations: s32;
    m_frictionIndex:               s32;
    m_solverBodyIdA:               s32;
    m_solverBodyIdB:               s32;

    b3SolverConstraintType :: enum s32 {
        CONTACT_1D  :: 0;
        FRICTION_1D :: 1;

        B3_SOLVER_CONTACT_1D  :: CONTACT_1D;
        B3_SOLVER_FRICTION_1D :: FRICTION_1D;
    }
}


b3ConstraintArray :: b3AlignedObjectArray(b3SolverConstraint);

//Don't change any of the existing enum values, so add enum types at the end for serialization compatibility
b3TypedConstraintType :: enum s32 {
    POINT2POINT_CONSTRAINT_TYPE :: 3;
    HINGE_CONSTRAINT_TYPE       :: 4;
    CONETWIST_CONSTRAINT_TYPE   :: 5;
    D6_CONSTRAINT_TYPE          :: 6;
    SLIDER_CONSTRAINT_TYPE      :: 7;
    CONTACT_CONSTRAINT_TYPE     :: 8;
    D6_SPRING_CONSTRAINT_TYPE   :: 9;
    GEAR_CONSTRAINT_TYPE        :: 10;
    FIXED_CONSTRAINT_TYPE       :: 11;
    MAX_CONSTRAINT_TYPE         :: 12;

    B3_POINT2POINT_CONSTRAINT_TYPE :: POINT2POINT_CONSTRAINT_TYPE;
    B3_HINGE_CONSTRAINT_TYPE       :: HINGE_CONSTRAINT_TYPE;
    B3_CONETWIST_CONSTRAINT_TYPE   :: CONETWIST_CONSTRAINT_TYPE;
    B3_D6_CONSTRAINT_TYPE          :: D6_CONSTRAINT_TYPE;
    B3_SLIDER_CONSTRAINT_TYPE      :: SLIDER_CONSTRAINT_TYPE;
    B3_CONTACT_CONSTRAINT_TYPE     :: CONTACT_CONSTRAINT_TYPE;
    B3_D6_SPRING_CONSTRAINT_TYPE   :: D6_SPRING_CONSTRAINT_TYPE;
    B3_GEAR_CONSTRAINT_TYPE        :: GEAR_CONSTRAINT_TYPE;
    B3_FIXED_CONSTRAINT_TYPE       :: FIXED_CONSTRAINT_TYPE;
    B3_MAX_CONSTRAINT_TYPE         :: MAX_CONSTRAINT_TYPE;
}

b3ConstraintParams :: enum s32 {
    ERP      :: 1;
    STOP_ERP :: 2;
    CFM      :: 3;
    STOP_CFM :: 4;

    B3_CONSTRAINT_ERP      :: ERP;
    B3_CONSTRAINT_STOP_ERP :: STOP_ERP;
    B3_CONSTRAINT_CFM      :: CFM;
    B3_CONSTRAINT_STOP_CFM :: STOP_CFM;
}

b3JointFeedback :: struct {
    m_appliedForceBodyA:  b3Vector3;
    m_appliedTorqueBodyA: b3Vector3;
    m_appliedForceBodyB:  b3Vector3;
    m_appliedTorqueBodyB: b3Vector3;
}

///TypedConstraint is the baseclass for Bullet constraints and vehicles
b3TypedConstraint :: struct {
    #as using b3typedobject: b3TypedObject;
    vtable: *b3TypedConstraint_VTable;

    m_userConstraintType:          s32;

    union {
        m_userConstraintId:  s32;
        m_userConstraintPtr: *void;
    }

    m_breakingImpulseThreshold:    b3Scalar;
    m_isEnabled:                   bool;
    m_needsFeedback:               bool;
    m_overrideNumSolverIterations: s32;

    m_rbA:                         s32;
    m_rbB:                         s32;
    m_appliedImpulse:              b3Scalar;
    m_dbgDrawSize:                 b3Scalar;
    m_jointFeedback:               *b3JointFeedback;

    ///internal method used by the constraint solver, don't use them directly
    getMotorFactor :: (this: *b3TypedConstraint, pos: b3Scalar, lowLim: b3Scalar, uppLim: b3Scalar, vel: b3Scalar, timeFact: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?getMotorFactor@b3TypedConstraint@@IEAAMMMMMM@Z";

    Constructor :: (this: *b3TypedConstraint, type: b3TypedConstraintType, bodyA: s32, bodyB: s32) -> void #cpp_method #foreign bullet3 "??0b3TypedConstraint@@QEAA@W4b3TypedConstraintType@@HH@Z";

    b3ConstraintInfo1 :: struct {
        m_numConstraintRows: s32;
        nub:                 s32;
    }

    b3ConstraintInfo2 :: struct {
        // integrator parameters: frames per second (1/stepsize), default error
        // reduction parameter (0..1).
        fps:               b3Scalar;
        // integrator parameters: frames per second (1/stepsize), default error
        // reduction parameter (0..1).
        erp:               b3Scalar;

        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J1linearAxis:    *b3Scalar;
        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J1angularAxis:   *b3Scalar;
        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J2linearAxis:    *b3Scalar;
        // for the first and second body, pointers to two (linear and angular)
        // n*3 jacobian sub matrices, stored by rows. these matrices will have
        // been initialized to 0 on entry. if the second body is zero then the
        // J2xx pointers may be 0.
        m_J2angularAxis:   *b3Scalar;

        // elements to jump from one row to the next in J's
        rowskip:           s32;

        // right hand sides of the equation J*v = c + cfm * lambda. cfm is the
        // "constraint force mixing" vector. c is set to zero on entry, cfm is
        // set to a constant value (typically very small or zero) value on entry.
        m_constraintError: *b3Scalar;
        // right hand sides of the equation J*v = c + cfm * lambda. cfm is the
        // "constraint force mixing" vector. c is set to zero on entry, cfm is
        // set to a constant value (typically very small or zero) value on entry.
        cfm:               *b3Scalar;

        // lo and hi limits for variables (set to -/+ infinity on entry).
        m_lowerLimit:      *b3Scalar;
        // lo and hi limits for variables (set to -/+ infinity on entry).
        m_upperLimit:      *b3Scalar;

        // findex vector for variables. see the LCP solver interface for a
        // description of what this does. this is set to -1 on entry.
        // note that the returned indexes are relative to the first index of
        // the constraint.
        findex:            *s32;

        // number of solver iterations
        m_numIterations:   s32;

        //damping of the velocity
        m_damping:         b3Scalar;
    }

    getOverrideNumSolverIterations :: (this: *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getOverrideNumSolverIterations@b3TypedConstraint@@QEBAHXZ";

    ///override the number of constraint solver iterations used to solve this constraint
    ///-1 will use the default number of iterations, as specified in SolverInfo.m_numIterations
    setOverrideNumSolverIterations :: (this: *b3TypedConstraint, overideNumIterations: s32) -> void #cpp_method #foreign bullet3 "?setOverrideNumSolverIterations@b3TypedConstraint@@QEAAXH@Z";

    ///internal method used by the constraint solver, don't use them directly
    internalSetAppliedImpulse :: (this: *b3TypedConstraint, appliedImpulse: b3Scalar) -> void #cpp_method #foreign bullet3 "?internalSetAppliedImpulse@b3TypedConstraint@@QEAAXM@Z";

    ///internal method used by the constraint solver, don't use them directly
    internalGetAppliedImpulse :: (this: *b3TypedConstraint) -> b3Scalar #cpp_method #foreign bullet3 "?internalGetAppliedImpulse@b3TypedConstraint@@QEAAMXZ";

    getBreakingImpulseThreshold :: (this: *b3TypedConstraint) -> b3Scalar #cpp_method #foreign bullet3 "?getBreakingImpulseThreshold@b3TypedConstraint@@QEBAMXZ";

    setBreakingImpulseThreshold :: (this: *b3TypedConstraint, threshold: b3Scalar) -> void #cpp_method #foreign bullet3 "?setBreakingImpulseThreshold@b3TypedConstraint@@QEAAXM@Z";

    isEnabled :: (this: *b3TypedConstraint) -> bool #cpp_method #foreign bullet3 "?isEnabled@b3TypedConstraint@@QEBA_NXZ";

    setEnabled :: (this: *b3TypedConstraint, enabled: bool) -> void #cpp_method #foreign bullet3 "?setEnabled@b3TypedConstraint@@QEAAX_N@Z";

    getRigidBodyA :: (this: /*const*/ *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getRigidBodyA@b3TypedConstraint@@QEBAHXZ";

    getRigidBodyB :: (this: /*const*/ *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getRigidBodyB@b3TypedConstraint@@QEBAHXZ";

    getRigidBodyA_1 :: (this: *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getRigidBodyA@b3TypedConstraint@@QEAAHXZ";

    getRigidBodyB_1 :: (this: *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getRigidBodyB@b3TypedConstraint@@QEAAHXZ";

    getUserConstraintType :: (this: *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getUserConstraintType@b3TypedConstraint@@QEBAHXZ";

    setUserConstraintType :: (this: *b3TypedConstraint, userConstraintType: s32) -> void #cpp_method #foreign bullet3 "?setUserConstraintType@b3TypedConstraint@@QEAAXH@Z";

    setUserConstraintId :: (this: *b3TypedConstraint, uid: s32) -> void #cpp_method #foreign bullet3 "?setUserConstraintId@b3TypedConstraint@@QEAAXH@Z";

    getUserConstraintId :: (this: *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getUserConstraintId@b3TypedConstraint@@QEBAHXZ";

    setUserConstraintPtr :: (this: *b3TypedConstraint, ptr: *void) -> void #cpp_method #foreign bullet3 "?setUserConstraintPtr@b3TypedConstraint@@QEAAXPEAX@Z";

    getUserConstraintPtr :: (this: *b3TypedConstraint) -> *void #cpp_method #foreign bullet3 "?getUserConstraintPtr@b3TypedConstraint@@QEAAPEAXXZ";

    setJointFeedback :: (this: *b3TypedConstraint, jointFeedback: *b3JointFeedback) -> void #cpp_method #foreign bullet3 "?setJointFeedback@b3TypedConstraint@@QEAAXPEAUb3JointFeedback@@@Z";

    getJointFeedback :: (this: /*const*/ *b3TypedConstraint) -> *b3JointFeedback #cpp_method #foreign bullet3 "?getJointFeedback@b3TypedConstraint@@QEBAPEBUb3JointFeedback@@XZ";

    getJointFeedback_1 :: (this: *b3TypedConstraint) -> *b3JointFeedback #cpp_method #foreign bullet3 "?getJointFeedback@b3TypedConstraint@@QEAAPEAUb3JointFeedback@@XZ";

    getUid :: (this: *b3TypedConstraint) -> s32 #cpp_method #foreign bullet3 "?getUid@b3TypedConstraint@@QEBAHXZ";

    needsFeedback :: (this: *b3TypedConstraint) -> bool #cpp_method #foreign bullet3 "?needsFeedback@b3TypedConstraint@@QEBA_NXZ";

    ///enableFeedback will allow to read the applied linear and angular impulse
    ///use getAppliedImpulse, getAppliedLinearImpulse and getAppliedAngularImpulse to read feedback information
    enableFeedback :: (this: *b3TypedConstraint, needsFeedback: bool) -> void #cpp_method #foreign bullet3 "?enableFeedback@b3TypedConstraint@@QEAAX_N@Z";

    ///getAppliedImpulse is an estimated total applied impulse.
    ///This feedback could be used to determine breaking constraints or playing sounds.
    getAppliedImpulse :: (this: *b3TypedConstraint) -> b3Scalar #cpp_method #foreign bullet3 "?getAppliedImpulse@b3TypedConstraint@@QEBAMXZ";

    getConstraintType :: (this: *b3TypedConstraint) -> b3TypedConstraintType #cpp_method #foreign bullet3 "?getConstraintType@b3TypedConstraint@@QEBA?AW4b3TypedConstraintType@@XZ";

    setDbgDrawSize :: (this: *b3TypedConstraint, dbgDrawSize: b3Scalar) -> void #cpp_method #foreign bullet3 "?setDbgDrawSize@b3TypedConstraint@@QEAAXM@Z";

    getDbgDrawSize :: (this: *b3TypedConstraint) -> b3Scalar #cpp_method #foreign bullet3 "?getDbgDrawSize@b3TypedConstraint@@QEAAMXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3TypedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3TypedConstraint@@UEAA@XZ";

    ///internal method used by the constraint solver, don't use them directly
    virtual_setupSolverConstraint :: (this: *b3TypedConstraint, ca: *b3ConstraintArray, solverBodyA: s32, solverBodyB: s32, timeStep: b3Scalar) -> void #cpp_method #foreign bullet3 "?setupSolverConstraint@b3TypedConstraint@@UEAAXAEAV?$b3AlignedObjectArray@Ub3SolverConstraint@@@@HHM@Z";

    ///internal method used by the constraint solver, don't use them directly
    virtual_solveConstraintObsolete :: (this: *b3TypedConstraint, unknown0: *b3SolverBody, unknown1: *b3SolverBody, unknown2: b3Scalar) -> void #cpp_method #foreign bullet3 "?solveConstraintObsolete@b3TypedConstraint@@UEAAXAEAUb3SolverBody@@0M@Z";
}
b3TypedConstraint_VTable :: struct #type_info_none {
    Destructor: (this: *b3TypedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    setupSolverConstraint: (this: *b3TypedConstraint, ca: *b3ConstraintArray, solverBodyA: s32, solverBodyB: s32, timeStep: b3Scalar) -> void #cpp_method;

    getInfo1: (this: *b3TypedConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) -> void #cpp_method;

    getInfo2: (this: *b3TypedConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, bodies: *b3RigidBodyData) -> void #cpp_method;

    solveConstraintObsolete: (this: *b3TypedConstraint, unknown0: *b3SolverBody, unknown1: *b3SolverBody, unknown2: b3Scalar) -> void #cpp_method;

    setParam: (this: *b3TypedConstraint, num: s32, value: b3Scalar, axis: s32 = -1) -> void #cpp_method;

    getParam: (this: *b3TypedConstraint, num: s32, axis: s32 = -1) -> b3Scalar #cpp_method;
}

b3TypedConstraint_Destructor :: inline (this: *b3TypedConstraint, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3TypedConstraint_setupSolverConstraint :: inline (this: *b3TypedConstraint, ca: *b3ConstraintArray, solverBodyA: s32, solverBodyB: s32, timeStep: b3Scalar) { this.vtable.setupSolverConstraint(this, ca, solverBodyA, solverBodyB, timeStep); }

b3TypedConstraint_getInfo1 :: inline (this: *b3TypedConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) { this.vtable.getInfo1(this, info, bodies); }

b3TypedConstraint_getInfo2 :: inline (this: *b3TypedConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, bodies: *b3RigidBodyData) { this.vtable.getInfo2(this, info, bodies); }

b3TypedConstraint_solveConstraintObsolete :: inline (this: *b3TypedConstraint, unknown0: *b3SolverBody, unknown1: *b3SolverBody, unknown2: b3Scalar) { this.vtable.solveConstraintObsolete(this, unknown0, unknown1, unknown2); }

b3TypedConstraint_setParam :: inline (this: *b3TypedConstraint, num: s32, value: b3Scalar, axis: s32 = -1) { this.vtable.setParam(this, num, value, axis); }

b3TypedConstraint_getParam :: inline (this: *b3TypedConstraint, num: s32, axis: s32 = -1) -> b3Scalar { return this.vtable.getParam(this, num, axis); }



operator_assign :: (this: *b3TypedConstraint, other: *b3TypedConstraint) -> *b3TypedConstraint #cpp_method #foreign bullet3 "??4b3TypedConstraint@@AEAAAEAV0@AEAV0@@Z";


// clang-format off
///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
b3TypedConstraintData :: struct {
    m_bodyA:                                s32;
    m_bodyB:                                s32;
    m_name:                                 *u8;

    m_objectType:                           s32;
    m_userConstraintType:                   s32;
    m_userConstraintId:                     s32;
    m_needsFeedback:                        s32;

    m_appliedImpulse:                       float;
    m_dbgDrawSize:                          float;

    m_disableCollisionsBetweenLinkedBodies: s32;
    m_overrideNumSolverIterations:          s32;

    m_breakingImpulseThreshold:             float;
    m_isEnabled:                            s32;
}

/*B3_FORCE_INLINE	int	b3TypedConstraint::calculateSerializeBufferSize() const
{
return sizeof(b3TypedConstraintData);
}
*/
b3AngularLimit :: struct {
    m_center:           b3Scalar;
    m_halfRange:        b3Scalar;
    m_softness:         b3Scalar;
    m_biasFactor:       b3Scalar;
    m_relaxationFactor: b3Scalar;
    m_correction:       b3Scalar;
    m_sign:             b3Scalar;

    m_solveLimit:       bool;

    /// Default constructor initializes limit as inactive, allowing free constraint movement
    Constructor :: (this: *b3AngularLimit) -> void #cpp_method #foreign bullet3 "??0b3AngularLimit@@QEAA@XZ";

    /// Sets all limit's parameters.
    /// When low > high limit becomes inactive.
    /// When high - low > 2PI limit is ineffective too becouse no angle can exceed the limit
    set :: (this: *b3AngularLimit, low: b3Scalar, high: b3Scalar, _softness: b3Scalar = 0.9, _biasFactor: b3Scalar = 0.3, _relaxationFactor: b3Scalar = 1.0) -> void #cpp_method #foreign bullet3 "?set@b3AngularLimit@@QEAAXMMMMM@Z";

    /// Checks conastaint angle against limit. If limit is active and the angle violates the limit
    /// correction is calculated.
    test :: (this: *b3AngularLimit, angle: b3Scalar) -> void #cpp_method #foreign bullet3 "?test@b3AngularLimit@@QEAAXM@Z";

    /// Returns limit's softness
    getSoftness :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getSoftness@b3AngularLimit@@QEBAMXZ";

    /// Returns limit's bias factor
    getBiasFactor :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getBiasFactor@b3AngularLimit@@QEBAMXZ";

    /// Returns limit's relaxation factor
    getRelaxationFactor :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getRelaxationFactor@b3AngularLimit@@QEBAMXZ";

    /// Returns correction value evaluated when test() was invoked
    getCorrection :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getCorrection@b3AngularLimit@@QEBAMXZ";

    /// Returns sign value evaluated when test() was invoked
    getSign :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getSign@b3AngularLimit@@QEBAMXZ";

    /// Gives half of the distance between min and max limit angle
    getHalfRange :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getHalfRange@b3AngularLimit@@QEBAMXZ";

    /// Returns true when the last test() invocation recognized limit violation
    isLimit :: (this: *b3AngularLimit) -> bool #cpp_method #foreign bullet3 "?isLimit@b3AngularLimit@@QEBA_NXZ";

    /// Checks given angle against limit. If limit is active and angle doesn't fit it, the angle
    /// returned is modified so it equals to the limit closest to given angle.
    fit :: (this: *b3AngularLimit, angle: *b3Scalar) -> void #cpp_method #foreign bullet3 "?fit@b3AngularLimit@@QEBAXAEAM@Z";

    /// Returns correction value multiplied by sign value
    getError :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getError@b3AngularLimit@@QEBAMXZ";

    getLow :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getLow@b3AngularLimit@@QEBAMXZ";

    getHigh :: (this: *b3AngularLimit) -> b3Scalar #cpp_method #foreign bullet3 "?getHigh@b3AngularLimit@@QEBAMXZ";
}

b3FixedConstraint :: struct {
    #as using b3typedconstraint: b3TypedConstraint;

    m_pivotInA:    b3Vector3;
    m_pivotInB:    b3Vector3;
    m_relTargetAB: b3Quaternion;

    Constructor :: (this: *b3FixedConstraint, rbA: s32, rbB: s32, frameInA: *b3Transform, frameInB: *b3Transform) -> void #cpp_method #foreign bullet3 "??0b3FixedConstraint@@QEAA@HHAEBVb3Transform@@0@Z";
    Constructor :: (this: *b3FixedConstraint, rbA: s32, rbB: s32, frameInA: b3Transform, frameInB: b3Transform) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *b3FixedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3FixedConstraint@@UEAA@XZ";

    virtual_getInfo1 :: (this: *b3FixedConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo1@b3FixedConstraint@@UEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    virtual_getInfo2 :: (this: *b3FixedConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo2@b3FixedConstraint@@UEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    virtual_setParam :: (this: *b3FixedConstraint, num: s32, value: b3Scalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@b3FixedConstraint@@UEAAXHMH@Z";

    virtual_getParam :: (this: *b3FixedConstraint, num: s32, axis: s32 = -1) -> b3Scalar #cpp_method #foreign bullet3 "?getParam@b3FixedConstraint@@UEBAMHH@Z";
}

/// Jacobian entry is an abstraction that allows to describe constraints
/// it can be used in combination with a constraint solver
/// Can be used to relate the effect of an impulse to the constraint error
b3JacobianEntry :: struct {
    Constructor :: (this: *b3JacobianEntry) -> void #cpp_method #foreign bullet3 "??0b3JacobianEntry@@QEAA@XZ";

    //constraint between two different rigidbodies
    Constructor :: (this: *b3JacobianEntry, world2A: *b3Matrix3x3, world2B: *b3Matrix3x3, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3, jointAxis: *b3Vector3, inertiaInvA: *b3Vector3, massInvA: b3Scalar, inertiaInvB: *b3Vector3, massInvB: b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3JacobianEntry@@QEAA@AEBVb3Matrix3x3@@0AEBVb3Vector3@@111M1M@Z";
    Constructor :: (this: *b3JacobianEntry, world2A: b3Matrix3x3, world2B: b3Matrix3x3, rel_pos1: b3Vector3, rel_pos2: b3Vector3, jointAxis: b3Vector3, inertiaInvA: b3Vector3, massInvA: b3Scalar, inertiaInvB: b3Vector3, massInvB: b3Scalar) #no_context {
        Constructor(this, *world2A, *world2B, *rel_pos1, *rel_pos2, *jointAxis, *inertiaInvA, massInvA, *inertiaInvB, massInvB);
    }

    //angular constraint between two different rigidbodies
    Constructor :: (this: *b3JacobianEntry, jointAxis: *b3Vector3, world2A: *b3Matrix3x3, world2B: *b3Matrix3x3, inertiaInvA: *b3Vector3, inertiaInvB: *b3Vector3) -> void #cpp_method #foreign bullet3 "??0b3JacobianEntry@@QEAA@AEBVb3Vector3@@AEBVb3Matrix3x3@@100@Z";
    Constructor :: (this: *b3JacobianEntry, jointAxis: b3Vector3, world2A: b3Matrix3x3, world2B: b3Matrix3x3, inertiaInvA: b3Vector3, inertiaInvB: b3Vector3) #no_context {
        Constructor(this, *jointAxis, *world2A, *world2B, *inertiaInvA, *inertiaInvB);
    }

    //angular constraint between two different rigidbodies
    Constructor :: (this: *b3JacobianEntry, axisInA: *b3Vector3, axisInB: *b3Vector3, inertiaInvA: *b3Vector3, inertiaInvB: *b3Vector3) -> void #cpp_method #foreign bullet3 "??0b3JacobianEntry@@QEAA@AEBVb3Vector3@@000@Z";
    Constructor :: (this: *b3JacobianEntry, axisInA: b3Vector3, axisInB: b3Vector3, inertiaInvA: b3Vector3, inertiaInvB: b3Vector3) #no_context {
        Constructor(this, *axisInA, *axisInB, *inertiaInvA, *inertiaInvB);
    }

    //constraint on one rigidbody
    Constructor :: (this: *b3JacobianEntry, world2A: *b3Matrix3x3, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3, jointAxis: *b3Vector3, inertiaInvA: *b3Vector3, massInvA: b3Scalar) -> void #cpp_method #foreign bullet3 "??0b3JacobianEntry@@QEAA@AEBVb3Matrix3x3@@AEBVb3Vector3@@111M@Z";
    Constructor :: (this: *b3JacobianEntry, world2A: b3Matrix3x3, rel_pos1: b3Vector3, rel_pos2: b3Vector3, jointAxis: b3Vector3, inertiaInvA: b3Vector3, massInvA: b3Scalar) #no_context {
        Constructor(this, *world2A, *rel_pos1, *rel_pos2, *jointAxis, *inertiaInvA, massInvA);
    }

    getDiagonal :: (this: *b3JacobianEntry) -> b3Scalar #cpp_method #foreign bullet3 "?getDiagonal@b3JacobianEntry@@QEBAMXZ";

    // for two constraints on the same rigidbody (for example vehicle friction)
    getNonDiagonal :: (this: *b3JacobianEntry, jacB: *b3JacobianEntry, massInvA: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?getNonDiagonal@b3JacobianEntry@@QEBAMAEBV1@M@Z";
    getNonDiagonal :: (this: *b3JacobianEntry, jacB: b3JacobianEntry, massInvA: b3Scalar) -> b3Scalar #no_context {
        return getNonDiagonal(this, *jacB, massInvA);
    }

    // for two constraints on sharing two same rigidbodies (for example two contact points between two rigidbodies)
    getNonDiagonal :: (this: *b3JacobianEntry, jacB: *b3JacobianEntry, massInvA: b3Scalar, massInvB: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?getNonDiagonal@b3JacobianEntry@@QEBAMAEBV1@MM@Z";
    getNonDiagonal :: (this: *b3JacobianEntry, jacB: b3JacobianEntry, massInvA: b3Scalar, massInvB: b3Scalar) -> b3Scalar #no_context {
        return getNonDiagonal(this, *jacB, massInvA, massInvB);
    }

    getRelativeVelocity :: (this: *b3JacobianEntry, linvelA: *b3Vector3, angvelA: *b3Vector3, linvelB: *b3Vector3, angvelB: *b3Vector3) -> b3Scalar #cpp_method #foreign bullet3 "?getRelativeVelocity@b3JacobianEntry@@QEAAMAEBVb3Vector3@@000@Z";
    getRelativeVelocity :: (this: *b3JacobianEntry, linvelA: b3Vector3, angvelA: b3Vector3, linvelB: b3Vector3, angvelB: b3Vector3) -> b3Scalar #no_context {
        return getRelativeVelocity(this, *linvelA, *angvelA, *linvelB, *angvelB);
    }

    //private:
    m_linearJointAxis: b3Vector3;
    m_aJ:              b3Vector3;
    m_bJ:              b3Vector3;
    m_0MinvJt:         b3Vector3;
    m_1MinvJt:         b3Vector3;

    //Optimization: can be stored in the w/last component of one of the vectors
    m_Adiag:           b3Scalar;
}

//! Rotation Limit structure for generic joints
b3RotationalLimitMotor :: struct {
    m_loLimit:            b3Scalar; //!< joint limit
    m_hiLimit:            b3Scalar; //!< joint limit
    m_targetVelocity:     b3Scalar; //!< target motor velocity
    m_maxMotorForce:      b3Scalar; //!< max force on motor
    m_maxLimitForce:      b3Scalar; //!< max force on limit
    m_damping:            b3Scalar; //!< Damping.
    m_limitSoftness:      b3Scalar;
    m_normalCFM:          b3Scalar; //!< Constraint force mixing factor
    m_stopERP:            b3Scalar; //!< Error tolerance factor when joint is at limit
    m_stopCFM:            b3Scalar; //!< Constraint force mixing factor when joint is at limit
    m_bounce:             b3Scalar; //!< restitution factor
    m_enableMotor:        bool;

    //! temp_variables
    //!@{
    m_currentLimitError:  b3Scalar;
    //!  How much is violated this limit
    m_currentPosition:    b3Scalar;
    m_currentLimit:       s32; //!< 0=free, 1=at lo limit, 2=at hi limit
    m_accumulatedImpulse: b3Scalar;

    //!@}
    Constructor :: (this: *b3RotationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0b3RotationalLimitMotor@@QEAA@XZ";

    CopyConstructor :: (this: *b3RotationalLimitMotor, limot: *b3RotationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0b3RotationalLimitMotor@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *b3RotationalLimitMotor, limot: b3RotationalLimitMotor) #no_context {
        CopyConstructor(this, *limot);
    }

    //! Is limited
    isLimited :: (this: *b3RotationalLimitMotor) -> bool #cpp_method #foreign bullet3 "?isLimited@b3RotationalLimitMotor@@QEAA_NXZ";

    //! Need apply correction
    needApplyTorques :: (this: *b3RotationalLimitMotor) -> bool #cpp_method #foreign bullet3 "?needApplyTorques@b3RotationalLimitMotor@@QEAA_NXZ";

    //! calculates  error
    /*!
    calculates m_currentLimit and m_currentLimitError.
    */
    testLimitValue :: (this: *b3RotationalLimitMotor, test_value: b3Scalar) -> s32 #cpp_method #foreign bullet3 "?testLimitValue@b3RotationalLimitMotor@@QEAAHM@Z";
}

b3TranslationalLimitMotor :: struct {
    m_lowerLimit:         b3Vector3; //!< the constraint lower limits
    m_upperLimit:         b3Vector3; //!< the constraint upper limits
    m_accumulatedImpulse: b3Vector3;

    m_normalCFM:          b3Vector3; //!< Constraint force mixing factor
    m_stopERP:            b3Vector3; //!< Error tolerance factor when joint is at limit
    m_stopCFM:            b3Vector3; //!< Constraint force mixing factor when joint is at limit
    m_targetVelocity:     b3Vector3; //!< target motor velocity
    m_maxMotorForce:      b3Vector3; //!< max force on motor
    m_currentLimitError:  b3Vector3;
    //!  How much is violated this limit
    m_currentLinearDiff:  b3Vector3;
    m_limitSoftness:      b3Scalar; //!< Softness for linear limit
    m_damping:            b3Scalar; //!< Damping for linear limit
    m_restitution:        b3Scalar;

    //! Bounce parameter for linear limit
    //!@}
    m_enableMotor:        [3] bool;
    m_currentLimit:       [3] s32; //!< 0=free, 1=at lower limit, 2=at upper limit

    Constructor :: (this: *b3TranslationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0b3TranslationalLimitMotor@@QEAA@XZ";

    CopyConstructor :: (this: *b3TranslationalLimitMotor, other: *b3TranslationalLimitMotor) -> void #cpp_method #foreign bullet3 "??0b3TranslationalLimitMotor@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *b3TranslationalLimitMotor, other: b3TranslationalLimitMotor) #no_context {
        CopyConstructor(this, *other);
    }

    //! Test limit
    /*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
    isLimited :: (this: *b3TranslationalLimitMotor, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?isLimited@b3TranslationalLimitMotor@@QEAA_NH@Z";

    needApplyForce :: (this: *b3TranslationalLimitMotor, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?needApplyForce@b3TranslationalLimitMotor@@QEAA_NH@Z";

    testLimitValue :: (this: *b3TranslationalLimitMotor, limitIndex: s32, test_value: b3Scalar) -> s32 #cpp_method #foreign bullet3 "?testLimitValue@b3TranslationalLimitMotor@@QEAAHHM@Z";
}

b36DofFlags :: enum s32 {
    CFM_NORM :: 1;
    CFM_STOP :: 2;
    ERP_STOP :: 4;

    B3_6DOF_FLAGS_CFM_NORM :: CFM_NORM;
    B3_6DOF_FLAGS_CFM_STOP :: CFM_STOP;
    B3_6DOF_FLAGS_ERP_STOP :: ERP_STOP;
}

/// b3Generic6DofConstraint between two rigidbodies each with a pivotpoint that descibes the axis location in local space
/*!
b3Generic6DofConstraint can leave any of the 6 degree of freedom 'free' or 'locked'.
currently this limit supports rotational motors<br>
<ul>
<li> For Linear limits, use b3Generic6DofConstraint.setLinearUpperLimit, b3Generic6DofConstraint.setLinearLowerLimit. You can set the parameters with the b3TranslationalLimitMotor structure accsesible through the b3Generic6DofConstraint.getTranslationalLimitMotor method.
At this moment translational motors are not supported. May be in the future. </li>

<li> For Angular limits, use the b3RotationalLimitMotor structure for configuring the limit.
This is accessible through b3Generic6DofConstraint.getLimitMotor method,
This brings support for limit parameters and motors. </li>

<li> Angulars limits have these possible ranges:
<table border=1 >
<tr>
<td><b>AXIS</b></td>
<td><b>MIN ANGLE</b></td>
<td><b>MAX ANGLE</b></td>
</tr><tr>
<td>X</td>
<td>-PI</td>
<td>PI</td>
</tr><tr>
<td>Y</td>
<td>-PI/2</td>
<td>PI/2</td>
</tr><tr>
<td>Z</td>
<td>-PI</td>
<td>PI</td>
</tr>
</table>
</li>
</ul>

*/
b3Generic6DofConstraint :: struct {
    #as using b3typedconstraint: b3TypedConstraint;

    m_frameInA:                    b3Transform; //!< the constraint space w.r.t body A
    m_frameInB:                    b3Transform; //!< the constraint space w.r.t body B

    //! Linear_Limit_parameters
    //!@{
    m_linearLimits:                b3TranslationalLimitMotor;

    //! hinge_parameters
    //!@{
    m_angularLimits:               [3] b3RotationalLimitMotor;

    //! temporal variables
    //!@{
    m_calculatedTransformA:        b3Transform;
    m_calculatedTransformB:        b3Transform;
    m_calculatedAxisAngleDiff:     b3Vector3;
    m_calculatedAxis:              [3] b3Vector3;
    m_calculatedLinearDiff:        b3Vector3;
    m_timeStep:                    b3Scalar;
    m_factA:                       b3Scalar;
    m_factB:                       b3Scalar;
    m_hasStaticBody:               bool;

    m_AnchorPos:                   b3Vector3 #align 3; // point betwen pivots of bodies A and B to solve linear axes

    m_useLinearReferenceFrameA:    bool;
    m_useOffsetForConstraintFrame: bool;

    m_flags:                       s32;

    setAngularLimits :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, row_offset: s32, transA: *b3Transform, transB: *b3Transform, linVelA: *b3Vector3, linVelB: *b3Vector3, angVelA: *b3Vector3, angVelB: *b3Vector3) -> s32 #cpp_method #foreign bullet3 "?setAngularLimits@b3Generic6DofConstraint@@IEAAHPEAUb3ConstraintInfo2@b3TypedConstraint@@HAEBVb3Transform@@1AEBVb3Vector3@@222@Z";
    setAngularLimits :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, row_offset: s32, transA: b3Transform, transB: b3Transform, linVelA: b3Vector3, linVelB: b3Vector3, angVelA: b3Vector3, angVelB: b3Vector3) -> s32 #no_context {
        return setAngularLimits(this, info, row_offset, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }

    setLinearLimits :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, row: s32, transA: *b3Transform, transB: *b3Transform, linVelA: *b3Vector3, linVelB: *b3Vector3, angVelA: *b3Vector3, angVelB: *b3Vector3) -> s32 #cpp_method #foreign bullet3 "?setLinearLimits@b3Generic6DofConstraint@@IEAAHPEAUb3ConstraintInfo2@b3TypedConstraint@@HAEBVb3Transform@@1AEBVb3Vector3@@222@Z";
    setLinearLimits :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, row: s32, transA: b3Transform, transB: b3Transform, linVelA: b3Vector3, linVelB: b3Vector3, angVelA: b3Vector3, angVelB: b3Vector3) -> s32 #no_context {
        return setLinearLimits(this, info, row, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB);
    }

    // tests linear limits
    calculateLinearInfo :: (this: *b3Generic6DofConstraint) -> void #cpp_method #foreign bullet3 "?calculateLinearInfo@b3Generic6DofConstraint@@IEAAXXZ";

    //! calcs the euler angles between the two bodies.
    calculateAngleInfo :: (this: *b3Generic6DofConstraint) -> void #cpp_method #foreign bullet3 "?calculateAngleInfo@b3Generic6DofConstraint@@IEAAXXZ";

    Constructor :: (this: *b3Generic6DofConstraint, rbA: s32, rbB: s32, frameInA: *b3Transform, frameInB: *b3Transform, useLinearReferenceFrameA: bool, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "??0b3Generic6DofConstraint@@QEAA@HHAEBVb3Transform@@0_NPEBUb3RigidBodyData@@@Z";
    Constructor :: (this: *b3Generic6DofConstraint, rbA: s32, rbB: s32, frameInA: b3Transform, frameInB: b3Transform, useLinearReferenceFrameA: bool, bodies: *b3RigidBodyData) #no_context {
        Constructor(this, rbA, rbB, *frameInA, *frameInB, useLinearReferenceFrameA, bodies);
    }

    //! Calcs global transform of the offsets
    /*!
    Calcs the global transform for the joint offset for body A an B, and also calcs the agle differences between the bodies.
    \sa b3Generic6DofConstraint.getCalculatedTransformA , b3Generic6DofConstraint.getCalculatedTransformB, b3Generic6DofConstraint.calculateAngleInfo
    */
    calculateTransforms :: (this: *b3Generic6DofConstraint, transA: *b3Transform, transB: *b3Transform, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?calculateTransforms@b3Generic6DofConstraint@@QEAAXAEBVb3Transform@@0PEBUb3RigidBodyData@@@Z";
    calculateTransforms :: (this: *b3Generic6DofConstraint, transA: b3Transform, transB: b3Transform, bodies: *b3RigidBodyData) #no_context {
        calculateTransforms(this, *transA, *transB, bodies);
    }

    calculateTransforms :: (this: *b3Generic6DofConstraint, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?calculateTransforms@b3Generic6DofConstraint@@QEAAXPEBUb3RigidBodyData@@@Z";

    //! Gets the global transform of the offset for body A
    /*!
    \sa b3Generic6DofConstraint.getFrameOffsetA, b3Generic6DofConstraint.getFrameOffsetB, b3Generic6DofConstraint.calculateAngleInfo.
    */
    getCalculatedTransformA :: (this: *b3Generic6DofConstraint) -> *b3Transform #cpp_method #foreign bullet3 "?getCalculatedTransformA@b3Generic6DofConstraint@@QEBAAEBVb3Transform@@XZ";

    //! Gets the global transform of the offset for body B
    /*!
    \sa b3Generic6DofConstraint.getFrameOffsetA, b3Generic6DofConstraint.getFrameOffsetB, b3Generic6DofConstraint.calculateAngleInfo.
    */
    getCalculatedTransformB :: (this: *b3Generic6DofConstraint) -> *b3Transform #cpp_method #foreign bullet3 "?getCalculatedTransformB@b3Generic6DofConstraint@@QEBAAEBVb3Transform@@XZ";

    getFrameOffsetA :: (this: /*const*/ *b3Generic6DofConstraint) -> *b3Transform #cpp_method #foreign bullet3 "?getFrameOffsetA@b3Generic6DofConstraint@@QEBAAEBVb3Transform@@XZ";

    getFrameOffsetB :: (this: /*const*/ *b3Generic6DofConstraint) -> *b3Transform #cpp_method #foreign bullet3 "?getFrameOffsetB@b3Generic6DofConstraint@@QEBAAEBVb3Transform@@XZ";

    getFrameOffsetA_1 :: (this: *b3Generic6DofConstraint) -> *b3Transform #cpp_method #foreign bullet3 "?getFrameOffsetA@b3Generic6DofConstraint@@QEAAAEAVb3Transform@@XZ";

    getFrameOffsetB_1 :: (this: *b3Generic6DofConstraint) -> *b3Transform #cpp_method #foreign bullet3 "?getFrameOffsetB@b3Generic6DofConstraint@@QEAAAEAVb3Transform@@XZ";

    getInfo1NonVirtual :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@b3Generic6DofConstraint@@QEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    getInfo2NonVirtual :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, transA: *b3Transform, transB: *b3Transform, linVelA: *b3Vector3, linVelB: *b3Vector3, angVelA: *b3Vector3, angVelB: *b3Vector3, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@b3Generic6DofConstraint@@QEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@AEBVb3Transform@@1AEBVb3Vector3@@222PEBUb3RigidBodyData@@@Z";
    getInfo2NonVirtual :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, transA: b3Transform, transB: b3Transform, linVelA: b3Vector3, linVelB: b3Vector3, angVelA: b3Vector3, angVelB: b3Vector3, bodies: *b3RigidBodyData) #no_context {
        getInfo2NonVirtual(this, info, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB, bodies);
    }

    updateRHS :: (this: *b3Generic6DofConstraint, timeStep: b3Scalar) -> void #cpp_method #foreign bullet3 "?updateRHS@b3Generic6DofConstraint@@QEAAXM@Z";

    //! Get the rotation axis in global coordinates
    getAxis :: (this: *b3Generic6DofConstraint, axis_index: s32) -> b3Vector3 #cpp_method #foreign bullet3 "?getAxis@b3Generic6DofConstraint@@QEBA?AVb3Vector3@@H@Z";

    //! Get the relative Euler angle
    /*!
    \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    */
    getAngle :: (this: *b3Generic6DofConstraint, axis_index: s32) -> b3Scalar #cpp_method #foreign bullet3 "?getAngle@b3Generic6DofConstraint@@QEBAMH@Z";

    //! Get the relative position of the constraint pivot
    /*!
    \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    */
    getRelativePivotPosition :: (this: *b3Generic6DofConstraint, axis_index: s32) -> b3Scalar #cpp_method #foreign bullet3 "?getRelativePivotPosition@b3Generic6DofConstraint@@QEBAMH@Z";

    setFrames :: (this: *b3Generic6DofConstraint, frameA: *b3Transform, frameB: *b3Transform, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?setFrames@b3Generic6DofConstraint@@QEAAXAEBVb3Transform@@0PEBUb3RigidBodyData@@@Z";
    setFrames :: (this: *b3Generic6DofConstraint, frameA: b3Transform, frameB: b3Transform, bodies: *b3RigidBodyData) #no_context {
        setFrames(this, *frameA, *frameB, bodies);
    }

    //! Test angular limit.
    /*!
    Calculates angular correction and returns true if limit needs to be corrected.
    \pre b3Generic6DofConstraint::calculateTransforms() must be called previously.
    */
    testAngularLimitMotor :: (this: *b3Generic6DofConstraint, axis_index: s32) -> bool #cpp_method #foreign bullet3 "?testAngularLimitMotor@b3Generic6DofConstraint@@QEAA_NH@Z";

    setLinearLowerLimit :: (this: *b3Generic6DofConstraint, linearLower: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setLinearLowerLimit@b3Generic6DofConstraint@@QEAAXAEBVb3Vector3@@@Z";
    setLinearLowerLimit :: (this: *b3Generic6DofConstraint, linearLower: b3Vector3) #no_context {
        setLinearLowerLimit(this, *linearLower);
    }

    getLinearLowerLimit :: (this: *b3Generic6DofConstraint, linearLower: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getLinearLowerLimit@b3Generic6DofConstraint@@QEAAXAEAVb3Vector3@@@Z";

    setLinearUpperLimit :: (this: *b3Generic6DofConstraint, linearUpper: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setLinearUpperLimit@b3Generic6DofConstraint@@QEAAXAEBVb3Vector3@@@Z";
    setLinearUpperLimit :: (this: *b3Generic6DofConstraint, linearUpper: b3Vector3) #no_context {
        setLinearUpperLimit(this, *linearUpper);
    }

    getLinearUpperLimit :: (this: *b3Generic6DofConstraint, linearUpper: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getLinearUpperLimit@b3Generic6DofConstraint@@QEAAXAEAVb3Vector3@@@Z";

    setAngularLowerLimit :: (this: *b3Generic6DofConstraint, angularLower: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setAngularLowerLimit@b3Generic6DofConstraint@@QEAAXAEBVb3Vector3@@@Z";
    setAngularLowerLimit :: (this: *b3Generic6DofConstraint, angularLower: b3Vector3) #no_context {
        setAngularLowerLimit(this, *angularLower);
    }

    getAngularLowerLimit :: (this: *b3Generic6DofConstraint, angularLower: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getAngularLowerLimit@b3Generic6DofConstraint@@QEAAXAEAVb3Vector3@@@Z";

    setAngularUpperLimit :: (this: *b3Generic6DofConstraint, angularUpper: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setAngularUpperLimit@b3Generic6DofConstraint@@QEAAXAEBVb3Vector3@@@Z";
    setAngularUpperLimit :: (this: *b3Generic6DofConstraint, angularUpper: b3Vector3) #no_context {
        setAngularUpperLimit(this, *angularUpper);
    }

    getAngularUpperLimit :: (this: *b3Generic6DofConstraint, angularUpper: *b3Vector3) -> void #cpp_method #foreign bullet3 "?getAngularUpperLimit@b3Generic6DofConstraint@@QEAAXAEAVb3Vector3@@@Z";

    //! Retrieves the angular limit informacion
    getRotationalLimitMotor :: (this: *b3Generic6DofConstraint, index: s32) -> *b3RotationalLimitMotor #cpp_method #foreign bullet3 "?getRotationalLimitMotor@b3Generic6DofConstraint@@QEAAPEAVb3RotationalLimitMotor@@H@Z";

    //! Retrieves the  limit informacion
    getTranslationalLimitMotor :: (this: *b3Generic6DofConstraint) -> *b3TranslationalLimitMotor #cpp_method #foreign bullet3 "?getTranslationalLimitMotor@b3Generic6DofConstraint@@QEAAPEAVb3TranslationalLimitMotor@@XZ";

    //first 3 are linear, next 3 are angular
    setLimit :: (this: *b3Generic6DofConstraint, axis: s32, lo: b3Scalar, hi: b3Scalar) -> void #cpp_method #foreign bullet3 "?setLimit@b3Generic6DofConstraint@@QEAAXHMM@Z";

    //! Test limit
    /*!
    - free means upper < lower,
    - locked means upper == lower
    - limited means upper > lower
    - limitIndex: first 3 are linear, next 3 are angular
    */
    isLimited :: (this: *b3Generic6DofConstraint, limitIndex: s32) -> bool #cpp_method #foreign bullet3 "?isLimited@b3Generic6DofConstraint@@QEAA_NH@Z";

    get_limit_motor_info2 :: (this: *b3Generic6DofConstraint, limot: *b3RotationalLimitMotor, transA: *b3Transform, transB: *b3Transform, linVelA: *b3Vector3, linVelB: *b3Vector3, angVelA: *b3Vector3, angVelB: *b3Vector3, info: *b3TypedConstraint.b3ConstraintInfo2, row: s32, ax1: *b3Vector3, rotational: s32, rotAllowed: s32 = 0) -> s32 #cpp_method #foreign bullet3 "?get_limit_motor_info2@b3Generic6DofConstraint@@QEAAHPEAVb3RotationalLimitMotor@@AEBVb3Transform@@1AEBVb3Vector3@@222PEAUb3ConstraintInfo2@b3TypedConstraint@@HAEAV4@HH@Z";
    get_limit_motor_info2 :: (this: *b3Generic6DofConstraint, limot: *b3RotationalLimitMotor, transA: b3Transform, transB: b3Transform, linVelA: b3Vector3, linVelB: b3Vector3, angVelA: b3Vector3, angVelB: b3Vector3, info: *b3TypedConstraint.b3ConstraintInfo2, row: s32, ax1: *b3Vector3, rotational: s32, rotAllowed: s32 = 0) -> s32 #no_context {
        return get_limit_motor_info2(this, limot, *transA, *transB, *linVelA, *linVelB, *angVelA, *angVelB, info, row, ax1, rotational, rotAllowed);
    }

    // access for UseFrameOffset
    getUseFrameOffset :: (this: *b3Generic6DofConstraint) -> bool #cpp_method #foreign bullet3 "?getUseFrameOffset@b3Generic6DofConstraint@@QEAA_NXZ";
    setUseFrameOffset :: (this: *b3Generic6DofConstraint, frameOffsetOnOff: bool) -> void #cpp_method #foreign bullet3 "?setUseFrameOffset@b3Generic6DofConstraint@@QEAAX_N@Z";

    setAxis :: (this: *b3Generic6DofConstraint, axis1: *b3Vector3, axis2: *b3Vector3, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?setAxis@b3Generic6DofConstraint@@QEAAXAEBVb3Vector3@@0PEBUb3RigidBodyData@@@Z";
    setAxis :: (this: *b3Generic6DofConstraint, axis1: b3Vector3, axis2: b3Vector3, bodies: *b3RigidBodyData) #no_context {
        setAxis(this, *axis1, *axis2, bodies);
    }
    #place b3typedconstraint; b3generic6dofconstraint_vtable: *b3Generic6DofConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getInfo1 :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo1@b3Generic6DofConstraint@@UEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    virtual_getInfo2 :: (this: *b3Generic6DofConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo2@b3Generic6DofConstraint@@UEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    virtual_calcAnchorPos :: (this: *b3Generic6DofConstraint, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?calcAnchorPos@b3Generic6DofConstraint@@UEAAXPEBUb3RigidBodyData@@@Z";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *b3Generic6DofConstraint, num: s32, value: b3Scalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@b3Generic6DofConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *b3Generic6DofConstraint, num: s32, axis: s32 = -1) -> b3Scalar #cpp_method #foreign bullet3 "?getParam@b3Generic6DofConstraint@@UEBAMHH@Z";
}
b3Generic6DofConstraint_VTable :: struct #type_info_none {
    using b3typedconstraint: b3TypedConstraint_VTable;
    calcAnchorPos: (this: *b3Generic6DofConstraint, bodies: *b3RigidBodyData) -> void #cpp_method;
}
b3Generic6DofConstraint_calcAnchorPos :: inline (this: *b3Generic6DofConstraint, bodies: *b3RigidBodyData) { this.b3generic6dofconstraint_vtable.calcAnchorPos(this, bodies); }

vtable :: (obj: *b3Generic6DofConstraint) -> *b3Generic6DofConstraint_VTable { return obj.b3generic6dofconstraint_vtable; }


//!@}
operator_assign :: (this: *b3Generic6DofConstraint, other: *b3Generic6DofConstraint) -> *b3Generic6DofConstraint #cpp_method #foreign bullet3 "??4b3Generic6DofConstraint@@IEAAAEAV0@AEAV0@@Z";


b3ContactPoint :: struct {}

b3PgsJacobiSolver :: struct {
    vtable: *b3PgsJacobiSolver_VTable;
    m_tmpSolverBodyPool:                             b3AlignedObjectArray(b3SolverBody);
    m_tmpSolverContactConstraintPool:                b3ConstraintArray;
    m_tmpSolverNonContactConstraintPool:             b3ConstraintArray;
    m_tmpSolverContactFrictionConstraintPool:        b3ConstraintArray;
    m_tmpSolverContactRollingFrictionConstraintPool: b3ConstraintArray;

    m_orderTmpConstraintPool:                        b3AlignedObjectArray(s32);
    m_orderNonContactConstraintPool:                 b3AlignedObjectArray(s32);
    m_orderFrictionConstraintPool:                   b3AlignedObjectArray(s32);
    m_tmpConstraintSizesPool:                        b3AlignedObjectArray(b3TypedConstraint.b3ConstraintInfo1);

    m_bodyCount:                                     b3AlignedObjectArray(s32);
    m_bodyCountCheck:                                b3AlignedObjectArray(s32);

    m_deltaLinearVelocities:                         b3AlignedObjectArray(b3Vector3);
    m_deltaAngularVelocities:                        b3AlignedObjectArray(b3Vector3);

    m_usePgs:                                        bool;
    averageVelocities :: (this: *b3PgsJacobiSolver) -> void #cpp_method #foreign bullet3 "?averageVelocities@b3PgsJacobiSolver@@IEAAXXZ";

    m_maxOverrideNumSolverIterations:                s32;

    m_numSplitImpulseRecoveries:                     s32;

    getContactProcessingThreshold :: (this: *b3PgsJacobiSolver, contact: *b3Contact4) -> b3Scalar #cpp_method #foreign bullet3 "?getContactProcessingThreshold@b3PgsJacobiSolver@@IEAAMPEAUb3Contact4@@@Z";

    setupFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, normalAxis: *b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0.0, cfmSlip: b3Scalar = 0.0) -> void #cpp_method #foreign bullet3 "?setupFrictionConstraint@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@AEBVb3Vector3@@HHAEAUb3ContactPoint@@3300MMM@Z";
    setupFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, normalAxis: b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, rel_pos1: b3Vector3, rel_pos2: b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0.0, cfmSlip: b3Scalar = 0.0) #no_context {
        setupFrictionConstraint(this, bodies, inertias, solverConstraint, *normalAxis, solverBodyIdA, solverBodyIdB, cp, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
    }

    setupRollingFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, normalAxis: *b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0.0, cfmSlip: b3Scalar = 0.0) -> void #cpp_method #foreign bullet3 "?setupRollingFrictionConstraint@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@AEBVb3Vector3@@HHAEAUb3ContactPoint@@3300MMM@Z";
    setupRollingFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, normalAxis: b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, rel_pos1: b3Vector3, rel_pos2: b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0.0, cfmSlip: b3Scalar = 0.0) #no_context {
        setupRollingFrictionConstraint(this, bodies, inertias, solverConstraint, *normalAxis, solverBodyIdA, solverBodyIdB, cp, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
    }

    addFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, normalAxis: *b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *b3ContactPoint, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0.0, cfmSlip: b3Scalar = 0.0) -> *b3SolverConstraint #cpp_method #foreign bullet3 "?addFrictionConstraint@b3PgsJacobiSolver@@IEAAAEAUb3SolverConstraint@@PEAUb3RigidBodyData@@PEAUb3InertiaData@@AEBVb3Vector3@@HHHAEAUb3ContactPoint@@2200MMM@Z";
    addFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, normalAxis: b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *b3ContactPoint, rel_pos1: b3Vector3, rel_pos2: b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0.0, cfmSlip: b3Scalar = 0.0) -> *b3SolverConstraint #no_context {
        return addFrictionConstraint(this, bodies, inertias, *normalAxis, solverBodyIdA, solverBodyIdB, frictionIndex, cp, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
    }
    addRollingFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, normalAxis: *b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *b3ContactPoint, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0, cfmSlip: b3Scalar = 0.0) -> *b3SolverConstraint #cpp_method #foreign bullet3 "?addRollingFrictionConstraint@b3PgsJacobiSolver@@IEAAAEAUb3SolverConstraint@@PEAUb3RigidBodyData@@PEAUb3InertiaData@@AEBVb3Vector3@@HHHAEAUb3ContactPoint@@2200MMM@Z";
    addRollingFrictionConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, normalAxis: b3Vector3, solverBodyIdA: s32, solverBodyIdB: s32, frictionIndex: s32, cp: *b3ContactPoint, rel_pos1: b3Vector3, rel_pos2: b3Vector3, colObj0: *b3RigidBodyData, colObj1: *b3RigidBodyData, relaxation: b3Scalar, desiredVelocity: b3Scalar = 0, cfmSlip: b3Scalar = 0.0) -> *b3SolverConstraint #no_context {
        return addRollingFrictionConstraint(this, bodies, inertias, *normalAxis, solverBodyIdA, solverBodyIdB, frictionIndex, cp, *rel_pos1, *rel_pos2, colObj0, colObj1, relaxation, desiredVelocity, cfmSlip);
    }

    setupContactConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, infoGlobal: *b3ContactSolverInfo, vel: *b3Vector3, rel_vel: *b3Scalar, relaxation: *b3Scalar, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setupContactConstraint@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@HHAEAUb3ContactPoint@@AEBUb3ContactSolverInfo@@AEAVb3Vector3@@AEAM655@Z";
    setupContactConstraint :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, infoGlobal: b3ContactSolverInfo, vel: *b3Vector3, rel_vel: *b3Scalar, relaxation: *b3Scalar, rel_pos1: *b3Vector3, rel_pos2: *b3Vector3) #no_context {
        setupContactConstraint(this, bodies, inertias, solverConstraint, solverBodyIdA, solverBodyIdB, cp, *infoGlobal, vel, rel_vel, relaxation, rel_pos1, rel_pos2);
    }

    setFrictionConstraintImpulse :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, infoGlobal: *b3ContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setFrictionConstraintImpulse@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@AEAUb3SolverConstraint@@HHAEAUb3ContactPoint@@AEBUb3ContactSolverInfo@@@Z";
    setFrictionConstraintImpulse :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, solverConstraint: *b3SolverConstraint, solverBodyIdA: s32, solverBodyIdB: s32, cp: *b3ContactPoint, infoGlobal: b3ContactSolverInfo) #no_context {
        setFrictionConstraintImpulse(this, bodies, inertias, solverConstraint, solverBodyIdA, solverBodyIdB, cp, *infoGlobal);
    }

    ///m_btSeed2 is used for re-arranging the constraint rows. improves convergence/quality of friction
    m_btSeed2:                                       u32;

    restitutionCurve :: (this: *b3PgsJacobiSolver, rel_vel: b3Scalar, restitution: b3Scalar) -> b3Scalar #cpp_method #foreign bullet3 "?restitutionCurve@b3PgsJacobiSolver@@IEAAMMM@Z";

    convertContact :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, manifold: *b3Contact4, infoGlobal: *b3ContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertContact@b3PgsJacobiSolver@@IEAAXPEAUb3RigidBodyData@@PEAUb3InertiaData@@PEAUb3Contact4@@AEBUb3ContactSolverInfo@@@Z";
    convertContact :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, manifold: *b3Contact4, infoGlobal: b3ContactSolverInfo) #no_context {
        convertContact(this, bodies, inertias, manifold, *infoGlobal);
    }

    resolveSplitPenetrationSIMD :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: *b3SolverConstraint) -> void #cpp_method #foreign bullet3 "?resolveSplitPenetrationSIMD@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z";
    resolveSplitPenetrationSIMD :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: b3SolverConstraint) #no_context {
        resolveSplitPenetrationSIMD(this, bodyA, bodyB, *contactConstraint);
    }

    resolveSplitPenetrationImpulseCacheFriendly :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: *b3SolverConstraint) -> void #cpp_method #foreign bullet3 "?resolveSplitPenetrationImpulseCacheFriendly@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z";
    resolveSplitPenetrationImpulseCacheFriendly :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: b3SolverConstraint) #no_context {
        resolveSplitPenetrationImpulseCacheFriendly(this, bodyA, bodyB, *contactConstraint);
    }

    //internal method
    getOrInitSolverBody :: (this: *b3PgsJacobiSolver, bodyIndex: s32, bodies: *b3RigidBodyData, inertias: *b3InertiaData) -> s32 #cpp_method #foreign bullet3 "?getOrInitSolverBody@b3PgsJacobiSolver@@IEAAHHPEAUb3RigidBodyData@@PEAUb3InertiaData@@@Z";
    initSolverBody :: (this: *b3PgsJacobiSolver, bodyIndex: s32, solverBody: *b3SolverBody, collisionObject: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?initSolverBody@b3PgsJacobiSolver@@IEAAXHPEAUb3SolverBody@@PEAUb3RigidBodyData@@@Z";

    resolveSingleConstraintRowGeneric :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: *b3SolverConstraint) -> void #cpp_method #foreign bullet3 "?resolveSingleConstraintRowGeneric@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z";
    resolveSingleConstraintRowGeneric :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: b3SolverConstraint) #no_context {
        resolveSingleConstraintRowGeneric(this, bodyA, bodyB, *contactConstraint);
    }

    resolveSingleConstraintRowGenericSIMD :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: *b3SolverConstraint) -> void #cpp_method #foreign bullet3 "?resolveSingleConstraintRowGenericSIMD@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z";
    resolveSingleConstraintRowGenericSIMD :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: b3SolverConstraint) #no_context {
        resolveSingleConstraintRowGenericSIMD(this, bodyA, bodyB, *contactConstraint);
    }

    resolveSingleConstraintRowLowerLimit :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: *b3SolverConstraint) -> void #cpp_method #foreign bullet3 "?resolveSingleConstraintRowLowerLimit@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z";
    resolveSingleConstraintRowLowerLimit :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: b3SolverConstraint) #no_context {
        resolveSingleConstraintRowLowerLimit(this, bodyA, bodyB, *contactConstraint);
    }

    resolveSingleConstraintRowLowerLimitSIMD :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: *b3SolverConstraint) -> void #cpp_method #foreign bullet3 "?resolveSingleConstraintRowLowerLimitSIMD@b3PgsJacobiSolver@@IEAAXAEAUb3SolverBody@@0AEBUb3SolverConstraint@@@Z";
    resolveSingleConstraintRowLowerLimitSIMD :: (this: *b3PgsJacobiSolver, bodyA: *b3SolverBody, bodyB: *b3SolverBody, contactConstraint: b3SolverConstraint) #no_context {
        resolveSingleConstraintRowLowerLimitSIMD(this, bodyA, bodyB, *contactConstraint);
    }

    solveSingleIteration :: (this: *b3PgsJacobiSolver, iteration: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method #foreign bullet3 "?solveSingleIteration@b3PgsJacobiSolver@@IEAAMHPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z";
    solveSingleIteration :: (this: *b3PgsJacobiSolver, iteration: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: b3ContactSolverInfo) -> b3Scalar #no_context {
        return solveSingleIteration(this, iteration, constraints, numConstraints, *infoGlobal);
    }

    Constructor :: (this: *b3PgsJacobiSolver, usePgs: bool) -> void #cpp_method #foreign bullet3 "??0b3PgsJacobiSolver@@QEAA@_N@Z";

    //	void	solveContacts(int numBodies, b3RigidBodyData* bodies, b3InertiaData* inertias, int numContacts, b3Contact4* contacts);
    solveContacts :: (this: *b3PgsJacobiSolver, numBodies: s32, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numContacts: s32, contacts: *b3Contact4, numConstraints: s32, constraints: **b3TypedConstraint) -> void #cpp_method #foreign bullet3 "?solveContacts@b3PgsJacobiSolver@@QEAAXHPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HPEAPEAVb3TypedConstraint@@@Z";

    solveGroup :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, manifoldPtr: *b3Contact4, numManifolds: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method #foreign bullet3 "?solveGroup@b3PgsJacobiSolver@@QEAAMPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z";
    solveGroup :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, manifoldPtr: *b3Contact4, numManifolds: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: b3ContactSolverInfo) -> b3Scalar #no_context {
        return solveGroup(this, bodies, inertias, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, *infoGlobal);
    }

    b3Rand2 :: (this: *b3PgsJacobiSolver) -> u32 #cpp_method #foreign bullet3 "?b3Rand2@b3PgsJacobiSolver@@QEAAKXZ";

    b3RandInt2 :: (this: *b3PgsJacobiSolver, n: s32) -> s32 #cpp_method #foreign bullet3 "?b3RandInt2@b3PgsJacobiSolver@@QEAAHH@Z";

    setRandSeed :: (this: *b3PgsJacobiSolver, seed: u32) -> void #cpp_method #foreign bullet3 "?setRandSeed@b3PgsJacobiSolver@@QEAAXK@Z";

    getRandSeed :: (this: *b3PgsJacobiSolver) -> u32 #cpp_method #foreign bullet3 "?getRandSeed@b3PgsJacobiSolver@@QEBAKXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveGroupCacheFriendlySetup :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, manifoldPtr: *b3Contact4, numManifolds: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@b3PgsJacobiSolver@@MEAAMPEAUb3RigidBodyData@@PEAUb3InertiaData@@HPEAUb3Contact4@@HPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z";

    virtual_solveGroupCacheFriendlyIterations :: (this: *b3PgsJacobiSolver, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyIterations@b3PgsJacobiSolver@@MEAAMPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z";
    virtual_solveGroupCacheFriendlySplitImpulseIterations :: (this: *b3PgsJacobiSolver, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySplitImpulseIterations@b3PgsJacobiSolver@@MEAAXPEAPEAVb3TypedConstraint@@HAEBUb3ContactSolverInfo@@@Z";

    virtual_solveGroupCacheFriendlyFinish :: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyFinish@b3PgsJacobiSolver@@MEAAMPEAUb3RigidBodyData@@PEAUb3InertiaData@@HAEBUb3ContactSolverInfo@@@Z";

    virtual_Destructor :: (this: *b3PgsJacobiSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3PgsJacobiSolver@@UEAA@XZ";

    ///clear internal cached data and reset random seed
    virtual_reset :: (this: *b3PgsJacobiSolver) -> void #cpp_method #foreign bullet3 "?reset@b3PgsJacobiSolver@@UEAAXXZ";
}
b3PgsJacobiSolver_VTable :: struct #type_info_none {
    solveGroupCacheFriendlySetup: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, manifoldPtr: *b3Contact4, numManifolds: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method;

    solveGroupCacheFriendlyIterations: (this: *b3PgsJacobiSolver, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method;
    solveGroupCacheFriendlySplitImpulseIterations: (this: *b3PgsJacobiSolver, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> void #cpp_method;

    solveGroupCacheFriendlyFinish: (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar #cpp_method;

    Destructor: (this: *b3PgsJacobiSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    reset: (this: *b3PgsJacobiSolver) -> void #cpp_method;
}

b3PgsJacobiSolver_solveGroupCacheFriendlySetup :: inline (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, manifoldPtr: *b3Contact4, numManifolds: s32, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar { return this.vtable.solveGroupCacheFriendlySetup(this, bodies, inertias, numBodies, manifoldPtr, numManifolds, constraints, numConstraints, infoGlobal); }

b3PgsJacobiSolver_solveGroupCacheFriendlyIterations :: inline (this: *b3PgsJacobiSolver, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar { return this.vtable.solveGroupCacheFriendlyIterations(this, constraints, numConstraints, infoGlobal); }
b3PgsJacobiSolver_solveGroupCacheFriendlySplitImpulseIterations :: inline (this: *b3PgsJacobiSolver, constraints: **b3TypedConstraint, numConstraints: s32, infoGlobal: *b3ContactSolverInfo) { this.vtable.solveGroupCacheFriendlySplitImpulseIterations(this, constraints, numConstraints, infoGlobal); }

b3PgsJacobiSolver_solveGroupCacheFriendlyFinish :: inline (this: *b3PgsJacobiSolver, bodies: *b3RigidBodyData, inertias: *b3InertiaData, numBodies: s32, infoGlobal: *b3ContactSolverInfo) -> b3Scalar { return this.vtable.solveGroupCacheFriendlyFinish(this, bodies, inertias, numBodies, infoGlobal); }

b3PgsJacobiSolver_Destructor :: inline (this: *b3PgsJacobiSolver, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3PgsJacobiSolver_reset :: inline (this: *b3PgsJacobiSolver) { this.vtable.reset(this); }




b3RigidBody :: struct {}

b3ConstraintSetting :: struct {
    Constructor :: (this: *b3ConstraintSetting) -> void #cpp_method #foreign bullet3 "??0b3ConstraintSetting@@QEAA@XZ";

    m_tau:          b3Scalar;
    m_damping:      b3Scalar;
    m_impulseClamp: b3Scalar;
}

b3Point2PointFlags :: enum s32 {
    ERP :: 1;
    CFM :: 2;

    B3_P2P_FLAGS_ERP :: ERP;
    B3_P2P_FLAGS_CFM :: CFM;
}

/// point to point constraint between two rigidbodies each with a pivotpoint that descibes the 'ballsocket' location in local space
b3Point2PointConstraint :: struct {
    #as using b3typedconstraint: b3TypedConstraint;

    m_pivotInA: b3Vector3;
    m_pivotInB: b3Vector3;

    m_flags:    s32;
    m_erp:      b3Scalar;
    m_cfm:      b3Scalar;

    m_setting:  b3ConstraintSetting;

    Constructor :: (this: *b3Point2PointConstraint, rbA: s32, rbB: s32, pivotInA: *b3Vector3, pivotInB: *b3Vector3) -> void #cpp_method #foreign bullet3 "??0b3Point2PointConstraint@@QEAA@HHAEBVb3Vector3@@0@Z";
    Constructor :: (this: *b3Point2PointConstraint, rbA: s32, rbB: s32, pivotInA: b3Vector3, pivotInB: b3Vector3) #no_context {
        Constructor(this, rbA, rbB, *pivotInA, *pivotInB);
    }

    getInfo1NonVirtual :: (this: *b3Point2PointConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo1NonVirtual@b3Point2PointConstraint@@QEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    getInfo2NonVirtual :: (this: *b3Point2PointConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, body0_trans: *b3Transform, body1_trans: *b3Transform) -> void #cpp_method #foreign bullet3 "?getInfo2NonVirtual@b3Point2PointConstraint@@QEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@AEBVb3Transform@@1@Z";
    getInfo2NonVirtual :: (this: *b3Point2PointConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, body0_trans: b3Transform, body1_trans: b3Transform) #no_context {
        getInfo2NonVirtual(this, info, *body0_trans, *body1_trans);
    }

    updateRHS :: (this: *b3Point2PointConstraint, timeStep: b3Scalar) -> void #cpp_method #foreign bullet3 "?updateRHS@b3Point2PointConstraint@@QEAAXM@Z";

    setPivotA :: (this: *b3Point2PointConstraint, pivotA: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setPivotA@b3Point2PointConstraint@@QEAAXAEBVb3Vector3@@@Z";
    setPivotA :: (this: *b3Point2PointConstraint, pivotA: b3Vector3) #no_context {
        setPivotA(this, *pivotA);
    }

    setPivotB :: (this: *b3Point2PointConstraint, pivotB: *b3Vector3) -> void #cpp_method #foreign bullet3 "?setPivotB@b3Point2PointConstraint@@QEAAXAEBVb3Vector3@@@Z";
    setPivotB :: (this: *b3Point2PointConstraint, pivotB: b3Vector3) #no_context {
        setPivotB(this, *pivotB);
    }

    getPivotInA :: (this: *b3Point2PointConstraint) -> *b3Vector3 #cpp_method #foreign bullet3 "?getPivotInA@b3Point2PointConstraint@@QEBAAEBVb3Vector3@@XZ";

    getPivotInB :: (this: *b3Point2PointConstraint) -> *b3Vector3 #cpp_method #foreign bullet3 "?getPivotInB@b3Point2PointConstraint@@QEBAAEBVb3Vector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //b3Point2PointConstraint(int  rbA,const b3Vector3& pivotInA);
    virtual_getInfo1 :: (this: *b3Point2PointConstraint, info: *b3TypedConstraint.b3ConstraintInfo1, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo1@b3Point2PointConstraint@@UEAAXPEAUb3ConstraintInfo1@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    virtual_getInfo2 :: (this: *b3Point2PointConstraint, info: *b3TypedConstraint.b3ConstraintInfo2, bodies: *b3RigidBodyData) -> void #cpp_method #foreign bullet3 "?getInfo2@b3Point2PointConstraint@@UEAAXPEAUb3ConstraintInfo2@b3TypedConstraint@@PEBUb3RigidBodyData@@@Z";

    ///override the default global value of a parameter (such as ERP or CFM), optionally provide the axis (0..5).
    ///If no axis is provided, it uses the default axis for this constraint.
    virtual_setParam :: (this: *b3Point2PointConstraint, num: s32, value: b3Scalar, axis: s32 = -1) -> void #cpp_method #foreign bullet3 "?setParam@b3Point2PointConstraint@@UEAAXHMH@Z";

    ///return the local value of parameter
    virtual_getParam :: (this: *b3Point2PointConstraint, num: s32, axis: s32 = -1) -> b3Scalar #cpp_method #foreign bullet3 "?getParam@b3Point2PointConstraint@@UEBAMHH@Z";
}


///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
b3Point2PointConstraintFloatData :: struct {
    m_typeConstraintData: b3TypedConstraintData;
    m_pivotInA:           b3Vector3FloatData;
    m_pivotInB:           b3Vector3FloatData;
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
b3Point2PointConstraintDoubleData :: struct {
    m_typeConstraintData: b3TypedConstraintData;
    m_pivotInA:           b3Vector3DoubleData;
    m_pivotInB:           b3Vector3DoubleData;
}

b3ContactConstraint4_t :: b3ContactConstraint4;

b3ContactConstraint4 :: struct {
    m_linear:           b3Vector3; //normal?
    m_worldPos:         [4] b3Vector3;
    m_center:           b3Vector3; //	friction
    m_jacCoeffInv:      [4] float;
    m_b:                [4] float;
    m_appliedRambdaDt:  [4] float;
    m_fJacCoeffInv:     [2] float; //	friction
    m_fAppliedRambdaDt: [2] float; //	friction

    m_bodyA:            u32;
    m_bodyB:            u32;
    m_batchIdx:         s32;
    m_paddings:         u32;
}

b3Inertia :: struct {
    m_invInertiaWorld: b3Matrix3x3;
    m_initInvInertia:  b3Matrix3x3;
}

bParse :: struct {
    bMain :: struct {}
    bFileData :: struct {}

    // delete void* undefined
    bStructHandle :: struct {
        unused: s32;
    }

    // delete void* undefined
    bListBasePtr :: b3AlignedObjectArray(*bStructHandle);
    bPtrMap :: b3HashMap(b3HashPtr, *bStructHandle);

    // ----------------------------------------------------- //
    bChunkPtr4 :: struct {
        Constructor :: (this: *bChunkPtr4) -> void #cpp_method #foreign bullet3 "??0bChunkPtr4@bParse@@QEAA@XZ";
        code:   s32;
        len:    s32;
        union {
            m_uniqueInt: s32;
        }

        dna_nr: s32;
        nr:     s32;
    }

    // ----------------------------------------------------- //
    bChunkPtr8 :: struct {
        Constructor :: (this: *bChunkPtr8) -> void #cpp_method #foreign bullet3 "??0bChunkPtr8@bParse@@QEAA@XZ";
        code:   s32;
        len:    s32;
        union {
            oldPrev:      s64;
            m_uniqueInts: [2] s32;
        }

        dna_nr: s32;
        nr:     s32;
    }

    // ----------------------------------------------------- //
    bChunkInd :: struct {
        Constructor :: (this: *bChunkInd) -> void #cpp_method #foreign bullet3 "??0bChunkInd@bParse@@QEAA@XZ";
        code:   s32;
        len:    s32;
        oldPtr: *void;
        dna_nr: s32;
        nr:     s32;
    }

    // ----------------------------------------------------- //
    ChunkUtils :: struct {
        // file chunk offset
        getOffset :: (flags: s32) -> s32 #foreign bullet3 "?getOffset@ChunkUtils@bParse@@SAHH@Z";

        // endian utils
        swapShort :: (sht: s16) -> s16 #foreign bullet3 "?swapShort@ChunkUtils@bParse@@SAFF@Z";
        swapInt :: (inte: s32) -> s32 #foreign bullet3 "?swapInt@ChunkUtils@bParse@@SAHH@Z";
        swapLong64 :: (lng: s64) -> s64 #foreign bullet3 "?swapLong64@ChunkUtils@bParse@@SA_J_J@Z";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    CHUNK_HEADER_LEN: s32 : 24;
    VOID_IS_8 := ((true == true));

    // ----------------------------------------------------- //
    bFileFlags :: enum s32 {
        INVALID          :: 0;
        OK               :: 1;
        VOID_IS_8        :: 2;
        ENDIAN_SWAP      :: 4;
        FILE_64          :: 8;
        BITS_VARIES      :: 16;
        VERSION_VARIES   :: 32;
        DOUBLE_PRECISION :: 64;
        BROKEN_DNA       :: 128;

        FD_INVALID          :: INVALID;
        FD_OK               :: OK;
        FD_VOID_IS_8        :: VOID_IS_8;
        FD_ENDIAN_SWAP      :: ENDIAN_SWAP;
        FD_FILE_64          :: FILE_64;
        FD_BITS_VARIES      :: BITS_VARIES;
        FD_VERSION_VARIES   :: VERSION_VARIES;
        FD_DOUBLE_PRECISION :: DOUBLE_PRECISION;
        FD_BROKEN_DNA       :: BROKEN_DNA;
    }

    bFileVerboseMode :: enum s32 {
        EXPORT_XML                :: 1;
        DUMP_DNA_TYPE_DEFINITIONS :: 2;
        DUMP_CHUNKS               :: 4;
        DUMP_FILE_INFO            :: 8;

        FD_VERBOSE_EXPORT_XML                :: EXPORT_XML;
        FD_VERBOSE_DUMP_DNA_TYPE_DEFINITIONS :: DUMP_DNA_TYPE_DEFINITIONS;
        FD_VERBOSE_DUMP_CHUNKS               :: DUMP_CHUNKS;
        FD_VERBOSE_DUMP_FILE_INFO            :: DUMP_FILE_INFO;
    }

    // ----------------------------------------------------- //
    bFile :: struct {
        vtable: *bFile_VTable;
        m_headerString:         [7] u8;

        mOwnsBuffer:            bool;
        mFileBuffer:            *u8;
        mFileLen:               s32;
        mVersion:               s32;

        mLibPointers:           bPtrMap;

        mDataStart:             s32;
        mFileDNA:               *bDNA;
        mMemoryDNA:             *bDNA;

        m_pointerFixupArray:    b3AlignedObjectArray(*u8);
        m_pointerPtrFixupArray: b3AlignedObjectArray(*u8);

        m_chunks:               b3AlignedObjectArray(bChunkInd);
        m_chunkPtrPtrMap:       b3HashMap(b3HashPtr, bChunkInd);

        //
        mDataPointers:          bPtrMap;

        mFlags:                 s32;

        // buffer offset util
        getNextBlock :: (this: *bFile, dataChunk: *bChunkInd, dataPtr: *u8, flags: s32) -> s32 #cpp_method #foreign bullet3 "?getNextBlock@bFile@bParse@@IEAAHPEAVbChunkInd@2@PEBDH@Z";
        safeSwapPtr :: (this: *bFile, dst: *u8, src: *u8) -> void #cpp_method #foreign bullet3 "?safeSwapPtr@bFile@bParse@@IEAAXPEADPEBD@Z";

        resolvePointersMismatch :: (this: *bFile) -> void #cpp_method #foreign bullet3 "?resolvePointersMismatch@bFile@bParse@@IEAAXXZ";
        resolvePointersChunk :: (this: *bFile, dataChunk: *bChunkInd, verboseMode: s32) -> void #cpp_method #foreign bullet3 "?resolvePointersChunk@bFile@bParse@@IEAAXAEBVbChunkInd@2@H@Z";
        resolvePointersChunk :: (this: *bFile, dataChunk: bChunkInd, verboseMode: s32) #no_context {
            resolvePointersChunk(this, *dataChunk, verboseMode);
        }

        resolvePointersStructRecursive :: (this: *bFile, strcPtr: *u8, old_dna: s32, verboseMode: s32, recursion: s32) -> s32 #cpp_method #foreign bullet3 "?resolvePointersStructRecursive@bFile@bParse@@IEAAHPEADHHH@Z";

        //void swapPtr(char *dst, char *src);
        parseStruct :: (this: *bFile, strcPtr: *u8, dtPtr: *u8, old_dna: s32, new_dna: s32, fixupPointers: bool) -> void #cpp_method #foreign bullet3 "?parseStruct@bFile@bParse@@IEAAXPEAD0HH_N@Z";
        getMatchingFileDNA :: (this: *bFile, old: *s16, lookupName: *u8, lookupType: *u8, strcData: *u8, data: *u8, fixupPointers: bool) -> void #cpp_method #foreign bullet3 "?getMatchingFileDNA@bFile@bParse@@IEAAXPEAFPEBD1PEAD2_N@Z";
        getFileElement :: (this: *bFile, firstStruct: *s16, lookupName: *u8, lookupType: *u8, data: *u8, foundPos: **s16) -> *u8 #cpp_method #foreign bullet3 "?getFileElement@bFile@bParse@@IEAAPEADPEAFPEAD11PEAPEAF@Z";

        swap :: (this: *bFile, head: *u8, ch: *bChunkInd, ignoreEndianFlag: bool) -> void #cpp_method #foreign bullet3 "?swap@bFile@bParse@@IEAAXPEADAEAVbChunkInd@2@_N@Z";
        swapData :: (this: *bFile, data: *u8, type: s16, arraySize: s32, ignoreEndianFlag: bool) -> void #cpp_method #foreign bullet3 "?swapData@bFile@bParse@@IEAAXPEADFH_N@Z";
        swapStruct :: (this: *bFile, dna_nr: s32, data: *u8, ignoreEndianFlag: bool) -> void #cpp_method #foreign bullet3 "?swapStruct@bFile@bParse@@IEAAXHPEAD_N@Z";
        swapLen :: (this: *bFile, dataPtr: *u8) -> void #cpp_method #foreign bullet3 "?swapLen@bFile@bParse@@IEAAXPEAD@Z";
        swapDNA :: (this: *bFile, ptr: *u8) -> void #cpp_method #foreign bullet3 "?swapDNA@bFile@bParse@@IEAAXPEAD@Z";

        readStruct :: (this: *bFile, head: *u8, chunk: *bChunkInd) -> *u8 #cpp_method #foreign bullet3 "?readStruct@bFile@bParse@@IEAAPEADPEADAEAVbChunkInd@2@@Z";

        parseInternal :: (this: *bFile, verboseMode: s32, memDna: *u8, memDnaLength: s32) -> void #cpp_method #foreign bullet3 "?parseInternal@bFile@bParse@@IEAAXHPEADH@Z";

        Constructor :: (this: *bFile, filename: *u8, headerString: *[7] u8) -> void #cpp_method #foreign bullet3 "??0bFile@bParse@@QEAA@PEBDQEBD@Z";

        //todo: make memoryBuffer const char
        //bFile( const char *memoryBuffer, int len);
        Constructor :: (this: *bFile, memoryBuffer: *u8, len: s32, headerString: *[7] u8) -> void #cpp_method #foreign bullet3 "??0bFile@bParse@@QEAA@PEADHQEBD@Z";

        getFileDNA :: (this: *bFile) -> *bDNA #cpp_method #foreign bullet3 "?getFileDNA@bFile@bParse@@QEAAPEAVbDNA@2@XZ";

        getFlags :: (this: *bFile) -> s32 #cpp_method #foreign bullet3 "?getFlags@bFile@bParse@@QEBAHXZ";

        getLibPointers :: (this: *bFile) -> *bPtrMap #cpp_method #foreign bullet3 "?getLibPointers@bFile@bParse@@QEAAAEAV?$b3HashMap@Vb3HashPtr@@PEAUbStructHandle@bParse@@@@XZ";

        findLibPointer :: (this: *bFile, ptr: *void) -> *void #cpp_method #foreign bullet3 "?findLibPointer@bFile@bParse@@QEAAPEAXPEAX@Z";

        ok :: (this: *bFile) -> bool #cpp_method #foreign bullet3 "?ok@bFile@bParse@@QEAA_NXZ";

        updateOldPointers :: (this: *bFile) -> void #cpp_method #foreign bullet3 "?updateOldPointers@bFile@bParse@@QEAAXXZ";
        resolvePointers :: (this: *bFile, verboseMode: s32) -> void #cpp_method #foreign bullet3 "?resolvePointers@bFile@bParse@@QEAAXH@Z";

        dumpChunks :: (this: *bFile, dna: *bDNA) -> void #cpp_method #foreign bullet3 "?dumpChunks@bFile@bParse@@QEAAXPEAVbDNA@2@@Z";

        getVersion :: (this: *bFile) -> s32 #cpp_method #foreign bullet3 "?getVersion@bFile@bParse@@QEBAHXZ";

        //pre-swap the endianness, so that data loaded on a target with different endianness doesn't need to be swapped
        preSwap :: (this: *bFile) -> void #cpp_method #foreign bullet3 "?preSwap@bFile@bParse@@QEAAXXZ";
        writeFile :: (this: *bFile, fileName: *u8) -> void #cpp_method #foreign bullet3 "?writeFile@bFile@bParse@@QEAAXPEBD@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_parseHeader :: (this: *bFile) -> void #cpp_method #foreign bullet3 "?parseHeader@bFile@bParse@@MEAAXXZ";

        virtual_Destructor :: (this: *bFile, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1bFile@bParse@@UEAA@XZ";

        virtual_writeChunks :: (this: *bFile, fp: *FILE, fixupPointers: bool) -> void #cpp_method #foreign bullet3 "?writeChunks@bFile@bParse@@UEAAXPEAU_iobuf@@_N@Z";
    }
    bFile_VTable :: struct #type_info_none {
        parseHeader: (this: *bFile) -> void #cpp_method;

        parseData: (this: *bFile) -> void #cpp_method;

        Destructor: (this: *bFile, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        addDataBlock: (this: *bFile, dataBlock: *u8) -> void #cpp_method;

        parse: (this: *bFile, verboseMode: s32) -> void #cpp_method;

        write: (this: *bFile, fileName: *u8, fixupPointers := false) -> s32 #cpp_method;

        writeChunks: (this: *bFile, fp: *FILE, fixupPointers: bool) -> void #cpp_method;

        writeDNA: (this: *bFile, fp: *FILE) -> void #cpp_method;
    }

    bFile_parseHeader :: inline (this: *bFile) { this.vtable.parseHeader(this); }

    bFile_parseData :: inline (this: *bFile) { this.vtable.parseData(this); }

    bFile_Destructor :: inline (this: *bFile, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    bFile_addDataBlock :: inline (this: *bFile, dataBlock: *u8) { this.vtable.addDataBlock(this, dataBlock); }

    bFile_parse :: inline (this: *bFile, verboseMode: s32) { this.vtable.parse(this, verboseMode); }

    bFile_write :: inline (this: *bFile, fileName: *u8, fixupPointers := false) -> s32 { return this.vtable.write(this, fileName, fixupPointers); }

    bFile_writeChunks :: inline (this: *bFile, fp: *FILE, fixupPointers: bool) { this.vtable.writeChunks(this, fp, fixupPointers); }

    bFile_writeDNA :: inline (this: *bFile, fp: *FILE) { this.vtable.writeDNA(this, fp); }



    // ----------------------------------------------------- //
    b3BulletFile :: struct {
        #as using bfile: bFile;

        m_DnaCopy:           *u8;

        m_softBodies:        b3AlignedObjectArray(*bStructHandle);

        m_rigidBodies:       b3AlignedObjectArray(*bStructHandle);

        m_collisionObjects:  b3AlignedObjectArray(*bStructHandle);

        m_collisionShapes:   b3AlignedObjectArray(*bStructHandle);

        m_constraints:       b3AlignedObjectArray(*bStructHandle);

        m_bvhs:              b3AlignedObjectArray(*bStructHandle);

        m_triangleInfoMaps:  b3AlignedObjectArray(*bStructHandle);

        m_dynamicsWorldInfo: b3AlignedObjectArray(*bStructHandle);

        m_dataBlocks:        b3AlignedObjectArray(*u8);
        Constructor :: (this: *b3BulletFile) -> void #cpp_method #foreign bullet3 "??0b3BulletFile@bParse@@QEAA@XZ";

        Constructor :: (this: *b3BulletFile, fileName: *u8) -> void #cpp_method #foreign bullet3 "??0b3BulletFile@bParse@@QEAA@PEBD@Z";

        Constructor :: (this: *b3BulletFile, memoryBuffer: *u8, len: s32) -> void #cpp_method #foreign bullet3 "??0b3BulletFile@bParse@@QEAA@PEADH@Z";

        addStruct :: (this: *b3BulletFile, structType: *u8, data: *void, len: s32, oldPtr: *void, code: s32) -> void #cpp_method #foreign bullet3 "?addStruct@b3BulletFile@bParse@@QEAAXPEBDPEAXH1H@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *b3BulletFile, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3BulletFile@bParse@@UEAA@XZ";

        virtual_addDataBlock :: (this: *b3BulletFile, dataBlock: *u8) -> void #cpp_method #foreign bullet3 "?addDataBlock@b3BulletFile@bParse@@UEAAXPEAD@Z";

        // experimental
        virtual_write :: (this: *b3BulletFile, fileName: *u8, fixupPointers := false) -> s32 #cpp_method #foreign bullet3 "?write@b3BulletFile@bParse@@UEAAHPEBD_N@Z";

        virtual_parse :: (this: *b3BulletFile, verboseMode: s32) -> void #cpp_method #foreign bullet3 "?parse@b3BulletFile@bParse@@UEAAXH@Z";

        virtual_parseData :: (this: *b3BulletFile) -> void #cpp_method #foreign bullet3 "?parseData@b3BulletFile@bParse@@UEAAXXZ";

        virtual_writeDNA :: (this: *b3BulletFile, fp: *FILE) -> void #cpp_method #foreign bullet3 "?writeDNA@b3BulletFile@bParse@@UEAAXPEAU_iobuf@@@Z";
    }

    bNameInfo :: struct {
        m_name:      *u8;
        m_isPointer: bool;
        m_dim0:      s32;
        m_dim1:      s32;
    }

    bDNA :: struct {
        Constructor :: (this: *bDNA) -> void #cpp_method #foreign bullet3 "??0bDNA@bParse@@QEAA@XZ";
        Destructor :: (this: *bDNA) -> void #cpp_method #foreign bullet3 "??1bDNA@bParse@@QEAA@XZ";

        init :: (this: *bDNA, data: *u8, len: s32, swap := false) -> void #cpp_method #foreign bullet3 "?init@bDNA@bParse@@QEAAXPEADH_N@Z";

        getArraySize :: (this: *bDNA, str: *u8) -> s32 #cpp_method #foreign bullet3 "?getArraySize@bDNA@bParse@@QEAAHPEAD@Z";
        getArraySizeNew :: (this: *bDNA, name: s16) -> s32 #cpp_method #foreign bullet3 "?getArraySizeNew@bDNA@bParse@@QEAAHF@Z";

        getElementSize :: (this: *bDNA, type: s16, name: s16) -> s32 #cpp_method #foreign bullet3 "?getElementSize@bDNA@bParse@@QEAAHFF@Z";

        getNumNames :: (this: *bDNA) -> s32 #cpp_method #foreign bullet3 "?getNumNames@bDNA@bParse@@QEBAHXZ";

        getName :: (this: *bDNA, ind: s32) -> *u8 #cpp_method #foreign bullet3 "?getName@bDNA@bParse@@QEAAPEADH@Z";
        getType :: (this: *bDNA, ind: s32) -> *u8 #cpp_method #foreign bullet3 "?getType@bDNA@bParse@@QEAAPEADH@Z";
        getStruct :: (this: *bDNA, ind: s32) -> *s16 #cpp_method #foreign bullet3 "?getStruct@bDNA@bParse@@QEAAPEAFH@Z";
        getLength :: (this: *bDNA, ind: s32) -> s16 #cpp_method #foreign bullet3 "?getLength@bDNA@bParse@@QEAAFH@Z";
        getReverseType :: (this: *bDNA, type: s16) -> s32 #cpp_method #foreign bullet3 "?getReverseType@bDNA@bParse@@QEAAHF@Z";
        getReverseType :: (this: *bDNA, type: *u8) -> s32 #cpp_method #foreign bullet3 "?getReverseType@bDNA@bParse@@QEAAHPEBD@Z";

        getNumStructs :: (this: *bDNA) -> s32 #cpp_method #foreign bullet3 "?getNumStructs@bDNA@bParse@@QEAAHXZ";

        //
        lessThan :: (this: *bDNA, other: *bDNA) -> bool #cpp_method #foreign bullet3 "?lessThan@bDNA@bParse@@QEAA_NPEAV12@@Z";

        initCmpFlags :: (this: *bDNA, memDNA: *bDNA) -> void #cpp_method #foreign bullet3 "?initCmpFlags@bDNA@bParse@@QEAAXPEAV12@@Z";
        flagNotEqual :: (this: *bDNA, dna_nr: s32) -> bool #cpp_method #foreign bullet3 "?flagNotEqual@bDNA@bParse@@QEAA_NH@Z";
        flagEqual :: (this: *bDNA, dna_nr: s32) -> bool #cpp_method #foreign bullet3 "?flagEqual@bDNA@bParse@@QEAA_NH@Z";
        flagNone :: (this: *bDNA, dna_nr: s32) -> bool #cpp_method #foreign bullet3 "?flagNone@bDNA@bParse@@QEAA_NH@Z";

        getPointerSize :: (this: *bDNA) -> s32 #cpp_method #foreign bullet3 "?getPointerSize@bDNA@bParse@@QEAAHXZ";

        dumpTypeDefinitions :: (this: *bDNA) -> void #cpp_method #foreign bullet3 "?dumpTypeDefinitions@bDNA@bParse@@QEAAXXZ";

        FileDNAFlags :: enum s32 {
            NONE        :: 0;
            STRUCT_NEQU :: 1;
            STRUCT_EQU  :: 2;

            FDF_NONE        :: NONE;
            FDF_STRUCT_NEQU :: STRUCT_NEQU;
            FDF_STRUCT_EQU  :: STRUCT_EQU;
        }

        initRecurseCmpFlags :: (this: *bDNA, i: s32) -> void #cpp_method #foreign bullet3 "?initRecurseCmpFlags@bDNA@bParse@@AEAAXH@Z";

        mCMPFlags:      b3AlignedObjectArray(s32);

        m_Names:        b3AlignedObjectArray(bNameInfo);
        mTypes:         b3AlignedObjectArray(*u8);
        mStructs:       b3AlignedObjectArray(*s16);
        mTlens:         b3AlignedObjectArray(s16);
        mStructReverse: b3HashMap(b3HashInt, s32);
        mTypeLookup:    b3HashMap(b3HashString, s32);

        mPtrLen:        s32;
    }
}

b3Chunk :: struct {
    m_chunkCode: s32;
    m_length:    s32;
    m_oldPtr:    *void;
    m_dna_nr:    s32;
    m_number:    s32;
}

b3SerializationFlags :: enum s32 {
    BVH              :: 1;
    TRIANGLEINFOMAP  :: 2;
    DUPLICATE_ASSERT :: 4;

    B3_SERIALIZE_NO_BVH              :: BVH;
    B3_SERIALIZE_NO_TRIANGLEINFOMAP  :: TRIANGLEINFOMAP;
    B3_SERIALIZE_NO_DUPLICATE_ASSERT :: DUPLICATE_ASSERT;
}

b3Serializer :: struct {
    vtable: *b3Serializer_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *b3Serializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3Serializer@@UEAA@XZ";
}
b3Serializer_VTable :: struct #type_info_none {
    Destructor: (this: *b3Serializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getBufferPointer: (this: *b3Serializer) -> *u8 #cpp_method;

    getCurrentBufferSize: (this: *b3Serializer) -> s32 #cpp_method;

    allocate: (this: *b3Serializer, size: size_t, numElements: s32) -> *b3Chunk #cpp_method;

    finalizeChunk: (this: *b3Serializer, chunk: *b3Chunk, structType: *u8, chunkCode: s32, oldPtr: *void) -> void #cpp_method;

    findPointer: (this: *b3Serializer, oldPtr: *void) -> *void #cpp_method;

    getUniquePointer: (this: *b3Serializer, oldPtr: *void) -> *void #cpp_method;

    startSerialization: (this: *b3Serializer) -> void #cpp_method;

    finishSerialization: (this: *b3Serializer) -> void #cpp_method;

    findNameForPointer: (this: *b3Serializer, ptr: *void) -> *u8 #cpp_method;

    registerNameForPointer: (this: *b3Serializer, ptr: *void, name: *u8) -> void #cpp_method;

    serializeName: (this: *b3Serializer, ptr: *u8) -> void #cpp_method;

    getSerializationFlags: (this: *b3Serializer) -> s32 #cpp_method;

    setSerializationFlags: (this: *b3Serializer, flags: s32) -> void #cpp_method;
}

b3Serializer_Destructor :: inline (this: *b3Serializer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

b3Serializer_getBufferPointer :: inline (this: *b3Serializer) -> *u8 { return this.vtable.getBufferPointer(this); }

b3Serializer_getCurrentBufferSize :: inline (this: *b3Serializer) -> s32 { return this.vtable.getCurrentBufferSize(this); }

b3Serializer_allocate :: inline (this: *b3Serializer, size: size_t, numElements: s32) -> *b3Chunk { return this.vtable.allocate(this, size, numElements); }

b3Serializer_finalizeChunk :: inline (this: *b3Serializer, chunk: *b3Chunk, structType: *u8, chunkCode: s32, oldPtr: *void) { this.vtable.finalizeChunk(this, chunk, structType, chunkCode, oldPtr); }

b3Serializer_findPointer :: inline (this: *b3Serializer, oldPtr: *void) -> *void { return this.vtable.findPointer(this, oldPtr); }

b3Serializer_getUniquePointer :: inline (this: *b3Serializer, oldPtr: *void) -> *void { return this.vtable.getUniquePointer(this, oldPtr); }

b3Serializer_startSerialization :: inline (this: *b3Serializer) { this.vtable.startSerialization(this); }

b3Serializer_finishSerialization :: inline (this: *b3Serializer) { this.vtable.finishSerialization(this); }

b3Serializer_findNameForPointer :: inline (this: *b3Serializer, ptr: *void) -> *u8 { return this.vtable.findNameForPointer(this, ptr); }

b3Serializer_registerNameForPointer :: inline (this: *b3Serializer, ptr: *void, name: *u8) { this.vtable.registerNameForPointer(this, ptr, name); }

b3Serializer_serializeName :: inline (this: *b3Serializer, ptr: *u8) { this.vtable.serializeName(this, ptr); }

b3Serializer_getSerializationFlags :: inline (this: *b3Serializer) -> s32 { return this.vtable.getSerializationFlags(this); }

b3Serializer_setSerializationFlags :: inline (this: *b3Serializer, flags: s32) { this.vtable.setSerializationFlags(this, flags); }



b3PointerUid :: struct {
    union {
        m_ptr:       *void;
        m_uniqueIds: [2] s32;
    }
}

///The b3DefaultSerializer is the main Bullet serialization class.
///The constructor takes an optional argument for backwards compatibility, it is recommended to leave this empty/zero.
b3DefaultSerializer :: struct {
    #as using b3serializer: b3Serializer;

    mTypes:               b3AlignedObjectArray(*u8);
    mStructs:             b3AlignedObjectArray(*s16);
    mTlens:               b3AlignedObjectArray(s16);
    mStructReverse:       b3HashMap(b3HashInt, s32);
    mTypeLookup:          b3HashMap(b3HashString, s32);

    m_chunkP:             b3HashMap(b3HashPtr, *void);

    m_nameMap:            b3HashMap(b3HashPtr, *u8);

    m_uniquePointers:     b3HashMap(b3HashPtr, b3PointerUid);
    m_uniqueIdGenerator:  s32;

    m_totalSize:          s32;
    m_buffer:             *u8;
    m_currentSize:        s32;
    m_dna:                *void;
    m_dnaLength:          s32;

    m_serializationFlags: s32;

    m_chunkPtrs:          b3AlignedObjectArray(*b3Chunk);

    writeDNA :: (this: *b3DefaultSerializer) -> void #cpp_method #foreign bullet3 "?writeDNA@b3DefaultSerializer@@IEAAXXZ";

    getReverseType :: (this: *b3DefaultSerializer, type: *u8) -> s32 #cpp_method #foreign bullet3 "?getReverseType@b3DefaultSerializer@@IEBAHPEBD@Z";

    initDNA :: (this: *b3DefaultSerializer, bdnaOrg: *u8, dnalen: s32) -> void #cpp_method #foreign bullet3 "?initDNA@b3DefaultSerializer@@IEAAXPEBDH@Z";

    Constructor :: (this: *b3DefaultSerializer, totalSize: s32 = 0) -> void #cpp_method #foreign bullet3 "??0b3DefaultSerializer@@QEAA@H@Z";

    writeHeader :: (this: *b3DefaultSerializer, buffer: *u8) -> void #cpp_method #foreign bullet3 "?writeHeader@b3DefaultSerializer@@QEBAXPEAE@Z";
    #place b3serializer; b3defaultserializer_vtable: *b3DefaultSerializer_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_findPointer :: (this: *b3DefaultSerializer, oldPtr: *void) -> *void #cpp_method #foreign bullet3 "?findPointer@b3DefaultSerializer@@MEAAPEAXPEAX@Z";

    virtual_Destructor :: (this: *b3DefaultSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1b3DefaultSerializer@@UEAA@XZ";

    virtual_startSerialization :: (this: *b3DefaultSerializer) -> void #cpp_method #foreign bullet3 "?startSerialization@b3DefaultSerializer@@UEAAXXZ";

    virtual_finishSerialization :: (this: *b3DefaultSerializer) -> void #cpp_method #foreign bullet3 "?finishSerialization@b3DefaultSerializer@@UEAAXXZ";

    virtual_getUniquePointer :: (this: *b3DefaultSerializer, oldPtr: *void) -> *void #cpp_method #foreign bullet3 "?getUniquePointer@b3DefaultSerializer@@UEAAPEAXPEAX@Z";

    virtual_getBufferPointer :: (this: *b3DefaultSerializer) -> *u8 #cpp_method #foreign bullet3 "?getBufferPointer@b3DefaultSerializer@@UEBAPEBEXZ";

    virtual_getCurrentBufferSize :: (this: *b3DefaultSerializer) -> s32 #cpp_method #foreign bullet3 "?getCurrentBufferSize@b3DefaultSerializer@@UEBAHXZ";

    virtual_finalizeChunk :: (this: *b3DefaultSerializer, chunk: *b3Chunk, structType: *u8, chunkCode: s32, oldPtr: *void) -> void #cpp_method #foreign bullet3 "?finalizeChunk@b3DefaultSerializer@@UEAAXPEAVb3Chunk@@PEBDHPEAX@Z";

    virtual_internalAlloc :: (this: *b3DefaultSerializer, size: size_t) -> *u8 #cpp_method #foreign bullet3 "?internalAlloc@b3DefaultSerializer@@UEAAPEAE_K@Z";

    virtual_allocate :: (this: *b3DefaultSerializer, size: size_t, numElements: s32) -> *b3Chunk #cpp_method #foreign bullet3 "?allocate@b3DefaultSerializer@@UEAAPEAVb3Chunk@@_KH@Z";

    virtual_findNameForPointer :: (this: *b3DefaultSerializer, ptr: *void) -> *u8 #cpp_method #foreign bullet3 "?findNameForPointer@b3DefaultSerializer@@UEBAPEBDPEBX@Z";

    virtual_registerNameForPointer :: (this: *b3DefaultSerializer, ptr: *void, name: *u8) -> void #cpp_method #foreign bullet3 "?registerNameForPointer@b3DefaultSerializer@@UEAAXPEBXPEBD@Z";

    virtual_serializeName :: (this: *b3DefaultSerializer, name: *u8) -> void #cpp_method #foreign bullet3 "?serializeName@b3DefaultSerializer@@UEAAXPEBD@Z";

    virtual_getSerializationFlags :: (this: *b3DefaultSerializer) -> s32 #cpp_method #foreign bullet3 "?getSerializationFlags@b3DefaultSerializer@@UEBAHXZ";

    virtual_setSerializationFlags :: (this: *b3DefaultSerializer, flags: s32) -> void #cpp_method #foreign bullet3 "?setSerializationFlags@b3DefaultSerializer@@UEAAXH@Z";
}
b3DefaultSerializer_VTable :: struct #type_info_none {
    using b3serializer: b3Serializer_VTable;
    internalAlloc: (this: *b3DefaultSerializer, size: size_t) -> *u8 #cpp_method;
}
b3DefaultSerializer_internalAlloc :: inline (this: *b3DefaultSerializer, size: size_t) -> *u8 { return this.b3defaultserializer_vtable.internalAlloc(this, size); }

vtable :: (obj: *b3DefaultSerializer) -> *b3DefaultSerializer_VTable { return obj.b3defaultserializer_vtable; }


///box-box collision detection
btBox2dBox2dCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_ownManifold: bool;
    m_manifoldPtr: *btPersistentManifold;

    Constructor :: (this: *btBox2dBox2dCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btBox2dBox2dCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btBox2dBox2dCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    Constructor :: (this: *btBox2dBox2dCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btBox2dBox2dCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z";
    Constructor :: (this: *btBox2dBox2dCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processCollision :: (this: *btBox2dBox2dCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btBox2dBox2dCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btBox2dBox2dCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btBox2dBox2dCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_Destructor :: (this: *btBox2dBox2dCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBox2dBox2dCollisionAlgorithm@@UEAA@XZ";

    virtual_getAllContactManifolds :: (this: *btBox2dBox2dCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btBox2dBox2dCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

///box-box collision detection
btBoxBoxCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_ownManifold: bool;
    m_manifoldPtr: *btPersistentManifold;

    Constructor :: (this: *btBoxBoxCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btBoxBoxCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btBoxBoxCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    Constructor :: (this: *btBoxBoxCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btBoxBoxCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2@Z";
    Constructor :: (this: *btBoxBoxCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processCollision :: (this: *btBoxBoxCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btBoxBoxCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btBoxBoxCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btBoxBoxCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_Destructor :: (this: *btBoxBoxCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBoxBoxCollisionAlgorithm@@UEAA@XZ";

    virtual_getAllContactManifolds :: (this: *btBoxBoxCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btBoxBoxCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

/// btBoxBoxDetector wraps the ODE box-box collision detector
/// re-distributed under the Zlib license with permission from Russell L. Smith
btBoxBoxDetector :: struct {
    #as using btdiscretecollisiondetectorinterface: btDiscreteCollisionDetectorInterface;

    m_box1: *btBoxShape;
    m_box2: *btBoxShape;

    Constructor :: (this: *btBoxBoxDetector, box1: *btBoxShape, box2: *btBoxShape) -> void #cpp_method #foreign bullet3 "??0btBoxBoxDetector@@QEAA@PEBVbtBoxShape@@0@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btBoxBoxDetector, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btBoxBoxDetector@@UEAA@XZ";

    virtual_getClosestPoints :: (this: *btBoxBoxDetector, input: *btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw, swapResults := false) -> void #cpp_method #foreign bullet3 "?getClosestPoints@btBoxBoxDetector@@UEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@_N@Z";
}

btCollisionDispatcherMt :: struct {
    #as using btcollisiondispatcher: btCollisionDispatcher;

    Constructor :: (this: *btCollisionDispatcherMt, config: *btCollisionConfiguration, grainSize: s32 = 40) -> void #cpp_method #foreign bullet3 "??0btCollisionDispatcherMt@@QEAA@PEAVbtCollisionConfiguration@@H@Z";

    m_batchManifoldsPtr: btAlignedObjectArray(btAlignedObjectArray(*btPersistentManifold));
    m_batchReleasePtr:   btAlignedObjectArray(btAlignedObjectArray(*btPersistentManifold));
    m_batchUpdating:     bool;
    m_grainSize:         s32;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getNewManifold :: (this: *btCollisionDispatcherMt, body0: *btCollisionObject, body1: *btCollisionObject) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getNewManifold@btCollisionDispatcherMt@@UEAAPEAVbtPersistentManifold@@PEBVbtCollisionObject@@0@Z";
    virtual_releaseManifold :: (this: *btCollisionDispatcherMt, manifold: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "?releaseManifold@btCollisionDispatcherMt@@UEAAXPEAVbtPersistentManifold@@@Z";

    virtual_dispatchAllCollisionPairs :: (this: *btCollisionDispatcherMt, pairCache: *btOverlappingPairCache, info: *btDispatcherInfo, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?dispatchAllCollisionPairs@btCollisionDispatcherMt@@UEAAXPEAVbtOverlappingPairCache@@AEBUbtDispatcherInfo@@PEAVbtDispatcher@@@Z";
}

ConstraintInput :: struct {}

btCollisionWorldImporter :: struct {
    vtable: *btCollisionWorldImporter_VTable;
    m_collisionWorld:                        *btCollisionWorld;

    m_verboseMode:                           s32;

    m_allocatedCollisionShapes:              btAlignedObjectArray(*btCollisionShape);
    m_allocatedRigidBodies:                  btAlignedObjectArray(*btCollisionObject);

    m_allocatedBvhs:                         btAlignedObjectArray(*btOptimizedBvh);
    m_allocatedTriangleInfoMaps:             btAlignedObjectArray(*btTriangleInfoMap);
    m_allocatedTriangleIndexArrays:          btAlignedObjectArray(*btTriangleIndexVertexArray);
    m_allocatedbtStridingMeshInterfaceDatas: btAlignedObjectArray(*btStridingMeshInterfaceData);
    m_allocatedCollisionObjects:             btAlignedObjectArray(*btCollisionObject);

    m_allocatedNames:                        btAlignedObjectArray(*u8);

    m_indexArrays:                           btAlignedObjectArray(*s32);
    m_shortIndexArrays:                      btAlignedObjectArray(*s16);
    m_charIndexArrays:                       btAlignedObjectArray(*u8);

    m_floatVertexArrays:                     btAlignedObjectArray(*btVector3FloatData);
    m_doubleVertexArrays:                    btAlignedObjectArray(*btVector3DoubleData);

    m_bvhMap:                                btHashMap(btHashPtr, *btOptimizedBvh);
    m_timMap:                                btHashMap(btHashPtr, *btTriangleInfoMap);

    m_nameShapeMap:                          btHashMap(btHashString, *btCollisionShape);
    m_nameColObjMap:                         btHashMap(btHashString, *btCollisionObject);

    m_objectNameMap:                         btHashMap(btHashPtr, *u8);

    m_shapeMap:                              btHashMap(btHashPtr, *btCollisionShape);
    m_bodyMap:                               btHashMap(btHashPtr, *btCollisionObject);

    //methods
    duplicateName :: (this: *btCollisionWorldImporter, name: *u8) -> *u8 #cpp_method #foreign bullet3 "?duplicateName@btCollisionWorldImporter@@IEAAPEADPEBD@Z";

    convertCollisionShape :: (this: *btCollisionWorldImporter, shapeData: *btCollisionShapeData) -> *btCollisionShape #cpp_method #foreign bullet3 "?convertCollisionShape@btCollisionWorldImporter@@IEAAPEAVbtCollisionShape@@PEAUbtCollisionShapeData@@@Z";

    Constructor :: (this: *btCollisionWorldImporter, world: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "??0btCollisionWorldImporter@@QEAA@PEAVbtCollisionWorld@@@Z";

    convertAllObjects :: (this: *btCollisionWorldImporter, arrays: *btBulletSerializedArrays) -> bool #cpp_method #foreign bullet3 "?convertAllObjects@btCollisionWorldImporter@@QEAA_NPEAUbtBulletSerializedArrays@@@Z";

    setVerboseMode :: (this: *btCollisionWorldImporter, verboseMode: s32) -> void #cpp_method #foreign bullet3 "?setVerboseMode@btCollisionWorldImporter@@QEAAXH@Z";

    getVerboseMode :: (this: *btCollisionWorldImporter) -> s32 #cpp_method #foreign bullet3 "?getVerboseMode@btCollisionWorldImporter@@QEBAHXZ";

    // query for data
    getNumCollisionShapes :: (this: *btCollisionWorldImporter) -> s32 #cpp_method #foreign bullet3 "?getNumCollisionShapes@btCollisionWorldImporter@@QEBAHXZ";
    getCollisionShapeByIndex :: (this: *btCollisionWorldImporter, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShapeByIndex@btCollisionWorldImporter@@QEAAPEAVbtCollisionShape@@H@Z";
    getNumRigidBodies :: (this: *btCollisionWorldImporter) -> s32 #cpp_method #foreign bullet3 "?getNumRigidBodies@btCollisionWorldImporter@@QEBAHXZ";
    getRigidBodyByIndex :: (this: *btCollisionWorldImporter, index: s32) -> *btCollisionObject #cpp_method #foreign bullet3 "?getRigidBodyByIndex@btCollisionWorldImporter@@QEBAPEAVbtCollisionObject@@H@Z";

    getNumBvhs :: (this: *btCollisionWorldImporter) -> s32 #cpp_method #foreign bullet3 "?getNumBvhs@btCollisionWorldImporter@@QEBAHXZ";
    getBvhByIndex :: (this: *btCollisionWorldImporter, index: s32) -> *btOptimizedBvh #cpp_method #foreign bullet3 "?getBvhByIndex@btCollisionWorldImporter@@QEBAPEAVbtOptimizedBvh@@H@Z";
    getNumTriangleInfoMaps :: (this: *btCollisionWorldImporter) -> s32 #cpp_method #foreign bullet3 "?getNumTriangleInfoMaps@btCollisionWorldImporter@@QEBAHXZ";
    getTriangleInfoMapByIndex :: (this: *btCollisionWorldImporter, index: s32) -> *btTriangleInfoMap #cpp_method #foreign bullet3 "?getTriangleInfoMapByIndex@btCollisionWorldImporter@@QEBAPEAUbtTriangleInfoMap@@H@Z";

    // queris involving named objects
    getCollisionShapeByName :: (this: *btCollisionWorldImporter, name: *u8) -> *btCollisionShape #cpp_method #foreign bullet3 "?getCollisionShapeByName@btCollisionWorldImporter@@QEAAPEAVbtCollisionShape@@PEBD@Z";
    getCollisionObjectByName :: (this: *btCollisionWorldImporter, name: *u8) -> *btCollisionObject #cpp_method #foreign bullet3 "?getCollisionObjectByName@btCollisionWorldImporter@@QEAAPEAVbtCollisionObject@@PEBD@Z";

    getNameForPointer :: (this: *btCollisionWorldImporter, ptr: *void) -> *u8 #cpp_method #foreign bullet3 "?getNameForPointer@btCollisionWorldImporter@@QEBAPEBDPEBX@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCollisionWorldImporter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCollisionWorldImporter@@UEAA@XZ";

    ///delete all memory collision shapes, rigid bodies, constraints etc. allocated during the load.
    ///make sure you don't use the dynamics world containing objects after you call this method
    virtual_deleteAllData :: (this: *btCollisionWorldImporter) -> void #cpp_method #foreign bullet3 "?deleteAllData@btCollisionWorldImporter@@UEAAXXZ";

    //bodies
    virtual_createCollisionObject :: (this: *btCollisionWorldImporter, startTransform: *btTransform, shape: *btCollisionShape, bodyName: *u8) -> *btCollisionObject #cpp_method #foreign bullet3 "?createCollisionObject@btCollisionWorldImporter@@UEAAPEAVbtCollisionObject@@AEBVbtTransform@@PEAVbtCollisionShape@@PEBD@Z";

    ///shapes
    virtual_createPlaneShape :: (this: *btCollisionWorldImporter, planeNormal: *btVector3, planeConstant: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createPlaneShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@AEBVbtVector3@@M@Z";
    virtual_createBoxShape :: (this: *btCollisionWorldImporter, halfExtents: *btVector3) -> *btCollisionShape #cpp_method #foreign bullet3 "?createBoxShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@AEBVbtVector3@@@Z";
    virtual_createSphereShape :: (this: *btCollisionWorldImporter, radius: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createSphereShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@M@Z";
    virtual_createCapsuleShapeX :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createCapsuleShapeX@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createCapsuleShapeY :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createCapsuleShapeY@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createCapsuleShapeZ :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createCapsuleShapeZ@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";

    virtual_createCylinderShapeX :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createCylinderShapeX@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createCylinderShapeY :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createCylinderShapeY@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createCylinderShapeZ :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createCylinderShapeZ@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createConeShapeX :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createConeShapeX@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createConeShapeY :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createConeShapeY@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createConeShapeZ :: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method #foreign bullet3 "?createConeShapeZ@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@MM@Z";
    virtual_createTriangleMeshContainer :: (this: *btCollisionWorldImporter) -> *btTriangleIndexVertexArray #cpp_method #foreign bullet3 "?createTriangleMeshContainer@btCollisionWorldImporter@@UEAAPEAVbtTriangleIndexVertexArray@@XZ";
    virtual_createBvhTriangleMeshShape :: (this: *btCollisionWorldImporter, trimesh: *btStridingMeshInterface, bvh: *btOptimizedBvh) -> *btBvhTriangleMeshShape #cpp_method #foreign bullet3 "?createBvhTriangleMeshShape@btCollisionWorldImporter@@UEAAPEAVbtBvhTriangleMeshShape@@PEAVbtStridingMeshInterface@@PEAVbtOptimizedBvh@@@Z";
    virtual_createConvexTriangleMeshShape :: (this: *btCollisionWorldImporter, trimesh: *btStridingMeshInterface) -> *btCollisionShape #cpp_method #foreign bullet3 "?createConvexTriangleMeshShape@btCollisionWorldImporter@@UEAAPEAVbtCollisionShape@@PEAVbtStridingMeshInterface@@@Z";

    virtual_createStridingMeshInterfaceData :: (this: *btCollisionWorldImporter, interfaceData: *btStridingMeshInterfaceData) -> *btStridingMeshInterfaceData #cpp_method #foreign bullet3 "?createStridingMeshInterfaceData@btCollisionWorldImporter@@UEAAPEAUbtStridingMeshInterfaceData@@PEAU2@@Z";

    virtual_createConvexHullShape :: (this: *btCollisionWorldImporter) -> *btConvexHullShape #cpp_method #foreign bullet3 "?createConvexHullShape@btCollisionWorldImporter@@UEAAPEAVbtConvexHullShape@@XZ";
    virtual_createCompoundShape :: (this: *btCollisionWorldImporter) -> *btCompoundShape #cpp_method #foreign bullet3 "?createCompoundShape@btCollisionWorldImporter@@UEAAPEAVbtCompoundShape@@XZ";
    virtual_createScaledTrangleMeshShape :: (this: *btCollisionWorldImporter, meshShape: *btBvhTriangleMeshShape, localScalingbtBvhTriangleMeshShape: *btVector3) -> *btScaledBvhTriangleMeshShape #cpp_method #foreign bullet3 "?createScaledTrangleMeshShape@btCollisionWorldImporter@@UEAAPEAVbtScaledBvhTriangleMeshShape@@PEAVbtBvhTriangleMeshShape@@AEBVbtVector3@@@Z";

    virtual_createMultiSphereShape :: (this: *btCollisionWorldImporter, positions: *btVector3, radi: *btScalar, numSpheres: s32) -> *btMultiSphereShape #cpp_method #foreign bullet3 "?createMultiSphereShape@btCollisionWorldImporter@@UEAAPEAVbtMultiSphereShape@@PEBVbtVector3@@PEBMH@Z";

    virtual_createMeshInterface :: (this: *btCollisionWorldImporter, meshData: *btStridingMeshInterfaceData) -> *btTriangleIndexVertexArray #cpp_method #foreign bullet3 "?createMeshInterface@btCollisionWorldImporter@@UEAAPEAVbtTriangleIndexVertexArray@@AEAUbtStridingMeshInterfaceData@@@Z";

    ///acceleration and connectivity structures
    virtual_createOptimizedBvh :: (this: *btCollisionWorldImporter) -> *btOptimizedBvh #cpp_method #foreign bullet3 "?createOptimizedBvh@btCollisionWorldImporter@@UEAAPEAVbtOptimizedBvh@@XZ";
    virtual_createTriangleInfoMap :: (this: *btCollisionWorldImporter) -> *btTriangleInfoMap #cpp_method #foreign bullet3 "?createTriangleInfoMap@btCollisionWorldImporter@@UEAAPEAUbtTriangleInfoMap@@XZ";
}
btCollisionWorldImporter_VTable :: struct #type_info_none {
    Destructor: (this: *btCollisionWorldImporter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    deleteAllData: (this: *btCollisionWorldImporter) -> void #cpp_method;

    createCollisionObject: (this: *btCollisionWorldImporter, startTransform: *btTransform, shape: *btCollisionShape, bodyName: *u8) -> *btCollisionObject #cpp_method;

    createPlaneShape: (this: *btCollisionWorldImporter, planeNormal: *btVector3, planeConstant: btScalar) -> *btCollisionShape #cpp_method;
    createBoxShape: (this: *btCollisionWorldImporter, halfExtents: *btVector3) -> *btCollisionShape #cpp_method;
    createSphereShape: (this: *btCollisionWorldImporter, radius: btScalar) -> *btCollisionShape #cpp_method;
    createCapsuleShapeX: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createCapsuleShapeY: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createCapsuleShapeZ: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;

    createCylinderShapeX: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createCylinderShapeY: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createCylinderShapeZ: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createConeShapeX: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createConeShapeY: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createConeShapeZ: (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape #cpp_method;
    createTriangleMeshContainer: (this: *btCollisionWorldImporter) -> *btTriangleIndexVertexArray #cpp_method;
    createBvhTriangleMeshShape: (this: *btCollisionWorldImporter, trimesh: *btStridingMeshInterface, bvh: *btOptimizedBvh) -> *btBvhTriangleMeshShape #cpp_method;
    createConvexTriangleMeshShape: (this: *btCollisionWorldImporter, trimesh: *btStridingMeshInterface) -> *btCollisionShape #cpp_method;

    createStridingMeshInterfaceData: (this: *btCollisionWorldImporter, interfaceData: *btStridingMeshInterfaceData) -> *btStridingMeshInterfaceData #cpp_method;

    createConvexHullShape: (this: *btCollisionWorldImporter) -> *btConvexHullShape #cpp_method;
    createCompoundShape: (this: *btCollisionWorldImporter) -> *btCompoundShape #cpp_method;
    createScaledTrangleMeshShape: (this: *btCollisionWorldImporter, meshShape: *btBvhTriangleMeshShape, localScalingbtBvhTriangleMeshShape: *btVector3) -> *btScaledBvhTriangleMeshShape #cpp_method;

    createMultiSphereShape: (this: *btCollisionWorldImporter, positions: *btVector3, radi: *btScalar, numSpheres: s32) -> *btMultiSphereShape #cpp_method;

    createMeshInterface: (this: *btCollisionWorldImporter, meshData: *btStridingMeshInterfaceData) -> *btTriangleIndexVertexArray #cpp_method;

    createOptimizedBvh: (this: *btCollisionWorldImporter) -> *btOptimizedBvh #cpp_method;
    createTriangleInfoMap: (this: *btCollisionWorldImporter) -> *btTriangleInfoMap #cpp_method;
}

btCollisionWorldImporter_Destructor :: inline (this: *btCollisionWorldImporter, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCollisionWorldImporter_deleteAllData :: inline (this: *btCollisionWorldImporter) { this.vtable.deleteAllData(this); }

btCollisionWorldImporter_createCollisionObject :: inline (this: *btCollisionWorldImporter, startTransform: *btTransform, shape: *btCollisionShape, bodyName: *u8) -> *btCollisionObject { return this.vtable.createCollisionObject(this, startTransform, shape, bodyName); }

btCollisionWorldImporter_createPlaneShape :: inline (this: *btCollisionWorldImporter, planeNormal: *btVector3, planeConstant: btScalar) -> *btCollisionShape { return this.vtable.createPlaneShape(this, planeNormal, planeConstant); }
btCollisionWorldImporter_createBoxShape :: inline (this: *btCollisionWorldImporter, halfExtents: *btVector3) -> *btCollisionShape { return this.vtable.createBoxShape(this, halfExtents); }
btCollisionWorldImporter_createSphereShape :: inline (this: *btCollisionWorldImporter, radius: btScalar) -> *btCollisionShape { return this.vtable.createSphereShape(this, radius); }
btCollisionWorldImporter_createCapsuleShapeX :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createCapsuleShapeX(this, radius, height); }
btCollisionWorldImporter_createCapsuleShapeY :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createCapsuleShapeY(this, radius, height); }
btCollisionWorldImporter_createCapsuleShapeZ :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createCapsuleShapeZ(this, radius, height); }

btCollisionWorldImporter_createCylinderShapeX :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createCylinderShapeX(this, radius, height); }
btCollisionWorldImporter_createCylinderShapeY :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createCylinderShapeY(this, radius, height); }
btCollisionWorldImporter_createCylinderShapeZ :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createCylinderShapeZ(this, radius, height); }
btCollisionWorldImporter_createConeShapeX :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createConeShapeX(this, radius, height); }
btCollisionWorldImporter_createConeShapeY :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createConeShapeY(this, radius, height); }
btCollisionWorldImporter_createConeShapeZ :: inline (this: *btCollisionWorldImporter, radius: btScalar, height: btScalar) -> *btCollisionShape { return this.vtable.createConeShapeZ(this, radius, height); }
btCollisionWorldImporter_createTriangleMeshContainer :: inline (this: *btCollisionWorldImporter) -> *btTriangleIndexVertexArray { return this.vtable.createTriangleMeshContainer(this); }
btCollisionWorldImporter_createBvhTriangleMeshShape :: inline (this: *btCollisionWorldImporter, trimesh: *btStridingMeshInterface, bvh: *btOptimizedBvh) -> *btBvhTriangleMeshShape { return this.vtable.createBvhTriangleMeshShape(this, trimesh, bvh); }
btCollisionWorldImporter_createConvexTriangleMeshShape :: inline (this: *btCollisionWorldImporter, trimesh: *btStridingMeshInterface) -> *btCollisionShape { return this.vtable.createConvexTriangleMeshShape(this, trimesh); }

btCollisionWorldImporter_createStridingMeshInterfaceData :: inline (this: *btCollisionWorldImporter, interfaceData: *btStridingMeshInterfaceData) -> *btStridingMeshInterfaceData { return this.vtable.createStridingMeshInterfaceData(this, interfaceData); }

btCollisionWorldImporter_createConvexHullShape :: inline (this: *btCollisionWorldImporter) -> *btConvexHullShape { return this.vtable.createConvexHullShape(this); }
btCollisionWorldImporter_createCompoundShape :: inline (this: *btCollisionWorldImporter) -> *btCompoundShape { return this.vtable.createCompoundShape(this); }
btCollisionWorldImporter_createScaledTrangleMeshShape :: inline (this: *btCollisionWorldImporter, meshShape: *btBvhTriangleMeshShape, localScalingbtBvhTriangleMeshShape: *btVector3) -> *btScaledBvhTriangleMeshShape { return this.vtable.createScaledTrangleMeshShape(this, meshShape, localScalingbtBvhTriangleMeshShape); }

btCollisionWorldImporter_createMultiSphereShape :: inline (this: *btCollisionWorldImporter, positions: *btVector3, radi: *btScalar, numSpheres: s32) -> *btMultiSphereShape { return this.vtable.createMultiSphereShape(this, positions, radi, numSpheres); }

btCollisionWorldImporter_createMeshInterface :: inline (this: *btCollisionWorldImporter, meshData: *btStridingMeshInterfaceData) -> *btTriangleIndexVertexArray { return this.vtable.createMeshInterface(this, meshData); }

btCollisionWorldImporter_createOptimizedBvh :: inline (this: *btCollisionWorldImporter) -> *btOptimizedBvh { return this.vtable.createOptimizedBvh(this); }
btCollisionWorldImporter_createTriangleInfoMap :: inline (this: *btCollisionWorldImporter) -> *btTriangleInfoMap { return this.vtable.createTriangleInfoMap(this); }



btShapePairCallback :: #type (pShape0: *btCollisionShape, pShape1: *btCollisionShape) -> bool #c_call;

/// btCompoundCollisionAlgorithm  supports collision between CompoundCollisionShapes and other collision shapes
btCompoundCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    stack2:                     btNodeStack;
    manifoldArray:              btManifoldArray;

    m_childCollisionAlgorithms: btAlignedObjectArray(*btCollisionAlgorithm);
    m_isSwapped:                bool;

    m_sharedManifold:           *btPersistentManifold;
    m_ownsManifold:             bool;

    m_compoundShapeRevision:    s32; //to keep track of changes, so that childAlgorithm array can be updated

    removeChildAlgorithms :: (this: *btCompoundCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?removeChildAlgorithms@btCompoundCollisionAlgorithm@@IEAAXXZ";

    preallocateChildAlgorithms :: (this: *btCompoundCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?preallocateChildAlgorithms@btCompoundCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0@Z";

    Constructor :: (this: *btCompoundCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btCompoundCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z";
    Constructor :: (this: *btCompoundCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) #no_context {
        Constructor(this, *ci, body0Wrap, body1Wrap, isSwapped);
    }

    getChildAlgorithm :: (this: *btCompoundCollisionAlgorithm, n: s32) -> *btCollisionAlgorithm #cpp_method #foreign bullet3 "?getChildAlgorithm@btCompoundCollisionAlgorithm@@QEBAPEAVbtCollisionAlgorithm@@H@Z";

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    SwappedCreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCompoundCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCompoundCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btCompoundCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btCompoundCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btCompoundCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btCompoundCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btCompoundCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btCompoundCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

btSimplePair :: struct {
    Constructor :: (this: *btSimplePair, indexA: s32, indexB: s32) -> void #cpp_method #foreign bullet3 "??0btSimplePair@@QEAA@HH@Z";

    m_indexA: s32;
    m_indexB: s32;
    union {
        m_userPointer: *void;
        m_userValue:   s32;
    }
}

btSimplePairArray :: btAlignedObjectArray(btSimplePair);

btHashedSimplePairCache :: struct {
    vtable: *btHashedSimplePairCache_VTable;
    m_overlappingPairArray: btSimplePairArray;

    m_hashTable:            btAlignedObjectArray(s32);
    m_next:                 btAlignedObjectArray(s32);

    Constructor :: (this: *btHashedSimplePairCache) -> void #cpp_method #foreign bullet3 "??0btHashedSimplePairCache@@QEAA@XZ";

    removeAllPairs :: (this: *btHashedSimplePairCache) -> void #cpp_method #foreign bullet3 "?removeAllPairs@btHashedSimplePairCache@@QEAAXXZ";

    getOverlappingPairArrayPtr :: (this: /*const*/ *btHashedSimplePairCache) -> *btSimplePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btHashedSimplePairCache@@QEBAPEBUbtSimplePair@@XZ";

    getOverlappingPairArray :: (this: *btHashedSimplePairCache) -> *btSimplePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btHashedSimplePairCache@@QEAAAEAV?$btAlignedObjectArray@UbtSimplePair@@@@XZ";

    getOverlappingPairArray_1 :: (this: /*const*/ *btHashedSimplePairCache) -> *btSimplePairArray #cpp_method #foreign bullet3 "?getOverlappingPairArray@btHashedSimplePairCache@@QEBAAEBV?$btAlignedObjectArray@UbtSimplePair@@@@XZ";

    findPair :: (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *btSimplePair #cpp_method #foreign bullet3 "?findPair@btHashedSimplePairCache@@QEAAPEAUbtSimplePair@@HH@Z";

    GetCount :: (this: *btHashedSimplePairCache) -> s32 #cpp_method #foreign bullet3 "?GetCount@btHashedSimplePairCache@@QEBAHXZ";

    getNumOverlappingPairs :: (this: *btHashedSimplePairCache) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingPairs@btHashedSimplePairCache@@QEBAHXZ";

    internalAddPair :: (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *btSimplePair #cpp_method #foreign bullet3 "?internalAddPair@btHashedSimplePairCache@@AEAAPEAUbtSimplePair@@HH@Z";

    growTables :: (this: *btHashedSimplePairCache) -> void #cpp_method #foreign bullet3 "?growTables@btHashedSimplePairCache@@AEAAXXZ";

    equalsPair :: (this: *btHashedSimplePairCache, pair: *btSimplePair, indexA: s32, indexB: s32) -> bool #cpp_method #foreign bullet3 "?equalsPair@btHashedSimplePairCache@@AEAA_NAEBUbtSimplePair@@HH@Z";
    equalsPair :: (this: *btHashedSimplePairCache, pair: btSimplePair, indexA: s32, indexB: s32) -> bool #no_context {
        return equalsPair(this, *pair, indexA, indexB);
    }

    getHash :: (this: *btHashedSimplePairCache, indexA: u32, indexB: u32) -> u32 #cpp_method #foreign bullet3 "?getHash@btHashedSimplePairCache@@AEAAIII@Z";

    internalFindPair :: (this: *btHashedSimplePairCache, proxyIdA: s32, proxyIdB: s32, hash: s32) -> *btSimplePair #cpp_method #foreign bullet3 "?internalFindPair@btHashedSimplePairCache@@AEAAPEAUbtSimplePair@@HHH@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btHashedSimplePairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btHashedSimplePairCache@@UEAA@XZ";

    virtual_removeOverlappingPair :: (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@btHashedSimplePairCache@@UEAAPEAXHH@Z";

    // Add a pair and return the new pair. If the pair already exists,
    // no new pair is created and the old one is returned.
    virtual_addOverlappingPair :: (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *btSimplePair #cpp_method #foreign bullet3 "?addOverlappingPair@btHashedSimplePairCache@@UEAAPEAUbtSimplePair@@HH@Z";

    virtual_getOverlappingPairArrayPtr_1 :: (this: *btHashedSimplePairCache) -> *btSimplePair #cpp_method #foreign bullet3 "?getOverlappingPairArrayPtr@btHashedSimplePairCache@@UEAAPEAUbtSimplePair@@XZ";
}
btHashedSimplePairCache_VTable :: struct #type_info_none {
    Destructor: (this: *btHashedSimplePairCache, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    removeOverlappingPair: (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *void #cpp_method;

    addOverlappingPair: (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *btSimplePair #cpp_method;

    getOverlappingPairArrayPtr_1: (this: *btHashedSimplePairCache) -> *btSimplePair #cpp_method;
}

btHashedSimplePairCache_Destructor :: inline (this: *btHashedSimplePairCache, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btHashedSimplePairCache_removeOverlappingPair :: inline (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *void { return this.vtable.removeOverlappingPair(this, indexA, indexB); }

btHashedSimplePairCache_addOverlappingPair :: inline (this: *btHashedSimplePairCache, indexA: s32, indexB: s32) -> *btSimplePair { return this.vtable.addOverlappingPair(this, indexA, indexB); }

btHashedSimplePairCache_getOverlappingPairArrayPtr_1 :: inline (this: *btHashedSimplePairCache) -> *btSimplePair { return this.vtable.getOverlappingPairArrayPtr_1(this); }



/// btCompoundCompoundCollisionAlgorithm  supports collision between two btCompoundCollisionShape shapes
btCompoundCompoundCollisionAlgorithm :: struct {
    #as btcompoundcollisionalgorithm: btCompoundCollisionAlgorithm; // jai: no "using" to avoid name-clashes

    m_childCollisionAlgorithmCache: *btHashedSimplePairCache;
    m_removePairs:                  btSimplePairArray;

    m_compoundShapeRevision0:       s32; //to keep track of changes, so that childAlgorithm array can be updated
    m_compoundShapeRevision1:       s32;

    removeChildAlgorithms :: (this: *btCompoundCompoundCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?removeChildAlgorithms@btCompoundCompoundCollisionAlgorithm@@AEAAXXZ";

    //	void	preallocateChildAlgorithms(const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap);
    Constructor :: (this: *btCompoundCompoundCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btCompoundCompoundCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z";
    Constructor :: (this: *btCompoundCompoundCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) #no_context {
        Constructor(this, *ci, body0Wrap, body1Wrap, isSwapped);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    SwappedCreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btCompoundCompoundCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCompoundCompoundCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btCompoundCompoundCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btCompoundCompoundCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btCompoundCompoundCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btCompoundCompoundCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btCompoundCompoundCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btCompoundCompoundCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

btUsageBitfield :: struct {
    Constructor :: (this: *btUsageBitfield) -> void #cpp_method #foreign bullet3 "??0btUsageBitfield@@QEAA@XZ";

    reset :: (this: *btUsageBitfield) -> void #cpp_method #foreign bullet3 "?reset@btUsageBitfield@@QEAAXXZ";

    usedVertexA: u16;
    #place usedVertexA; /*bitfield 1*/ usedVertexB: u16;
    #place usedVertexA; /*bitfield 2*/ usedVertexC: u16;
    #place usedVertexA; /*bitfield 3*/ usedVertexD: u16;
    #place usedVertexA; /*bitfield 4*/ unused1:     u16;
    #place usedVertexA; /*bitfield 5*/ unused2:     u16;
    #place usedVertexA; /*bitfield 6*/ unused3:     u16;
    #place usedVertexA; /*bitfield 7*/ unused4:     u16;
}

btSubSimplexClosestResult :: struct {
    m_closestPointOnSimplex: btVector3;

    //MASK for m_usedVertices
    //stores the simplex vertex-usage, using the MASK,
    // if m_usedVertices & MASK then the related vertex is used
    m_usedVertices:          btUsageBitfield;
    m_barycentricCoords:     [4] btScalar;
    m_degenerate:            bool;

    reset :: (this: *btSubSimplexClosestResult) -> void #cpp_method #foreign bullet3 "?reset@btSubSimplexClosestResult@@QEAAXXZ";

    isValid :: (this: *btSubSimplexClosestResult) -> bool #cpp_method #foreign bullet3 "?isValid@btSubSimplexClosestResult@@QEAA_NXZ";

    setBarycentricCoordinates :: (this: *btSubSimplexClosestResult, a: btScalar, b: btScalar, c: btScalar, d: btScalar) -> void #cpp_method #foreign bullet3 "?setBarycentricCoordinates@btSubSimplexClosestResult@@QEAAXMMMM@Z";
}

btVoronoiSimplexSolver :: struct {
    m_numVertices:          s32;

    m_simplexVectorW:       [5] btVector3;
    m_simplexPointsP:       [5] btVector3;
    m_simplexPointsQ:       [5] btVector3;

    m_cachedP1:             btVector3;
    m_cachedP2:             btVector3;
    m_cachedV:              btVector3;
    m_lastW:                btVector3;

    m_equalVertexThreshold: btScalar;
    m_cachedValidClosest:   bool;

    m_cachedBC:             btSubSimplexClosestResult;

    m_needsUpdate:          bool;

    removeVertex :: (this: *btVoronoiSimplexSolver, index: s32) -> void #cpp_method #foreign bullet3 "?removeVertex@btVoronoiSimplexSolver@@QEAAXH@Z";
    reduceVertices :: (this: *btVoronoiSimplexSolver, usedVerts: *btUsageBitfield) -> void #cpp_method #foreign bullet3 "?reduceVertices@btVoronoiSimplexSolver@@QEAAXAEBUbtUsageBitfield@@@Z";
    reduceVertices :: (this: *btVoronoiSimplexSolver, usedVerts: btUsageBitfield) #no_context {
        reduceVertices(this, *usedVerts);
    }
    updateClosestVectorAndPoints :: (this: *btVoronoiSimplexSolver) -> bool #cpp_method #foreign bullet3 "?updateClosestVectorAndPoints@btVoronoiSimplexSolver@@QEAA_NXZ";

    closestPtPointTetrahedron :: (this: *btVoronoiSimplexSolver, p: *btVector3, a: *btVector3, b: *btVector3, c: *btVector3, d: *btVector3, finalResult: *btSubSimplexClosestResult) -> bool #cpp_method #foreign bullet3 "?closestPtPointTetrahedron@btVoronoiSimplexSolver@@QEAA_NAEBVbtVector3@@0000AEAUbtSubSimplexClosestResult@@@Z";
    closestPtPointTetrahedron :: (this: *btVoronoiSimplexSolver, p: btVector3, a: btVector3, b: btVector3, c: btVector3, d: btVector3, finalResult: *btSubSimplexClosestResult) -> bool #no_context {
        return closestPtPointTetrahedron(this, *p, *a, *b, *c, *d, finalResult);
    }
    pointOutsideOfPlane :: (this: *btVoronoiSimplexSolver, p: *btVector3, a: *btVector3, b: *btVector3, c: *btVector3, d: *btVector3) -> s32 #cpp_method #foreign bullet3 "?pointOutsideOfPlane@btVoronoiSimplexSolver@@QEAAHAEBVbtVector3@@0000@Z";
    pointOutsideOfPlane :: (this: *btVoronoiSimplexSolver, p: btVector3, a: btVector3, b: btVector3, c: btVector3, d: btVector3) -> s32 #no_context {
        return pointOutsideOfPlane(this, *p, *a, *b, *c, *d);
    }
    closestPtPointTriangle :: (this: *btVoronoiSimplexSolver, p: *btVector3, a: *btVector3, b: *btVector3, c: *btVector3, result: *btSubSimplexClosestResult) -> bool #cpp_method #foreign bullet3 "?closestPtPointTriangle@btVoronoiSimplexSolver@@QEAA_NAEBVbtVector3@@000AEAUbtSubSimplexClosestResult@@@Z";
    closestPtPointTriangle :: (this: *btVoronoiSimplexSolver, p: btVector3, a: btVector3, b: btVector3, c: btVector3, result: *btSubSimplexClosestResult) -> bool #no_context {
        return closestPtPointTriangle(this, *p, *a, *b, *c, result);
    }

    Constructor :: (this: *btVoronoiSimplexSolver) -> void #cpp_method #foreign bullet3 "??0btVoronoiSimplexSolver@@QEAA@XZ";

    reset :: (this: *btVoronoiSimplexSolver) -> void #cpp_method #foreign bullet3 "?reset@btVoronoiSimplexSolver@@QEAAXXZ";

    addVertex :: (this: *btVoronoiSimplexSolver, w: *btVector3, p: *btVector3, q: *btVector3) -> void #cpp_method #foreign bullet3 "?addVertex@btVoronoiSimplexSolver@@QEAAXAEBVbtVector3@@00@Z";
    addVertex :: (this: *btVoronoiSimplexSolver, w: btVector3, p: btVector3, q: btVector3) #no_context {
        addVertex(this, *w, *p, *q);
    }

    setEqualVertexThreshold :: (this: *btVoronoiSimplexSolver, threshold: btScalar) -> void #cpp_method #foreign bullet3 "?setEqualVertexThreshold@btVoronoiSimplexSolver@@QEAAXM@Z";

    getEqualVertexThreshold :: (this: *btVoronoiSimplexSolver) -> btScalar #cpp_method #foreign bullet3 "?getEqualVertexThreshold@btVoronoiSimplexSolver@@QEBAMXZ";

    closest :: (this: *btVoronoiSimplexSolver, v: *btVector3) -> bool #cpp_method #foreign bullet3 "?closest@btVoronoiSimplexSolver@@QEAA_NAEAVbtVector3@@@Z";

    maxVertex :: (this: *btVoronoiSimplexSolver) -> btScalar #cpp_method #foreign bullet3 "?maxVertex@btVoronoiSimplexSolver@@QEAAMXZ";

    fullSimplex :: (this: *btVoronoiSimplexSolver) -> bool #cpp_method #foreign bullet3 "?fullSimplex@btVoronoiSimplexSolver@@QEBA_NXZ";

    getSimplex :: (this: *btVoronoiSimplexSolver, pBuf: *btVector3, qBuf: *btVector3, yBuf: *btVector3) -> s32 #cpp_method #foreign bullet3 "?getSimplex@btVoronoiSimplexSolver@@QEBAHPEAVbtVector3@@00@Z";

    inSimplex :: (this: *btVoronoiSimplexSolver, w: *btVector3) -> bool #cpp_method #foreign bullet3 "?inSimplex@btVoronoiSimplexSolver@@QEAA_NAEBVbtVector3@@@Z";
    inSimplex :: (this: *btVoronoiSimplexSolver, w: btVector3) -> bool #no_context {
        return inSimplex(this, *w);
    }

    backup_closest :: (this: *btVoronoiSimplexSolver, v: *btVector3) -> void #cpp_method #foreign bullet3 "?backup_closest@btVoronoiSimplexSolver@@QEAAXAEAVbtVector3@@@Z";

    emptySimplex :: (this: *btVoronoiSimplexSolver) -> bool #cpp_method #foreign bullet3 "?emptySimplex@btVoronoiSimplexSolver@@QEBA_NXZ";

    compute_points :: (this: *btVoronoiSimplexSolver, p1: *btVector3, p2: *btVector3) -> void #cpp_method #foreign bullet3 "?compute_points@btVoronoiSimplexSolver@@QEAAXAEAVbtVector3@@0@Z";

    numVertices :: (this: *btVoronoiSimplexSolver) -> s32 #cpp_method #foreign bullet3 "?numVertices@btVoronoiSimplexSolver@@QEBAHXZ";
}


/// btGjkPairDetector uses GJK to implement the btDiscreteCollisionDetectorInterface
btGjkPairDetector :: struct {
    #as using btdiscretecollisiondetectorinterface: btDiscreteCollisionDetectorInterface;

    m_cachedSeparatingAxis:      btVector3;
    m_penetrationDepthSolver:    *btConvexPenetrationDepthSolver;
    m_simplexSolver:             *btVoronoiSimplexSolver;
    m_minkowskiA:                *btConvexShape;
    m_minkowskiB:                *btConvexShape;
    m_shapeTypeA:                s32;
    m_shapeTypeB:                s32;
    m_marginA:                   btScalar;
    m_marginB:                   btScalar;

    m_ignoreMargin:              bool;
    m_cachedSeparatingDistance:  btScalar;

    //some debugging to fix degeneracy problems
    m_lastUsedMethod:            s32;
    m_curIter:                   s32;
    m_degenerateSimplex:         s32;
    m_catchDegeneracies:         s32;
    m_fixContactNormalDirection: s32;

    Constructor :: (this: *btGjkPairDetector, objectA: *btConvexShape, objectB: *btConvexShape, simplexSolver: *btVoronoiSimplexSolver, penetrationDepthSolver: *btConvexPenetrationDepthSolver) -> void #cpp_method #foreign bullet3 "??0btGjkPairDetector@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z";
    Constructor :: (this: *btGjkPairDetector, objectA: *btConvexShape, objectB: *btConvexShape, shapeTypeA: s32, shapeTypeB: s32, marginA: btScalar, marginB: btScalar, simplexSolver: *btVoronoiSimplexSolver, penetrationDepthSolver: *btConvexPenetrationDepthSolver) -> void #cpp_method #foreign bullet3 "??0btGjkPairDetector@@QEAA@PEBVbtConvexShape@@0HHMMPEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z";

    getClosestPointsNonVirtual :: (this: *btGjkPairDetector, input: *btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?getClosestPointsNonVirtual@btGjkPairDetector@@QEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@@Z";
    getClosestPointsNonVirtual :: (this: *btGjkPairDetector, input: btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw) #no_context {
        getClosestPointsNonVirtual(this, *input, output, debugDraw);
    }

    setMinkowskiA :: (this: *btGjkPairDetector, minkA: *btConvexShape) -> void #cpp_method #foreign bullet3 "?setMinkowskiA@btGjkPairDetector@@QEAAXPEBVbtConvexShape@@@Z";

    setMinkowskiB :: (this: *btGjkPairDetector, minkB: *btConvexShape) -> void #cpp_method #foreign bullet3 "?setMinkowskiB@btGjkPairDetector@@QEAAXPEBVbtConvexShape@@@Z";

    setCachedSeparatingAxis :: (this: *btGjkPairDetector, separatingAxis: *btVector3) -> void #cpp_method #foreign bullet3 "?setCachedSeparatingAxis@btGjkPairDetector@@QEAAXAEBVbtVector3@@@Z";
    setCachedSeparatingAxis :: (this: *btGjkPairDetector, separatingAxis: btVector3) #no_context {
        setCachedSeparatingAxis(this, *separatingAxis);
    }

    getCachedSeparatingAxis :: (this: *btGjkPairDetector) -> *btVector3 #cpp_method #foreign bullet3 "?getCachedSeparatingAxis@btGjkPairDetector@@QEBAAEBVbtVector3@@XZ";

    getCachedSeparatingDistance :: (this: *btGjkPairDetector) -> btScalar #cpp_method #foreign bullet3 "?getCachedSeparatingDistance@btGjkPairDetector@@QEBAMXZ";

    setPenetrationDepthSolver :: (this: *btGjkPairDetector, penetrationDepthSolver: *btConvexPenetrationDepthSolver) -> void #cpp_method #foreign bullet3 "?setPenetrationDepthSolver@btGjkPairDetector@@QEAAXPEAVbtConvexPenetrationDepthSolver@@@Z";

    ///don't use setIgnoreMargin, it's for Bullet's internal use
    setIgnoreMargin :: (this: *btGjkPairDetector, ignoreMargin: bool) -> void #cpp_method #foreign bullet3 "?setIgnoreMargin@btGjkPairDetector@@QEAAX_N@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGjkPairDetector, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGjkPairDetector@@UEAA@XZ";

    virtual_getClosestPoints :: (this: *btGjkPairDetector, input: *btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw, swapResults := false) -> void #cpp_method #foreign bullet3 "?getClosestPoints@btGjkPairDetector@@UEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@_N@Z";
}

///The convex2dConvex2dAlgorithm collision algorithm support 2d collision detection for btConvex2dShape
///Currently it requires the btMinkowskiPenetrationDepthSolver, it has support for 2d penetration depth computation
btConvex2dConvex2dAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_simplexSolver:    *btVoronoiSimplexSolver;
    m_pdSolver:         *btConvexPenetrationDepthSolver;

    m_ownManifold:      bool;
    m_manifoldPtr:      *btPersistentManifold;
    m_lowLevelOfDetail: bool;

    Constructor :: (this: *btConvex2dConvex2dAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, simplexSolver: *btVoronoiSimplexSolver, pdSolver: *btConvexPenetrationDepthSolver, numPerturbationIterations: s32, minimumPointsPerturbationThreshold: s32) -> void #cpp_method #foreign bullet3 "??0btConvex2dConvex2dAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@HH@Z";
    Constructor :: (this: *btConvex2dConvex2dAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, simplexSolver: *btVoronoiSimplexSolver, pdSolver: *btConvexPenetrationDepthSolver, numPerturbationIterations: s32, minimumPointsPerturbationThreshold: s32) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap, simplexSolver, pdSolver, numPerturbationIterations, minimumPointsPerturbationThreshold);
    }

    setLowLevelOfDetail :: (this: *btConvex2dConvex2dAlgorithm, useLowLevel: bool) -> void #cpp_method #foreign bullet3 "?setLowLevelOfDetail@btConvex2dConvex2dAlgorithm@@QEAAX_N@Z";

    getManifold :: (this: *btConvex2dConvex2dAlgorithm) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getManifold@btConvex2dConvex2dAlgorithm@@QEAAPEBVbtPersistentManifold@@XZ";

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;

        m_pdSolver:                           *btConvexPenetrationDepthSolver;
        m_simplexSolver:                      *btVoronoiSimplexSolver;
        m_numPerturbationIterations:          s32;
        m_minimumPointsPerturbationThreshold: s32;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvex2dConvex2dAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvex2dConvex2dAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btConvex2dConvex2dAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btConvex2dConvex2dAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btConvex2dConvex2dAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btConvex2dConvex2dAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btConvex2dConvex2dAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btConvex2dConvex2dAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

///For each triangle in the concave mesh that overlaps with the AABB of a convex (m_convexProxy), processTriangle is called.
btConvexTriangleCallback :: struct {
    #as using bttrianglecallback: btTriangleCallback;

    m_aabbMin:                 btVector3;
    m_aabbMax:                 btVector3;

    m_convexBodyWrap:          *btCollisionObjectWrapper;
    m_triBodyWrap:             *btCollisionObjectWrapper;

    m_resultOut:               *btManifoldResult;
    m_dispatcher:              *btDispatcher;
    m_dispatchInfoPtr:         *btDispatcherInfo;
    m_collisionMarginTriangle: btScalar;

    m_triangleCount:           s32;

    m_manifoldPtr:             *btPersistentManifold;

    Constructor :: (this: *btConvexTriangleCallback, dispatcher: *btDispatcher, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btConvexTriangleCallback@@QEAA@PEAVbtDispatcher@@PEBUbtCollisionObjectWrapper@@1_N@Z";

    setTimeStepAndCounters :: (this: *btConvexTriangleCallback, collisionMarginTriangle: btScalar, dispatchInfo: *btDispatcherInfo, convexBodyWrap: *btCollisionObjectWrapper, triBodyWrap: *btCollisionObjectWrapper, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?setTimeStepAndCounters@btConvexTriangleCallback@@QEAAXMAEBUbtDispatcherInfo@@PEBUbtCollisionObjectWrapper@@1PEAVbtManifoldResult@@@Z";
    setTimeStepAndCounters :: (this: *btConvexTriangleCallback, collisionMarginTriangle: btScalar, dispatchInfo: btDispatcherInfo, convexBodyWrap: *btCollisionObjectWrapper, triBodyWrap: *btCollisionObjectWrapper, resultOut: *btManifoldResult) #no_context {
        setTimeStepAndCounters(this, collisionMarginTriangle, *dispatchInfo, convexBodyWrap, triBodyWrap, resultOut);
    }

    clearWrapperData :: (this: *btConvexTriangleCallback) -> void #cpp_method #foreign bullet3 "?clearWrapperData@btConvexTriangleCallback@@QEAAXXZ";

    clearCache :: (this: *btConvexTriangleCallback) -> void #cpp_method #foreign bullet3 "?clearCache@btConvexTriangleCallback@@QEAAXXZ";

    getAabbMin :: (this: *btConvexTriangleCallback) -> *btVector3 #cpp_method #foreign bullet3 "?getAabbMin@btConvexTriangleCallback@@QEBAAEBVbtVector3@@XZ";

    getAabbMax :: (this: *btConvexTriangleCallback) -> *btVector3 #cpp_method #foreign bullet3 "?getAabbMax@btConvexTriangleCallback@@QEBAAEBVbtVector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexTriangleCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexTriangleCallback@@UEAA@XZ";

    virtual_processTriangle :: (this: *btConvexTriangleCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method #foreign bullet3 "?processTriangle@btConvexTriangleCallback@@UEAAXPEAVbtVector3@@HH@Z";
}


/// btConvexConcaveCollisionAlgorithm  supports collision between convex shapes and (concave) trianges meshes.
btConvexConcaveCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_btConvexTriangleCallback: btConvexTriangleCallback;

    m_isSwapped:                bool;

    Constructor :: (this: *btConvexConcaveCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btConvexConcaveCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1_N@Z";
    Constructor :: (this: *btConvexConcaveCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) #no_context {
        Constructor(this, *ci, body0Wrap, body1Wrap, isSwapped);
    }

    clearCache :: (this: *btConvexConcaveCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?clearCache@btConvexConcaveCollisionAlgorithm@@QEAAXXZ";

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    SwappedCreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexConcaveCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexConcaveCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btConvexConcaveCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btConvexConcaveCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btConvexConcaveCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btConvexConcaveCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btConvexConcaveCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btConvexConcaveCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}


btVertexArray :: btAlignedObjectArray(btVector3);

// Clips a face to the back of a plane
btPolyhedralContactClipping :: struct {
    clipHullAgainstHull :: (separatingNormal1: *btVector3, hullA: *btConvexPolyhedron, hullB: *btConvexPolyhedron, transA: *btTransform, transB: *btTransform, minDist: btScalar, maxDist: btScalar, worldVertsB1: *btVertexArray, worldVertsB2: *btVertexArray, resultOut: *btDiscreteCollisionDetectorInterface.Result) -> void #foreign bullet3 "?clipHullAgainstHull@btPolyhedralContactClipping@@SAXAEBVbtVector3@@AEBVbtConvexPolyhedron@@1AEBVbtTransform@@2MMAEAV?$btAlignedObjectArray@VbtVector3@@@@3AEAUResult@btDiscreteCollisionDetectorInterface@@@Z";
    clipHullAgainstHull :: (separatingNormal1: btVector3, hullA: btConvexPolyhedron, hullB: btConvexPolyhedron, transA: btTransform, transB: btTransform, minDist: btScalar, maxDist: btScalar, worldVertsB1: *btVertexArray, worldVertsB2: *btVertexArray, resultOut: *btDiscreteCollisionDetectorInterface.Result) #no_context {
        clipHullAgainstHull(*separatingNormal1, *hullA, *hullB, *transA, *transB, minDist, maxDist, worldVertsB1, worldVertsB2, resultOut);
    }

    clipFaceAgainstHull :: (separatingNormal: *btVector3, hullA: *btConvexPolyhedron, transA: *btTransform, worldVertsB1: *btVertexArray, worldVertsB2: *btVertexArray, minDist: btScalar, maxDist: btScalar, resultOut: *btDiscreteCollisionDetectorInterface.Result) -> void #foreign bullet3 "?clipFaceAgainstHull@btPolyhedralContactClipping@@SAXAEBVbtVector3@@AEBVbtConvexPolyhedron@@AEBVbtTransform@@AEAV?$btAlignedObjectArray@VbtVector3@@@@3MMAEAUResult@btDiscreteCollisionDetectorInterface@@@Z";
    clipFaceAgainstHull :: (separatingNormal: btVector3, hullA: btConvexPolyhedron, transA: btTransform, worldVertsB1: *btVertexArray, worldVertsB2: *btVertexArray, minDist: btScalar, maxDist: btScalar, resultOut: *btDiscreteCollisionDetectorInterface.Result) #no_context {
        clipFaceAgainstHull(*separatingNormal, *hullA, *transA, worldVertsB1, worldVertsB2, minDist, maxDist, resultOut);
    }

    findSeparatingAxis :: (hullA: *btConvexPolyhedron, hullB: *btConvexPolyhedron, transA: *btTransform, transB: *btTransform, sep: *btVector3, resultOut: *btDiscreteCollisionDetectorInterface.Result) -> bool #foreign bullet3 "?findSeparatingAxis@btPolyhedralContactClipping@@SA_NAEBVbtConvexPolyhedron@@0AEBVbtTransform@@1AEAVbtVector3@@AEAUResult@btDiscreteCollisionDetectorInterface@@@Z";
    findSeparatingAxis :: (hullA: btConvexPolyhedron, hullB: btConvexPolyhedron, transA: btTransform, transB: btTransform, sep: *btVector3, resultOut: *btDiscreteCollisionDetectorInterface.Result) -> bool #no_context {
        return findSeparatingAxis(*hullA, *hullB, *transA, *transB, sep, resultOut);
    }

    ///the clipFace method is used internally
    clipFace :: (pVtxIn: *btVertexArray, ppVtxOut: *btVertexArray, planeNormalWS: *btVector3, planeEqWS: btScalar) -> void #foreign bullet3 "?clipFace@btPolyhedralContactClipping@@SAXAEBV?$btAlignedObjectArray@VbtVector3@@@@AEAV2@AEBVbtVector3@@M@Z";
    clipFace :: (pVtxIn: btVertexArray, ppVtxOut: *btVertexArray, planeNormalWS: btVector3, planeEqWS: btScalar) #no_context {
        clipFace(*pVtxIn, ppVtxOut, *planeNormalWS, planeEqWS);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///The convexConvexAlgorithm collision algorithm implements time of impact, convex closest points and penetration depth calculations between two convex objects.
///Multiple contact points are calculated by perturbing the orientation of the smallest object orthogonal to the separating normal.
///This idea was described by Gino van den Bergen in this forum topic http://www.bulletphysics.com/Bullet/phpBB3/viewtopic.php?f=4&t=288&p=888#p888
btConvexConvexAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_pdSolver:                           *btConvexPenetrationDepthSolver;

    worldVertsB1:                         btVertexArray;
    worldVertsB2:                         btVertexArray;

    m_ownManifold:                        bool;
    m_manifoldPtr:                        *btPersistentManifold;
    m_lowLevelOfDetail:                   bool;

    m_numPerturbationIterations:          s32;
    m_minimumPointsPerturbationThreshold: s32;

    ///cache separating vector to speedup collision detection
    Constructor :: (this: *btConvexConvexAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, pdSolver: *btConvexPenetrationDepthSolver, numPerturbationIterations: s32, minimumPointsPerturbationThreshold: s32) -> void #cpp_method #foreign bullet3 "??0btConvexConvexAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2PEAVbtConvexPenetrationDepthSolver@@HH@Z";
    Constructor :: (this: *btConvexConvexAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, pdSolver: *btConvexPenetrationDepthSolver, numPerturbationIterations: s32, minimumPointsPerturbationThreshold: s32) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap, pdSolver, numPerturbationIterations, minimumPointsPerturbationThreshold);
    }

    setLowLevelOfDetail :: (this: *btConvexConvexAlgorithm, useLowLevel: bool) -> void #cpp_method #foreign bullet3 "?setLowLevelOfDetail@btConvexConvexAlgorithm@@QEAAX_N@Z";

    getManifold :: (this: *btConvexConvexAlgorithm) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getManifold@btConvexConvexAlgorithm@@QEAAPEBVbtPersistentManifold@@XZ";

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;

        m_pdSolver:                           *btConvexPenetrationDepthSolver;
        m_numPerturbationIterations:          s32;
        m_minimumPointsPerturbationThreshold: s32;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexConvexAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexConvexAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btConvexConvexAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btConvexConvexAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btConvexConvexAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btConvexConvexAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btConvexConvexAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btConvexConvexAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

/// btSphereBoxCollisionAlgorithm  provides sphere-box collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
btConvexPlaneCollisionAlgorithm :: struct {
    #as using btcollisionalgorithm: btCollisionAlgorithm;

    m_ownManifold:                        bool;
    m_manifoldPtr:                        *btPersistentManifold;
    m_isSwapped:                          bool;
    m_numPerturbationIterations:          s32;
    m_minimumPointsPerturbationThreshold: s32;

    Constructor :: (this: *btConvexPlaneCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool, numPerturbationIterations: s32, minimumPointsPerturbationThreshold: s32) -> void #cpp_method #foreign bullet3 "??0btConvexPlaneCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_NHH@Z";
    Constructor :: (this: *btConvexPlaneCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool, numPerturbationIterations: s32, minimumPointsPerturbationThreshold: s32) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap, isSwapped, numPerturbationIterations, minimumPointsPerturbationThreshold);
    }

    collideSingleContact :: (this: *btConvexPlaneCollisionAlgorithm, perturbeRot: *btQuaternion, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?collideSingleContact@btConvexPlaneCollisionAlgorithm@@QEAAXAEBVbtQuaternion@@PEBUbtCollisionObjectWrapper@@1AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";
    collideSingleContact :: (this: *btConvexPlaneCollisionAlgorithm, perturbeRot: btQuaternion, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: btDispatcherInfo, resultOut: *btManifoldResult) #no_context {
        collideSingleContact(this, *perturbeRot, body0Wrap, body1Wrap, *dispatchInfo, resultOut);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;

        m_numPerturbationIterations:          s32;
        m_minimumPointsPerturbationThreshold: s32;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexPlaneCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexPlaneCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btConvexPlaneCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btConvexPlaneCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btConvexPlaneCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btConvexPlaneCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btConvexPlaneCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btConvexPlaneCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

///EmptyAlgorithm is a stub for unsupported collision pairs.
///The dispatcher can dispatch a persistent btEmptyAlgorithm to avoid a search every frame.
btEmptyAlgorithm :: struct {
    #as using btcollisionalgorithm: btCollisionAlgorithm;

    Constructor :: (this: *btEmptyAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btEmptyAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btEmptyAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processCollision :: (this: *btEmptyAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btEmptyAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btEmptyAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btEmptyAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btEmptyAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btEmptyAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

///The btGhostObject can keep track of all objects that are overlapping
///By default, this overlap is based on the AABB
///This is useful for creating a character controller, collision sensors/triggers, explosions etc.
///We plan on adding rayTest and other queries for the btGhostObject
btGhostObject :: struct {
    #as using btcollisionobject: btCollisionObject;

    m_overlappingObjects: btAlignedObjectArray(*btCollisionObject);

    Constructor :: (this: *btGhostObject) -> void #cpp_method #foreign bullet3 "??0btGhostObject@@QEAA@XZ";

    convexSweepTest :: (this: *btGhostObject, castShape: *btConvexShape, convexFromWorld: *btTransform, convexToWorld: *btTransform, resultCallback: *btCollisionWorld.ConvexResultCallback, allowedCcdPenetration: btScalar = 0.0) -> void #cpp_method #foreign bullet3 "?convexSweepTest@btGhostObject@@QEBAXPEBVbtConvexShape@@AEBVbtTransform@@1AEAUConvexResultCallback@btCollisionWorld@@M@Z";
    convexSweepTest :: (this: *btGhostObject, castShape: *btConvexShape, convexFromWorld: btTransform, convexToWorld: btTransform, resultCallback: *btCollisionWorld.ConvexResultCallback, allowedCcdPenetration: btScalar = 0.0) #no_context {
        convexSweepTest(this, castShape, *convexFromWorld, *convexToWorld, resultCallback, allowedCcdPenetration);
    }

    rayTest :: (this: *btGhostObject, rayFromWorld: *btVector3, rayToWorld: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btGhostObject@@QEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z";
    rayTest :: (this: *btGhostObject, rayFromWorld: btVector3, rayToWorld: btVector3, resultCallback: *btCollisionWorld.RayResultCallback) #no_context {
        rayTest(this, *rayFromWorld, *rayToWorld, resultCallback);
    }

    getNumOverlappingObjects :: (this: *btGhostObject) -> s32 #cpp_method #foreign bullet3 "?getNumOverlappingObjects@btGhostObject@@QEBAHXZ";

    getOverlappingObject :: (this: *btGhostObject, index: s32) -> *btCollisionObject #cpp_method #foreign bullet3 "?getOverlappingObject@btGhostObject@@QEAAPEAVbtCollisionObject@@H@Z";

    getOverlappingObject_1 :: (this: /*const*/ *btGhostObject, index: s32) -> *btCollisionObject #cpp_method #foreign bullet3 "?getOverlappingObject@btGhostObject@@QEBAPEBVbtCollisionObject@@H@Z";

    getOverlappingPairs :: (this: *btGhostObject) -> *btAlignedObjectArray(*btCollisionObject) #cpp_method #foreign bullet3 "?getOverlappingPairs@btGhostObject@@QEAAAEAV?$btAlignedObjectArray@PEAVbtCollisionObject@@@@XZ";

    getOverlappingPairs_1 :: (this: /*const*/ *btGhostObject) -> btAlignedObjectArray(*btCollisionObject) #cpp_method #foreign bullet3 "?getOverlappingPairs@btGhostObject@@QEBA?BV?$btAlignedObjectArray@PEAVbtCollisionObject@@@@XZ";

    //
    // internal cast
    //
    upcast :: (colObj: /*const*/ *btCollisionObject) -> *btGhostObject #foreign bullet3 "?upcast@btGhostObject@@SAPEBV1@PEBVbtCollisionObject@@@Z";

    upcast_1 :: (colObj: *btCollisionObject) -> *btGhostObject #foreign bullet3 "?upcast@btGhostObject@@SAPEAV1@PEAVbtCollisionObject@@@Z";
    #place btcollisionobject; btghostobject_vtable: *btGhostObject_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGhostObject, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGhostObject@@UEAA@XZ";

    ///this method is mainly for expert/internal use only.
    virtual_addOverlappingObjectInternal :: (this: *btGhostObject, otherProxy: *btBroadphaseProxy, thisProxy: *btBroadphaseProxy = null) -> void #cpp_method #foreign bullet3 "?addOverlappingObjectInternal@btGhostObject@@UEAAXPEAUbtBroadphaseProxy@@0@Z";

    ///this method is mainly for expert/internal use only.
    virtual_removeOverlappingObjectInternal :: (this: *btGhostObject, otherProxy: *btBroadphaseProxy, dispatcher: *btDispatcher, thisProxy: *btBroadphaseProxy = null) -> void #cpp_method #foreign bullet3 "?removeOverlappingObjectInternal@btGhostObject@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@0@Z";
}
btGhostObject_VTable :: struct #type_info_none {
    using btcollisionobject: btCollisionObject_VTable;
    addOverlappingObjectInternal: (this: *btGhostObject, otherProxy: *btBroadphaseProxy, thisProxy: *btBroadphaseProxy = null) -> void #cpp_method;

    removeOverlappingObjectInternal: (this: *btGhostObject, otherProxy: *btBroadphaseProxy, dispatcher: *btDispatcher, thisProxy: *btBroadphaseProxy = null) -> void #cpp_method;
}

btGhostObject_addOverlappingObjectInternal :: inline (this: *btGhostObject, otherProxy: *btBroadphaseProxy, thisProxy: *btBroadphaseProxy = null) { this.btghostobject_vtable.addOverlappingObjectInternal(this, otherProxy, thisProxy); }

btGhostObject_removeOverlappingObjectInternal :: inline (this: *btGhostObject, otherProxy: *btBroadphaseProxy, dispatcher: *btDispatcher, thisProxy: *btBroadphaseProxy = null) { this.btghostobject_vtable.removeOverlappingObjectInternal(this, otherProxy, dispatcher, thisProxy); }

vtable :: (obj: *btGhostObject) -> *btGhostObject_VTable { return obj.btghostobject_vtable; }


btPairCachingGhostObject :: struct {
    #as using btghostobject: btGhostObject;

    m_hashPairCache: *btHashedOverlappingPairCache;

    Constructor :: (this: *btPairCachingGhostObject) -> void #cpp_method #foreign bullet3 "??0btPairCachingGhostObject@@QEAA@XZ";

    getOverlappingPairCache :: (this: *btPairCachingGhostObject) -> *btHashedOverlappingPairCache #cpp_method #foreign bullet3 "?getOverlappingPairCache@btPairCachingGhostObject@@QEAAPEAVbtHashedOverlappingPairCache@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btPairCachingGhostObject, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btPairCachingGhostObject@@UEAA@XZ";

    ///this method is mainly for expert/internal use only.
    virtual_addOverlappingObjectInternal :: (this: *btPairCachingGhostObject, otherProxy: *btBroadphaseProxy, thisProxy: *btBroadphaseProxy = null) -> void #cpp_method #foreign bullet3 "?addOverlappingObjectInternal@btPairCachingGhostObject@@UEAAXPEAUbtBroadphaseProxy@@0@Z";

    virtual_removeOverlappingObjectInternal :: (this: *btPairCachingGhostObject, otherProxy: *btBroadphaseProxy, dispatcher: *btDispatcher, thisProxy: *btBroadphaseProxy = null) -> void #cpp_method #foreign bullet3 "?removeOverlappingObjectInternal@btPairCachingGhostObject@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@0@Z";
}

///The btGhostPairCallback interfaces and forwards adding and removal of overlapping pairs from the btBroadphaseInterface to btGhostObject.
btGhostPairCallback :: struct {
    #as using btoverlappingpaircallback: btOverlappingPairCallback;

    Constructor :: (this: *btGhostPairCallback) -> void #cpp_method #foreign bullet3 "??0btGhostPairCallback@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGhostPairCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGhostPairCallback@@UEAA@XZ";

    virtual_addOverlappingPair :: (this: *btGhostPairCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy) -> *btBroadphasePair #cpp_method #foreign bullet3 "?addOverlappingPair@btGhostPairCallback@@UEAAPEAUbtBroadphasePair@@PEAUbtBroadphaseProxy@@0@Z";

    virtual_removeOverlappingPair :: (this: *btGhostPairCallback, proxy0: *btBroadphaseProxy, proxy1: *btBroadphaseProxy, dispatcher: *btDispatcher) -> *void #cpp_method #foreign bullet3 "?removeOverlappingPair@btGhostPairCallback@@UEAAPEAXPEAUbtBroadphaseProxy@@0PEAVbtDispatcher@@@Z";

    virtual_removeOverlappingPairsContainingProxy :: (this: *btGhostPairCallback, unknown0: *btBroadphaseProxy, unknown1: *btDispatcher) -> void #cpp_method #foreign bullet3 "?removeOverlappingPairsContainingProxy@btGhostPairCallback@@UEAAXPEAUbtBroadphaseProxy@@PEAVbtDispatcher@@@Z";
}

btInternalEdgeAdjustFlags :: enum s32 {
    CONVEX_BACKFACE_MODE :: 1;
    CONCAVE_DOUBLE_SIDED :: 2;
    CONVEX_DOUBLE_SIDED  :: 4;

    BT_TRIANGLE_CONVEX_BACKFACE_MODE :: CONVEX_BACKFACE_MODE;
    BT_TRIANGLE_CONCAVE_DOUBLE_SIDED :: CONCAVE_DOUBLE_SIDED;
    BT_TRIANGLE_CONVEX_DOUBLE_SIDED  :: CONVEX_DOUBLE_SIDED;
}

/// btSphereBoxCollisionAlgorithm  provides sphere-box collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
btSphereBoxCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_ownManifold: bool;
    m_manifoldPtr: *btPersistentManifold;
    m_isSwapped:   bool;

    Constructor :: (this: *btSphereBoxCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) -> void #cpp_method #foreign bullet3 "??0btSphereBoxCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_N@Z";
    Constructor :: (this: *btSphereBoxCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, isSwapped: bool) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap, isSwapped);
    }

    getSphereDistance :: (this: *btSphereBoxCollisionAlgorithm, boxObjWrap: *btCollisionObjectWrapper, v3PointOnBox: *btVector3, normal: *btVector3, penetrationDepth: *btScalar, v3SphereCenter: *btVector3, fRadius: btScalar, maxContactDistance: btScalar) -> bool #cpp_method #foreign bullet3 "?getSphereDistance@btSphereBoxCollisionAlgorithm@@QEAA_NPEBUbtCollisionObjectWrapper@@AEAVbtVector3@@1AEAMAEBV3@MM@Z";
    getSphereDistance :: (this: *btSphereBoxCollisionAlgorithm, boxObjWrap: *btCollisionObjectWrapper, v3PointOnBox: *btVector3, normal: *btVector3, penetrationDepth: *btScalar, v3SphereCenter: btVector3, fRadius: btScalar, maxContactDistance: btScalar) -> bool #no_context {
        return getSphereDistance(this, boxObjWrap, v3PointOnBox, normal, penetrationDepth, *v3SphereCenter, fRadius, maxContactDistance);
    }

    getSpherePenetration :: (this: *btSphereBoxCollisionAlgorithm, boxHalfExtent: *btVector3, sphereRelPos: *btVector3, closestPoint: *btVector3, normal: *btVector3) -> btScalar #cpp_method #foreign bullet3 "?getSpherePenetration@btSphereBoxCollisionAlgorithm@@QEAAMAEBVbtVector3@@0AEAV2@1@Z";
    getSpherePenetration :: (this: *btSphereBoxCollisionAlgorithm, boxHalfExtent: btVector3, sphereRelPos: btVector3, closestPoint: *btVector3, normal: *btVector3) -> btScalar #no_context {
        return getSpherePenetration(this, *boxHalfExtent, *sphereRelPos, closestPoint, normal);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSphereBoxCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSphereBoxCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btSphereBoxCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btSphereBoxCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btSphereBoxCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btSphereBoxCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btSphereBoxCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btSphereBoxCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

/// btSphereSphereCollisionAlgorithm  provides sphere-sphere collision detection.
/// Other features are frame-coherency (persistent data) and collision response.
/// Also provides the most basic sample for custom/user btCollisionAlgorithm
btSphereTriangleCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_ownManifold: bool;
    m_manifoldPtr: *btPersistentManifold;
    m_swapped:     bool;

    Constructor :: (this: *btSphereTriangleCollisionAlgorithm, mf: *btPersistentManifold, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, swapped: bool) -> void #cpp_method #foreign bullet3 "??0btSphereTriangleCollisionAlgorithm@@QEAA@PEAVbtPersistentManifold@@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@2_N@Z";
    Constructor :: (this: *btSphereTriangleCollisionAlgorithm, mf: *btPersistentManifold, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, swapped: bool) #no_context {
        Constructor(this, mf, *ci, body0Wrap, body1Wrap, swapped);
    }

    Constructor :: (this: *btSphereTriangleCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo) -> void #cpp_method #foreign bullet3 "??0btSphereTriangleCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@@Z";
    Constructor :: (this: *btSphereTriangleCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo) #no_context {
        Constructor(this, *ci);
    }

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processCollision :: (this: *btSphereTriangleCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btSphereTriangleCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btSphereTriangleCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btSphereTriangleCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btSphereTriangleCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btSphereTriangleCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";

    virtual_Destructor :: (this: *btSphereTriangleCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSphereTriangleCollisionAlgorithm@@UEAA@XZ";
}

/// sphere-triangle to match the btDiscreteCollisionDetectorInterface
SphereTriangleDetector :: struct {
    #as using btdiscretecollisiondetectorinterface: btDiscreteCollisionDetectorInterface;

    Constructor :: (this: *SphereTriangleDetector, sphere: *btSphereShape, triangle: *btTriangleShape, contactBreakingThreshold: btScalar) -> void #cpp_method #foreign bullet3 "??0SphereTriangleDetector@@QEAA@PEAVbtSphereShape@@PEAVbtTriangleShape@@M@Z";

    collide :: (this: *SphereTriangleDetector, sphereCenter: *btVector3, point: *btVector3, resultNormal: *btVector3, depth: *btScalar, timeOfImpact: *btScalar, contactBreakingThreshold: btScalar) -> bool #cpp_method #foreign bullet3 "?collide@SphereTriangleDetector@@QEAA_NAEBVbtVector3@@AEAV2@1AEAM2M@Z";
    collide :: (this: *SphereTriangleDetector, sphereCenter: btVector3, point: *btVector3, resultNormal: *btVector3, depth: *btScalar, timeOfImpact: *btScalar, contactBreakingThreshold: btScalar) -> bool #no_context {
        return collide(this, *sphereCenter, point, resultNormal, depth, timeOfImpact, contactBreakingThreshold);
    }

    pointInTriangle :: (this: *SphereTriangleDetector, vertices: *btVector3, normal: *btVector3, p: *btVector3) -> bool #cpp_method #foreign bullet3 "?pointInTriangle@SphereTriangleDetector@@AEAA_NQEBVbtVector3@@AEBV2@PEAV2@@Z";
    pointInTriangle :: (this: *SphereTriangleDetector, vertices: *btVector3, normal: btVector3, p: *btVector3) -> bool #no_context {
        return pointInTriangle(this, vertices, *normal, p);
    }
    facecontains :: (this: *SphereTriangleDetector, p: *btVector3, vertices: *btVector3, normal: *btVector3) -> bool #cpp_method #foreign bullet3 "?facecontains@SphereTriangleDetector@@AEAA_NAEBVbtVector3@@PEBV2@AEAV2@@Z";
    facecontains :: (this: *SphereTriangleDetector, p: btVector3, vertices: *btVector3, normal: *btVector3) -> bool #no_context {
        return facecontains(this, *p, vertices, normal);
    }

    m_sphere:                   *btSphereShape;
    m_triangle:                 *btTriangleShape;
    m_contactBreakingThreshold: btScalar;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getClosestPoints :: (this: *SphereTriangleDetector, input: *btDiscreteCollisionDetectorInterface.ClosestPointInput, output: *btDiscreteCollisionDetectorInterface.Result, debugDraw: *btIDebugDraw, swapResults := false) -> void #cpp_method #foreign bullet3 "?getClosestPoints@SphereTriangleDetector@@UEAAXAEBUClosestPointInput@btDiscreteCollisionDetectorInterface@@AEAUResult@3@PEAVbtIDebugDraw@@_N@Z";

    virtual_Destructor :: (this: *SphereTriangleDetector, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1SphereTriangleDetector@@UEAA@XZ";
}

///The btBox2dShape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. When used as part of a btCollisionObject or btRigidBody it will be an oriented box in world space.
btBox2dShape :: struct {
    #as using btpolyhedralconvexshape: btPolyhedralConvexShape;

    //btVector3	m_boxHalfExtents1; //use m_implicitShapeDimensions instead
    m_centroid: btVector3;
    m_vertices: [4] btVector3;
    m_normals:  [4] btVector3;

    getHalfExtentsWithMargin :: (this: *btBox2dShape) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getHalfExtentsWithMargin@btBox2dShape@@QEBA?AVbtVector3@@XZ";

    getHalfExtentsWithoutMargin :: (this: *btBox2dShape) -> *btVector3 #cpp_method #foreign bullet3 "?getHalfExtentsWithoutMargin@btBox2dShape@@QEBAAEBVbtVector3@@XZ";

    ///a btBox2dShape is a flat 2D box in the X-Y plane (Z extents are zero)
    Constructor :: (this: *btBox2dShape, boxHalfExtents: *btVector3) -> void #cpp_method #foreign bullet3 "??0btBox2dShape@@QEAA@AEBVbtVector3@@@Z";
    Constructor :: (this: *btBox2dShape, boxHalfExtents: btVector3) #no_context {
        Constructor(this, *boxHalfExtents);
    }

    getVertexCount :: (this: *btBox2dShape) -> s32 #cpp_method #foreign bullet3 "?getVertexCount@btBox2dShape@@QEBAHXZ";

    getVertices :: (this: *btBox2dShape) -> *btVector3 #cpp_method #foreign bullet3 "?getVertices@btBox2dShape@@QEBAPEBVbtVector3@@XZ";

    getNormals :: (this: *btBox2dShape) -> *btVector3 #cpp_method #foreign bullet3 "?getNormals@btBox2dShape@@QEBAPEBVbtVector3@@XZ";

    getCentroid :: (this: *btBox2dShape) -> *btVector3 #cpp_method #foreign bullet3 "?getCentroid@btBox2dShape@@QEBAAEBVbtVector3@@XZ";
    #place btpolyhedralconvexshape; btbox2dshape_vtable: *btBox2dShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btBox2dShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btBox2dShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btBox2dShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btBox2dShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btBox2dShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btBox2dShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_setMargin :: (this: *btBox2dShape, collisionMargin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btBox2dShape@@UEAAXM@Z";

    virtual_setLocalScaling :: (this: *btBox2dShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btBox2dShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getAabb :: (this: *btBox2dShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btBox2dShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_calculateLocalInertia :: (this: *btBox2dShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btBox2dShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getNumVertices :: (this: *btBox2dShape) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btBox2dShape@@UEBAHXZ";

    virtual_getPlane :: (this: *btBox2dShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btBox2dShape@@UEBAXAEAVbtVector3@@0H@Z";

    virtual_getNumPlanes :: (this: *btBox2dShape) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btBox2dShape@@UEBAHXZ";

    virtual_getNumEdges :: (this: *btBox2dShape) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btBox2dShape@@UEBAHXZ";

    virtual_getVertex :: (this: *btBox2dShape, i: s32, vtx: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btBox2dShape@@UEBAXHAEAVbtVector3@@@Z";

    virtual_getPlaneEquation :: (this: *btBox2dShape, plane: *btVector4, i: s32) -> void #cpp_method #foreign bullet3 "?getPlaneEquation@btBox2dShape@@UEBAXAEAVbtVector4@@H@Z";

    virtual_getEdge :: (this: *btBox2dShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btBox2dShape@@UEBAXHAEAVbtVector3@@0@Z";

    virtual_isInside :: (this: *btBox2dShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btBox2dShape@@UEBA_NAEBVbtVector3@@M@Z";

    //debugging
    virtual_getName :: (this: *btBox2dShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btBox2dShape@@UEBAPEBDXZ";

    virtual_getNumPreferredPenetrationDirections :: (this: *btBox2dShape) -> s32 #cpp_method #foreign bullet3 "?getNumPreferredPenetrationDirections@btBox2dShape@@UEBAHXZ";

    virtual_getPreferredPenetrationDirection :: (this: *btBox2dShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method #foreign bullet3 "?getPreferredPenetrationDirection@btBox2dShape@@UEBAXHAEAVbtVector3@@@Z";
}
btBox2dShape_VTable :: struct #type_info_none {
    using btpolyhedralconvexshape: btPolyhedralConvexShape_VTable;
    getPlaneEquation: (this: *btBox2dShape, plane: *btVector4, i: s32) -> void #cpp_method;
}
btBox2dShape_getPlaneEquation :: inline (this: *btBox2dShape, plane: *btVector4, i: s32) { this.btbox2dshape_vtable.getPlaneEquation(this, plane, i); }

vtable :: (obj: *btBox2dShape) -> *btBox2dShape_VTable { return obj.btbox2dshape_vtable; }



///The btConvex2dShape allows to use arbitrary convex shapes as 2d convex shapes, with the Z component assumed to be 0.
///For 2d boxes, the btBox2dShape is recommended.
btConvex2dShape :: struct {
    #as using btconvexshape: btConvexShape;

    m_childConvexShape: *btConvexShape;

    Constructor :: (this: *btConvex2dShape, convexChildShape: *btConvexShape) -> void #cpp_method #foreign bullet3 "??0btConvex2dShape@@QEAA@PEAVbtConvexShape@@@Z";

    getChildShape :: (this: *btConvex2dShape) -> *btConvexShape #cpp_method #foreign bullet3 "?getChildShape@btConvex2dShape@@QEAAPEAVbtConvexShape@@XZ";

    getChildShape_1 :: (this: /*const*/ *btConvex2dShape) -> *btConvexShape #cpp_method #foreign bullet3 "?getChildShape@btConvex2dShape@@QEBAPEBVbtConvexShape@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvex2dShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvex2dShape@@UEAA@XZ";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btConvex2dShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btConvex2dShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_localGetSupportingVertex :: (this: *btConvex2dShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btConvex2dShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btConvex2dShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvex2dShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btConvex2dShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btConvex2dShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btConvex2dShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btConvex2dShape@@UEBAPEBDXZ";

    ///getAabb's default implementation is brute force, expected derived classes to implement a fast dedicated version
    virtual_getAabb :: (this: *btConvex2dShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btConvex2dShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_getAabbSlow :: (this: *btConvex2dShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabbSlow@btConvex2dShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_setLocalScaling :: (this: *btConvex2dShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConvex2dShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btConvex2dShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btConvex2dShape@@UEBAAEBVbtVector3@@XZ";

    virtual_setMargin :: (this: *btConvex2dShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btConvex2dShape@@UEAAXM@Z";
    virtual_getMargin :: (this: *btConvex2dShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btConvex2dShape@@UEBAMXZ";

    virtual_getNumPreferredPenetrationDirections :: (this: *btConvex2dShape) -> s32 #cpp_method #foreign bullet3 "?getNumPreferredPenetrationDirections@btConvex2dShape@@UEBAHXZ";

    virtual_getPreferredPenetrationDirection :: (this: *btConvex2dShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method #foreign bullet3 "?getPreferredPenetrationDirection@btConvex2dShape@@UEBAXHAEAVbtVector3@@@Z";
}


///The btConvexPointCloudShape implements an implicit convex hull of an array of vertices.
btConvexPointCloudShape :: struct {
    #as using btpolyhedralconvexaabbcachingshape: btPolyhedralConvexAabbCachingShape;

    m_unscaledPoints: *btVector3;
    m_numPoints:      s32;

    Constructor :: (this: *btConvexPointCloudShape) -> void #cpp_method #foreign bullet3 "??0btConvexPointCloudShape@@QEAA@XZ";

    Constructor :: (this: *btConvexPointCloudShape, points: *btVector3, numPoints: s32, localScaling: *btVector3, computeAabb := true) -> void #cpp_method #foreign bullet3 "??0btConvexPointCloudShape@@QEAA@PEAVbtVector3@@HAEBV1@_N@Z";
    Constructor :: (this: *btConvexPointCloudShape, points: *btVector3, numPoints: s32, localScaling: btVector3, computeAabb := true) #no_context {
        Constructor(this, points, numPoints, *localScaling, computeAabb);
    }

    setPoints :: (this: *btConvexPointCloudShape, points: *btVector3, numPoints: s32, computeAabb := true, localScaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setPoints@btConvexPointCloudShape@@QEAAXPEAVbtVector3@@H_NAEBV2@@Z";
    setPoints :: (this: *btConvexPointCloudShape, points: *btVector3, numPoints: s32, computeAabb := true, localScaling: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setPoints(this, points, numPoints, computeAabb, *localScaling);
    }

    getUnscaledPoints :: (this: *btConvexPointCloudShape) -> *btVector3 #cpp_method #foreign bullet3 "?getUnscaledPoints@btConvexPointCloudShape@@QEAAPEAVbtVector3@@XZ";

    getUnscaledPoints_1 :: (this: /*const*/ *btConvexPointCloudShape) -> *btVector3 #cpp_method #foreign bullet3 "?getUnscaledPoints@btConvexPointCloudShape@@QEBAPEBVbtVector3@@XZ";

    getNumPoints :: (this: *btConvexPointCloudShape) -> s32 #cpp_method #foreign bullet3 "?getNumPoints@btConvexPointCloudShape@@QEBAHXZ";

    getScaledPoint :: (this: *btConvexPointCloudShape, index: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getScaledPoint@btConvexPointCloudShape@@QEBA?AVbtVector3@@H@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertex :: (this: *btConvexPointCloudShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertex@btConvexPointCloudShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_localGetSupportingVertexWithoutMargin :: (this: *btConvexPointCloudShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btConvexPointCloudShape@@UEBA?AVbtVector3@@AEBV2@@Z";
    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btConvexPointCloudShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btConvexPointCloudShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    //debugging
    virtual_getName :: (this: *btConvexPointCloudShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btConvexPointCloudShape@@UEBAPEBDXZ";

    virtual_getNumVertices :: (this: *btConvexPointCloudShape) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btConvexPointCloudShape@@UEBAHXZ";
    virtual_getNumEdges :: (this: *btConvexPointCloudShape) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btConvexPointCloudShape@@UEBAHXZ";
    virtual_getEdge :: (this: *btConvexPointCloudShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btConvexPointCloudShape@@UEBAXHAEAVbtVector3@@0@Z";
    virtual_getVertex :: (this: *btConvexPointCloudShape, i: s32, vtx: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btConvexPointCloudShape@@UEBAXHAEAVbtVector3@@@Z";
    virtual_getNumPlanes :: (this: *btConvexPointCloudShape) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btConvexPointCloudShape@@UEBAHXZ";
    virtual_getPlane :: (this: *btConvexPointCloudShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btConvexPointCloudShape@@UEBAXAEAVbtVector3@@0H@Z";
    virtual_isInside :: (this: *btConvexPointCloudShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btConvexPointCloudShape@@UEBA_NAEBVbtVector3@@M@Z";

    ///in case we receive negative scaling
    virtual_setLocalScaling :: (this: *btConvexPointCloudShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btConvexPointCloudShape@@UEAAXAEBVbtVector3@@@Z";
}


btFace :: struct {
    m_indices: btAlignedObjectArray(s32);

    //	btAlignedObjectArray<int>	m_connectedFaces;
    m_plane:   [4] btScalar;
}

btConvexPolyhedron :: struct {
    vtable: *btConvexPolyhedron_VTable;
    Constructor :: (this: *btConvexPolyhedron) -> void #cpp_method #foreign bullet3 "??0btConvexPolyhedron@@QEAA@XZ";

    m_vertices:    btAlignedObjectArray(btVector3);
    m_faces:       btAlignedObjectArray(btFace);
    m_uniqueEdges: btAlignedObjectArray(btVector3);

    m_localCenter: btVector3;
    m_extents:     btVector3;
    m_radius:      btScalar;
    mC:            btVector3;
    mE:            btVector3;

    initialize :: (this: *btConvexPolyhedron) -> void #cpp_method #foreign bullet3 "?initialize@btConvexPolyhedron@@QEAAXXZ";
    initialize2 :: (this: *btConvexPolyhedron) -> void #cpp_method #foreign bullet3 "?initialize2@btConvexPolyhedron@@QEAAXXZ";
    testContainment :: (this: *btConvexPolyhedron) -> bool #cpp_method #foreign bullet3 "?testContainment@btConvexPolyhedron@@QEBA_NXZ";

    project :: (this: *btConvexPolyhedron, trans: *btTransform, dir: *btVector3, minProj: *btScalar, maxProj: *btScalar, witnesPtMin: *btVector3, witnesPtMax: *btVector3) -> void #cpp_method #foreign bullet3 "?project@btConvexPolyhedron@@QEBAXAEBVbtTransform@@AEBVbtVector3@@AEAM2AEAV3@3@Z";
    project :: (this: *btConvexPolyhedron, trans: btTransform, dir: btVector3, minProj: *btScalar, maxProj: *btScalar, witnesPtMin: *btVector3, witnesPtMax: *btVector3) #no_context {
        project(this, *trans, *dir, minProj, maxProj, witnesPtMin, witnesPtMax);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexPolyhedron, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexPolyhedron@@UEAA@XZ";
}
btConvexPolyhedron_VTable :: struct #type_info_none {
    Destructor: (this: *btConvexPolyhedron, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
btConvexPolyhedron_Destructor :: inline (this: *btConvexPolyhedron, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }




///btHeightfieldTerrainShape simulates a 2D heightfield terrain
/**
The caller is responsible for maintaining the heightfield array; this
class does not make a copy.

The heightfield can be dynamic so long as the min/max height values
capture the extremes (heights must always be in that range).

The local origin of the heightfield is assumed to be the exact
center (as determined by width and length and height, with each
axis multiplied by the localScaling).

\b NOTE: be careful with coordinates.  If you have a heightfield with a local
min height of -100m, and a max height of +500m, you may be tempted to place it
at the origin (0,0) and expect the heights in world coordinates to be
-100 to +500 meters.
Actually, the heights will be -300 to +300m, because bullet will re-center
the heightfield based on its AABB (which is determined by the min/max
heights).  So keep in mind that once you create a btHeightfieldTerrainShape
object, the heights will be adjusted relative to the center of the AABB.  This
is different to the behavior of many rendering engines, but is useful for
physics engines.

Most (but not all) rendering and heightfield libraries assume upAxis = 1
(that is, the y-axis is "up").  This class allows any of the 3 coordinates
to be "up".  Make sure your choice of axis is consistent with your rendering
system.

The heightfield heights are determined from the data type used for the
heightfieldData array.  

- unsigned char: height at a point is the uchar value at the
grid point, multipled by heightScale.  uchar isn't recommended
because of its inability to deal with negative values, and
low resolution (8-bit).

- short: height at a point is the short int value at that grid
point, multipled by heightScale.

- float or dobule: height at a point is the value at that grid point.

Whatever the caller specifies as minHeight and maxHeight will be honored.
The class will not inspect the heightfield to discover the actual minimum
or maximum heights.  These values are used to determine the heightfield's
axis-aligned bounding box, multiplied by localScaling.

For usage and testing see the TerrainDemo.
*/
btHeightfieldTerrainShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    Range :: struct {
        Constructor :: (this: *Range) -> void #cpp_method #foreign bullet3 "??0Range@btHeightfieldTerrainShape@@QEAA@XZ";
        Constructor :: (this: *Range, min: btScalar, max: btScalar) -> void #cpp_method #foreign bullet3 "??0Range@btHeightfieldTerrainShape@@QEAA@MM@Z";

        overlaps :: (this: *Range, other: *Range) -> bool #cpp_method #foreign bullet3 "?overlaps@Range@btHeightfieldTerrainShape@@QEBA_NAEBU12@@Z";
        overlaps :: (this: *Range, other: Range) -> bool #no_context {
            return overlaps(this, *other);
        }

        min: btScalar;
        max: btScalar;
    }

    m_localAabbMin:          btVector3;
    m_localAabbMax:          btVector3;
    m_localOrigin:           btVector3;

    ///terrain data
    m_heightStickWidth:      s32;
    m_heightStickLength:     s32;
    m_minHeight:             btScalar;
    m_maxHeight:             btScalar;
    m_width:                 btScalar;
    m_length:                btScalar;
    m_heightScale:           btScalar;
    union {
        m_heightfieldDataUnsignedChar: *u8;
        m_heightfieldDataShort:        *s16;
        m_heightfieldDataFloat:        *float;
        m_heightfieldDataDouble:       *float64;
        m_heightfieldDataUnknown:      *void;
    }

    m_heightDataType:        PHY_ScalarType;
    m_flipQuadEdges:         bool;
    m_useDiamondSubdivision: bool;
    m_useZigzagSubdivision:  bool;
    m_flipTriangleWinding:   bool;
    m_upAxis:                s32;

    m_localScaling:          btVector3;

    // Accelerator
    m_vboundsGrid:           btAlignedObjectArray(Range);
    m_vboundsGridWidth:      s32;
    m_vboundsGridLength:     s32;
    m_vboundsChunkSize:      s32;

    m_userValue3:            btScalar;

    m_triangleInfoMap:       *btTriangleInfoMap;

    quantizeWithClamp :: (this: *btHeightfieldTerrainShape, out: *s32, point: *btVector3, isMax: s32) -> void #cpp_method #foreign bullet3 "?quantizeWithClamp@btHeightfieldTerrainShape@@IEBAXPEAHAEBVbtVector3@@H@Z";
    quantizeWithClamp :: (this: *btHeightfieldTerrainShape, out: *s32, point: btVector3, isMax: s32) #no_context {
        quantizeWithClamp(this, out, *point, isMax);
    }

    /// protected initialization
    /**
    Handles the work of constructors so that public constructors can be
    backwards-compatible without a lot of copy/paste.
    */
    initialize :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *void, heightScale: btScalar, minHeight: btScalar, maxHeight: btScalar, upAxis: s32, heightDataType: PHY_ScalarType, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "?initialize@btHeightfieldTerrainShape@@IEAAXHHPEBXMMMHW4PHY_ScalarType@@_N@Z";

    /// preferred constructors
    Constructor :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *float, minHeight: btScalar, maxHeight: btScalar, upAxis: s32, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "??0btHeightfieldTerrainShape@@QEAA@HHPEBMMMH_N@Z";

    Constructor :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *float64, minHeight: btScalar, maxHeight: btScalar, upAxis: s32, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "??0btHeightfieldTerrainShape@@QEAA@HHPEBNMMH_N@Z";

    Constructor :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *s16, heightScale: btScalar, minHeight: btScalar, maxHeight: btScalar, upAxis: s32, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "??0btHeightfieldTerrainShape@@QEAA@HHPEBFMMMH_N@Z";

    Constructor :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *u8, heightScale: btScalar, minHeight: btScalar, maxHeight: btScalar, upAxis: s32, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "??0btHeightfieldTerrainShape@@QEAA@HHPEBEMMMH_N@Z";

    /// legacy constructor
    /**
    This constructor supports a range of heightfield
    data types, and allows for a non-zero minimum height value.
    heightScale is needed for any integer-based heightfield data types.
    
    This legacy constructor considers `PHY_FLOAT` to mean `btScalar`.
    With `BT_USE_DOUBLE_PRECISION`, it will expect `heightfieldData`
    to be double-precision.
    */
    Constructor :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *void, heightScale: btScalar, minHeight: btScalar, maxHeight: btScalar, upAxis: s32, heightDataType: PHY_ScalarType, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "??0btHeightfieldTerrainShape@@QEAA@HHPEBXMMMHW4PHY_ScalarType@@_N@Z";

    /// legacy constructor
    /**
    The legacy constructor assumes the heightfield has a minimum height
    of zero.  Only unsigned char or btScalar data are supported.  For legacy
    compatibility reasons, heightScale is calculated as maxHeight / 65535 
    (and is only used when useFloatData = false).
    */
    Constructor :: (this: *btHeightfieldTerrainShape, heightStickWidth: s32, heightStickLength: s32, heightfieldData: *void, maxHeight: btScalar, upAxis: s32, useFloatData: bool, flipQuadEdges: bool) -> void #cpp_method #foreign bullet3 "??0btHeightfieldTerrainShape@@QEAA@HHPEBXMH_N1@Z";

    setUseDiamondSubdivision :: (this: *btHeightfieldTerrainShape, useDiamondSubdivision := true) -> void #cpp_method #foreign bullet3 "?setUseDiamondSubdivision@btHeightfieldTerrainShape@@QEAAX_N@Z";

    ///could help compatibility with Ogre heightfields. See https://code.google.com/p/bullet/issues/detail?id=625
    setUseZigzagSubdivision :: (this: *btHeightfieldTerrainShape, useZigzagSubdivision := true) -> void #cpp_method #foreign bullet3 "?setUseZigzagSubdivision@btHeightfieldTerrainShape@@QEAAX_N@Z";

    setFlipTriangleWinding :: (this: *btHeightfieldTerrainShape, flipTriangleWinding: bool) -> void #cpp_method #foreign bullet3 "?setFlipTriangleWinding@btHeightfieldTerrainShape@@QEAAX_N@Z";

    getVertex :: (this: *btHeightfieldTerrainShape, x: s32, y: s32, vertex: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btHeightfieldTerrainShape@@QEBAXHHAEAVbtVector3@@@Z";

    performRaycast :: (this: *btHeightfieldTerrainShape, callback: *btTriangleCallback, raySource: *btVector3, rayTarget: *btVector3) -> void #cpp_method #foreign bullet3 "?performRaycast@btHeightfieldTerrainShape@@QEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
    performRaycast :: (this: *btHeightfieldTerrainShape, callback: *btTriangleCallback, raySource: btVector3, rayTarget: btVector3) #no_context {
        performRaycast(this, callback, *raySource, *rayTarget);
    }

    buildAccelerator :: (this: *btHeightfieldTerrainShape, chunkSize: s32 = 16) -> void #cpp_method #foreign bullet3 "?buildAccelerator@btHeightfieldTerrainShape@@QEAAXH@Z";
    clearAccelerator :: (this: *btHeightfieldTerrainShape) -> void #cpp_method #foreign bullet3 "?clearAccelerator@btHeightfieldTerrainShape@@QEAAXXZ";

    getUpAxis :: (this: *btHeightfieldTerrainShape) -> s32 #cpp_method #foreign bullet3 "?getUpAxis@btHeightfieldTerrainShape@@QEBAHXZ";

    setUserValue3 :: (this: *btHeightfieldTerrainShape, value: btScalar) -> void #cpp_method #foreign bullet3 "?setUserValue3@btHeightfieldTerrainShape@@QEAAXM@Z";

    getUserValue3 :: (this: *btHeightfieldTerrainShape) -> btScalar #cpp_method #foreign bullet3 "?getUserValue3@btHeightfieldTerrainShape@@QEBAMXZ";

    getTriangleInfoMap :: (this: /*const*/ *btHeightfieldTerrainShape) -> *btTriangleInfoMap #cpp_method #foreign bullet3 "?getTriangleInfoMap@btHeightfieldTerrainShape@@QEBAPEBUbtTriangleInfoMap@@XZ";

    getTriangleInfoMap_1 :: (this: *btHeightfieldTerrainShape) -> *btTriangleInfoMap #cpp_method #foreign bullet3 "?getTriangleInfoMap@btHeightfieldTerrainShape@@QEAAPEAUbtTriangleInfoMap@@XZ";

    setTriangleInfoMap :: (this: *btHeightfieldTerrainShape, map: *btTriangleInfoMap) -> void #cpp_method #foreign bullet3 "?setTriangleInfoMap@btHeightfieldTerrainShape@@QEAAXPEAUbtTriangleInfoMap@@@Z";

    getHeightfieldRawData :: (this: *btHeightfieldTerrainShape) -> *u8 #cpp_method #foreign bullet3 "?getHeightfieldRawData@btHeightfieldTerrainShape@@QEBAPEBEXZ";
    #place btconcaveshape; btheightfieldterrainshape_vtable: *btHeightfieldTerrainShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getRawHeightFieldValue :: (this: *btHeightfieldTerrainShape, x: s32, y: s32) -> btScalar #cpp_method #foreign bullet3 "?getRawHeightFieldValue@btHeightfieldTerrainShape@@MEBAMHH@Z";

    virtual_Destructor :: (this: *btHeightfieldTerrainShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btHeightfieldTerrainShape@@UEAA@XZ";

    virtual_getAabb :: (this: *btHeightfieldTerrainShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btHeightfieldTerrainShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_processAllTriangles :: (this: *btHeightfieldTerrainShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btHeightfieldTerrainShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    virtual_calculateLocalInertia :: (this: *btHeightfieldTerrainShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btHeightfieldTerrainShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_setLocalScaling :: (this: *btHeightfieldTerrainShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btHeightfieldTerrainShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_getLocalScaling :: (this: *btHeightfieldTerrainShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btHeightfieldTerrainShape@@UEBAAEBVbtVector3@@XZ";

    //debugging
    virtual_getName :: (this: *btHeightfieldTerrainShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btHeightfieldTerrainShape@@UEBAPEBDXZ";
}
btHeightfieldTerrainShape_VTable :: struct #type_info_none {
    using btconcaveshape: btConcaveShape_VTable;
    getRawHeightFieldValue: (this: *btHeightfieldTerrainShape, x: s32, y: s32) -> btScalar #cpp_method;
}
btHeightfieldTerrainShape_getRawHeightFieldValue :: inline (this: *btHeightfieldTerrainShape, x: s32, y: s32) -> btScalar { return this.btheightfieldterrainshape_vtable.getRawHeightFieldValue(this, x, y); }

vtable :: (obj: *btHeightfieldTerrainShape) -> *btHeightfieldTerrainShape_VTable { return obj.btheightfieldterrainshape_vtable; }



// Material class to be used by btMultimaterialTriangleMeshShape to store triangle properties
btMaterial :: struct {
    // public members so that materials can change due to world events
    m_friction:    btScalar;
    m_restitution: btScalar;
    pad:           [2] s32;

    Constructor :: (this: *btMaterial) -> void #cpp_method #foreign bullet3 "??0btMaterial@@QEAA@XZ";
    Constructor :: (this: *btMaterial, fric: btScalar, rest: btScalar) -> void #cpp_method #foreign bullet3 "??0btMaterial@@QEAA@MM@Z";
}

btMultiIndex :: struct {
    ijk: [3] u32;
}

btAlignedBox3d :: struct {
    m_min: btVector3;
    m_max: btVector3;

    min :: (this: *btAlignedBox3d) -> *btVector3 #cpp_method #foreign bullet3 "?min@btAlignedBox3d@@QEBAAEBVbtVector3@@XZ";

    max :: (this: *btAlignedBox3d) -> *btVector3 #cpp_method #foreign bullet3 "?max@btAlignedBox3d@@QEBAAEBVbtVector3@@XZ";

    contains :: (this: *btAlignedBox3d, x: *btVector3) -> bool #cpp_method #foreign bullet3 "?contains@btAlignedBox3d@@QEBA_NAEBVbtVector3@@@Z";
    contains :: (this: *btAlignedBox3d, x: btVector3) -> bool #no_context {
        return contains(this, *x);
    }

    Constructor :: (this: *btAlignedBox3d, mn: *btVector3, mx: *btVector3) -> void #cpp_method #foreign bullet3 "??0btAlignedBox3d@@QEAA@AEBVbtVector3@@0@Z";
    Constructor :: (this: *btAlignedBox3d, mn: btVector3, mx: btVector3) #no_context {
        Constructor(this, *mn, *mx);
    }

    Constructor :: (this: *btAlignedBox3d) -> void #cpp_method #foreign bullet3 "??0btAlignedBox3d@@QEAA@XZ";
}

btShapeMatrix :: struct {
    m_vec: [32] float64;
}

operator[] :: (this: *btShapeMatrix, i: s32) -> *float64 #cpp_method #foreign bullet3 "??AbtShapeMatrix@@QEAAAEANH@Z";
operator[] :: (this: btShapeMatrix, i: s32) -> *float64 #no_context {
    return operator[](*this, i);
}

operator_brackets_1 :: (this: /*const*/ *btShapeMatrix, i: s32) -> *float64 #cpp_method #foreign bullet3 "??AbtShapeMatrix@@QEBAAEBNH@Z";
operator_brackets_1 :: (this: btShapeMatrix, i: s32) -> *float64 #no_context {
    return operator_brackets_1(*this, i);
}

btShapeGradients :: struct {
    m_vec: [32] btVector3;

    topRowsDivide :: (this: *btShapeGradients, row: s32, denom: float64) -> void #cpp_method #foreign bullet3 "?topRowsDivide@btShapeGradients@@QEAAXHN@Z";

    bottomRowsMul :: (this: *btShapeGradients, row: s32, val: float64) -> void #cpp_method #foreign bullet3 "?bottomRowsMul@btShapeGradients@@QEAAXHN@Z";
}

operator_parens :: (this: *btShapeGradients, i: s32, j: s32) -> *btScalar #cpp_method #foreign bullet3 "??RbtShapeGradients@@QEAAAEAMHH@Z";
operator_parens :: (this: btShapeGradients, i: s32, j: s32) -> *btScalar #no_context {
    return operator_parens(*this, i, j);
}

btCell32 :: struct {
    m_cells: [32] u32;
}

btMiniSDF :: struct {
    m_domain:        btAlignedBox3d;
    m_resolution:    [3] u32;
    m_cell_size:     btVector3 #align 8;
    m_inv_cell_size: btVector3;
    m_n_cells:       size_t;
    m_n_fields:      size_t;
    m_isValid:       bool;

    m_nodes:         btAlignedObjectArray(btAlignedObjectArray(float64));
    m_cells:         btAlignedObjectArray(btAlignedObjectArray(btCell32));
    m_cell_map:      btAlignedObjectArray(btAlignedObjectArray(u32));

    Constructor :: (this: *btMiniSDF) -> void #cpp_method #foreign bullet3 "??0btMiniSDF@@QEAA@XZ";

    load :: (this: *btMiniSDF, data: *u8, size: s32) -> bool #cpp_method #foreign bullet3 "?load@btMiniSDF@@QEAA_NPEBDH@Z";
    isValid :: (this: *btMiniSDF) -> bool #cpp_method #foreign bullet3 "?isValid@btMiniSDF@@QEBA_NXZ";

    multiToSingleIndex :: (this: *btMiniSDF, ijk: *btMultiIndex) -> u32 #cpp_method #foreign bullet3 "?multiToSingleIndex@btMiniSDF@@QEBAIAEBUbtMultiIndex@@@Z";
    multiToSingleIndex :: (this: *btMiniSDF, ijk: btMultiIndex) -> u32 #no_context {
        return multiToSingleIndex(this, *ijk);
    }

    subdomain :: (this: *btMiniSDF, ijk: *btMultiIndex) -> btAlignedBox3d #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?subdomain@btMiniSDF@@QEBA?AUbtAlignedBox3d@@AEBUbtMultiIndex@@@Z";
    subdomain :: (this: *btMiniSDF, ijk: btMultiIndex) -> btAlignedBox3d #no_context {
        return subdomain(this, *ijk);
    }

    singleToMultiIndex :: (this: *btMiniSDF, l: u32) -> btMultiIndex #cpp_method #foreign bullet3 "?singleToMultiIndex@btMiniSDF@@QEBA?AUbtMultiIndex@@I@Z";

    subdomain :: (this: *btMiniSDF, l: u32) -> btAlignedBox3d #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?subdomain@btMiniSDF@@QEBA?AUbtAlignedBox3d@@I@Z";

    shape_function_ :: (this: *btMiniSDF, xi: *btVector3, gradient: *btShapeGradients = null) -> btShapeMatrix #cpp_method #foreign bullet3 "?shape_function_@btMiniSDF@@QEBA?AUbtShapeMatrix@@AEBVbtVector3@@PEAUbtShapeGradients@@@Z";
    shape_function_ :: (this: *btMiniSDF, xi: btVector3, gradient: *btShapeGradients = null) -> btShapeMatrix #no_context {
        return shape_function_(this, *xi, gradient);
    }

    interpolate :: (this: *btMiniSDF, field_id: u32, dist: *float64, x: *btVector3, gradient: *btVector3) -> bool #cpp_method #foreign bullet3 "?interpolate@btMiniSDF@@QEBA_NIAEANAEBVbtVector3@@PEAV2@@Z";
    interpolate :: (this: *btMiniSDF, field_id: u32, dist: *float64, x: btVector3, gradient: *btVector3) -> bool #no_context {
        return interpolate(this, field_id, dist, *x, gradient);
    }
}

/// The btMinkowskiSumShape is only for advanced users. This shape represents implicit based minkowski sum of two convex implicit shapes.
btMinkowskiSumShape :: struct {
    #as using btconvexinternalshape: btConvexInternalShape;

    m_transA: btTransform;
    m_transB: btTransform;
    m_shapeA: *btConvexShape;
    m_shapeB: *btConvexShape;

    Constructor :: (this: *btMinkowskiSumShape, shapeA: *btConvexShape, shapeB: *btConvexShape) -> void #cpp_method #foreign bullet3 "??0btMinkowskiSumShape@@QEAA@PEBVbtConvexShape@@0@Z";

    setTransformA :: (this: *btMinkowskiSumShape, transA: *btTransform) -> void #cpp_method #foreign bullet3 "?setTransformA@btMinkowskiSumShape@@QEAAXAEBVbtTransform@@@Z";
    setTransformA :: (this: *btMinkowskiSumShape, transA: btTransform) #no_context {
        setTransformA(this, *transA);
    }
    setTransformB :: (this: *btMinkowskiSumShape, transB: *btTransform) -> void #cpp_method #foreign bullet3 "?setTransformB@btMinkowskiSumShape@@QEAAXAEBVbtTransform@@@Z";
    setTransformB :: (this: *btMinkowskiSumShape, transB: btTransform) #no_context {
        setTransformB(this, *transB);
    }

    getTransformA :: (this: *btMinkowskiSumShape) -> *btTransform #cpp_method #foreign bullet3 "?getTransformA@btMinkowskiSumShape@@QEBAAEBVbtTransform@@XZ";
    getTransformB :: (this: *btMinkowskiSumShape) -> *btTransform #cpp_method #foreign bullet3 "?getTransformB@btMinkowskiSumShape@@QEBAAEBVbtTransform@@XZ";

    // keep this for backward compatibility
    GetTransformB :: (this: *btMinkowskiSumShape) -> *btTransform #cpp_method #foreign bullet3 "?GetTransformB@btMinkowskiSumShape@@QEBAAEBVbtTransform@@XZ";

    getShapeA :: (this: *btMinkowskiSumShape) -> *btConvexShape #cpp_method #foreign bullet3 "?getShapeA@btMinkowskiSumShape@@QEBAPEBVbtConvexShape@@XZ";
    getShapeB :: (this: *btMinkowskiSumShape) -> *btConvexShape #cpp_method #foreign bullet3 "?getShapeB@btMinkowskiSumShape@@QEBAPEBVbtConvexShape@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btMinkowskiSumShape, vec: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btMinkowskiSumShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btMinkowskiSumShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btMinkowskiSumShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_calculateLocalInertia :: (this: *btMinkowskiSumShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btMinkowskiSumShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getMargin :: (this: *btMinkowskiSumShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btMinkowskiSumShape@@UEBAMXZ";

    virtual_getName :: (this: *btMinkowskiSumShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btMinkowskiSumShape@@UEBAPEBDXZ";
}


///The BvhTriangleMaterialMeshShape extends the btBvhTriangleMeshShape. Its main contribution is the interface into a material array, which allows per-triangle friction and restitution.
btMultimaterialTriangleMeshShape :: struct {
    #as using btbvhtrianglemeshshape: btBvhTriangleMeshShape;

    m_materialList: btAlignedObjectArray(*btMaterial);

    Constructor :: (this: *btMultimaterialTriangleMeshShape, meshInterface: *btStridingMeshInterface, useQuantizedAabbCompression: bool, buildBvh := true) -> void #cpp_method #foreign bullet3 "??0btMultimaterialTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_N1@Z";

    ///optionally pass in a larger bvh aabb, used for quantization. This allows for deformations within this aabb
    Constructor :: (this: *btMultimaterialTriangleMeshShape, meshInterface: *btStridingMeshInterface, useQuantizedAabbCompression: bool, bvhAabbMin: *btVector3, bvhAabbMax: *btVector3, buildBvh := true) -> void #cpp_method #foreign bullet3 "??0btMultimaterialTriangleMeshShape@@QEAA@PEAVbtStridingMeshInterface@@_NAEBVbtVector3@@21@Z";
    Constructor :: (this: *btMultimaterialTriangleMeshShape, meshInterface: *btStridingMeshInterface, useQuantizedAabbCompression: bool, bvhAabbMin: btVector3, bvhAabbMax: btVector3, buildBvh := true) #no_context {
        Constructor(this, meshInterface, useQuantizedAabbCompression, *bvhAabbMin, *bvhAabbMax, buildBvh);
    }

    ///Obtains the material for a specific triangle
    getMaterialProperties :: (this: *btMultimaterialTriangleMeshShape, partID: s32, triIndex: s32) -> *btMaterial #cpp_method #foreign bullet3 "?getMaterialProperties@btMultimaterialTriangleMeshShape@@QEAAPEBVbtMaterial@@HH@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultimaterialTriangleMeshShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultimaterialTriangleMeshShape@@UEAA@XZ";

    //debugging
    virtual_getName :: (this: *btMultimaterialTriangleMeshShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btMultimaterialTriangleMeshShape@@UEBAPEBDXZ";
}


btSdfCollisionShape :: struct {
    #as using btconcaveshape: btConcaveShape;

    btSdfCollisionShapeInternalData :: struct {}
    m_data: *btSdfCollisionShapeInternalData;

    Constructor :: (this: *btSdfCollisionShape) -> void #cpp_method #foreign bullet3 "??0btSdfCollisionShape@@QEAA@XZ";

    initializeSDF :: (this: *btSdfCollisionShape, sdfData: *u8, sizeInBytes: s32) -> bool #cpp_method #foreign bullet3 "?initializeSDF@btSdfCollisionShape@@QEAA_NPEBDH@Z";

    queryPoint :: (this: *btSdfCollisionShape, ptInSDF: *btVector3, distOut: *btScalar, normal: *btVector3) -> bool #cpp_method #foreign bullet3 "?queryPoint@btSdfCollisionShape@@QEAA_NAEBVbtVector3@@AEAMAEAV2@@Z";
    queryPoint :: (this: *btSdfCollisionShape, ptInSDF: btVector3, distOut: *btScalar, normal: *btVector3) -> bool #no_context {
        return queryPoint(this, *ptInSDF, distOut, normal);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btSdfCollisionShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSdfCollisionShape@@UEAA@XZ";

    virtual_getAabb :: (this: *btSdfCollisionShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btSdfCollisionShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";
    virtual_setLocalScaling :: (this: *btSdfCollisionShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btSdfCollisionShape@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLocalScaling :: (this: *btSdfCollisionShape) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btSdfCollisionShape@@UEBAAEBVbtVector3@@XZ";
    virtual_calculateLocalInertia :: (this: *btSdfCollisionShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btSdfCollisionShape@@UEBAXMAEAVbtVector3@@@Z";
    virtual_getName :: (this: *btSdfCollisionShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btSdfCollisionShape@@UEBAPEBDXZ";
    virtual_setMargin :: (this: *btSdfCollisionShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btSdfCollisionShape@@UEAAXM@Z";
    virtual_getMargin :: (this: *btSdfCollisionShape) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btSdfCollisionShape@@UEBAMXZ";

    virtual_processAllTriangles :: (this: *btSdfCollisionShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btSdfCollisionShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
}

///The btShapeHull class takes a btConvexShape, builds a simplified convex hull using btConvexHull and provides triangle indices and vertices.
///It can be useful for to simplify a complex convex object and for visualization of a non-polyhedral convex object.
///It approximates the convex hull using the supporting vertex of 42 directions.
btShapeHull :: struct {
    m_vertices:   btAlignedObjectArray(btVector3);
    m_indices:    btAlignedObjectArray(u32);
    m_numIndices: u32;
    m_shape:      *btConvexShape;

    getUnitSpherePoints :: (highres: s32 = 0) -> *btVector3 #foreign bullet3 "?getUnitSpherePoints@btShapeHull@@KAPEAVbtVector3@@H@Z";

    Constructor :: (this: *btShapeHull, shape: *btConvexShape) -> void #cpp_method #foreign bullet3 "??0btShapeHull@@QEAA@PEBVbtConvexShape@@@Z";
    Destructor :: (this: *btShapeHull) -> void #cpp_method #foreign bullet3 "??1btShapeHull@@QEAA@XZ";

    buildHull :: (this: *btShapeHull, margin: btScalar, highres: s32 = 0) -> bool #cpp_method #foreign bullet3 "?buildHull@btShapeHull@@QEAA_NMH@Z";

    numTriangles :: (this: *btShapeHull) -> s32 #cpp_method #foreign bullet3 "?numTriangles@btShapeHull@@QEBAHXZ";
    numVertices :: (this: *btShapeHull) -> s32 #cpp_method #foreign bullet3 "?numVertices@btShapeHull@@QEBAHXZ";
    numIndices :: (this: *btShapeHull) -> s32 #cpp_method #foreign bullet3 "?numIndices@btShapeHull@@QEBAHXZ";

    getVertexPointer :: (this: *btShapeHull) -> *btVector3 #cpp_method #foreign bullet3 "?getVertexPointer@btShapeHull@@QEBAPEBVbtVector3@@XZ";

    getIndexPointer :: (this: *btShapeHull) -> *u32 #cpp_method #foreign bullet3 "?getIndexPointer@btShapeHull@@QEBAPEBIXZ";
}


btTriangle :: struct {
    m_vertex0:       btVector3;
    m_vertex1:       btVector3;
    m_vertex2:       btVector3;
    m_partId:        s32;
    m_triangleIndex: s32;
}

///The btTriangleBuffer callback can be useful to collect and store overlapping triangles between AABB and concave objects that support 'processAllTriangles'
///Example usage of this class:
///			btTriangleBuffer	triBuf;
///			concaveShape->processAllTriangles(&triBuf,aabbMin, aabbMax);
///			for (int i=0;i<triBuf.getNumTriangles();i++)
///			{
///				const btTriangle& tri = triBuf.getTriangle(i);
///				//do something useful here with the triangle
///			}
btTriangleBuffer :: struct {
    #as using bttrianglecallback: btTriangleCallback;

    m_triangleBuffer: btAlignedObjectArray(btTriangle);

    getNumTriangles :: (this: *btTriangleBuffer) -> s32 #cpp_method #foreign bullet3 "?getNumTriangles@btTriangleBuffer@@QEBAHXZ";

    getTriangle :: (this: *btTriangleBuffer, index: s32) -> *btTriangle #cpp_method #foreign bullet3 "?getTriangle@btTriangleBuffer@@QEBAAEBUbtTriangle@@H@Z";

    clearBuffer :: (this: *btTriangleBuffer) -> void #cpp_method #foreign bullet3 "?clearBuffer@btTriangleBuffer@@QEAAXXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processTriangle :: (this: *btTriangleBuffer, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method #foreign bullet3 "?processTriangle@btTriangleBuffer@@UEAAXPEAVbtVector3@@HH@Z";
}

btMaterialProperties :: struct {
    ///m_materialBase ==========> 2 btScalar values make up one material, friction then restitution
    m_numMaterials:           s32;
    m_materialBase:           *u8;
    m_materialStride:         s32;
    m_materialType:           PHY_ScalarType;

    ///m_numTriangles <=========== This exists in the btIndexedMesh object for the same subpart, but since we're
    ///                           padding the structure, it can be reproduced at no real cost
    ///m_triangleMaterials =====> 1 integer value makes up one entry
    ///                           eg: m_triangleMaterials[1] = 5; // This will set triangle 2 to use material 5
    m_numTriangles:           s32;
    m_triangleMaterialsBase:  *u8;
    m_triangleMaterialStride: s32;

    ///m_triangleType <========== Automatically set in addMaterialProperties
    m_triangleType:           PHY_ScalarType;
}

MaterialArray :: btAlignedObjectArray(btMaterialProperties);

///Teh btTriangleIndexVertexMaterialArray is built on TriangleIndexVertexArray
///The addition of a material array allows for the utilization of the partID and
///triangleIndex that are returned in the ContactAddedCallback.  As with
///TriangleIndexVertexArray, no duplicate is made of the material data, so it
///is the users responsibility to maintain the array during the lifetime of the
///TriangleIndexVertexMaterialArray.
btTriangleIndexVertexMaterialArray :: struct {
    #as using bttriangleindexvertexarray: btTriangleIndexVertexArray;

    m_materials: MaterialArray;

    Constructor :: (this: *btTriangleIndexVertexMaterialArray) -> void #cpp_method #foreign bullet3 "??0btTriangleIndexVertexMaterialArray@@QEAA@XZ";

    Constructor :: (this: *btTriangleIndexVertexMaterialArray, numTriangles: s32, triangleIndexBase: *s32, triangleIndexStride: s32, numVertices: s32, vertexBase: *btScalar, vertexStride: s32, numMaterials: s32, materialBase: *u8, materialStride: s32, triangleMaterialsBase: *s32, materialIndexStride: s32) -> void #cpp_method #foreign bullet3 "??0btTriangleIndexVertexMaterialArray@@QEAA@HPEAHHHPEAMHHPEAEH0H@Z";

    addMaterialProperties :: (this: *btTriangleIndexVertexMaterialArray, mat: *btMaterialProperties, triangleType: PHY_ScalarType = .INTEGER) -> void #cpp_method #foreign bullet3 "?addMaterialProperties@btTriangleIndexVertexMaterialArray@@QEAAXAEBUbtMaterialProperties@@W4PHY_ScalarType@@@Z";
    addMaterialProperties :: (this: *btTriangleIndexVertexMaterialArray, mat: btMaterialProperties, triangleType: PHY_ScalarType = .INTEGER) #no_context {
        addMaterialProperties(this, *mat, triangleType);
    }
    #place bttriangleindexvertexarray; bttriangleindexvertexmaterialarray_vtable: *btTriangleIndexVertexMaterialArray_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btTriangleIndexVertexMaterialArray, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btTriangleIndexVertexMaterialArray@@UEAA@XZ";

    virtual_getLockedMaterialBase :: (this: *btTriangleIndexVertexMaterialArray, materialBase: **u8, numMaterials: *s32, materialType: *PHY_ScalarType, materialStride: *s32, triangleMaterialBase: **u8, numTriangles: *s32, triangleMaterialStride: *s32, triangleType: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method #foreign bullet3 "?getLockedMaterialBase@btTriangleIndexVertexMaterialArray@@UEAAXPEAPEAEAEAHAEAW4PHY_ScalarType@@10112H@Z";

    virtual_getLockedReadOnlyMaterialBase :: (this: *btTriangleIndexVertexMaterialArray, materialBase: **u8, numMaterials: *s32, materialType: *PHY_ScalarType, materialStride: *s32, triangleMaterialBase: **u8, numTriangles: *s32, triangleMaterialStride: *s32, triangleType: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method #foreign bullet3 "?getLockedReadOnlyMaterialBase@btTriangleIndexVertexMaterialArray@@UEAAXPEAPEBEAEAHAEAW4PHY_ScalarType@@10112H@Z";
}
btTriangleIndexVertexMaterialArray_VTable :: struct #type_info_none {
    using btstridingmeshinterface: btStridingMeshInterface_VTable;
    getLockedMaterialBase: (this: *btTriangleIndexVertexMaterialArray, materialBase: **u8, numMaterials: *s32, materialType: *PHY_ScalarType, materialStride: *s32, triangleMaterialBase: **u8, numTriangles: *s32, triangleMaterialStride: *s32, triangleType: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method;

    getLockedReadOnlyMaterialBase: (this: *btTriangleIndexVertexMaterialArray, materialBase: **u8, numMaterials: *s32, materialType: *PHY_ScalarType, materialStride: *s32, triangleMaterialBase: **u8, numTriangles: *s32, triangleMaterialStride: *s32, triangleType: *PHY_ScalarType, subpart: s32 = 0) -> void #cpp_method;
}

btTriangleIndexVertexMaterialArray_getLockedMaterialBase :: inline (this: *btTriangleIndexVertexMaterialArray, materialBase: **u8, numMaterials: *s32, materialType: *PHY_ScalarType, materialStride: *s32, triangleMaterialBase: **u8, numTriangles: *s32, triangleMaterialStride: *s32, triangleType: *PHY_ScalarType, subpart: s32 = 0) { this.bttriangleindexvertexmaterialarray_vtable.getLockedMaterialBase(this, materialBase, numMaterials, materialType, materialStride, triangleMaterialBase, numTriangles, triangleMaterialStride, triangleType, subpart); }

btTriangleIndexVertexMaterialArray_getLockedReadOnlyMaterialBase :: inline (this: *btTriangleIndexVertexMaterialArray, materialBase: **u8, numMaterials: *s32, materialType: *PHY_ScalarType, materialStride: *s32, triangleMaterialBase: **u8, numTriangles: *s32, triangleMaterialStride: *s32, triangleType: *PHY_ScalarType, subpart: s32 = 0) { this.bttriangleindexvertexmaterialarray_vtable.getLockedReadOnlyMaterialBase(this, materialBase, numMaterials, materialType, materialStride, triangleMaterialBase, numTriangles, triangleMaterialStride, triangleType, subpart); }

vtable :: (obj: *btTriangleIndexVertexMaterialArray) -> *btTriangleIndexVertexMaterialArray_VTable { return obj.bttriangleindexvertexmaterialarray_vtable; }



btTriangleShape :: struct {
    #as using btpolyhedralconvexshape: btPolyhedralConvexShape;

    m_vertices1: [3] btVector3;

    getVertexPtr :: (this: *btTriangleShape, index: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getVertexPtr@btTriangleShape@@QEAAAEAVbtVector3@@H@Z";

    getVertexPtr_1 :: (this: /*const*/ *btTriangleShape, index: s32) -> *btVector3 #cpp_method #foreign bullet3 "?getVertexPtr@btTriangleShape@@QEBAAEBVbtVector3@@H@Z";

    Constructor :: (this: *btTriangleShape) -> void #cpp_method #foreign bullet3 "??0btTriangleShape@@QEAA@XZ";

    Constructor :: (this: *btTriangleShape, p0: *btVector3, p1: *btVector3, p2: *btVector3) -> void #cpp_method #foreign bullet3 "??0btTriangleShape@@QEAA@AEBVbtVector3@@00@Z";
    Constructor :: (this: *btTriangleShape, p0: btVector3, p1: btVector3, p2: btVector3) #no_context {
        Constructor(this, *p0, *p1, *p2);
    }

    calcNormal :: (this: *btTriangleShape, normal: *btVector3) -> void #cpp_method #foreign bullet3 "?calcNormal@btTriangleShape@@QEBAXAEAVbtVector3@@@Z";
    #place btpolyhedralconvexshape; bttriangleshape_vtable: *btTriangleShape_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getNumVertices :: (this: *btTriangleShape) -> s32 #cpp_method #foreign bullet3 "?getNumVertices@btTriangleShape@@UEBAHXZ";

    virtual_getVertex :: (this: *btTriangleShape, index: s32, vert: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btTriangleShape@@UEBAXHAEAVbtVector3@@@Z";

    virtual_getNumEdges :: (this: *btTriangleShape) -> s32 #cpp_method #foreign bullet3 "?getNumEdges@btTriangleShape@@UEBAHXZ";

    virtual_getEdge :: (this: *btTriangleShape, i: s32, pa: *btVector3, pb: *btVector3) -> void #cpp_method #foreign bullet3 "?getEdge@btTriangleShape@@UEBAXHAEAVbtVector3@@0@Z";

    virtual_getAabb :: (this: *btTriangleShape, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btTriangleShape@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    virtual_localGetSupportingVertexWithoutMargin :: (this: *btTriangleShape, dir: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?localGetSupportingVertexWithoutMargin@btTriangleShape@@UEBA?AVbtVector3@@AEBV2@@Z";

    virtual_batchedUnitVectorGetSupportingVertexWithoutMargin :: (this: *btTriangleShape, vectors: *btVector3, supportVerticesOut: *btVector3, numVectors: s32) -> void #cpp_method #foreign bullet3 "?batchedUnitVectorGetSupportingVertexWithoutMargin@btTriangleShape@@UEBAXPEBVbtVector3@@PEAV2@H@Z";

    virtual_getPlane :: (this: *btTriangleShape, planeNormal: *btVector3, planeSupport: *btVector3, i: s32) -> void #cpp_method #foreign bullet3 "?getPlane@btTriangleShape@@UEBAXAEAVbtVector3@@0H@Z";

    virtual_getNumPlanes :: (this: *btTriangleShape) -> s32 #cpp_method #foreign bullet3 "?getNumPlanes@btTriangleShape@@UEBAHXZ";

    virtual_getPlaneEquation :: (this: *btTriangleShape, i: s32, planeNormal: *btVector3, planeSupport: *btVector3) -> void #cpp_method #foreign bullet3 "?getPlaneEquation@btTriangleShape@@UEBAXHAEAVbtVector3@@0@Z";

    virtual_calculateLocalInertia :: (this: *btTriangleShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btTriangleShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_isInside :: (this: *btTriangleShape, pt: *btVector3, tolerance: btScalar) -> bool #cpp_method #foreign bullet3 "?isInside@btTriangleShape@@UEBA_NAEBVbtVector3@@M@Z";

    //debugging
    virtual_getName :: (this: *btTriangleShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btTriangleShape@@UEBAPEBDXZ";

    virtual_getNumPreferredPenetrationDirections :: (this: *btTriangleShape) -> s32 #cpp_method #foreign bullet3 "?getNumPreferredPenetrationDirections@btTriangleShape@@UEBAHXZ";

    virtual_getPreferredPenetrationDirection :: (this: *btTriangleShape, index: s32, penetrationVector: *btVector3) -> void #cpp_method #foreign bullet3 "?getPreferredPenetrationDirection@btTriangleShape@@UEBAXHAEAVbtVector3@@@Z";
}
btTriangleShape_VTable :: struct #type_info_none {
    using btpolyhedralconvexshape: btPolyhedralConvexShape_VTable;
    getPlaneEquation: (this: *btTriangleShape, i: s32, planeNormal: *btVector3, planeSupport: *btVector3) -> void #cpp_method;
}
btTriangleShape_getPlaneEquation :: inline (this: *btTriangleShape, i: s32, planeNormal: *btVector3, planeSupport: *btVector3) { this.bttriangleshape_vtable.getPlaneEquation(this, i, planeNormal, planeSupport); }

vtable :: (obj: *btTriangleShape) -> *btTriangleShape_VTable { return obj.bttriangleshape_vtable; }



eBT_PLANE_INTERSECTION_TYPE :: enum s32 {
    BACK_PLANE    :: 0;
    COLLIDE_PLANE :: 1;
    FRONT_PLANE   :: 2;

    BT_CONST_BACK_PLANE    :: BACK_PLANE;
    BT_CONST_COLLIDE_PLANE :: COLLIDE_PLANE;
    BT_CONST_FRONT_PLANE   :: FRONT_PLANE;
}

//!  Class for transforming a model1 to the space of model0
BT_BOX_BOX_TRANSFORM_CACHE :: struct {
    m_T1to0: btVector3; //!< Transforms translation of model1 to model 0
    m_R1to0: btMatrix3x3; //!< Transforms Rotation of model1 to model 0, equal  to R0' * R1
    m_AR:    btMatrix3x3; //!< Absolute value of m_R1to0

    calc_absolute_matrix :: (this: *BT_BOX_BOX_TRANSFORM_CACHE) -> void #cpp_method #foreign bullet3 "?calc_absolute_matrix@BT_BOX_BOX_TRANSFORM_CACHE@@QEAAXXZ";

    Constructor :: (this: *BT_BOX_BOX_TRANSFORM_CACHE) -> void #cpp_method #foreign bullet3 "??0BT_BOX_BOX_TRANSFORM_CACHE@@QEAA@XZ";

    //! Calc the transformation relative  1 to 0. Inverts matrics by transposing
    calc_from_homogenic :: (this: *BT_BOX_BOX_TRANSFORM_CACHE, trans0: *btTransform, trans1: *btTransform) -> void #cpp_method #foreign bullet3 "?calc_from_homogenic@BT_BOX_BOX_TRANSFORM_CACHE@@QEAAXAEBVbtTransform@@0@Z";
    calc_from_homogenic :: (this: *BT_BOX_BOX_TRANSFORM_CACHE, trans0: btTransform, trans1: btTransform) #no_context {
        calc_from_homogenic(this, *trans0, *trans1);
    }

    //! Calcs the full invertion of the matrices. Useful for scaling matrices
    calc_from_full_invert :: (this: *BT_BOX_BOX_TRANSFORM_CACHE, trans0: *btTransform, trans1: *btTransform) -> void #cpp_method #foreign bullet3 "?calc_from_full_invert@BT_BOX_BOX_TRANSFORM_CACHE@@QEAAXAEBVbtTransform@@0@Z";
    calc_from_full_invert :: (this: *BT_BOX_BOX_TRANSFORM_CACHE, trans0: btTransform, trans1: btTransform) #no_context {
        calc_from_full_invert(this, *trans0, *trans1);
    }

    transform :: (this: *BT_BOX_BOX_TRANSFORM_CACHE, point: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?transform@BT_BOX_BOX_TRANSFORM_CACHE@@QEBA?AVbtVector3@@AEBV2@@Z";
    transform :: (this: *BT_BOX_BOX_TRANSFORM_CACHE, point: btVector3) -> btVector3 #no_context {
        return transform(this, *point);
    }
}

//! Axis aligned box
btAABB :: struct {
    m_min: btVector3;
    m_max: btVector3;

    Constructor :: (this: *btAABB) -> void #cpp_method #foreign bullet3 "??0btAABB@@QEAA@XZ";

    Constructor :: (this: *btAABB, V1: *btVector3, V2: *btVector3, V3: *btVector3) -> void #cpp_method #foreign bullet3 "??0btAABB@@QEAA@AEBVbtVector3@@00@Z";
    Constructor :: (this: *btAABB, V1: btVector3, V2: btVector3, V3: btVector3) #no_context {
        Constructor(this, *V1, *V2, *V3);
    }

    Constructor :: (this: *btAABB, V1: *btVector3, V2: *btVector3, V3: *btVector3, margin: btScalar) -> void #cpp_method #foreign bullet3 "??0btAABB@@QEAA@AEBVbtVector3@@00M@Z";
    Constructor :: (this: *btAABB, V1: btVector3, V2: btVector3, V3: btVector3, margin: btScalar) #no_context {
        Constructor(this, *V1, *V2, *V3, margin);
    }

    CopyConstructor :: (this: *btAABB, other: *btAABB) -> void #cpp_method #foreign bullet3 "??0btAABB@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btAABB, other: btAABB) #no_context {
        CopyConstructor(this, *other);
    }

    Constructor :: (this: *btAABB, other: *btAABB, margin: btScalar) -> void #cpp_method #foreign bullet3 "??0btAABB@@QEAA@AEBV0@M@Z";
    Constructor :: (this: *btAABB, other: btAABB, margin: btScalar) #no_context {
        Constructor(this, *other, margin);
    }

    invalidate :: (this: *btAABB) -> void #cpp_method #foreign bullet3 "?invalidate@btAABB@@QEAAXXZ";

    increment_margin :: (this: *btAABB, margin: btScalar) -> void #cpp_method #foreign bullet3 "?increment_margin@btAABB@@QEAAXM@Z";

    copy_with_margin :: (this: *btAABB, other: *btAABB, margin: btScalar) -> void #cpp_method #foreign bullet3 "?copy_with_margin@btAABB@@QEAAXAEBV1@M@Z";
    copy_with_margin :: (this: *btAABB, other: btAABB, margin: btScalar) #no_context {
        copy_with_margin(this, *other, margin);
    }

    //! Apply a transform to an AABB
    appy_transform :: (this: *btAABB, trans: *btTransform) -> void #cpp_method #foreign bullet3 "?appy_transform@btAABB@@QEAAXAEBVbtTransform@@@Z";
    appy_transform :: (this: *btAABB, trans: btTransform) #no_context {
        appy_transform(this, *trans);
    }

    //! Apply a transform to an AABB
    appy_transform_trans_cache :: (this: *btAABB, trans: *BT_BOX_BOX_TRANSFORM_CACHE) -> void #cpp_method #foreign bullet3 "?appy_transform_trans_cache@btAABB@@QEAAXAEBVBT_BOX_BOX_TRANSFORM_CACHE@@@Z";
    appy_transform_trans_cache :: (this: *btAABB, trans: BT_BOX_BOX_TRANSFORM_CACHE) #no_context {
        appy_transform_trans_cache(this, *trans);
    }

    //! Merges a Box
    merge :: (this: *btAABB, box: *btAABB) -> void #cpp_method #foreign bullet3 "?merge@btAABB@@QEAAXAEBV1@@Z";
    merge :: (this: *btAABB, box: btAABB) #no_context {
        merge(this, *box);
    }

    //! Gets the extend and center
    get_center_extend :: (this: *btAABB, center: *btVector3, extend: *btVector3) -> void #cpp_method #foreign bullet3 "?get_center_extend@btAABB@@QEBAXAEAVbtVector3@@0@Z";

    //! Finds the intersecting box between this box and the other.
    find_intersection :: (this: *btAABB, other: *btAABB, intersection: *btAABB) -> void #cpp_method #foreign bullet3 "?find_intersection@btAABB@@QEBAXAEBV1@AEAV1@@Z";
    find_intersection :: (this: *btAABB, other: btAABB, intersection: *btAABB) #no_context {
        find_intersection(this, *other, intersection);
    }

    has_collision :: (this: *btAABB, other: *btAABB) -> bool #cpp_method #foreign bullet3 "?has_collision@btAABB@@QEBA_NAEBV1@@Z";
    has_collision :: (this: *btAABB, other: btAABB) -> bool #no_context {
        return has_collision(this, *other);
    }

    /*! \brief Finds the Ray intersection parameter.
    \param aabb Aligned box
    \param vorigin A vec3f with the origin of the ray
    \param vdir A vec3f with the direction of the ray
    */
    collide_ray :: (this: *btAABB, vorigin: *btVector3, vdir: *btVector3) -> bool #cpp_method #foreign bullet3 "?collide_ray@btAABB@@QEBA_NAEBVbtVector3@@0@Z";
    collide_ray :: (this: *btAABB, vorigin: btVector3, vdir: btVector3) -> bool #no_context {
        return collide_ray(this, *vorigin, *vdir);
    }

    projection_interval :: (this: *btAABB, direction: *btVector3, vmin: *btScalar, vmax: *btScalar) -> void #cpp_method #foreign bullet3 "?projection_interval@btAABB@@QEBAXAEBVbtVector3@@AEAM1@Z";
    projection_interval :: (this: *btAABB, direction: btVector3, vmin: *btScalar, vmax: *btScalar) #no_context {
        projection_interval(this, *direction, vmin, vmax);
    }

    plane_classify :: (this: *btAABB, plane: *btVector4) -> eBT_PLANE_INTERSECTION_TYPE #cpp_method #foreign bullet3 "?plane_classify@btAABB@@QEBA?AW4eBT_PLANE_INTERSECTION_TYPE@@AEBVbtVector4@@@Z";
    plane_classify :: (this: *btAABB, plane: btVector4) -> eBT_PLANE_INTERSECTION_TYPE #no_context {
        return plane_classify(this, *plane);
    }

    overlapping_trans_conservative :: (this: *btAABB, box: *btAABB, trans1_to_0: *btTransform) -> bool #cpp_method #foreign bullet3 "?overlapping_trans_conservative@btAABB@@QEBA_NAEBV1@AEAVbtTransform@@@Z";
    overlapping_trans_conservative :: (this: *btAABB, box: btAABB, trans1_to_0: *btTransform) -> bool #no_context {
        return overlapping_trans_conservative(this, *box, trans1_to_0);
    }

    overlapping_trans_conservative2 :: (this: *btAABB, box: *btAABB, trans1_to_0: *BT_BOX_BOX_TRANSFORM_CACHE) -> bool #cpp_method #foreign bullet3 "?overlapping_trans_conservative2@btAABB@@QEBA_NAEBV1@AEBVBT_BOX_BOX_TRANSFORM_CACHE@@@Z";
    overlapping_trans_conservative2 :: (this: *btAABB, box: btAABB, trans1_to_0: BT_BOX_BOX_TRANSFORM_CACHE) -> bool #no_context {
        return overlapping_trans_conservative2(this, *box, *trans1_to_0);
    }

    //! transcache is the transformation cache from box to this AABB
    overlapping_trans_cache :: (this: *btAABB, box: *btAABB, transcache: *BT_BOX_BOX_TRANSFORM_CACHE, fulltest: bool) -> bool #cpp_method #foreign bullet3 "?overlapping_trans_cache@btAABB@@QEBA_NAEBV1@AEBVBT_BOX_BOX_TRANSFORM_CACHE@@_N@Z";
    overlapping_trans_cache :: (this: *btAABB, box: btAABB, transcache: BT_BOX_BOX_TRANSFORM_CACHE, fulltest: bool) -> bool #no_context {
        return overlapping_trans_cache(this, *box, *transcache, fulltest);
    }

    //! Simple test for planes.
    collide_plane :: (this: *btAABB, plane: *btVector4) -> bool #cpp_method #foreign bullet3 "?collide_plane@btAABB@@QEBA_NAEBVbtVector4@@@Z";
    collide_plane :: (this: *btAABB, plane: btVector4) -> bool #no_context {
        return collide_plane(this, *plane);
    }

    //! test for a triangle, with edges
    collide_triangle_exact :: (this: *btAABB, p1: *btVector3, p2: *btVector3, p3: *btVector3, triangle_plane: *btVector4) -> bool #cpp_method #foreign bullet3 "?collide_triangle_exact@btAABB@@QEBA_NAEBVbtVector3@@00AEBVbtVector4@@@Z";
    collide_triangle_exact :: (this: *btAABB, p1: btVector3, p2: btVector3, p3: btVector3, triangle_plane: btVector4) -> bool #no_context {
        return collide_triangle_exact(this, *p1, *p2, *p3, *triangle_plane);
    }
}

//! Structure for collision
GIM_TRIANGLE_CONTACT :: struct {
    m_penetration_depth: btScalar;
    m_point_count:       s32;
    m_separating_normal: btVector4;
    m_points:            [16] btVector3;

    copy_from :: (this: *GIM_TRIANGLE_CONTACT, other: *GIM_TRIANGLE_CONTACT) -> void #cpp_method #foreign bullet3 "?copy_from@GIM_TRIANGLE_CONTACT@@QEAAXAEBU1@@Z";
    copy_from :: (this: *GIM_TRIANGLE_CONTACT, other: GIM_TRIANGLE_CONTACT) #no_context {
        copy_from(this, *other);
    }

    Constructor :: (this: *GIM_TRIANGLE_CONTACT) -> void #cpp_method #foreign bullet3 "??0GIM_TRIANGLE_CONTACT@@QEAA@XZ";

    CopyConstructor :: (this: *GIM_TRIANGLE_CONTACT, other: *GIM_TRIANGLE_CONTACT) -> void #cpp_method #foreign bullet3 "??0GIM_TRIANGLE_CONTACT@@QEAA@AEBU0@@Z";
    CopyConstructor :: (this: *GIM_TRIANGLE_CONTACT, other: GIM_TRIANGLE_CONTACT) #no_context {
        CopyConstructor(this, *other);
    }

    //! classify points that are closer
    merge_points :: (this: *GIM_TRIANGLE_CONTACT, plane: *btVector4, margin: btScalar, points: *btVector3, point_count: s32) -> void #cpp_method #foreign bullet3 "?merge_points@GIM_TRIANGLE_CONTACT@@QEAAXAEBVbtVector4@@MPEBVbtVector3@@H@Z";
    merge_points :: (this: *GIM_TRIANGLE_CONTACT, plane: btVector4, margin: btScalar, points: *btVector3, point_count: s32) #no_context {
        merge_points(this, *plane, margin, points, point_count);
    }
}

btPrimitiveTriangle :: struct {
    m_vertices: [3] btVector3;
    m_plane:    btVector4;
    m_margin:   btScalar;
    m_dummy:    btScalar;
    Constructor :: (this: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "??0btPrimitiveTriangle@@QEAA@XZ";

    buildTriPlane :: (this: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "?buildTriPlane@btPrimitiveTriangle@@QEAAXXZ";

    //! Test if triangles could collide
    overlap_test_conservative :: (this: *btPrimitiveTriangle, other: *btPrimitiveTriangle) -> bool #cpp_method #foreign bullet3 "?overlap_test_conservative@btPrimitiveTriangle@@QEAA_NAEBV1@@Z";
    overlap_test_conservative :: (this: *btPrimitiveTriangle, other: btPrimitiveTriangle) -> bool #no_context {
        return overlap_test_conservative(this, *other);
    }

    //! Calcs the plane which is paralele to the edge and perpendicular to the triangle plane
    /*!
    \pre this triangle must have its plane calculated.
    */
    get_edge_plane :: (this: *btPrimitiveTriangle, edge_index: s32, plane: *btVector4) -> void #cpp_method #foreign bullet3 "?get_edge_plane@btPrimitiveTriangle@@QEBAXHAEAVbtVector4@@@Z";

    applyTransform :: (this: *btPrimitiveTriangle, t: *btTransform) -> void #cpp_method #foreign bullet3 "?applyTransform@btPrimitiveTriangle@@QEAAXAEBVbtTransform@@@Z";
    applyTransform :: (this: *btPrimitiveTriangle, t: btTransform) #no_context {
        applyTransform(this, *t);
    }

    //! Clips the triangle against this
    /*!
    \pre clipped_points must have MAX_TRI_CLIPPING size, and this triangle must have its plane calculated.
    \return the number of clipped points
    */
    clip_triangle :: (this: *btPrimitiveTriangle, other: *btPrimitiveTriangle, clipped_points: *btVector3) -> s32 #cpp_method #foreign bullet3 "?clip_triangle@btPrimitiveTriangle@@QEAAHAEAV1@PEAVbtVector3@@@Z";

    //! Find collision using the clipping method
    /*!
    \pre this triangle and other must have their triangles calculated
    */
    find_triangle_collision_clip_method :: (this: *btPrimitiveTriangle, other: *btPrimitiveTriangle, contacts: *GIM_TRIANGLE_CONTACT) -> bool #cpp_method #foreign bullet3 "?find_triangle_collision_clip_method@btPrimitiveTriangle@@QEAA_NAEAV1@AEAUGIM_TRIANGLE_CONTACT@@@Z";
}

//! Helper class for colliding Bullet Triangle Shapes
/*!
This class implements a better getAabb method than the previous btTriangleShape class
*/
btTriangleShapeEx :: struct {
    #as using bttriangleshape: btTriangleShape;

    Constructor :: (this: *btTriangleShapeEx) -> void #cpp_method #foreign bullet3 "??0btTriangleShapeEx@@QEAA@XZ";

    Constructor :: (this: *btTriangleShapeEx, p0: *btVector3, p1: *btVector3, p2: *btVector3) -> void #cpp_method #foreign bullet3 "??0btTriangleShapeEx@@QEAA@AEBVbtVector3@@00@Z";
    Constructor :: (this: *btTriangleShapeEx, p0: btVector3, p1: btVector3, p2: btVector3) #no_context {
        Constructor(this, *p0, *p1, *p2);
    }

    CopyConstructor :: (this: *btTriangleShapeEx, other: *btTriangleShapeEx) -> void #cpp_method #foreign bullet3 "??0btTriangleShapeEx@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *btTriangleShapeEx, other: btTriangleShapeEx) #no_context {
        CopyConstructor(this, *other);
    }

    applyTransform :: (this: *btTriangleShapeEx, t: *btTransform) -> void #cpp_method #foreign bullet3 "?applyTransform@btTriangleShapeEx@@QEAAXAEBVbtTransform@@@Z";
    applyTransform :: (this: *btTriangleShapeEx, t: btTransform) #no_context {
        applyTransform(this, *t);
    }

    buildTriPlane :: (this: *btTriangleShapeEx, plane: *btVector4) -> void #cpp_method #foreign bullet3 "?buildTriPlane@btTriangleShapeEx@@QEBAXAEAVbtVector4@@@Z";

    overlap_test_conservative :: (this: *btTriangleShapeEx, other: *btTriangleShapeEx) -> bool #cpp_method #foreign bullet3 "?overlap_test_conservative@btTriangleShapeEx@@QEAA_NAEBV1@@Z";
    overlap_test_conservative :: (this: *btTriangleShapeEx, other: btTriangleShapeEx) -> bool #no_context {
        return overlap_test_conservative(this, *other);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_getAabb :: (this: *btTriangleShapeEx, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btTriangleShapeEx@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";
}

//! Overlapping pair
GIM_PAIR :: struct {
    m_index1: s32;
    m_index2: s32;
    Constructor :: (this: *GIM_PAIR) -> void #cpp_method #foreign bullet3 "??0GIM_PAIR@@QEAA@XZ";

    CopyConstructor :: (this: *GIM_PAIR, p: *GIM_PAIR) -> void #cpp_method #foreign bullet3 "??0GIM_PAIR@@QEAA@AEBU0@@Z";
    CopyConstructor :: (this: *GIM_PAIR, p: GIM_PAIR) #no_context {
        CopyConstructor(this, *p);
    }

    Constructor :: (this: *GIM_PAIR, index1: s32, index2: s32) -> void #cpp_method #foreign bullet3 "??0GIM_PAIR@@QEAA@HH@Z";
}

///GIM_BVH_DATA is an internal GIMPACT collision structure to contain axis aligned bounding box
GIM_BVH_DATA :: struct {
    m_bound: btAABB;
    m_data:  s32;
}

//! Node Structure for trees
GIM_BVH_TREE_NODE :: struct {
    m_bound:                  btAABB;

    m_escapeIndexOrDataIndex: s32;

    Constructor :: (this: *GIM_BVH_TREE_NODE) -> void #cpp_method #foreign bullet3 "??0GIM_BVH_TREE_NODE@@QEAA@XZ";

    isLeafNode :: (this: *GIM_BVH_TREE_NODE) -> bool #cpp_method #foreign bullet3 "?isLeafNode@GIM_BVH_TREE_NODE@@QEBA_NXZ";

    getEscapeIndex :: (this: *GIM_BVH_TREE_NODE) -> s32 #cpp_method #foreign bullet3 "?getEscapeIndex@GIM_BVH_TREE_NODE@@QEBAHXZ";

    setEscapeIndex :: (this: *GIM_BVH_TREE_NODE, index: s32) -> void #cpp_method #foreign bullet3 "?setEscapeIndex@GIM_BVH_TREE_NODE@@QEAAXH@Z";

    getDataIndex :: (this: *GIM_BVH_TREE_NODE) -> s32 #cpp_method #foreign bullet3 "?getDataIndex@GIM_BVH_TREE_NODE@@QEBAHXZ";

    setDataIndex :: (this: *GIM_BVH_TREE_NODE, index: s32) -> void #cpp_method #foreign bullet3 "?setDataIndex@GIM_BVH_TREE_NODE@@QEAAXH@Z";
}

//! A pairset array
btPairSet :: struct {
    #as using btalignedobjectarray: btAlignedObjectArray(GIM_PAIR);

    Constructor :: (this: *btPairSet) -> void #cpp_method #foreign bullet3 "??0btPairSet@@QEAA@XZ";

    push_pair :: (this: *btPairSet, index1: s32, index2: s32) -> void #cpp_method #foreign bullet3 "?push_pair@btPairSet@@QEAAXHH@Z";

    push_pair_inv :: (this: *btPairSet, index1: s32, index2: s32) -> void #cpp_method #foreign bullet3 "?push_pair_inv@btPairSet@@QEAAXHH@Z";
}

GIM_BVH_DATA_ARRAY :: struct {
    #as using btalignedobjectarray: btAlignedObjectArray(GIM_BVH_DATA);
}

GIM_BVH_TREE_NODE_ARRAY :: struct {
    #as using btalignedobjectarray: btAlignedObjectArray(GIM_BVH_TREE_NODE);
}

//! Basic Box tree structure
btBvhTree :: struct {
    m_num_nodes:  s32;
    m_node_array: GIM_BVH_TREE_NODE_ARRAY;

    _sort_and_calc_splitting_index :: (this: *btBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, startIndex: s32, endIndex: s32, splitAxis: s32) -> s32 #cpp_method #foreign bullet3 "?_sort_and_calc_splitting_index@btBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HHH@Z";

    _calc_splitting_axis :: (this: *btBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, startIndex: s32, endIndex: s32) -> s32 #cpp_method #foreign bullet3 "?_calc_splitting_axis@btBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HH@Z";

    _build_sub_tree :: (this: *btBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, startIndex: s32, endIndex: s32) -> void #cpp_method #foreign bullet3 "?_build_sub_tree@btBvhTree@@IEAAXAEAVGIM_BVH_DATA_ARRAY@@HH@Z";

    Constructor :: (this: *btBvhTree) -> void #cpp_method #foreign bullet3 "??0btBvhTree@@QEAA@XZ";

    //! prototype functions for box tree management
    //!@{
    build_tree :: (this: *btBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY) -> void #cpp_method #foreign bullet3 "?build_tree@btBvhTree@@QEAAXAEAVGIM_BVH_DATA_ARRAY@@@Z";

    clearNodes :: (this: *btBvhTree) -> void #cpp_method #foreign bullet3 "?clearNodes@btBvhTree@@QEAAXXZ";

    //! node count
    getNodeCount :: (this: *btBvhTree) -> s32 #cpp_method #foreign bullet3 "?getNodeCount@btBvhTree@@QEBAHXZ";

    //! tells if the node is a leaf
    isLeafNode :: (this: *btBvhTree, nodeindex: s32) -> bool #cpp_method #foreign bullet3 "?isLeafNode@btBvhTree@@QEBA_NH@Z";

    getNodeData :: (this: *btBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getNodeData@btBvhTree@@QEBAHH@Z";

    getNodeBound :: (this: *btBvhTree, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?getNodeBound@btBvhTree@@QEBAXHAEAVbtAABB@@@Z";

    setNodeBound :: (this: *btBvhTree, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?setNodeBound@btBvhTree@@QEAAXHAEBVbtAABB@@@Z";
    setNodeBound :: (this: *btBvhTree, nodeindex: s32, bound: btAABB) #no_context {
        setNodeBound(this, nodeindex, *bound);
    }

    getLeftNode :: (this: *btBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getLeftNode@btBvhTree@@QEBAHH@Z";

    getRightNode :: (this: *btBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getRightNode@btBvhTree@@QEBAHH@Z";

    getEscapeNodeIndex :: (this: *btBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getEscapeNodeIndex@btBvhTree@@QEBAHH@Z";

    get_node_pointer :: (this: *btBvhTree, index: s32 = 0) -> *GIM_BVH_TREE_NODE #cpp_method #foreign bullet3 "?get_node_pointer@btBvhTree@@QEBAPEBVGIM_BVH_TREE_NODE@@H@Z";
}

//! Prototype Base class for primitive classification
/*!
This class is a wrapper for primitive collections.
This tells relevant info for the Bounding Box set classes, which take care of space classification.
This class can manage Compound shapes and trimeshes, and if it is managing trimesh then the  Hierarchy Bounding Box classes will take advantage of primitive Vs Box overlapping tests for getting optimal results and less Per Box compairisons.
*/
btPrimitiveManagerBase :: struct {
    vtable: *btPrimitiveManagerBase_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btPrimitiveManagerBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btPrimitiveManagerBase@@UEAA@XZ";
}
btPrimitiveManagerBase_VTable :: struct #type_info_none {
    Destructor: (this: *btPrimitiveManagerBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    is_trimesh: (this: *btPrimitiveManagerBase) -> bool #cpp_method;
    get_primitive_count: (this: *btPrimitiveManagerBase) -> s32 #cpp_method;
    get_primitive_box: (this: *btPrimitiveManagerBase, prim_index: s32, primbox: *btAABB) -> void #cpp_method;

    get_primitive_triangle: (this: *btPrimitiveManagerBase, prim_index: s32, triangle: *btPrimitiveTriangle) -> void #cpp_method;
}

btPrimitiveManagerBase_Destructor :: inline (this: *btPrimitiveManagerBase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btPrimitiveManagerBase_is_trimesh :: inline (this: *btPrimitiveManagerBase) -> bool { return this.vtable.is_trimesh(this); }
btPrimitiveManagerBase_get_primitive_count :: inline (this: *btPrimitiveManagerBase) -> s32 { return this.vtable.get_primitive_count(this); }
btPrimitiveManagerBase_get_primitive_box :: inline (this: *btPrimitiveManagerBase, prim_index: s32, primbox: *btAABB) { this.vtable.get_primitive_box(this, prim_index, primbox); }

btPrimitiveManagerBase_get_primitive_triangle :: inline (this: *btPrimitiveManagerBase, prim_index: s32, triangle: *btPrimitiveTriangle) { this.vtable.get_primitive_triangle(this, prim_index, triangle); }



//! Structure for containing Boxes
/*!
This class offers an structure for managing a box tree of primitives.
Requires a Primitive prototype (like btPrimitiveManagerBase )
*/
btGImpactBvh :: struct {
    m_box_tree:          btBvhTree;
    m_primitive_manager: *btPrimitiveManagerBase;

    //stackless refit
    refit :: (this: *btGImpactBvh) -> void #cpp_method #foreign bullet3 "?refit@btGImpactBvh@@IEAAXXZ";

    //! this constructor doesn't build the tree. you must call	buildSet
    Constructor :: (this: *btGImpactBvh) -> void #cpp_method #foreign bullet3 "??0btGImpactBvh@@QEAA@XZ";

    //! this constructor doesn't build the tree. you must call	buildSet
    Constructor :: (this: *btGImpactBvh, primitive_manager: *btPrimitiveManagerBase) -> void #cpp_method #foreign bullet3 "??0btGImpactBvh@@QEAA@PEAVbtPrimitiveManagerBase@@@Z";

    getGlobalBox :: (this: *btGImpactBvh) -> btAABB #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getGlobalBox@btGImpactBvh@@QEBA?AVbtAABB@@XZ";

    setPrimitiveManager :: (this: *btGImpactBvh, primitive_manager: *btPrimitiveManagerBase) -> void #cpp_method #foreign bullet3 "?setPrimitiveManager@btGImpactBvh@@QEAAXPEAVbtPrimitiveManagerBase@@@Z";

    getPrimitiveManager :: (this: *btGImpactBvh) -> *btPrimitiveManagerBase #cpp_method #foreign bullet3 "?getPrimitiveManager@btGImpactBvh@@QEBAPEAVbtPrimitiveManagerBase@@XZ";

    //! this attemps to refit the box set.
    update :: (this: *btGImpactBvh) -> void #cpp_method #foreign bullet3 "?update@btGImpactBvh@@QEAAXXZ";

    //! this rebuild the entire set
    buildSet :: (this: *btGImpactBvh) -> void #cpp_method #foreign bullet3 "?buildSet@btGImpactBvh@@QEAAXXZ";

    //! returns the indices of the primitives in the m_primitive_manager
    boxQuery :: (this: *btGImpactBvh, box: *btAABB, collided_results: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?boxQuery@btGImpactBvh@@QEBA_NAEBVbtAABB@@AEAV?$btAlignedObjectArray@H@@@Z";
    boxQuery :: (this: *btGImpactBvh, box: btAABB, collided_results: *btAlignedObjectArray(s32)) -> bool #no_context {
        return boxQuery(this, *box, collided_results);
    }

    //! returns the indices of the primitives in the m_primitive_manager
    boxQueryTrans :: (this: *btGImpactBvh, box: *btAABB, transform: *btTransform, collided_results: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?boxQueryTrans@btGImpactBvh@@QEBA_NAEBVbtAABB@@AEBVbtTransform@@AEAV?$btAlignedObjectArray@H@@@Z";
    boxQueryTrans :: (this: *btGImpactBvh, box: btAABB, transform: btTransform, collided_results: *btAlignedObjectArray(s32)) -> bool #no_context {
        return boxQueryTrans(this, *box, *transform, collided_results);
    }

    //! returns the indices of the primitives in the m_primitive_manager
    rayQuery :: (this: *btGImpactBvh, ray_dir: *btVector3, ray_origin: *btVector3, collided_results: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?rayQuery@btGImpactBvh@@QEBA_NAEBVbtVector3@@0AEAV?$btAlignedObjectArray@H@@@Z";
    rayQuery :: (this: *btGImpactBvh, ray_dir: btVector3, ray_origin: btVector3, collided_results: *btAlignedObjectArray(s32)) -> bool #no_context {
        return rayQuery(this, *ray_dir, *ray_origin, collided_results);
    }

    //! tells if this set has hierarcht
    hasHierarchy :: (this: *btGImpactBvh) -> bool #cpp_method #foreign bullet3 "?hasHierarchy@btGImpactBvh@@QEBA_NXZ";

    //! tells if this set is a trimesh
    isTrimesh :: (this: *btGImpactBvh) -> bool #cpp_method #foreign bullet3 "?isTrimesh@btGImpactBvh@@QEBA_NXZ";

    //! node count
    getNodeCount :: (this: *btGImpactBvh) -> s32 #cpp_method #foreign bullet3 "?getNodeCount@btGImpactBvh@@QEBAHXZ";

    //! tells if the node is a leaf
    isLeafNode :: (this: *btGImpactBvh, nodeindex: s32) -> bool #cpp_method #foreign bullet3 "?isLeafNode@btGImpactBvh@@QEBA_NH@Z";

    getNodeData :: (this: *btGImpactBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getNodeData@btGImpactBvh@@QEBAHH@Z";

    getNodeBound :: (this: *btGImpactBvh, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?getNodeBound@btGImpactBvh@@QEBAXHAEAVbtAABB@@@Z";

    setNodeBound :: (this: *btGImpactBvh, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?setNodeBound@btGImpactBvh@@QEAAXHAEBVbtAABB@@@Z";
    setNodeBound :: (this: *btGImpactBvh, nodeindex: s32, bound: btAABB) #no_context {
        setNodeBound(this, nodeindex, *bound);
    }

    getLeftNode :: (this: *btGImpactBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getLeftNode@btGImpactBvh@@QEBAHH@Z";

    getRightNode :: (this: *btGImpactBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getRightNode@btGImpactBvh@@QEBAHH@Z";

    getEscapeNodeIndex :: (this: *btGImpactBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getEscapeNodeIndex@btGImpactBvh@@QEBAHH@Z";

    getNodeTriangle :: (this: *btGImpactBvh, nodeindex: s32, triangle: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "?getNodeTriangle@btGImpactBvh@@QEBAXHAEAVbtPrimitiveTriangle@@@Z";

    get_node_pointer :: (this: *btGImpactBvh, index: s32 = 0) -> *GIM_BVH_TREE_NODE #cpp_method #foreign bullet3 "?get_node_pointer@btGImpactBvh@@QEBAPEBVGIM_BVH_TREE_NODE@@H@Z";

    find_collision :: (boxset1: *btGImpactBvh, trans1: *btTransform, boxset2: *btGImpactBvh, trans2: *btTransform, collision_pairs: *btPairSet) -> void #foreign bullet3 "?find_collision@btGImpactBvh@@SAXPEAV1@AEBVbtTransform@@01AEAVbtPairSet@@@Z";
    find_collision :: (boxset1: *btGImpactBvh, trans1: btTransform, boxset2: *btGImpactBvh, trans2: btTransform, collision_pairs: *btPairSet) #no_context {
        find_collision(boxset1, *trans1, boxset2, *trans2, collision_pairs);
    }
}

///btQuantizedBvhNode is a compressed aabb node, 16 bytes.
///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
BT_QUANTIZED_BVH_NODE :: struct {
    //12 bytes
    m_quantizedAabbMin:       [3] u16;
    m_quantizedAabbMax:       [3] u16;

    //4 bytes
    m_escapeIndexOrDataIndex: s32;

    Constructor :: (this: *BT_QUANTIZED_BVH_NODE) -> void #cpp_method #foreign bullet3 "??0BT_QUANTIZED_BVH_NODE@@QEAA@XZ";

    isLeafNode :: (this: *BT_QUANTIZED_BVH_NODE) -> bool #cpp_method #foreign bullet3 "?isLeafNode@BT_QUANTIZED_BVH_NODE@@QEBA_NXZ";

    getEscapeIndex :: (this: *BT_QUANTIZED_BVH_NODE) -> s32 #cpp_method #foreign bullet3 "?getEscapeIndex@BT_QUANTIZED_BVH_NODE@@QEBAHXZ";

    setEscapeIndex :: (this: *BT_QUANTIZED_BVH_NODE, index: s32) -> void #cpp_method #foreign bullet3 "?setEscapeIndex@BT_QUANTIZED_BVH_NODE@@QEAAXH@Z";

    getDataIndex :: (this: *BT_QUANTIZED_BVH_NODE) -> s32 #cpp_method #foreign bullet3 "?getDataIndex@BT_QUANTIZED_BVH_NODE@@QEBAHXZ";

    setDataIndex :: (this: *BT_QUANTIZED_BVH_NODE, index: s32) -> void #cpp_method #foreign bullet3 "?setDataIndex@BT_QUANTIZED_BVH_NODE@@QEAAXH@Z";

    testQuantizedBoxOverlapp :: (this: *BT_QUANTIZED_BVH_NODE, quantizedMin: *u16, quantizedMax: *u16) -> bool #cpp_method #foreign bullet3 "?testQuantizedBoxOverlapp@BT_QUANTIZED_BVH_NODE@@QEBA_NPEAG0@Z";
}

GIM_QUANTIZED_BVH_NODE_ARRAY :: struct {
    #as using btalignedobjectarray: btAlignedObjectArray(BT_QUANTIZED_BVH_NODE);
}

//! Basic Box tree structure
btQuantizedBvhTree :: struct {
    m_num_nodes:       s32;
    m_node_array:      GIM_QUANTIZED_BVH_NODE_ARRAY;
    m_global_bound:    btAABB;
    m_bvhQuantization: btVector3;

    calc_quantization :: (this: *btQuantizedBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, boundMargin: btScalar) -> void #cpp_method #foreign bullet3 "?calc_quantization@btQuantizedBvhTree@@IEAAXAEAVGIM_BVH_DATA_ARRAY@@M@Z";

    _sort_and_calc_splitting_index :: (this: *btQuantizedBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, startIndex: s32, endIndex: s32, splitAxis: s32) -> s32 #cpp_method #foreign bullet3 "?_sort_and_calc_splitting_index@btQuantizedBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HHH@Z";

    _calc_splitting_axis :: (this: *btQuantizedBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, startIndex: s32, endIndex: s32) -> s32 #cpp_method #foreign bullet3 "?_calc_splitting_axis@btQuantizedBvhTree@@IEAAHAEAVGIM_BVH_DATA_ARRAY@@HH@Z";

    _build_sub_tree :: (this: *btQuantizedBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY, startIndex: s32, endIndex: s32) -> void #cpp_method #foreign bullet3 "?_build_sub_tree@btQuantizedBvhTree@@IEAAXAEAVGIM_BVH_DATA_ARRAY@@HH@Z";

    Constructor :: (this: *btQuantizedBvhTree) -> void #cpp_method #foreign bullet3 "??0btQuantizedBvhTree@@QEAA@XZ";

    //! prototype functions for box tree management
    //!@{
    build_tree :: (this: *btQuantizedBvhTree, primitive_boxes: *GIM_BVH_DATA_ARRAY) -> void #cpp_method #foreign bullet3 "?build_tree@btQuantizedBvhTree@@QEAAXAEAVGIM_BVH_DATA_ARRAY@@@Z";

    quantizePoint :: (this: *btQuantizedBvhTree, quantizedpoint: *u16, point: *btVector3) -> void #cpp_method #foreign bullet3 "?quantizePoint@btQuantizedBvhTree@@QEBAXPEAGAEBVbtVector3@@@Z";
    quantizePoint :: (this: *btQuantizedBvhTree, quantizedpoint: *u16, point: btVector3) #no_context {
        quantizePoint(this, quantizedpoint, *point);
    }

    testQuantizedBoxOverlapp :: (this: *btQuantizedBvhTree, node_index: s32, quantizedMin: *u16, quantizedMax: *u16) -> bool #cpp_method #foreign bullet3 "?testQuantizedBoxOverlapp@btQuantizedBvhTree@@QEBA_NHPEAG0@Z";

    clearNodes :: (this: *btQuantizedBvhTree) -> void #cpp_method #foreign bullet3 "?clearNodes@btQuantizedBvhTree@@QEAAXXZ";

    //! node count
    getNodeCount :: (this: *btQuantizedBvhTree) -> s32 #cpp_method #foreign bullet3 "?getNodeCount@btQuantizedBvhTree@@QEBAHXZ";

    //! tells if the node is a leaf
    isLeafNode :: (this: *btQuantizedBvhTree, nodeindex: s32) -> bool #cpp_method #foreign bullet3 "?isLeafNode@btQuantizedBvhTree@@QEBA_NH@Z";

    getNodeData :: (this: *btQuantizedBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getNodeData@btQuantizedBvhTree@@QEBAHH@Z";

    getNodeBound :: (this: *btQuantizedBvhTree, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?getNodeBound@btQuantizedBvhTree@@QEBAXHAEAVbtAABB@@@Z";

    setNodeBound :: (this: *btQuantizedBvhTree, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?setNodeBound@btQuantizedBvhTree@@QEAAXHAEBVbtAABB@@@Z";
    setNodeBound :: (this: *btQuantizedBvhTree, nodeindex: s32, bound: btAABB) #no_context {
        setNodeBound(this, nodeindex, *bound);
    }

    getLeftNode :: (this: *btQuantizedBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getLeftNode@btQuantizedBvhTree@@QEBAHH@Z";

    getRightNode :: (this: *btQuantizedBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getRightNode@btQuantizedBvhTree@@QEBAHH@Z";

    getEscapeNodeIndex :: (this: *btQuantizedBvhTree, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getEscapeNodeIndex@btQuantizedBvhTree@@QEBAHH@Z";

    get_node_pointer :: (this: *btQuantizedBvhTree, index: s32 = 0) -> *BT_QUANTIZED_BVH_NODE #cpp_method #foreign bullet3 "?get_node_pointer@btQuantizedBvhTree@@QEBAPEBUBT_QUANTIZED_BVH_NODE@@H@Z";
}

//! Structure for containing Boxes
/*!
This class offers an structure for managing a box tree of primitives.
Requires a Primitive prototype (like btPrimitiveManagerBase )
*/
btGImpactQuantizedBvh :: struct {
    m_box_tree:          btQuantizedBvhTree;
    m_primitive_manager: *btPrimitiveManagerBase;

    //stackless refit
    refit :: (this: *btGImpactQuantizedBvh) -> void #cpp_method #foreign bullet3 "?refit@btGImpactQuantizedBvh@@IEAAXXZ";

    //! this constructor doesn't build the tree. you must call	buildSet
    Constructor :: (this: *btGImpactQuantizedBvh) -> void #cpp_method #foreign bullet3 "??0btGImpactQuantizedBvh@@QEAA@XZ";

    //! this constructor doesn't build the tree. you must call	buildSet
    Constructor :: (this: *btGImpactQuantizedBvh, primitive_manager: *btPrimitiveManagerBase) -> void #cpp_method #foreign bullet3 "??0btGImpactQuantizedBvh@@QEAA@PEAVbtPrimitiveManagerBase@@@Z";

    getGlobalBox :: (this: *btGImpactQuantizedBvh) -> btAABB #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getGlobalBox@btGImpactQuantizedBvh@@QEBA?AVbtAABB@@XZ";

    setPrimitiveManager :: (this: *btGImpactQuantizedBvh, primitive_manager: *btPrimitiveManagerBase) -> void #cpp_method #foreign bullet3 "?setPrimitiveManager@btGImpactQuantizedBvh@@QEAAXPEAVbtPrimitiveManagerBase@@@Z";

    getPrimitiveManager :: (this: *btGImpactQuantizedBvh) -> *btPrimitiveManagerBase #cpp_method #foreign bullet3 "?getPrimitiveManager@btGImpactQuantizedBvh@@QEBAPEAVbtPrimitiveManagerBase@@XZ";

    //! this attemps to refit the box set.
    update :: (this: *btGImpactQuantizedBvh) -> void #cpp_method #foreign bullet3 "?update@btGImpactQuantizedBvh@@QEAAXXZ";

    //! this rebuild the entire set
    buildSet :: (this: *btGImpactQuantizedBvh) -> void #cpp_method #foreign bullet3 "?buildSet@btGImpactQuantizedBvh@@QEAAXXZ";

    //! returns the indices of the primitives in the m_primitive_manager
    boxQuery :: (this: *btGImpactQuantizedBvh, box: *btAABB, collided_results: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?boxQuery@btGImpactQuantizedBvh@@QEBA_NAEBVbtAABB@@AEAV?$btAlignedObjectArray@H@@@Z";
    boxQuery :: (this: *btGImpactQuantizedBvh, box: btAABB, collided_results: *btAlignedObjectArray(s32)) -> bool #no_context {
        return boxQuery(this, *box, collided_results);
    }

    //! returns the indices of the primitives in the m_primitive_manager
    boxQueryTrans :: (this: *btGImpactQuantizedBvh, box: *btAABB, transform: *btTransform, collided_results: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?boxQueryTrans@btGImpactQuantizedBvh@@QEBA_NAEBVbtAABB@@AEBVbtTransform@@AEAV?$btAlignedObjectArray@H@@@Z";
    boxQueryTrans :: (this: *btGImpactQuantizedBvh, box: btAABB, transform: btTransform, collided_results: *btAlignedObjectArray(s32)) -> bool #no_context {
        return boxQueryTrans(this, *box, *transform, collided_results);
    }

    //! returns the indices of the primitives in the m_primitive_manager
    rayQuery :: (this: *btGImpactQuantizedBvh, ray_dir: *btVector3, ray_origin: *btVector3, collided_results: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?rayQuery@btGImpactQuantizedBvh@@QEBA_NAEBVbtVector3@@0AEAV?$btAlignedObjectArray@H@@@Z";
    rayQuery :: (this: *btGImpactQuantizedBvh, ray_dir: btVector3, ray_origin: btVector3, collided_results: *btAlignedObjectArray(s32)) -> bool #no_context {
        return rayQuery(this, *ray_dir, *ray_origin, collided_results);
    }

    //! tells if this set has hierarcht
    hasHierarchy :: (this: *btGImpactQuantizedBvh) -> bool #cpp_method #foreign bullet3 "?hasHierarchy@btGImpactQuantizedBvh@@QEBA_NXZ";

    //! tells if this set is a trimesh
    isTrimesh :: (this: *btGImpactQuantizedBvh) -> bool #cpp_method #foreign bullet3 "?isTrimesh@btGImpactQuantizedBvh@@QEBA_NXZ";

    //! node count
    getNodeCount :: (this: *btGImpactQuantizedBvh) -> s32 #cpp_method #foreign bullet3 "?getNodeCount@btGImpactQuantizedBvh@@QEBAHXZ";

    //! tells if the node is a leaf
    isLeafNode :: (this: *btGImpactQuantizedBvh, nodeindex: s32) -> bool #cpp_method #foreign bullet3 "?isLeafNode@btGImpactQuantizedBvh@@QEBA_NH@Z";

    getNodeData :: (this: *btGImpactQuantizedBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getNodeData@btGImpactQuantizedBvh@@QEBAHH@Z";

    getNodeBound :: (this: *btGImpactQuantizedBvh, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?getNodeBound@btGImpactQuantizedBvh@@QEBAXHAEAVbtAABB@@@Z";

    setNodeBound :: (this: *btGImpactQuantizedBvh, nodeindex: s32, bound: *btAABB) -> void #cpp_method #foreign bullet3 "?setNodeBound@btGImpactQuantizedBvh@@QEAAXHAEBVbtAABB@@@Z";
    setNodeBound :: (this: *btGImpactQuantizedBvh, nodeindex: s32, bound: btAABB) #no_context {
        setNodeBound(this, nodeindex, *bound);
    }

    getLeftNode :: (this: *btGImpactQuantizedBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getLeftNode@btGImpactQuantizedBvh@@QEBAHH@Z";

    getRightNode :: (this: *btGImpactQuantizedBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getRightNode@btGImpactQuantizedBvh@@QEBAHH@Z";

    getEscapeNodeIndex :: (this: *btGImpactQuantizedBvh, nodeindex: s32) -> s32 #cpp_method #foreign bullet3 "?getEscapeNodeIndex@btGImpactQuantizedBvh@@QEBAHH@Z";

    getNodeTriangle :: (this: *btGImpactQuantizedBvh, nodeindex: s32, triangle: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "?getNodeTriangle@btGImpactQuantizedBvh@@QEBAXHAEAVbtPrimitiveTriangle@@@Z";

    get_node_pointer :: (this: *btGImpactQuantizedBvh, index: s32 = 0) -> *BT_QUANTIZED_BVH_NODE #cpp_method #foreign bullet3 "?get_node_pointer@btGImpactQuantizedBvh@@QEBAPEBUBT_QUANTIZED_BVH_NODE@@H@Z";

    find_collision :: (boxset1: *btGImpactQuantizedBvh, trans1: *btTransform, boxset2: *btGImpactQuantizedBvh, trans2: *btTransform, collision_pairs: *btPairSet) -> void #foreign bullet3 "?find_collision@btGImpactQuantizedBvh@@SAXPEBV1@AEBVbtTransform@@01AEAVbtPairSet@@@Z";
    find_collision :: (boxset1: *btGImpactQuantizedBvh, trans1: btTransform, boxset2: *btGImpactQuantizedBvh, trans2: btTransform, collision_pairs: *btPairSet) #no_context {
        find_collision(boxset1, *trans1, boxset2, *trans2, collision_pairs);
    }
}

//! declare Quantized trees, (you can change to float based trees)
btGImpactBoxSet :: btGImpactQuantizedBvh;

eGIMPACT_SHAPE_TYPE :: enum s32 {
    COMPOUND_SHAPE     :: 0;
    TRIMESH_SHAPE_PART :: 1;
    TRIMESH_SHAPE      :: 2;

    CONST_GIMPACT_COMPOUND_SHAPE     :: COMPOUND_SHAPE;
    CONST_GIMPACT_TRIMESH_SHAPE_PART :: TRIMESH_SHAPE_PART;
    CONST_GIMPACT_TRIMESH_SHAPE      :: TRIMESH_SHAPE;
}

//! Helper class for tetrahedrons
btTetrahedronShapeEx :: struct {
    #as using btbu_simplex1to4: btBU_Simplex1to4;

    Constructor :: (this: *btTetrahedronShapeEx) -> void #cpp_method #foreign bullet3 "??0btTetrahedronShapeEx@@QEAA@XZ";

    setVertices :: (this: *btTetrahedronShapeEx, v0: *btVector3, v1: *btVector3, v2: *btVector3, v3: *btVector3) -> void #cpp_method #foreign bullet3 "?setVertices@btTetrahedronShapeEx@@QEAAXAEBVbtVector3@@000@Z";
    setVertices :: (this: *btTetrahedronShapeEx, v0: btVector3, v1: btVector3, v2: btVector3, v3: btVector3) #no_context {
        setVertices(this, *v0, *v1, *v2, *v3);
    }
}

//! Base class for gimpact shapes
btGImpactShapeInterface :: struct {
    #as using btconcaveshape: btConcaveShape;

    m_localAABB:    btAABB;
    m_needs_update: bool;
    localScaling:   btVector3;
    m_box_set:      btGImpactBoxSet; // optionally boxset

    Constructor :: (this: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "??0btGImpactShapeInterface@@QEAA@XZ";

    //! performs refit operation
    /*!
    Updates the entire Box set of this shape.
    \pre postUpdate() must be called for attemps to calculating the box set, else this function
    will does nothing.
    \post if m_needs_update == true, then it calls calcLocalAABB();
    */
    updateBound :: (this: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "?updateBound@btGImpactShapeInterface@@QEAAXXZ";

    //! Obtains the local box, which is the global calculated box of the total of subshapes
    getLocalBox :: (this: *btGImpactShapeInterface) -> *btAABB #cpp_method #foreign bullet3 "?getLocalBox@btGImpactShapeInterface@@QEAAAEBVbtAABB@@XZ";

    //! gets boxset
    getBoxSet :: (this: *btGImpactShapeInterface) -> *btGImpactBoxSet #cpp_method #foreign bullet3 "?getBoxSet@btGImpactShapeInterface@@QEBAPEBVbtGImpactQuantizedBvh@@XZ";

    //! Determines if this class has a hierarchy structure for sorting its primitives
    hasBoxSet :: (this: *btGImpactShapeInterface) -> bool #cpp_method #foreign bullet3 "?hasBoxSet@btGImpactShapeInterface@@QEBA_NXZ";

    //! if this trimesh
    getPrimitiveTriangle :: (this: *btGImpactShapeInterface, index: s32, triangle: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "?getPrimitiveTriangle@btGImpactShapeInterface@@QEBAXHAEAVbtPrimitiveTriangle@@@Z";
    #place btconcaveshape; btgimpactshapeinterface_vtable: *btGImpactShapeInterface_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //! use this function for perfofm refit in bounding boxes
    //! use this function for perfofm refit in bounding boxes
    virtual_calcLocalAABB :: (this: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "?calcLocalAABB@btGImpactShapeInterface@@MEAAXXZ";

    //! If the Bounding box is not updated, then this class attemps to calculate it.
    /*!
    \post Calls updateBound() for update the box set.
    */
    virtual_getAabb :: (this: *btGImpactShapeInterface, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getAabb@btGImpactShapeInterface@@UEBAXAEBVbtTransform@@AEAVbtVector3@@1@Z";

    //! Tells to this object that is needed to refit the box set
    virtual_postUpdate :: (this: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "?postUpdate@btGImpactShapeInterface@@UEAAXXZ";

    virtual_getShapeType :: (this: *btGImpactShapeInterface) -> s32 #cpp_method #foreign bullet3 "?getShapeType@btGImpactShapeInterface@@UEBAHXZ";

    /*!
    \post You must call updateBound() for update the box set.
    */
    virtual_setLocalScaling :: (this: *btGImpactShapeInterface, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btGImpactShapeInterface@@UEAAXAEBVbtVector3@@@Z";

    virtual_getLocalScaling :: (this: *btGImpactShapeInterface) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btGImpactShapeInterface@@UEBAAEBVbtVector3@@XZ";

    virtual_setMargin :: (this: *btGImpactShapeInterface, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btGImpactShapeInterface@@UEAAXM@Z";

    //! call when reading child shapes
    virtual_lockChildShapes :: (this: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "?lockChildShapes@btGImpactShapeInterface@@UEBAXXZ";

    virtual_unlockChildShapes :: (this: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "?unlockChildShapes@btGImpactShapeInterface@@UEBAXXZ";

    //! Retrieves the bound from a child
    /*!
    */
    virtual_getChildAabb :: (this: *btGImpactShapeInterface, child_index: s32, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getChildAabb@btGImpactShapeInterface@@UEBAXHAEBVbtTransform@@AEAVbtVector3@@1@Z";

    //! virtual method for ray collision
    virtual_rayTest :: (this: *btGImpactShapeInterface, rayFrom: *btVector3, rayTo: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btGImpactShapeInterface@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z";

    //! Function for retrieve triangles.
    /*!
    It gives the triangles in local space
    */
    virtual_processAllTriangles :: (this: *btGImpactShapeInterface, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btGImpactShapeInterface@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    //! Function for retrieve triangles.
    /*!
    It gives the triangles in local space
    */
    virtual_processAllTrianglesRay :: (this: *btGImpactShapeInterface, unknown0: *btTriangleCallback, unknown1: *btVector3, unknown2: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTrianglesRay@btGImpactShapeInterface@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
}
btGImpactShapeInterface_VTable :: struct #type_info_none {
    using btconcaveshape: btConcaveShape_VTable;
    calcLocalAABB: (this: *btGImpactShapeInterface) -> void #cpp_method;

    postUpdate: (this: *btGImpactShapeInterface) -> void #cpp_method;

    getShapeType: (this: *btGImpactShapeInterface) -> s32 #cpp_method;

    getGImpactShapeType: (this: *btGImpactShapeInterface) -> eGIMPACT_SHAPE_TYPE #cpp_method;

    getPrimitiveManager: (this: *btGImpactShapeInterface) -> *btPrimitiveManagerBase #cpp_method;

    getNumChildShapes: (this: *btGImpactShapeInterface) -> s32 #cpp_method;

    childrenHasTransform: (this: *btGImpactShapeInterface) -> bool #cpp_method;

    needsRetrieveTriangles: (this: *btGImpactShapeInterface) -> bool #cpp_method;

    needsRetrieveTetrahedrons: (this: *btGImpactShapeInterface) -> bool #cpp_method;

    getBulletTriangle: (this: *btGImpactShapeInterface, prim_index: s32, triangle: *btTriangleShapeEx) -> void #cpp_method;

    getBulletTetrahedron: (this: *btGImpactShapeInterface, prim_index: s32, tetrahedron: *btTetrahedronShapeEx) -> void #cpp_method;

    lockChildShapes: (this: *btGImpactShapeInterface) -> void #cpp_method;

    unlockChildShapes: (this: *btGImpactShapeInterface) -> void #cpp_method;

    getChildAabb: (this: *btGImpactShapeInterface, child_index: s32, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method;

    getChildShape_1: (this: /*const*/ *btGImpactShapeInterface, index: s32) -> *btCollisionShape #cpp_method;

    getChildShape: (this: *btGImpactShapeInterface, index: s32) -> *btCollisionShape #cpp_method;

    getChildTransform: (this: *btGImpactShapeInterface, index: s32) -> btTransform #cpp_method #cpp_return_type_is_non_pod;

    setChildTransform: (this: *btGImpactShapeInterface, index: s32, transform: *btTransform) -> void #cpp_method;

    rayTest: (this: *btGImpactShapeInterface, rayFrom: *btVector3, rayTo: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method;

    processAllTrianglesRay: (this: *btGImpactShapeInterface, unknown0: *btTriangleCallback, unknown1: *btVector3, unknown2: *btVector3) -> void #cpp_method;
}

btGImpactShapeInterface_calcLocalAABB :: inline (this: *btGImpactShapeInterface) { this.btgimpactshapeinterface_vtable.calcLocalAABB(this); }

btGImpactShapeInterface_postUpdate :: inline (this: *btGImpactShapeInterface) { this.btgimpactshapeinterface_vtable.postUpdate(this); }

btGImpactShapeInterface_getShapeType :: inline (this: *btGImpactShapeInterface) -> s32 { return this.btgimpactshapeinterface_vtable.getShapeType(this); }

btGImpactShapeInterface_getGImpactShapeType :: inline (this: *btGImpactShapeInterface) -> eGIMPACT_SHAPE_TYPE { return this.btgimpactshapeinterface_vtable.getGImpactShapeType(this); }

btGImpactShapeInterface_getPrimitiveManager :: inline (this: *btGImpactShapeInterface) -> *btPrimitiveManagerBase { return this.btgimpactshapeinterface_vtable.getPrimitiveManager(this); }

btGImpactShapeInterface_getNumChildShapes :: inline (this: *btGImpactShapeInterface) -> s32 { return this.btgimpactshapeinterface_vtable.getNumChildShapes(this); }

btGImpactShapeInterface_childrenHasTransform :: inline (this: *btGImpactShapeInterface) -> bool { return this.btgimpactshapeinterface_vtable.childrenHasTransform(this); }

btGImpactShapeInterface_needsRetrieveTriangles :: inline (this: *btGImpactShapeInterface) -> bool { return this.btgimpactshapeinterface_vtable.needsRetrieveTriangles(this); }

btGImpactShapeInterface_needsRetrieveTetrahedrons :: inline (this: *btGImpactShapeInterface) -> bool { return this.btgimpactshapeinterface_vtable.needsRetrieveTetrahedrons(this); }

btGImpactShapeInterface_getBulletTriangle :: inline (this: *btGImpactShapeInterface, prim_index: s32, triangle: *btTriangleShapeEx) { this.btgimpactshapeinterface_vtable.getBulletTriangle(this, prim_index, triangle); }

btGImpactShapeInterface_getBulletTetrahedron :: inline (this: *btGImpactShapeInterface, prim_index: s32, tetrahedron: *btTetrahedronShapeEx) { this.btgimpactshapeinterface_vtable.getBulletTetrahedron(this, prim_index, tetrahedron); }

btGImpactShapeInterface_lockChildShapes :: inline (this: *btGImpactShapeInterface) { this.btgimpactshapeinterface_vtable.lockChildShapes(this); }

btGImpactShapeInterface_unlockChildShapes :: inline (this: *btGImpactShapeInterface) { this.btgimpactshapeinterface_vtable.unlockChildShapes(this); }

btGImpactShapeInterface_getChildAabb :: inline (this: *btGImpactShapeInterface, child_index: s32, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) { this.btgimpactshapeinterface_vtable.getChildAabb(this, child_index, t, aabbMin, aabbMax); }

btGImpactShapeInterface_getChildShape_1 :: inline (this: /*const*/ *btGImpactShapeInterface, index: s32) -> *btCollisionShape { return this.btgimpactshapeinterface_vtable.getChildShape_1(this, index); }

btGImpactShapeInterface_getChildShape :: inline (this: *btGImpactShapeInterface, index: s32) -> *btCollisionShape { return this.btgimpactshapeinterface_vtable.getChildShape(this, index); }

btGImpactShapeInterface_getChildTransform :: inline (this: *btGImpactShapeInterface, index: s32) -> btTransform { return this.btgimpactshapeinterface_vtable.getChildTransform(this, index); }

btGImpactShapeInterface_setChildTransform :: inline (this: *btGImpactShapeInterface, index: s32, transform: *btTransform) { this.btgimpactshapeinterface_vtable.setChildTransform(this, index, transform); }

btGImpactShapeInterface_rayTest :: inline (this: *btGImpactShapeInterface, rayFrom: *btVector3, rayTo: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) { this.btgimpactshapeinterface_vtable.rayTest(this, rayFrom, rayTo, resultCallback); }

btGImpactShapeInterface_processAllTrianglesRay :: inline (this: *btGImpactShapeInterface, unknown0: *btTriangleCallback, unknown1: *btVector3, unknown2: *btVector3) { this.btgimpactshapeinterface_vtable.processAllTrianglesRay(this, unknown0, unknown1, unknown2); }

vtable :: (obj: *btGImpactShapeInterface) -> *btGImpactShapeInterface_VTable { return obj.btgimpactshapeinterface_vtable; }


//! btGImpactCompoundShape allows to handle multiple btCollisionShape objects at once
/*!
This class only can manage Convex subshapes
*/
btGImpactCompoundShape :: struct {
    #as using btgimpactshapeinterface: btGImpactShapeInterface;

    //! compound primitive manager
    CompoundPrimitiveManager :: struct {
        #as using btprimitivemanagerbase: btPrimitiveManagerBase;

        m_compoundShape: *btGImpactCompoundShape;

        CopyConstructor :: (this: *CompoundPrimitiveManager, compound: *CompoundPrimitiveManager) -> void #cpp_method #foreign bullet3 "??0CompoundPrimitiveManager@btGImpactCompoundShape@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *CompoundPrimitiveManager, compound: CompoundPrimitiveManager) #no_context {
            CopyConstructor(this, *compound);
        }

        Constructor :: (this: *CompoundPrimitiveManager, compoundShape: *btGImpactCompoundShape) -> void #cpp_method #foreign bullet3 "??0CompoundPrimitiveManager@btGImpactCompoundShape@@QEAA@PEAV1@@Z";

        Constructor :: (this: *CompoundPrimitiveManager) -> void #cpp_method #foreign bullet3 "??0CompoundPrimitiveManager@btGImpactCompoundShape@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *CompoundPrimitiveManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1CompoundPrimitiveManager@btGImpactCompoundShape@@UEAA@XZ";

        virtual_is_trimesh :: (this: *CompoundPrimitiveManager) -> bool #cpp_method #foreign bullet3 "?is_trimesh@CompoundPrimitiveManager@btGImpactCompoundShape@@UEBA_NXZ";

        virtual_get_primitive_count :: (this: *CompoundPrimitiveManager) -> s32 #cpp_method #foreign bullet3 "?get_primitive_count@CompoundPrimitiveManager@btGImpactCompoundShape@@UEBAHXZ";

        virtual_get_primitive_box :: (this: *CompoundPrimitiveManager, prim_index: s32, primbox: *btAABB) -> void #cpp_method #foreign bullet3 "?get_primitive_box@CompoundPrimitiveManager@btGImpactCompoundShape@@UEBAXHAEAVbtAABB@@@Z";

        virtual_get_primitive_triangle :: (this: *CompoundPrimitiveManager, prim_index: s32, triangle: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "?get_primitive_triangle@CompoundPrimitiveManager@btGImpactCompoundShape@@UEBAXHAEAVbtPrimitiveTriangle@@@Z";
    }

    m_primitive_manager: CompoundPrimitiveManager;
    m_childTransforms:   btAlignedObjectArray(btTransform);
    m_childShapes:       btAlignedObjectArray(*btCollisionShape);

    Constructor :: (this: *btGImpactCompoundShape, children_has_transform := true) -> void #cpp_method #foreign bullet3 "??0btGImpactCompoundShape@@QEAA@_N@Z";

    //! Obtains the compopund primitive manager
    getCompoundPrimitiveManager :: (this: *btGImpactCompoundShape) -> *CompoundPrimitiveManager #cpp_method #foreign bullet3 "?getCompoundPrimitiveManager@btGImpactCompoundShape@@QEAAPEAVCompoundPrimitiveManager@1@XZ";

    //! Use this method for adding children. Only Convex shapes are allowed.
    addChildShape :: (this: *btGImpactCompoundShape, localTransform: *btTransform, shape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?addChildShape@btGImpactCompoundShape@@QEAAXAEBVbtTransform@@PEAVbtCollisionShape@@@Z";
    addChildShape :: (this: *btGImpactCompoundShape, localTransform: btTransform, shape: *btCollisionShape) #no_context {
        addChildShape(this, *localTransform, shape);
    }

    //! Use this method for adding children. Only Convex shapes are allowed.
    addChildShape :: (this: *btGImpactCompoundShape, shape: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?addChildShape@btGImpactCompoundShape@@QEAAXPEAVbtCollisionShape@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGImpactCompoundShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGImpactCompoundShape@@UEAA@XZ";

    //! if true, then its children must get transforms.
    virtual_childrenHasTransform :: (this: *btGImpactCompoundShape) -> bool #cpp_method #foreign bullet3 "?childrenHasTransform@btGImpactCompoundShape@@UEBA_NXZ";

    //! Obtains the primitive manager
    virtual_getPrimitiveManager :: (this: *btGImpactCompoundShape) -> *btPrimitiveManagerBase #cpp_method #foreign bullet3 "?getPrimitiveManager@btGImpactCompoundShape@@UEBAPEBVbtPrimitiveManagerBase@@XZ";

    //! Gets the number of children
    virtual_getNumChildShapes :: (this: *btGImpactCompoundShape) -> s32 #cpp_method #foreign bullet3 "?getNumChildShapes@btGImpactCompoundShape@@UEBAHXZ";

    //! Gets the children
    virtual_getChildShape :: (this: *btGImpactCompoundShape, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btGImpactCompoundShape@@UEAAPEAVbtCollisionShape@@H@Z";

    //! Gets the children
    virtual_getChildShape_1 :: (this: /*const*/ *btGImpactCompoundShape, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btGImpactCompoundShape@@UEBAPEBVbtCollisionShape@@H@Z";

    //! Retrieves the bound from a child
    /*!
    */
    virtual_getChildAabb :: (this: *btGImpactCompoundShape, child_index: s32, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getChildAabb@btGImpactCompoundShape@@UEBAXHAEBVbtTransform@@AEAVbtVector3@@1@Z";

    //! Gets the children transform
    virtual_getChildTransform :: (this: *btGImpactCompoundShape, index: s32) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getChildTransform@btGImpactCompoundShape@@UEBA?AVbtTransform@@H@Z";

    //! Sets the children transform
    /*!
    \post You must call updateBound() for update the box set.
    */
    virtual_setChildTransform :: (this: *btGImpactCompoundShape, index: s32, transform: *btTransform) -> void #cpp_method #foreign bullet3 "?setChildTransform@btGImpactCompoundShape@@UEAAXHAEBVbtTransform@@@Z";

    //! Determines if this shape has triangles
    virtual_needsRetrieveTriangles :: (this: *btGImpactCompoundShape) -> bool #cpp_method #foreign bullet3 "?needsRetrieveTriangles@btGImpactCompoundShape@@UEBA_NXZ";

    //! Determines if this shape has tetrahedrons
    virtual_needsRetrieveTetrahedrons :: (this: *btGImpactCompoundShape) -> bool #cpp_method #foreign bullet3 "?needsRetrieveTetrahedrons@btGImpactCompoundShape@@UEBA_NXZ";

    virtual_getBulletTriangle :: (this: *btGImpactCompoundShape, prim_index: s32, triangle: *btTriangleShapeEx) -> void #cpp_method #foreign bullet3 "?getBulletTriangle@btGImpactCompoundShape@@UEBAXHAEAVbtTriangleShapeEx@@@Z";

    virtual_getBulletTetrahedron :: (this: *btGImpactCompoundShape, prim_index: s32, tetrahedron: *btTetrahedronShapeEx) -> void #cpp_method #foreign bullet3 "?getBulletTetrahedron@btGImpactCompoundShape@@UEBAXHAEAVbtTetrahedronShapeEx@@@Z";

    //! Calculates the exact inertia tensor for this shape
    virtual_calculateLocalInertia :: (this: *btGImpactCompoundShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btGImpactCompoundShape@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btGImpactCompoundShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btGImpactCompoundShape@@UEBAPEBDXZ";

    virtual_getGImpactShapeType :: (this: *btGImpactCompoundShape) -> eGIMPACT_SHAPE_TYPE #cpp_method #foreign bullet3 "?getGImpactShapeType@btGImpactCompoundShape@@UEBA?AW4eGIMPACT_SHAPE_TYPE@@XZ";
}

//! This class manages a sub part of a mesh supplied by the btStridingMeshInterface interface.
/*!
- Simply create this shape by passing the btStridingMeshInterface to the constructor btGImpactMeshShapePart, then you must call updateBound() after creating the mesh
- When making operations with this shape, you must call <b>lock</b> before accessing to the trimesh primitives, and then call <b>unlock</b>
- You can handle deformable meshes with this shape, by calling postUpdate() every time when changing the mesh vertices.

*/
btGImpactMeshShapePart :: struct {
    #as using btgimpactshapeinterface: btGImpactShapeInterface;

    //! Trimesh primitive manager
    /*!
    Manages the info from btStridingMeshInterface object and controls the Lock/Unlock mechanism
    */
    TrimeshPrimitiveManager :: struct {
        #as using btprimitivemanagerbase: btPrimitiveManagerBase;

        m_margin:        btScalar;
        m_meshInterface: *btStridingMeshInterface;
        m_scale:         btVector3;
        m_part:          s32;
        m_lock_count:    s32;
        vertexbase:      *u8;
        numverts:        s32;
        type:            PHY_ScalarType;
        stride:          s32;
        indexbase:       *u8;
        indexstride:     s32;
        numfaces:        s32;
        indicestype:     PHY_ScalarType;

        Constructor :: (this: *TrimeshPrimitiveManager) -> void #cpp_method #foreign bullet3 "??0TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEAA@XZ";

        CopyConstructor :: (this: *TrimeshPrimitiveManager, manager: *TrimeshPrimitiveManager) -> void #cpp_method #foreign bullet3 "??0TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *TrimeshPrimitiveManager, manager: TrimeshPrimitiveManager) #no_context {
            CopyConstructor(this, *manager);
        }

        Constructor :: (this: *TrimeshPrimitiveManager, meshInterface: *btStridingMeshInterface, part: s32) -> void #cpp_method #foreign bullet3 "??0TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEAA@PEAVbtStridingMeshInterface@@H@Z";

        lock :: (this: *TrimeshPrimitiveManager) -> void #cpp_method #foreign bullet3 "?lock@TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEAAXXZ";

        unlock :: (this: *TrimeshPrimitiveManager) -> void #cpp_method #foreign bullet3 "?unlock@TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEAAXXZ";

        get_vertex_count :: (this: *TrimeshPrimitiveManager) -> s32 #cpp_method #foreign bullet3 "?get_vertex_count@TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEBAHXZ";

        get_indices :: (this: *TrimeshPrimitiveManager, face_index: s32, i0: *u32, i1: *u32, i2: *u32) -> void #cpp_method #foreign bullet3 "?get_indices@TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEBAXHAEAI00@Z";

        get_vertex :: (this: *TrimeshPrimitiveManager, vertex_index: u32, vertex: *btVector3) -> void #cpp_method #foreign bullet3 "?get_vertex@TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEBAXIAEAVbtVector3@@@Z";

        get_bullet_triangle :: (this: *TrimeshPrimitiveManager, prim_index: s32, triangle: *btTriangleShapeEx) -> void #cpp_method #foreign bullet3 "?get_bullet_triangle@TrimeshPrimitiveManager@btGImpactMeshShapePart@@QEBAXHAEAVbtTriangleShapeEx@@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *TrimeshPrimitiveManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1TrimeshPrimitiveManager@btGImpactMeshShapePart@@UEAA@XZ";

        virtual_is_trimesh :: (this: *TrimeshPrimitiveManager) -> bool #cpp_method #foreign bullet3 "?is_trimesh@TrimeshPrimitiveManager@btGImpactMeshShapePart@@UEBA_NXZ";

        virtual_get_primitive_count :: (this: *TrimeshPrimitiveManager) -> s32 #cpp_method #foreign bullet3 "?get_primitive_count@TrimeshPrimitiveManager@btGImpactMeshShapePart@@UEBAHXZ";

        virtual_get_primitive_box :: (this: *TrimeshPrimitiveManager, prim_index: s32, primbox: *btAABB) -> void #cpp_method #foreign bullet3 "?get_primitive_box@TrimeshPrimitiveManager@btGImpactMeshShapePart@@UEBAXHAEAVbtAABB@@@Z";

        virtual_get_primitive_triangle :: (this: *TrimeshPrimitiveManager, prim_index: s32, triangle: *btPrimitiveTriangle) -> void #cpp_method #foreign bullet3 "?get_primitive_triangle@TrimeshPrimitiveManager@btGImpactMeshShapePart@@UEBAXHAEAVbtPrimitiveTriangle@@@Z";
    }

    m_primitive_manager: TrimeshPrimitiveManager;

    Constructor :: (this: *btGImpactMeshShapePart) -> void #cpp_method #foreign bullet3 "??0btGImpactMeshShapePart@@QEAA@XZ";

    Constructor :: (this: *btGImpactMeshShapePart, meshInterface: *btStridingMeshInterface, part: s32) -> void #cpp_method #foreign bullet3 "??0btGImpactMeshShapePart@@QEAA@PEAVbtStridingMeshInterface@@H@Z";

    getTrimeshPrimitiveManager :: (this: *btGImpactMeshShapePart) -> *TrimeshPrimitiveManager #cpp_method #foreign bullet3 "?getTrimeshPrimitiveManager@btGImpactMeshShapePart@@QEAAPEAVTrimeshPrimitiveManager@1@XZ";

    getVertexCount :: (this: *btGImpactMeshShapePart) -> s32 #cpp_method #foreign bullet3 "?getVertexCount@btGImpactMeshShapePart@@QEBAHXZ";

    getVertex :: (this: *btGImpactMeshShapePart, vertex_index: s32, vertex: *btVector3) -> void #cpp_method #foreign bullet3 "?getVertex@btGImpactMeshShapePart@@QEBAXHAEAVbtVector3@@@Z";

    getPart :: (this: *btGImpactMeshShapePart) -> s32 #cpp_method #foreign bullet3 "?getPart@btGImpactMeshShapePart@@QEBAHXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGImpactMeshShapePart, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGImpactMeshShapePart@@UEAA@XZ";

    //! if true, then its children must get transforms.
    virtual_childrenHasTransform :: (this: *btGImpactMeshShapePart) -> bool #cpp_method #foreign bullet3 "?childrenHasTransform@btGImpactMeshShapePart@@UEBA_NXZ";

    //! call when reading child shapes
    virtual_lockChildShapes :: (this: *btGImpactMeshShapePart) -> void #cpp_method #foreign bullet3 "?lockChildShapes@btGImpactMeshShapePart@@UEBAXXZ";
    virtual_unlockChildShapes :: (this: *btGImpactMeshShapePart) -> void #cpp_method #foreign bullet3 "?unlockChildShapes@btGImpactMeshShapePart@@UEBAXXZ";

    //! Gets the number of children
    virtual_getNumChildShapes :: (this: *btGImpactMeshShapePart) -> s32 #cpp_method #foreign bullet3 "?getNumChildShapes@btGImpactMeshShapePart@@UEBAHXZ";

    //! Gets the children
    virtual_getChildShape :: (this: *btGImpactMeshShapePart, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btGImpactMeshShapePart@@UEAAPEAVbtCollisionShape@@H@Z";

    //! Gets the child
    virtual_getChildShape_1 :: (this: /*const*/ *btGImpactMeshShapePart, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btGImpactMeshShapePart@@UEBAPEBVbtCollisionShape@@H@Z";

    //! Gets the children transform
    virtual_getChildTransform :: (this: *btGImpactMeshShapePart, index: s32) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getChildTransform@btGImpactMeshShapePart@@UEBA?AVbtTransform@@H@Z";

    //! Sets the children transform
    /*!
    \post You must call updateBound() for update the box set.
    */
    virtual_setChildTransform :: (this: *btGImpactMeshShapePart, index: s32, transform: *btTransform) -> void #cpp_method #foreign bullet3 "?setChildTransform@btGImpactMeshShapePart@@UEAAXHAEBVbtTransform@@@Z";

    //! Obtains the primitive manager
    virtual_getPrimitiveManager :: (this: *btGImpactMeshShapePart) -> *btPrimitiveManagerBase #cpp_method #foreign bullet3 "?getPrimitiveManager@btGImpactMeshShapePart@@UEBAPEBVbtPrimitiveManagerBase@@XZ";

    virtual_calculateLocalInertia :: (this: *btGImpactMeshShapePart, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btGImpactMeshShapePart@@UEBAXMAEAVbtVector3@@@Z";

    virtual_getName :: (this: *btGImpactMeshShapePart) -> *u8 #cpp_method #foreign bullet3 "?getName@btGImpactMeshShapePart@@UEBAPEBDXZ";

    virtual_getGImpactShapeType :: (this: *btGImpactMeshShapePart) -> eGIMPACT_SHAPE_TYPE #cpp_method #foreign bullet3 "?getGImpactShapeType@btGImpactMeshShapePart@@UEBA?AW4eGIMPACT_SHAPE_TYPE@@XZ";

    //! Determines if this shape has triangles
    virtual_needsRetrieveTriangles :: (this: *btGImpactMeshShapePart) -> bool #cpp_method #foreign bullet3 "?needsRetrieveTriangles@btGImpactMeshShapePart@@UEBA_NXZ";

    //! Determines if this shape has tetrahedrons
    virtual_needsRetrieveTetrahedrons :: (this: *btGImpactMeshShapePart) -> bool #cpp_method #foreign bullet3 "?needsRetrieveTetrahedrons@btGImpactMeshShapePart@@UEBA_NXZ";

    virtual_getBulletTriangle :: (this: *btGImpactMeshShapePart, prim_index: s32, triangle: *btTriangleShapeEx) -> void #cpp_method #foreign bullet3 "?getBulletTriangle@btGImpactMeshShapePart@@UEBAXHAEAVbtTriangleShapeEx@@@Z";

    virtual_getBulletTetrahedron :: (this: *btGImpactMeshShapePart, prim_index: s32, tetrahedron: *btTetrahedronShapeEx) -> void #cpp_method #foreign bullet3 "?getBulletTetrahedron@btGImpactMeshShapePart@@UEBAXHAEAVbtTetrahedronShapeEx@@@Z";

    virtual_setMargin :: (this: *btGImpactMeshShapePart, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btGImpactMeshShapePart@@UEAAXM@Z";

    virtual_getMargin :: (this: *btGImpactMeshShapePart) -> btScalar #cpp_method #foreign bullet3 "?getMargin@btGImpactMeshShapePart@@UEBAMXZ";

    virtual_setLocalScaling :: (this: *btGImpactMeshShapePart, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btGImpactMeshShapePart@@UEAAXAEBVbtVector3@@@Z";

    virtual_getLocalScaling :: (this: *btGImpactMeshShapePart) -> *btVector3 #cpp_method #foreign bullet3 "?getLocalScaling@btGImpactMeshShapePart@@UEBAAEBVbtVector3@@XZ";

    virtual_processAllTriangles :: (this: *btGImpactMeshShapePart, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btGImpactMeshShapePart@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
    virtual_processAllTrianglesRay :: (this: *btGImpactMeshShapePart, callback: *btTriangleCallback, rayFrom: *btVector3, rayTo: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTrianglesRay@btGImpactMeshShapePart@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";
}

//! This class manages a mesh supplied by the btStridingMeshInterface interface.
/*!
Set of btGImpactMeshShapePart parts
- Simply create this shape by passing the btStridingMeshInterface to the constructor btGImpactMeshShape, then you must call updateBound() after creating the mesh

- You can handle deformable meshes with this shape, by calling postUpdate() every time when changing the mesh vertices.

*/
btGImpactMeshShape :: struct {
    #as using btgimpactshapeinterface: btGImpactShapeInterface;

    m_meshInterface: *btStridingMeshInterface;

    m_mesh_parts:    btAlignedObjectArray(*btGImpactMeshShapePart);
    buildMeshParts :: (this: *btGImpactMeshShape, meshInterface: *btStridingMeshInterface) -> void #cpp_method #foreign bullet3 "?buildMeshParts@btGImpactMeshShape@@IEAAXPEAVbtStridingMeshInterface@@@Z";

    Constructor :: (this: *btGImpactMeshShape, meshInterface: *btStridingMeshInterface) -> void #cpp_method #foreign bullet3 "??0btGImpactMeshShape@@QEAA@PEAVbtStridingMeshInterface@@@Z";

    getMeshInterface :: (this: *btGImpactMeshShape) -> *btStridingMeshInterface #cpp_method #foreign bullet3 "?getMeshInterface@btGImpactMeshShape@@QEAAPEAVbtStridingMeshInterface@@XZ";

    getMeshInterface_1 :: (this: /*const*/ *btGImpactMeshShape) -> *btStridingMeshInterface #cpp_method #foreign bullet3 "?getMeshInterface@btGImpactMeshShape@@QEBAPEBVbtStridingMeshInterface@@XZ";

    getMeshPartCount :: (this: *btGImpactMeshShape) -> s32 #cpp_method #foreign bullet3 "?getMeshPartCount@btGImpactMeshShape@@QEBAHXZ";

    getMeshPart :: (this: *btGImpactMeshShape, index: s32) -> *btGImpactMeshShapePart #cpp_method #foreign bullet3 "?getMeshPart@btGImpactMeshShape@@QEAAPEAVbtGImpactMeshShapePart@@H@Z";

    getMeshPart_1 :: (this: /*const*/ *btGImpactMeshShape, index: s32) -> *btGImpactMeshShapePart #cpp_method #foreign bullet3 "?getMeshPart@btGImpactMeshShape@@QEBAPEBVbtGImpactMeshShapePart@@H@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //! use this function for perfofm refit in bounding boxes
    virtual_calcLocalAABB :: (this: *btGImpactMeshShape) -> void #cpp_method #foreign bullet3 "?calcLocalAABB@btGImpactMeshShape@@MEAAXXZ";

    virtual_Destructor :: (this: *btGImpactMeshShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGImpactMeshShape@@UEAA@XZ";

    virtual_setLocalScaling :: (this: *btGImpactMeshShape, scaling: *btVector3) -> void #cpp_method #foreign bullet3 "?setLocalScaling@btGImpactMeshShape@@UEAAXAEBVbtVector3@@@Z";

    virtual_setMargin :: (this: *btGImpactMeshShape, margin: btScalar) -> void #cpp_method #foreign bullet3 "?setMargin@btGImpactMeshShape@@UEAAXM@Z";

    //! Tells to this object that is needed to refit all the meshes
    virtual_postUpdate :: (this: *btGImpactMeshShape) -> void #cpp_method #foreign bullet3 "?postUpdate@btGImpactMeshShape@@UEAAXXZ";

    virtual_calculateLocalInertia :: (this: *btGImpactMeshShape, mass: btScalar, inertia: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateLocalInertia@btGImpactMeshShape@@UEBAXMAEAVbtVector3@@@Z";

    //! Obtains the primitive manager
    virtual_getPrimitiveManager :: (this: *btGImpactMeshShape) -> *btPrimitiveManagerBase #cpp_method #foreign bullet3 "?getPrimitiveManager@btGImpactMeshShape@@UEBAPEBVbtPrimitiveManagerBase@@XZ";

    //! Gets the number of children
    virtual_getNumChildShapes :: (this: *btGImpactMeshShape) -> s32 #cpp_method #foreign bullet3 "?getNumChildShapes@btGImpactMeshShape@@UEBAHXZ";

    //! if true, then its children must get transforms.
    virtual_childrenHasTransform :: (this: *btGImpactMeshShape) -> bool #cpp_method #foreign bullet3 "?childrenHasTransform@btGImpactMeshShape@@UEBA_NXZ";

    //! Determines if this shape has triangles
    virtual_needsRetrieveTriangles :: (this: *btGImpactMeshShape) -> bool #cpp_method #foreign bullet3 "?needsRetrieveTriangles@btGImpactMeshShape@@UEBA_NXZ";

    //! Determines if this shape has tetrahedrons
    virtual_needsRetrieveTetrahedrons :: (this: *btGImpactMeshShape) -> bool #cpp_method #foreign bullet3 "?needsRetrieveTetrahedrons@btGImpactMeshShape@@UEBA_NXZ";

    virtual_getBulletTriangle :: (this: *btGImpactMeshShape, prim_index: s32, triangle: *btTriangleShapeEx) -> void #cpp_method #foreign bullet3 "?getBulletTriangle@btGImpactMeshShape@@UEBAXHAEAVbtTriangleShapeEx@@@Z";

    virtual_getBulletTetrahedron :: (this: *btGImpactMeshShape, prim_index: s32, tetrahedron: *btTetrahedronShapeEx) -> void #cpp_method #foreign bullet3 "?getBulletTetrahedron@btGImpactMeshShape@@UEBAXHAEAVbtTetrahedronShapeEx@@@Z";

    //! call when reading child shapes
    virtual_lockChildShapes :: (this: *btGImpactMeshShape) -> void #cpp_method #foreign bullet3 "?lockChildShapes@btGImpactMeshShape@@UEBAXXZ";

    virtual_unlockChildShapes :: (this: *btGImpactMeshShape) -> void #cpp_method #foreign bullet3 "?unlockChildShapes@btGImpactMeshShape@@UEBAXXZ";

    //! Retrieves the bound from a child
    /*!
    */
    virtual_getChildAabb :: (this: *btGImpactMeshShape, child_index: s32, t: *btTransform, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?getChildAabb@btGImpactMeshShape@@UEBAXHAEBVbtTransform@@AEAVbtVector3@@1@Z";

    //! Gets the children
    virtual_getChildShape :: (this: *btGImpactMeshShape, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btGImpactMeshShape@@UEAAPEAVbtCollisionShape@@H@Z";

    //! Gets the child
    virtual_getChildShape_1 :: (this: /*const*/ *btGImpactMeshShape, index: s32) -> *btCollisionShape #cpp_method #foreign bullet3 "?getChildShape@btGImpactMeshShape@@UEBAPEBVbtCollisionShape@@H@Z";

    //! Gets the children transform
    virtual_getChildTransform :: (this: *btGImpactMeshShape, index: s32) -> btTransform #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getChildTransform@btGImpactMeshShape@@UEBA?AVbtTransform@@H@Z";

    //! Sets the children transform
    /*!
    \post You must call updateBound() for update the box set.
    */
    virtual_setChildTransform :: (this: *btGImpactMeshShape, index: s32, transform: *btTransform) -> void #cpp_method #foreign bullet3 "?setChildTransform@btGImpactMeshShape@@UEAAXHAEBVbtTransform@@@Z";

    virtual_getGImpactShapeType :: (this: *btGImpactMeshShape) -> eGIMPACT_SHAPE_TYPE #cpp_method #foreign bullet3 "?getGImpactShapeType@btGImpactMeshShape@@UEBA?AW4eGIMPACT_SHAPE_TYPE@@XZ";

    virtual_getName :: (this: *btGImpactMeshShape) -> *u8 #cpp_method #foreign bullet3 "?getName@btGImpactMeshShape@@UEBAPEBDXZ";

    virtual_rayTest :: (this: *btGImpactMeshShape, rayFrom: *btVector3, rayTo: *btVector3, resultCallback: *btCollisionWorld.RayResultCallback) -> void #cpp_method #foreign bullet3 "?rayTest@btGImpactMeshShape@@UEBAXAEBVbtVector3@@0AEAURayResultCallback@btCollisionWorld@@@Z";

    //! Function for retrieve triangles.
    /*!
    It gives the triangles in local space
    */
    virtual_processAllTriangles :: (this: *btGImpactMeshShape, callback: *btTriangleCallback, aabbMin: *btVector3, aabbMax: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTriangles@btGImpactMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    virtual_processAllTrianglesRay :: (this: *btGImpactMeshShape, callback: *btTriangleCallback, rayFrom: *btVector3, rayTo: *btVector3) -> void #cpp_method #foreign bullet3 "?processAllTrianglesRay@btGImpactMeshShape@@UEBAXPEAVbtTriangleCallback@@AEBVbtVector3@@1@Z";

    virtual_calculateSerializeBufferSize :: (this: *btGImpactMeshShape) -> s32 #cpp_method #foreign bullet3 "?calculateSerializeBufferSize@btGImpactMeshShape@@UEBAHXZ";

    ///fills the dataBuffer and returns the struct name (and 0 on failure)
    virtual_serialize :: (this: *btGImpactMeshShape, dataBuffer: *void, serializer: *btSerializer) -> *u8 #cpp_method #foreign bullet3 "?serialize@btGImpactMeshShape@@UEBAPEBDPEAXPEAVbtSerializer@@@Z";
}

///do not change those serialization structures, it requires an updated sBulletDNAstr/sBulletDNAstr64
btGImpactMeshShapeData :: struct {
    m_collisionShapeData: btCollisionShapeData;

    m_meshInterface:      btStridingMeshInterfaceData;

    m_localScaling:       btVector3FloatData;

    m_collisionMargin:    float;

    m_gimpactSubType:     s32;
}

btTriangleRaycastCallback :: struct {
    #as using bttrianglecallback: btTriangleCallback;

    //input
    m_from:        btVector3;
    m_to:          btVector3;

    //@BP Mod - allow backface filtering and unflipped normals
    EFlags :: enum s32 {
        None                           :: 0;
        FilterBackfaces                :: 1;
        KeepUnflippedNormal            :: 2;

        UseSubSimplexConvexCastRaytest :: 4;
        UseGjkConvexCastRaytest        :: 8;
        DisableHeightfieldAccelerator  :: 16;
        Terminator                     :: -1;

        kF_None                           :: None;
        kF_FilterBackfaces                :: FilterBackfaces;
        kF_KeepUnflippedNormal            :: KeepUnflippedNormal;

        kF_UseSubSimplexConvexCastRaytest :: UseSubSimplexConvexCastRaytest;
        kF_UseGjkConvexCastRaytest        :: UseGjkConvexCastRaytest;
        kF_DisableHeightfieldAccelerator  :: DisableHeightfieldAccelerator;
        kF_Terminator                     :: Terminator;
    }

    m_flags:       u32;

    m_hitFraction: btScalar;

    Constructor :: (this: *btTriangleRaycastCallback, from: *btVector3, to: *btVector3, flags: u32 = 0) -> void #cpp_method #foreign bullet3 "??0btTriangleRaycastCallback@@QEAA@AEBVbtVector3@@0I@Z";
    Constructor :: (this: *btTriangleRaycastCallback, from: btVector3, to: btVector3, flags: u32 = 0) #no_context {
        Constructor(this, *from, *to, flags);
    }
    #place bttrianglecallback; bttriangleraycastcallback_vtable: *btTriangleRaycastCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processTriangle :: (this: *btTriangleRaycastCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method #foreign bullet3 "?processTriangle@btTriangleRaycastCallback@@UEAAXPEAVbtVector3@@HH@Z";
}
btTriangleRaycastCallback_VTable :: struct #type_info_none {
    using bttrianglecallback: btTriangleCallback_VTable;
    reportHit: (this: *btTriangleRaycastCallback, hitNormalLocal: *btVector3, hitFraction: btScalar, partId: s32, triangleIndex: s32) -> btScalar #cpp_method;
}
btTriangleRaycastCallback_reportHit :: inline (this: *btTriangleRaycastCallback, hitNormalLocal: *btVector3, hitFraction: btScalar, partId: s32, triangleIndex: s32) -> btScalar { return this.bttriangleraycastcallback_vtable.reportHit(this, hitNormalLocal, hitFraction, partId, triangleIndex); }

vtable :: (obj: *btTriangleRaycastCallback) -> *btTriangleRaycastCallback_VTable { return obj.bttriangleraycastcallback_vtable; }


btTriangleConvexcastCallback :: struct {
    #as using bttrianglecallback: btTriangleCallback;

    m_convexShape:             *btConvexShape;
    m_convexShapeFrom:         btTransform;
    m_convexShapeTo:           btTransform;
    m_triangleToWorld:         btTransform;
    m_hitFraction:             btScalar;
    m_triangleCollisionMargin: btScalar;
    m_allowedPenetration:      btScalar;

    Constructor :: (this: *btTriangleConvexcastCallback, convexShape: *btConvexShape, convexShapeFrom: *btTransform, convexShapeTo: *btTransform, triangleToWorld: *btTransform, triangleCollisionMargin: btScalar) -> void #cpp_method #foreign bullet3 "??0btTriangleConvexcastCallback@@QEAA@PEBVbtConvexShape@@AEBVbtTransform@@11M@Z";
    Constructor :: (this: *btTriangleConvexcastCallback, convexShape: *btConvexShape, convexShapeFrom: btTransform, convexShapeTo: btTransform, triangleToWorld: btTransform, triangleCollisionMargin: btScalar) #no_context {
        Constructor(this, convexShape, *convexShapeFrom, *convexShapeTo, *triangleToWorld, triangleCollisionMargin);
    }
    #place bttrianglecallback; bttriangleconvexcastcallback_vtable: *btTriangleConvexcastCallback_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_processTriangle :: (this: *btTriangleConvexcastCallback, triangle: *btVector3, partId: s32, triangleIndex: s32) -> void #cpp_method #foreign bullet3 "?processTriangle@btTriangleConvexcastCallback@@UEAAXPEAVbtVector3@@HH@Z";
}
btTriangleConvexcastCallback_VTable :: struct #type_info_none {
    using bttrianglecallback: btTriangleCallback_VTable;
    reportHit: (this: *btTriangleConvexcastCallback, hitNormalLocal: *btVector3, hitPointLocal: *btVector3, hitFraction: btScalar, partId: s32, triangleIndex: s32) -> btScalar #cpp_method;
}
btTriangleConvexcastCallback_reportHit :: inline (this: *btTriangleConvexcastCallback, hitNormalLocal: *btVector3, hitPointLocal: *btVector3, hitFraction: btScalar, partId: s32, triangleIndex: s32) -> btScalar { return this.bttriangleconvexcastcallback_vtable.reportHit(this, hitNormalLocal, hitPointLocal, hitFraction, partId, triangleIndex); }

vtable :: (obj: *btTriangleConvexcastCallback) -> *btTriangleConvexcastCallback_VTable { return obj.bttriangleconvexcastcallback_vtable; }


btCompoundFromGimpactShape :: struct {
    #as using btcompoundshape: btCompoundShape;
}

MyCallback :: struct {
    #as using bttriangleraycastcallback: btTriangleRaycastCallback;

    m_ignorePart:          s32;
    m_ignoreTriangleIndex: s32;
}

MyInternalTriangleIndexCallback :: struct {
    #as using btinternaltriangleindexcallback: btInternalTriangleIndexCallback;

    m_gimpactShape: *btGImpactMeshShape;
    m_colShape:     *btCompoundShape;
    m_depth:        btScalar;
}

///The GIM_CONTACT is an internal GIMPACT structure, similar to btManifoldPoint.
///@todo: remove and replace GIM_CONTACT by btManifoldPoint.
GIM_CONTACT :: struct {
    m_point:    btVector3;
    m_normal:   btVector3;
    m_depth:    btScalar; //Positive value indicates interpenetration
    m_distance: btScalar; //Padding not for use
    m_feature1: s32; //Face number
    m_feature2: s32; //Face number

    Constructor :: (this: *GIM_CONTACT) -> void #cpp_method #foreign bullet3 "??0GIM_CONTACT@@QEAA@XZ";

    CopyConstructor :: (this: *GIM_CONTACT, contact: *GIM_CONTACT) -> void #cpp_method #foreign bullet3 "??0GIM_CONTACT@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *GIM_CONTACT, contact: GIM_CONTACT) #no_context {
        CopyConstructor(this, *contact);
    }

    Constructor :: (this: *GIM_CONTACT, point: *btVector3, normal: *btVector3, depth: btScalar, feature1: s32, feature2: s32) -> void #cpp_method #foreign bullet3 "??0GIM_CONTACT@@QEAA@AEBVbtVector3@@0MHH@Z";
    Constructor :: (this: *GIM_CONTACT, point: btVector3, normal: btVector3, depth: btScalar, feature1: s32, feature2: s32) #no_context {
        Constructor(this, *point, *normal, depth, feature1, feature2);
    }

    //! Calcs key for coord classification
    calc_key_contact :: (this: *GIM_CONTACT) -> u32 #cpp_method #foreign bullet3 "?calc_key_contact@GIM_CONTACT@@QEBAIXZ";

    interpolate_normals :: (this: *GIM_CONTACT, normals: *btVector3, normal_count: s32) -> void #cpp_method #foreign bullet3 "?interpolate_normals@GIM_CONTACT@@QEAAXPEAVbtVector3@@H@Z";
}

btContactArray :: struct {
    #as using btalignedobjectarray: btAlignedObjectArray(GIM_CONTACT);

    Constructor :: (this: *btContactArray) -> void #cpp_method #foreign bullet3 "??0btContactArray@@QEAA@XZ";

    push_contact :: (this: *btContactArray, point: *btVector3, normal: *btVector3, depth: btScalar, feature1: s32, feature2: s32) -> void #cpp_method #foreign bullet3 "?push_contact@btContactArray@@QEAAXAEBVbtVector3@@0MHH@Z";
    push_contact :: (this: *btContactArray, point: btVector3, normal: btVector3, depth: btScalar, feature1: s32, feature2: s32) #no_context {
        push_contact(this, *point, *normal, depth, feature1, feature2);
    }

    push_triangle_contacts :: (this: *btContactArray, tricontact: *GIM_TRIANGLE_CONTACT, feature1: s32, feature2: s32) -> void #cpp_method #foreign bullet3 "?push_triangle_contacts@btContactArray@@QEAAXAEBUGIM_TRIANGLE_CONTACT@@HH@Z";
    push_triangle_contacts :: (this: *btContactArray, tricontact: GIM_TRIANGLE_CONTACT, feature1: s32, feature2: s32) #no_context {
        push_triangle_contacts(this, *tricontact, feature1, feature2);
    }

    merge_contacts :: (this: *btContactArray, contacts: *btContactArray, normal_contact_average := true) -> void #cpp_method #foreign bullet3 "?merge_contacts@btContactArray@@QEAAXAEBV1@_N@Z";
    merge_contacts :: (this: *btContactArray, contacts: btContactArray, normal_contact_average := true) #no_context {
        merge_contacts(this, *contacts, normal_contact_average);
    }

    merge_contacts_unique :: (this: *btContactArray, contacts: *btContactArray) -> void #cpp_method #foreign bullet3 "?merge_contacts_unique@btContactArray@@QEAAXAEBV1@@Z";
    merge_contacts_unique :: (this: *btContactArray, contacts: btContactArray) #no_context {
        merge_contacts_unique(this, *contacts);
    }
}

//! Generic Pool class
btGenericMemoryPool :: struct {
    m_pool:              *u8; //[m_element_size*m_max_element_count];
    m_free_nodes:        *size_t; //[m_max_element_count];//! free nodes
    m_allocated_sizes:   *size_t; //[m_max_element_count];//! Number of elements allocated per node
    m_allocated_count:   size_t;
    m_free_nodes_count:  size_t;

    m_element_size:      size_t;
    m_max_element_count: size_t;

    allocate_from_free_nodes :: (this: *btGenericMemoryPool, num_elements: size_t) -> size_t #cpp_method #foreign bullet3 "?allocate_from_free_nodes@btGenericMemoryPool@@IEAA_K_K@Z";
    allocate_from_pool :: (this: *btGenericMemoryPool, num_elements: size_t) -> size_t #cpp_method #foreign bullet3 "?allocate_from_pool@btGenericMemoryPool@@IEAA_K_K@Z";

    init_pool :: (this: *btGenericMemoryPool, element_size: size_t, element_count: size_t) -> void #cpp_method #foreign bullet3 "?init_pool@btGenericMemoryPool@@QEAAX_K0@Z";

    end_pool :: (this: *btGenericMemoryPool) -> void #cpp_method #foreign bullet3 "?end_pool@btGenericMemoryPool@@QEAAXXZ";

    Constructor :: (this: *btGenericMemoryPool, element_size: size_t, element_count: size_t) -> void #cpp_method #foreign bullet3 "??0btGenericMemoryPool@@QEAA@_K0@Z";

    Destructor :: (this: *btGenericMemoryPool) -> void #cpp_method #foreign bullet3 "??1btGenericMemoryPool@@QEAA@XZ";

    get_pool_capacity :: (this: *btGenericMemoryPool) -> size_t #cpp_method #foreign bullet3 "?get_pool_capacity@btGenericMemoryPool@@QEAA_KXZ";

    gem_element_size :: (this: *btGenericMemoryPool) -> size_t #cpp_method #foreign bullet3 "?gem_element_size@btGenericMemoryPool@@QEAA_KXZ";

    get_max_element_count :: (this: *btGenericMemoryPool) -> size_t #cpp_method #foreign bullet3 "?get_max_element_count@btGenericMemoryPool@@QEAA_KXZ";

    get_allocated_count :: (this: *btGenericMemoryPool) -> size_t #cpp_method #foreign bullet3 "?get_allocated_count@btGenericMemoryPool@@QEAA_KXZ";

    get_free_positions_count :: (this: *btGenericMemoryPool) -> size_t #cpp_method #foreign bullet3 "?get_free_positions_count@btGenericMemoryPool@@QEAA_KXZ";

    get_element_data :: (this: *btGenericMemoryPool, element_index: size_t) -> *void #cpp_method #foreign bullet3 "?get_element_data@btGenericMemoryPool@@QEAAPEAX_K@Z";

    //! Allocates memory in pool
    /*!
    \param size_bytes size in bytes of the buffer
    */
    allocate :: (this: *btGenericMemoryPool, size_bytes: size_t) -> *void #cpp_method #foreign bullet3 "?allocate@btGenericMemoryPool@@QEAAPEAX_K@Z";

    freeMemory :: (this: *btGenericMemoryPool, pointer: *void) -> bool #cpp_method #foreign bullet3 "?freeMemory@btGenericMemoryPool@@QEAA_NPEAX@Z";
}

//! Generic Allocator with pools
/*!
General purpose Allocator which can create Memory Pools dynamiacally as needed.
*/
btGenericPoolAllocator :: struct {
    vtable: *btGenericPoolAllocator_VTable;
    m_pool_element_size:  size_t;
    m_pool_element_count: size_t;

    m_pools:              [16] *btGenericMemoryPool;
    m_pool_count:         size_t;

    get_pool_capacity :: (this: *btGenericPoolAllocator) -> size_t #cpp_method #foreign bullet3 "?get_pool_capacity@btGenericPoolAllocator@@QEAA_KXZ";

    // creates a pool
    push_new_pool :: (this: *btGenericPoolAllocator) -> *btGenericMemoryPool #cpp_method #foreign bullet3 "?push_new_pool@btGenericPoolAllocator@@IEAAPEAVbtGenericMemoryPool@@XZ";

    failback_alloc :: (this: *btGenericPoolAllocator, size_bytes: size_t) -> *void #cpp_method #foreign bullet3 "?failback_alloc@btGenericPoolAllocator@@IEAAPEAX_K@Z";

    failback_free :: (this: *btGenericPoolAllocator, pointer: *void) -> bool #cpp_method #foreign bullet3 "?failback_free@btGenericPoolAllocator@@IEAA_NPEAX@Z";

    Constructor :: (this: *btGenericPoolAllocator, pool_element_size: size_t, pool_element_count: size_t) -> void #cpp_method #foreign bullet3 "??0btGenericPoolAllocator@@QEAA@_K0@Z";

    //! Allocates memory in pool
    /*!
    \param size_bytes size in bytes of the buffer
    */
    allocate :: (this: *btGenericPoolAllocator, size_bytes: size_t) -> *void #cpp_method #foreign bullet3 "?allocate@btGenericPoolAllocator@@QEAAPEAX_K@Z";

    freeMemory :: (this: *btGenericPoolAllocator, pointer: *void) -> bool #cpp_method #foreign bullet3 "?freeMemory@btGenericPoolAllocator@@QEAA_NPEAX@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGenericPoolAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGenericPoolAllocator@@UEAA@XZ";
}
btGenericPoolAllocator_VTable :: struct #type_info_none {
    Destructor: (this: *btGenericPoolAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
btGenericPoolAllocator_Destructor :: inline (this: *btGenericPoolAllocator, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



//! Collision Algorithm for GImpact Shapes
/*!
For register this algorithm in Bullet, proceed as following:
\code
btCollisionDispatcher * dispatcher = static_cast<btCollisionDispatcher *>(m_dynamicsWorld ->getDispatcher());
btGImpactCollisionAlgorithm::registerAlgorithm(dispatcher);
\endcode
*/
btGImpactCollisionAlgorithm :: struct {
    #as using btactivatingcollisionalgorithm: btActivatingCollisionAlgorithm;

    m_convex_algorithm: *btCollisionAlgorithm;
    m_manifoldPtr:      *btPersistentManifold;
    m_resultOut:        *btManifoldResult;
    m_dispatchInfo:     *btDispatcherInfo;
    m_triface0:         s32;
    m_part0:            s32;
    m_triface1:         s32;
    m_part1:            s32;

    //! Creates a new contact point
    newContactManifold :: (this: *btGImpactCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject) -> *btPersistentManifold #cpp_method #foreign bullet3 "?newContactManifold@btGImpactCollisionAlgorithm@@IEAAPEAVbtPersistentManifold@@PEBVbtCollisionObject@@0@Z";

    destroyConvexAlgorithm :: (this: *btGImpactCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?destroyConvexAlgorithm@btGImpactCollisionAlgorithm@@IEAAXXZ";

    destroyContactManifolds :: (this: *btGImpactCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?destroyContactManifolds@btGImpactCollisionAlgorithm@@IEAAXXZ";

    clearCache :: (this: *btGImpactCollisionAlgorithm) -> void #cpp_method #foreign bullet3 "?clearCache@btGImpactCollisionAlgorithm@@IEAAXXZ";

    getLastManifold :: (this: *btGImpactCollisionAlgorithm) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getLastManifold@btGImpactCollisionAlgorithm@@IEAAPEAVbtPersistentManifold@@XZ";

    // Call before process collision
    checkManifold :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?checkManifold@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0@Z";

    // Call before process collision
    newAlgorithm :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> *btCollisionAlgorithm #cpp_method #foreign bullet3 "?newAlgorithm@btGImpactCollisionAlgorithm@@IEAAPEAVbtCollisionAlgorithm@@PEBUbtCollisionObjectWrapper@@0@Z";

    // Call before process collision
    checkConvexAlgorithm :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "?checkConvexAlgorithm@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0@Z";

    addContactPoint :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, point: *btVector3, normal: *btVector3, distance: btScalar) -> void #cpp_method #foreign bullet3 "?addContactPoint@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0AEBVbtVector3@@1M@Z";
    addContactPoint :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, point: btVector3, normal: btVector3, distance: btScalar) #no_context {
        addContactPoint(this, body0Wrap, body1Wrap, *point, *normal, distance);
    }

    //! Collision routines
    //!@{
    collide_gjk_triangles :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactMeshShapePart, shape1: *btGImpactMeshShapePart, pairs: *s32, pair_count: s32) -> void #cpp_method #foreign bullet3 "?collide_gjk_triangles@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactMeshShapePart@@1PEBHH@Z";

    collide_sat_triangles :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactMeshShapePart, shape1: *btGImpactMeshShapePart, pairs: *s32, pair_count: s32) -> void #cpp_method #foreign bullet3 "?collide_sat_triangles@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactMeshShapePart@@1PEBHH@Z";

    shape_vs_shape_collision :: (this: *btGImpactCollisionAlgorithm, body0: *btCollisionObjectWrapper, body1: *btCollisionObjectWrapper, shape0: *btCollisionShape, shape1: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?shape_vs_shape_collision@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtCollisionShape@@1@Z";

    convex_vs_convex_collision :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btCollisionShape, shape1: *btCollisionShape) -> void #cpp_method #foreign bullet3 "?convex_vs_convex_collision@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtCollisionShape@@1@Z";

    gimpact_vs_gimpact_find_pairs :: (this: *btGImpactCollisionAlgorithm, trans0: *btTransform, trans1: *btTransform, shape0: *btGImpactShapeInterface, shape1: *btGImpactShapeInterface, pairset: *btPairSet) -> void #cpp_method #foreign bullet3 "?gimpact_vs_gimpact_find_pairs@btGImpactCollisionAlgorithm@@IEAAXAEBVbtTransform@@0PEBVbtGImpactShapeInterface@@1AEAVbtPairSet@@@Z";
    gimpact_vs_gimpact_find_pairs :: (this: *btGImpactCollisionAlgorithm, trans0: btTransform, trans1: btTransform, shape0: *btGImpactShapeInterface, shape1: *btGImpactShapeInterface, pairset: *btPairSet) #no_context {
        gimpact_vs_gimpact_find_pairs(this, *trans0, *trans1, shape0, shape1, pairset);
    }

    gimpact_vs_shape_find_pairs :: (this: *btGImpactCollisionAlgorithm, trans0: *btTransform, trans1: *btTransform, shape0: *btGImpactShapeInterface, shape1: *btCollisionShape, collided_primitives: *btAlignedObjectArray(s32)) -> void #cpp_method #foreign bullet3 "?gimpact_vs_shape_find_pairs@btGImpactCollisionAlgorithm@@IEAAXAEBVbtTransform@@0PEBVbtGImpactShapeInterface@@PEBVbtCollisionShape@@AEAV?$btAlignedObjectArray@H@@@Z";
    gimpact_vs_shape_find_pairs :: (this: *btGImpactCollisionAlgorithm, trans0: btTransform, trans1: btTransform, shape0: *btGImpactShapeInterface, shape1: *btCollisionShape, collided_primitives: *btAlignedObjectArray(s32)) #no_context {
        gimpact_vs_shape_find_pairs(this, *trans0, *trans1, shape0, shape1, collided_primitives);
    }

    gimpacttrimeshpart_vs_plane_collision :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactMeshShapePart, shape1: *btStaticPlaneShape, swapped: bool) -> void #cpp_method #foreign bullet3 "?gimpacttrimeshpart_vs_plane_collision@btGImpactCollisionAlgorithm@@IEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactMeshShapePart@@PEBVbtStaticPlaneShape@@_N@Z";

    Constructor :: (this: *btGImpactCollisionAlgorithm, ci: *btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) -> void #cpp_method #foreign bullet3 "??0btGImpactCollisionAlgorithm@@QEAA@AEBUbtCollisionAlgorithmConstructionInfo@@PEBUbtCollisionObjectWrapper@@1@Z";
    Constructor :: (this: *btGImpactCollisionAlgorithm, ci: btCollisionAlgorithmConstructionInfo, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper) #no_context {
        Constructor(this, *ci, body0Wrap, body1Wrap);
    }

    internalGetResultOut :: (this: *btGImpactCollisionAlgorithm) -> *btManifoldResult #cpp_method #foreign bullet3 "?internalGetResultOut@btGImpactCollisionAlgorithm@@QEAAPEAVbtManifoldResult@@XZ";

    CreateFunc :: struct {
        #as using btcollisionalgorithmcreatefunc: btCollisionAlgorithmCreateFunc;
    }

    //! Use this function for register the algorithm externally
    registerAlgorithm :: (dispatcher: *btCollisionDispatcher) -> void #foreign bullet3 "?registerAlgorithm@btGImpactCollisionAlgorithm@@SAXPEAVbtCollisionDispatcher@@@Z";

    //! Collides two gimpact shapes
    /*!
    \pre shape0 and shape1 couldn't be btGImpactMeshShape objects
    */
    gimpact_vs_gimpact :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactShapeInterface, shape1: *btGImpactShapeInterface) -> void #cpp_method #foreign bullet3 "?gimpact_vs_gimpact@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@1@Z";

    gimpact_vs_shape :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactShapeInterface, shape1: *btCollisionShape, swapped: bool) -> void #cpp_method #foreign bullet3 "?gimpact_vs_shape@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@PEBVbtCollisionShape@@_N@Z";

    gimpact_vs_compoundshape :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactShapeInterface, shape1: *btCompoundShape, swapped: bool) -> void #cpp_method #foreign bullet3 "?gimpact_vs_compoundshape@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@PEBVbtCompoundShape@@_N@Z";

    gimpact_vs_concave :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, shape0: *btGImpactShapeInterface, shape1: *btConcaveShape, swapped: bool) -> void #cpp_method #foreign bullet3 "?gimpact_vs_concave@btGImpactCollisionAlgorithm@@QEAAXPEBUbtCollisionObjectWrapper@@0PEBVbtGImpactShapeInterface@@PEBVbtConcaveShape@@_N@Z";

    /// Accessor/Mutator pairs for Part and triangleID
    setFace0 :: (this: *btGImpactCollisionAlgorithm, value: s32) -> void #cpp_method #foreign bullet3 "?setFace0@btGImpactCollisionAlgorithm@@QEAAXH@Z";

    getFace0 :: (this: *btGImpactCollisionAlgorithm) -> s32 #cpp_method #foreign bullet3 "?getFace0@btGImpactCollisionAlgorithm@@QEAAHXZ";

    setFace1 :: (this: *btGImpactCollisionAlgorithm, value: s32) -> void #cpp_method #foreign bullet3 "?setFace1@btGImpactCollisionAlgorithm@@QEAAXH@Z";

    getFace1 :: (this: *btGImpactCollisionAlgorithm) -> s32 #cpp_method #foreign bullet3 "?getFace1@btGImpactCollisionAlgorithm@@QEAAHXZ";

    setPart0 :: (this: *btGImpactCollisionAlgorithm, value: s32) -> void #cpp_method #foreign bullet3 "?setPart0@btGImpactCollisionAlgorithm@@QEAAXH@Z";

    getPart0 :: (this: *btGImpactCollisionAlgorithm) -> s32 #cpp_method #foreign bullet3 "?getPart0@btGImpactCollisionAlgorithm@@QEAAHXZ";

    setPart1 :: (this: *btGImpactCollisionAlgorithm, value: s32) -> void #cpp_method #foreign bullet3 "?setPart1@btGImpactCollisionAlgorithm@@QEAAXH@Z";

    getPart1 :: (this: *btGImpactCollisionAlgorithm) -> s32 #cpp_method #foreign bullet3 "?getPart1@btGImpactCollisionAlgorithm@@QEAAHXZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btGImpactCollisionAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btGImpactCollisionAlgorithm@@UEAA@XZ";

    virtual_processCollision :: (this: *btGImpactCollisionAlgorithm, body0Wrap: *btCollisionObjectWrapper, body1Wrap: *btCollisionObjectWrapper, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> void #cpp_method #foreign bullet3 "?processCollision@btGImpactCollisionAlgorithm@@UEAAXPEBUbtCollisionObjectWrapper@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_calculateTimeOfImpact :: (this: *btGImpactCollisionAlgorithm, body0: *btCollisionObject, body1: *btCollisionObject, dispatchInfo: *btDispatcherInfo, resultOut: *btManifoldResult) -> btScalar #cpp_method #foreign bullet3 "?calculateTimeOfImpact@btGImpactCollisionAlgorithm@@UEAAMPEAVbtCollisionObject@@0AEBUbtDispatcherInfo@@PEAVbtManifoldResult@@@Z";

    virtual_getAllContactManifolds :: (this: *btGImpactCollisionAlgorithm, manifoldArray: *btManifoldArray) -> void #cpp_method #foreign bullet3 "?getAllContactManifolds@btGImpactCollisionAlgorithm@@UEAAXAEAV?$btAlignedObjectArray@PEAVbtPersistentManifold@@@@@Z";
}

GIM_SCALAR_TYPES :: enum s32 {
    REAL   :: 0;
    REAL2  :: 1;
    SHORT  :: 2;
    USHORT :: 3;
    INT    :: 4;
    UINT   :: 5;
    INT64  :: 6;
    UINT64 :: 7;

    G_STYPE_REAL   :: REAL;
    G_STYPE_REAL2  :: REAL2;
    G_STYPE_SHORT  :: SHORT;
    G_STYPE_USHORT :: USHORT;
    G_STYPE_INT    :: INT;
    G_STYPE_UINT   :: UINT;
    G_STYPE_INT64  :: INT64;
    G_STYPE_UINT64 :: UINT64;
}

///Function prototypes to allocate and free memory.
gim_alloc_function :: #type (size: size_t) -> *void #c_call;
gim_alloca_function :: #type (size: size_t) -> *void #c_call;
gim_realloc_function :: #type (ptr: *void, oldsize: size_t, newsize: size_t) -> *void #c_call;
gim_free_function :: #type (ptr: *void) -> void #c_call;

//!	Very simple array container with fast access and simd memory
gim_array :: struct(T: Type) {
    //! properties
    //!@{
    m_data:           *T;
    m_size:           u32;
    m_allocated_size: u32;
}

//! Short Integer vector 2D
vec2s :: [2] s16;

//! Integer vector 3D
vec3s :: [3] s16;

//! Integer vector 4D
vec4s :: [4] s16;

//! Short Integer vector 2D
vec2us :: [2] u16;

//! Integer vector 3D
vec3us :: [3] u16;

//! Integer vector 4D
vec4us :: [4] u16;

//! Integer vector 2D
vec2i :: [2] s32;

//! Integer vector 3D
vec3i :: [3] s32;

//! Integer vector 4D
vec4i :: [4] s32;

//! Unsigned Integer vector 2D
vec2ui :: [2] u32;

//! Unsigned Integer vector 3D
vec3ui :: [3] u32;

//! Unsigned Integer vector 4D
vec4ui :: [4] u32;

//! Float vector 2D
vec2f :: [2] btScalar;

//! Float vector 3D
vec3f :: [3] btScalar;

//! Float vector 4D
vec4f :: [4] btScalar;

//! Double vector 2D
vec2d :: [2] float64;

//! Float vector 3D
vec3d :: [3] float64;

//! Float vector 4D
vec4d :: [4] float64;

//! Matrix 2D, row ordered
mat2f :: [2] [2] btScalar;

//! Matrix 3D, row ordered
mat3f :: [3] [3] btScalar;

//! Matrix 4D, row ordered
mat4f :: [4] [4] btScalar;

//! Quaternion
quatf :: [4] btScalar;

ePLANE_INTERSECTION_TYPE :: enum s32 {
    BACK_PLANE    :: 0;
    COLLIDE_PLANE :: 1;
    FRONT_PLANE   :: 2;

    G_BACK_PLANE    :: BACK_PLANE;
    G_COLLIDE_PLANE :: COLLIDE_PLANE;
    G_FRONT_PLANE   :: FRONT_PLANE;
}

eLINE_PLANE_INTERSECTION_TYPE :: enum s32 {
    FRONT_PLANE_S1   :: 0;
    FRONT_PLANE_S2   :: 1;
    BACK_PLANE_S1    :: 2;
    BACK_PLANE_S2    :: 3;
    COLLIDE_PLANE_S1 :: 4;
    COLLIDE_PLANE_S2 :: 5;

    G_FRONT_PLANE_S1   :: FRONT_PLANE_S1;
    G_FRONT_PLANE_S2   :: FRONT_PLANE_S2;
    G_BACK_PLANE_S1    :: BACK_PLANE_S1;
    G_BACK_PLANE_S2    :: BACK_PLANE_S2;
    G_COLLIDE_PLANE_S1 :: COLLIDE_PLANE_S1;
    G_COLLIDE_PLANE_S2 :: COLLIDE_PLANE_S2;
}

gim_bitset :: struct {
    m_container: gim_array(u32);
}

//!  Class for transforming a model1 to the space of model0
GIM_BOX_BOX_TRANSFORM_CACHE :: struct {
    m_T1to0: btVector3; //!< Transforms translation of model1 to model 0
    m_R1to0: btMatrix3x3; //!< Transforms Rotation of model1 to model 0, equal  to R0' * R1
    m_AR:    btMatrix3x3; //!< Absolute value of m_R1to0

    calc_absolute_matrix :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE) -> void #cpp_method #foreign bullet3 "?calc_absolute_matrix@GIM_BOX_BOX_TRANSFORM_CACHE@@QEAAXXZ";

    Constructor :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE) -> void #cpp_method #foreign bullet3 "??0GIM_BOX_BOX_TRANSFORM_CACHE@@QEAA@XZ";

    Constructor :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, trans1_to_0: *mat4f) -> void #cpp_method #foreign bullet3 "??0GIM_BOX_BOX_TRANSFORM_CACHE@@QEAA@QEAY03M@Z";

    //! Calc the transformation relative  1 to 0. Inverts matrics by transposing
    calc_from_homogenic :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, trans0: *btTransform, trans1: *btTransform) -> void #cpp_method #foreign bullet3 "?calc_from_homogenic@GIM_BOX_BOX_TRANSFORM_CACHE@@QEAAXAEBVbtTransform@@0@Z";
    calc_from_homogenic :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, trans0: btTransform, trans1: btTransform) #no_context {
        calc_from_homogenic(this, *trans0, *trans1);
    }

    //! Calcs the full invertion of the matrices. Useful for scaling matrices
    calc_from_full_invert :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, trans0: *btTransform, trans1: *btTransform) -> void #cpp_method #foreign bullet3 "?calc_from_full_invert@GIM_BOX_BOX_TRANSFORM_CACHE@@QEAAXAEBVbtTransform@@0@Z";
    calc_from_full_invert :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, trans0: btTransform, trans1: btTransform) #no_context {
        calc_from_full_invert(this, *trans0, *trans1);
    }

    transform :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, point: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?transform@GIM_BOX_BOX_TRANSFORM_CACHE@@QEAA?AVbtVector3@@AEBV2@@Z";
    transform :: (this: *GIM_BOX_BOX_TRANSFORM_CACHE, point: btVector3) -> btVector3 #no_context {
        return transform(this, *point);
    }
}

//! Axis aligned box
GIM_AABB :: struct {
    m_min: btVector3;
    m_max: btVector3;

    Constructor :: (this: *GIM_AABB) -> void #cpp_method #foreign bullet3 "??0GIM_AABB@@QEAA@XZ";

    Constructor :: (this: *GIM_AABB, V1: *btVector3, V2: *btVector3, V3: *btVector3) -> void #cpp_method #foreign bullet3 "??0GIM_AABB@@QEAA@AEBVbtVector3@@00@Z";
    Constructor :: (this: *GIM_AABB, V1: btVector3, V2: btVector3, V3: btVector3) #no_context {
        Constructor(this, *V1, *V2, *V3);
    }

    Constructor :: (this: *GIM_AABB, V1: *btVector3, V2: *btVector3, V3: *btVector3, margin: btScalar) -> void #cpp_method #foreign bullet3 "??0GIM_AABB@@QEAA@AEBVbtVector3@@00M@Z";
    Constructor :: (this: *GIM_AABB, V1: btVector3, V2: btVector3, V3: btVector3, margin: btScalar) #no_context {
        Constructor(this, *V1, *V2, *V3, margin);
    }

    CopyConstructor :: (this: *GIM_AABB, other: *GIM_AABB) -> void #cpp_method #foreign bullet3 "??0GIM_AABB@@QEAA@AEBV0@@Z";
    CopyConstructor :: (this: *GIM_AABB, other: GIM_AABB) #no_context {
        CopyConstructor(this, *other);
    }

    Constructor :: (this: *GIM_AABB, other: *GIM_AABB, margin: btScalar) -> void #cpp_method #foreign bullet3 "??0GIM_AABB@@QEAA@AEBV0@M@Z";
    Constructor :: (this: *GIM_AABB, other: GIM_AABB, margin: btScalar) #no_context {
        Constructor(this, *other, margin);
    }

    invalidate :: (this: *GIM_AABB) -> void #cpp_method #foreign bullet3 "?invalidate@GIM_AABB@@QEAAXXZ";

    increment_margin :: (this: *GIM_AABB, margin: btScalar) -> void #cpp_method #foreign bullet3 "?increment_margin@GIM_AABB@@QEAAXM@Z";

    copy_with_margin :: (this: *GIM_AABB, other: *GIM_AABB, margin: btScalar) -> void #cpp_method #foreign bullet3 "?copy_with_margin@GIM_AABB@@QEAAXAEBV1@M@Z";
    copy_with_margin :: (this: *GIM_AABB, other: GIM_AABB, margin: btScalar) #no_context {
        copy_with_margin(this, *other, margin);
    }

    //! Apply a transform to an AABB
    appy_transform :: (this: *GIM_AABB, trans: *btTransform) -> void #cpp_method #foreign bullet3 "?appy_transform@GIM_AABB@@QEAAXAEBVbtTransform@@@Z";
    appy_transform :: (this: *GIM_AABB, trans: btTransform) #no_context {
        appy_transform(this, *trans);
    }

    //! Merges a Box
    merge :: (this: *GIM_AABB, box: *GIM_AABB) -> void #cpp_method #foreign bullet3 "?merge@GIM_AABB@@QEAAXAEBV1@@Z";
    merge :: (this: *GIM_AABB, box: GIM_AABB) #no_context {
        merge(this, *box);
    }

    //! Gets the extend and center
    get_center_extend :: (this: *GIM_AABB, center: *btVector3, extend: *btVector3) -> void #cpp_method #foreign bullet3 "?get_center_extend@GIM_AABB@@QEBAXAEAVbtVector3@@0@Z";

    //! Finds the intersecting box between this box and the other.
    find_intersection :: (this: *GIM_AABB, other: *GIM_AABB, intersection: *GIM_AABB) -> void #cpp_method #foreign bullet3 "?find_intersection@GIM_AABB@@QEBAXAEBV1@AEAV1@@Z";
    find_intersection :: (this: *GIM_AABB, other: GIM_AABB, intersection: *GIM_AABB) #no_context {
        find_intersection(this, *other, intersection);
    }

    has_collision :: (this: *GIM_AABB, other: *GIM_AABB) -> bool #cpp_method #foreign bullet3 "?has_collision@GIM_AABB@@QEBA_NAEBV1@@Z";
    has_collision :: (this: *GIM_AABB, other: GIM_AABB) -> bool #no_context {
        return has_collision(this, *other);
    }

    /*! \brief Finds the Ray intersection parameter.
    \param aabb Aligned box
    \param vorigin A vec3f with the origin of the ray
    \param vdir A vec3f with the direction of the ray
    */
    collide_ray :: (this: *GIM_AABB, vorigin: *btVector3, vdir: *btVector3) -> bool #cpp_method #foreign bullet3 "?collide_ray@GIM_AABB@@QEAA_NAEBVbtVector3@@0@Z";
    collide_ray :: (this: *GIM_AABB, vorigin: btVector3, vdir: btVector3) -> bool #no_context {
        return collide_ray(this, *vorigin, *vdir);
    }

    projection_interval :: (this: *GIM_AABB, direction: *btVector3, vmin: *btScalar, vmax: *btScalar) -> void #cpp_method #foreign bullet3 "?projection_interval@GIM_AABB@@QEBAXAEBVbtVector3@@AEAM1@Z";
    projection_interval :: (this: *GIM_AABB, direction: btVector3, vmin: *btScalar, vmax: *btScalar) #no_context {
        projection_interval(this, *direction, vmin, vmax);
    }

    plane_classify :: (this: *GIM_AABB, plane: *btVector4) -> ePLANE_INTERSECTION_TYPE #cpp_method #foreign bullet3 "?plane_classify@GIM_AABB@@QEBA?AW4ePLANE_INTERSECTION_TYPE@@AEBVbtVector4@@@Z";
    plane_classify :: (this: *GIM_AABB, plane: btVector4) -> ePLANE_INTERSECTION_TYPE #no_context {
        return plane_classify(this, *plane);
    }

    overlapping_trans_conservative :: (this: *GIM_AABB, box: *GIM_AABB, trans1_to_0: *btTransform) -> bool #cpp_method #foreign bullet3 "?overlapping_trans_conservative@GIM_AABB@@QEAA_NAEBV1@AEAVbtTransform@@@Z";
    overlapping_trans_conservative :: (this: *GIM_AABB, box: GIM_AABB, trans1_to_0: *btTransform) -> bool #no_context {
        return overlapping_trans_conservative(this, *box, trans1_to_0);
    }

    //! transcache is the transformation cache from box to this AABB
    overlapping_trans_cache :: (this: *GIM_AABB, box: *GIM_AABB, transcache: *GIM_BOX_BOX_TRANSFORM_CACHE, fulltest: bool) -> bool #cpp_method #foreign bullet3 "?overlapping_trans_cache@GIM_AABB@@QEAA_NAEBV1@AEBVGIM_BOX_BOX_TRANSFORM_CACHE@@_N@Z";
    overlapping_trans_cache :: (this: *GIM_AABB, box: GIM_AABB, transcache: GIM_BOX_BOX_TRANSFORM_CACHE, fulltest: bool) -> bool #no_context {
        return overlapping_trans_cache(this, *box, *transcache, fulltest);
    }

    //! Simple test for planes.
    collide_plane :: (this: *GIM_AABB, plane: *btVector4) -> bool #cpp_method #foreign bullet3 "?collide_plane@GIM_AABB@@QEAA_NAEBVbtVector4@@@Z";
    collide_plane :: (this: *GIM_AABB, plane: btVector4) -> bool #no_context {
        return collide_plane(this, *plane);
    }

    //! test for a triangle, with edges
    collide_triangle_exact :: (this: *GIM_AABB, p1: *btVector3, p2: *btVector3, p3: *btVector3, triangle_plane: *btVector4) -> bool #cpp_method #foreign bullet3 "?collide_triangle_exact@GIM_AABB@@QEAA_NAEBVbtVector3@@00AEBVbtVector4@@@Z";
    collide_triangle_exact :: (this: *GIM_AABB, p1: btVector3, p2: btVector3, p3: btVector3, triangle_plane: btVector4) -> bool #no_context {
        return collide_triangle_exact(this, *p1, *p2, *p3, *triangle_plane);
    }
}

///Macros for sorting.
//! Prototype for comparators
less_comparator :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//! Prototype for comparators
integer_comparator :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//!Prototype for getting the integer representation of an object
uint_key_func :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//!Prototype for copying elements
copy_elements_func :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//!Prototype for copying elements
memcopy_elements_func :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//! @{
GIM_RSORT_TOKEN :: struct {
    m_key:   u32;
    m_value: u32;
    Constructor :: (this: *GIM_RSORT_TOKEN) -> void #cpp_method #foreign bullet3 "??0GIM_RSORT_TOKEN@@QEAA@XZ";

    CopyConstructor :: (this: *GIM_RSORT_TOKEN, rtoken: *GIM_RSORT_TOKEN) -> void #cpp_method #foreign bullet3 "??0GIM_RSORT_TOKEN@@QEAA@AEBU0@@Z";
    CopyConstructor :: (this: *GIM_RSORT_TOKEN, rtoken: GIM_RSORT_TOKEN) #no_context {
        CopyConstructor(this, *rtoken);
    }
}

operator< :: (this: *GIM_RSORT_TOKEN, other: *GIM_RSORT_TOKEN) -> bool #cpp_method #foreign bullet3 "??MGIM_RSORT_TOKEN@@QEBA_NAEBU0@@Z";
operator< :: (this: GIM_RSORT_TOKEN, other: GIM_RSORT_TOKEN) -> bool #no_context {
    return operator<(*this, *other);
}

operator> :: (this: *GIM_RSORT_TOKEN, other: *GIM_RSORT_TOKEN) -> bool #cpp_method #foreign bullet3 "??OGIM_RSORT_TOKEN@@QEBA_NAEBU0@@Z";
operator> :: (this: GIM_RSORT_TOKEN, other: GIM_RSORT_TOKEN) -> bool #no_context {
    return operator>(*this, *other);
}

//! Prototype for comparators
GIM_RSORT_TOKEN_COMPARATOR :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}
operator_parens :: (this: *GIM_RSORT_TOKEN_COMPARATOR, a: *GIM_RSORT_TOKEN, b: *GIM_RSORT_TOKEN) -> s32 #cpp_method #foreign bullet3 "??RGIM_RSORT_TOKEN_COMPARATOR@@QEAAHAEBUGIM_RSORT_TOKEN@@0@Z";
operator_parens :: (this: GIM_RSORT_TOKEN_COMPARATOR, a: GIM_RSORT_TOKEN, b: GIM_RSORT_TOKEN) -> s32 #no_context {
    return operator_parens(*this, *a, *b);
}

//! This function calcs the distance from a 3D plane
DISTANCE_PLANE_3D_FUNC :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//! Structure for collision
GIM_TRIANGLE_CONTACT_DATA :: struct {
    m_penetration_depth: btScalar;
    m_point_count:       u32;
    m_separating_normal: btVector4;
    m_points:            [16] btVector3;

    copy_from :: (this: *GIM_TRIANGLE_CONTACT_DATA, other: *GIM_TRIANGLE_CONTACT_DATA) -> void #cpp_method #foreign bullet3 "?copy_from@GIM_TRIANGLE_CONTACT_DATA@@QEAAXAEBU1@@Z";
    copy_from :: (this: *GIM_TRIANGLE_CONTACT_DATA, other: GIM_TRIANGLE_CONTACT_DATA) #no_context {
        copy_from(this, *other);
    }

    Constructor :: (this: *GIM_TRIANGLE_CONTACT_DATA) -> void #cpp_method #foreign bullet3 "??0GIM_TRIANGLE_CONTACT_DATA@@QEAA@XZ";

    CopyConstructor :: (this: *GIM_TRIANGLE_CONTACT_DATA, other: *GIM_TRIANGLE_CONTACT_DATA) -> void #cpp_method #foreign bullet3 "??0GIM_TRIANGLE_CONTACT_DATA@@QEAA@AEBU0@@Z";
    CopyConstructor :: (this: *GIM_TRIANGLE_CONTACT_DATA, other: GIM_TRIANGLE_CONTACT_DATA) #no_context {
        CopyConstructor(this, *other);
    }

    //! classify points that are closer
    merge_points :: (this: *GIM_TRIANGLE_CONTACT_DATA, plane: *btVector4, margin: btScalar, points: *btVector3, point_count: u32) -> void #cpp_method #foreign bullet3 "?merge_points@GIM_TRIANGLE_CONTACT_DATA@@QEAAXAEBVbtVector4@@MPEBVbtVector3@@I@Z";
    merge_points :: (this: *GIM_TRIANGLE_CONTACT_DATA, plane: btVector4, margin: btScalar, points: *btVector3, point_count: u32) #no_context {
        merge_points(this, *plane, margin, points, point_count);
    }
}

//! Class for colliding triangles
GIM_TRIANGLE :: struct {
    m_margin:   btScalar;
    m_vertices: [3] btVector3;

    Constructor :: (this: *GIM_TRIANGLE) -> void #cpp_method #foreign bullet3 "??0GIM_TRIANGLE@@QEAA@XZ";

    get_box :: (this: *GIM_TRIANGLE) -> GIM_AABB #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?get_box@GIM_TRIANGLE@@QEBA?AVGIM_AABB@@XZ";

    get_normal :: (this: *GIM_TRIANGLE, normal: *btVector3) -> void #cpp_method #foreign bullet3 "?get_normal@GIM_TRIANGLE@@QEBAXAEAVbtVector3@@@Z";

    get_plane :: (this: *GIM_TRIANGLE, plane: *btVector4) -> void #cpp_method #foreign bullet3 "?get_plane@GIM_TRIANGLE@@QEBAXAEAVbtVector4@@@Z";

    apply_transform :: (this: *GIM_TRIANGLE, trans: *btTransform) -> void #cpp_method #foreign bullet3 "?apply_transform@GIM_TRIANGLE@@QEAAXAEBVbtTransform@@@Z";
    apply_transform :: (this: *GIM_TRIANGLE, trans: btTransform) #no_context {
        apply_transform(this, *trans);
    }

    get_edge_plane :: (this: *GIM_TRIANGLE, edge_index: u32, triangle_normal: *btVector3, plane: *btVector4) -> void #cpp_method #foreign bullet3 "?get_edge_plane@GIM_TRIANGLE@@QEBAXIAEBVbtVector3@@AEAVbtVector4@@@Z";
    get_edge_plane :: (this: *GIM_TRIANGLE, edge_index: u32, triangle_normal: btVector3, plane: *btVector4) #no_context {
        get_edge_plane(this, edge_index, *triangle_normal, plane);
    }

    //! Gets the relative transformation of this triangle
    /*!
    The transformation is oriented to the triangle normal , and aligned to the 1st edge of this triangle. The position corresponds to vertice 0:
    - triangle normal corresponds to Z axis.
    - 1st normalized edge corresponds to X axis,
    
    */
    get_triangle_transform :: (this: *GIM_TRIANGLE, triangle_transform: *btTransform) -> void #cpp_method #foreign bullet3 "?get_triangle_transform@GIM_TRIANGLE@@QEBAXAEAVbtTransform@@@Z";

    //! Test triangles by finding separating axis
    /*!
    \param other Triangle for collide
    \param contact_data Structure for holding contact points, normal and penetration depth; The normal is pointing toward this triangle from the other triangle
    */
    collide_triangle_hard_test :: (this: *GIM_TRIANGLE, other: *GIM_TRIANGLE, contact_data: *GIM_TRIANGLE_CONTACT_DATA) -> bool #cpp_method #foreign bullet3 "?collide_triangle_hard_test@GIM_TRIANGLE@@QEBA_NAEBV1@AEAUGIM_TRIANGLE_CONTACT_DATA@@@Z";
    collide_triangle_hard_test :: (this: *GIM_TRIANGLE, other: GIM_TRIANGLE, contact_data: *GIM_TRIANGLE_CONTACT_DATA) -> bool #no_context {
        return collide_triangle_hard_test(this, *other, contact_data);
    }

    //! Test boxes before doing hard test
    /*!
    \param other Triangle for collide
    \param contact_data Structure for holding contact points, normal and penetration depth; The normal is pointing toward this triangle from the other triangle
    \
    */
    collide_triangle :: (this: *GIM_TRIANGLE, other: *GIM_TRIANGLE, contact_data: *GIM_TRIANGLE_CONTACT_DATA) -> bool #cpp_method #foreign bullet3 "?collide_triangle@GIM_TRIANGLE@@QEBA_NAEBV1@AEAUGIM_TRIANGLE_CONTACT_DATA@@@Z";
    collide_triangle :: (this: *GIM_TRIANGLE, other: GIM_TRIANGLE, contact_data: *GIM_TRIANGLE_CONTACT_DATA) -> bool #no_context {
        return collide_triangle(this, *other, contact_data);
    }

    /*!
    
    Solve the System for u,v parameters:
    
    u*axe1[i1] + v*axe2[i1] = vecproj[i1]
    u*axe1[i2] + v*axe2[i2] = vecproj[i2]
    
    sustitute:
    v = (vecproj[i2] - u*axe1[i2])/axe2[i2]
    
    then the first equation in terms of 'u':
    
    --> u*axe1[i1] + ((vecproj[i2] - u*axe1[i2])/axe2[i2])*axe2[i1] = vecproj[i1]
    
    --> u*axe1[i1] + vecproj[i2]*axe2[i1]/axe2[i2] - u*axe1[i2]*axe2[i1]/axe2[i2] = vecproj[i1]
    
    --> u*(axe1[i1]  - axe1[i2]*axe2[i1]/axe2[i2]) = vecproj[i1] - vecproj[i2]*axe2[i1]/axe2[i2]
    
    --> u*((axe1[i1]*axe2[i2]  - axe1[i2]*axe2[i1])/axe2[i2]) = (vecproj[i1]*axe2[i2] - vecproj[i2]*axe2[i1])/axe2[i2]
    
    --> u*(axe1[i1]*axe2[i2]  - axe1[i2]*axe2[i1]) = vecproj[i1]*axe2[i2] - vecproj[i2]*axe2[i1]
    
    --> u = (vecproj[i1]*axe2[i2] - vecproj[i2]*axe2[i1]) /(axe1[i1]*axe2[i2]  - axe1[i2]*axe2[i1])
    
    if 0.0<= u+v <=1.0 then they are inside of triangle
    
    \return false if the point is outside of triangle.This function  doesn't take the margin
    */
    get_uv_parameters :: (this: *GIM_TRIANGLE, point: *btVector3, tri_plane: *btVector3, u: *btScalar, v: *btScalar) -> bool #cpp_method #foreign bullet3 "?get_uv_parameters@GIM_TRIANGLE@@QEBA_NAEBVbtVector3@@0AEAM1@Z";
    get_uv_parameters :: (this: *GIM_TRIANGLE, point: btVector3, tri_plane: btVector3, u: *btScalar, v: *btScalar) -> bool #no_context {
        return get_uv_parameters(this, *point, *tri_plane, u, v);
    }

    //! is point in triangle beam?
    /*!
    Test if point is in triangle, with m_margin tolerance
    */
    is_point_inside :: (this: *GIM_TRIANGLE, point: *btVector3, tri_normal: *btVector3) -> bool #cpp_method #foreign bullet3 "?is_point_inside@GIM_TRIANGLE@@QEBA_NAEBVbtVector3@@0@Z";
    is_point_inside :: (this: *GIM_TRIANGLE, point: btVector3, tri_normal: btVector3) -> bool #no_context {
        return is_point_inside(this, *point, *tri_normal);
    }

    //! Bidireccional ray collision
    ray_collision :: (this: *GIM_TRIANGLE, vPoint: *btVector3, vDir: *btVector3, pout: *btVector3, triangle_normal: *btVector3, tparam: *btScalar, tmax: btScalar = cast(float) 340282346638528859000000000000000000000.0) -> bool #cpp_method #foreign bullet3 "?ray_collision@GIM_TRIANGLE@@QEAA_NAEBVbtVector3@@0AEAV2@1AEAMM@Z";
    ray_collision :: (this: *GIM_TRIANGLE, vPoint: btVector3, vDir: btVector3, pout: *btVector3, triangle_normal: *btVector3, tparam: *btScalar, tmax: btScalar = cast(float) 340282346638528859000000000000000000000.0) -> bool #no_context {
        return ray_collision(this, *vPoint, *vDir, pout, triangle_normal, tparam, tmax);
    }

    //! one direccion ray collision
    ray_collision_front_side :: (this: *GIM_TRIANGLE, vPoint: *btVector3, vDir: *btVector3, pout: *btVector3, triangle_normal: *btVector3, tparam: *btScalar, tmax: btScalar = cast(float) 340282346638528859000000000000000000000.0) -> bool #cpp_method #foreign bullet3 "?ray_collision_front_side@GIM_TRIANGLE@@QEAA_NAEBVbtVector3@@0AEAV2@1AEAMM@Z";
    ray_collision_front_side :: (this: *GIM_TRIANGLE, vPoint: btVector3, vDir: btVector3, pout: *btVector3, triangle_normal: *btVector3, tparam: *btScalar, tmax: btScalar = cast(float) 340282346638528859000000000000000000000.0) -> bool #no_context {
        return ray_collision_front_side(this, *vPoint, *vDir, pout, triangle_normal, tparam, tmax);
    }
}

//! A pairset array
gim_pair_set :: struct {
    #as using gim_array_: gim_array(GIM_PAIR);

    Constructor :: (this: *gim_pair_set) -> void #cpp_method #foreign bullet3 "??0gim_pair_set@@QEAA@XZ";

    push_pair :: (this: *gim_pair_set, index1: u32, index2: u32) -> void #cpp_method #foreign bullet3 "?push_pair@gim_pair_set@@QEAAXII@Z";

    push_pair_inv :: (this: *gim_pair_set, index1: u32, index2: u32) -> void #cpp_method #foreign bullet3 "?push_pair_inv@gim_pair_set@@QEAAXII@Z";
}

//! Prototype Base class for primitive classification
/*!
This class is a wrapper for primitive collections.
This tells relevant info for the Bounding Box set classes, which take care of space classification.
This class can manage Compound shapes and trimeshes, and if it is managing trimesh then the  Hierarchy Bounding Box classes will take advantage of primitive Vs Box overlapping tests for getting optimal results and less Per Box compairisons.
*/
GIM_PRIMITIVE_MANAGER_PROTOTYPE :: struct {
    vtable: *GIM_PRIMITIVE_MANAGER_PROTOTYPE_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1GIM_PRIMITIVE_MANAGER_PROTOTYPE@@UEAA@XZ";
}
GIM_PRIMITIVE_MANAGER_PROTOTYPE_VTable :: struct #type_info_none {
    Destructor: (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    is_trimesh: (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE) -> bool #cpp_method;
    get_primitive_count: (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE) -> u32 #cpp_method;
    get_primitive_box: (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, prim_index: u32, primbox: *GIM_AABB) -> void #cpp_method;
    get_primitive_triangle: (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, prim_index: u32, triangle: *GIM_TRIANGLE) -> void #cpp_method;
}

GIM_PRIMITIVE_MANAGER_PROTOTYPE_Destructor :: inline (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

GIM_PRIMITIVE_MANAGER_PROTOTYPE_is_trimesh :: inline (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE) -> bool { return this.vtable.is_trimesh(this); }
GIM_PRIMITIVE_MANAGER_PROTOTYPE_get_primitive_count :: inline (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE) -> u32 { return this.vtable.get_primitive_count(this); }
GIM_PRIMITIVE_MANAGER_PROTOTYPE_get_primitive_box :: inline (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, prim_index: u32, primbox: *GIM_AABB) { this.vtable.get_primitive_box(this, prim_index, primbox); }
GIM_PRIMITIVE_MANAGER_PROTOTYPE_get_primitive_triangle :: inline (this: *GIM_PRIMITIVE_MANAGER_PROTOTYPE, prim_index: u32, triangle: *GIM_TRIANGLE) { this.vtable.get_primitive_triangle(this, prim_index, triangle); }



GIM_AABB_DATA :: struct {
    m_bound: GIM_AABB;
    m_data:  u32;
}

//! Node Structure for trees
GIM_BOX_TREE_NODE :: struct {
    m_bound:       GIM_AABB;
    m_left:        u32; //!< Left subtree
    m_right:       u32; //!< Right subtree
    m_escapeIndex: u32; //!< Scape index for traversing
    m_data:        u32; //!< primitive index if apply

    Constructor :: (this: *GIM_BOX_TREE_NODE) -> void #cpp_method #foreign bullet3 "??0GIM_BOX_TREE_NODE@@QEAA@XZ";

    is_leaf_node :: (this: *GIM_BOX_TREE_NODE) -> bool #cpp_method #foreign bullet3 "?is_leaf_node@GIM_BOX_TREE_NODE@@QEBA_NXZ";
}

//! Basic Box tree structure
GIM_BOX_TREE :: struct {
    m_num_nodes:  u32;
    m_node_array: gim_array(GIM_BOX_TREE_NODE);

    _sort_and_calc_splitting_index :: (this: *GIM_BOX_TREE, primitive_boxes: *gim_array(GIM_AABB_DATA), startIndex: u32, endIndex: u32, splitAxis: u32) -> u32 #cpp_method #foreign bullet3 "?_sort_and_calc_splitting_index@GIM_BOX_TREE@@IEAAIAEAV?$gim_array@UGIM_AABB_DATA@@@@III@Z";

    _calc_splitting_axis :: (this: *GIM_BOX_TREE, primitive_boxes: *gim_array(GIM_AABB_DATA), startIndex: u32, endIndex: u32) -> u32 #cpp_method #foreign bullet3 "?_calc_splitting_axis@GIM_BOX_TREE@@IEAAIAEAV?$gim_array@UGIM_AABB_DATA@@@@II@Z";

    _build_sub_tree :: (this: *GIM_BOX_TREE, primitive_boxes: *gim_array(GIM_AABB_DATA), startIndex: u32, endIndex: u32) -> void #cpp_method #foreign bullet3 "?_build_sub_tree@GIM_BOX_TREE@@IEAAXAEAV?$gim_array@UGIM_AABB_DATA@@@@II@Z";

    Constructor :: (this: *GIM_BOX_TREE) -> void #cpp_method #foreign bullet3 "??0GIM_BOX_TREE@@QEAA@XZ";

    //! prototype functions for box tree management
    //!@{
    build_tree :: (this: *GIM_BOX_TREE, primitive_boxes: *gim_array(GIM_AABB_DATA)) -> void #cpp_method #foreign bullet3 "?build_tree@GIM_BOX_TREE@@QEAAXAEAV?$gim_array@UGIM_AABB_DATA@@@@@Z";

    clearNodes :: (this: *GIM_BOX_TREE) -> void #cpp_method #foreign bullet3 "?clearNodes@GIM_BOX_TREE@@QEAAXXZ";

    //! node count
    getNodeCount :: (this: *GIM_BOX_TREE) -> u32 #cpp_method #foreign bullet3 "?getNodeCount@GIM_BOX_TREE@@QEBAIXZ";

    //! tells if the node is a leaf
    isLeafNode :: (this: *GIM_BOX_TREE, nodeindex: u32) -> bool #cpp_method #foreign bullet3 "?isLeafNode@GIM_BOX_TREE@@QEBA_NI@Z";

    getNodeData :: (this: *GIM_BOX_TREE, nodeindex: u32) -> u32 #cpp_method #foreign bullet3 "?getNodeData@GIM_BOX_TREE@@QEBAII@Z";

    getNodeBound :: (this: *GIM_BOX_TREE, nodeindex: u32, bound: *GIM_AABB) -> void #cpp_method #foreign bullet3 "?getNodeBound@GIM_BOX_TREE@@QEBAXIAEAVGIM_AABB@@@Z";

    setNodeBound :: (this: *GIM_BOX_TREE, nodeindex: u32, bound: *GIM_AABB) -> void #cpp_method #foreign bullet3 "?setNodeBound@GIM_BOX_TREE@@QEAAXIAEBVGIM_AABB@@@Z";
    setNodeBound :: (this: *GIM_BOX_TREE, nodeindex: u32, bound: GIM_AABB) #no_context {
        setNodeBound(this, nodeindex, *bound);
    }

    getLeftNodeIndex :: (this: *GIM_BOX_TREE, nodeindex: u32) -> u32 #cpp_method #foreign bullet3 "?getLeftNodeIndex@GIM_BOX_TREE@@QEBAII@Z";

    getRightNodeIndex :: (this: *GIM_BOX_TREE, nodeindex: u32) -> u32 #cpp_method #foreign bullet3 "?getRightNodeIndex@GIM_BOX_TREE@@QEBAII@Z";

    getScapeNodeIndex :: (this: *GIM_BOX_TREE, nodeindex: u32) -> u32 #cpp_method #foreign bullet3 "?getScapeNodeIndex@GIM_BOX_TREE@@QEBAII@Z";
}

//! Generic Box Tree Template
/*!
This class offers an structure for managing a box tree of primitives.
Requires a Primitive prototype (like GIM_PRIMITIVE_MANAGER_PROTOTYPE ) and
a Box tree structure ( like GIM_BOX_TREE).
*/
GIM_BOX_TREE_TEMPLATE_SET :: struct(_GIM_PRIMITIVE_MANAGER_PROTOTYPE: Type, _GIM_BOX_TREE_PROTOTYPE: Type) {
    m_primitive_manager: _GIM_PRIMITIVE_MANAGER_PROTOTYPE;
    m_box_tree:          _GIM_BOX_TREE_PROTOTYPE;
}

//! Class for Box Tree Sets
/*!
this has the GIM_BOX_TREE implementation for bounding boxes.
*/
GIM_BOX_TREE_SET :: struct(_GIM_PRIMITIVE_MANAGER_PROTOTYPE: Type) {
    #as gim_box_tree_template_set: GIM_BOX_TREE_TEMPLATE_SET(_GIM_PRIMITIVE_MANAGER_PROTOTYPE, GIM_BOX_TREE); // jai: no "using" to avoid name-clashes
}

/// GIM_BOX_SET collision methods
GIM_TREE_TREE_COLLIDER :: struct(BOX_SET_CLASS0: Type, BOX_SET_CLASS1: Type) {
    m_collision_pairs:  *gim_pair_set;
    m_boxset0:          *BOX_SET_CLASS0;
    m_boxset1:          *BOX_SET_CLASS1;
    current_node0:      u32;
    current_node1:      u32;
    node0_is_leaf:      bool;
    node1_is_leaf:      bool;
    t0_is_trimesh:      bool;
    t1_is_trimesh:      bool;
    node0_has_triangle: bool;
    node1_has_triangle: bool;
    m_box0:             GIM_AABB;
    m_box1:             GIM_AABB;
    trans_cache_1to0:   GIM_BOX_BOX_TRANSFORM_CACHE;
    trans_cache_0to1:   btTransform;
    m_tri0:             GIM_TRIANGLE;
    m_tri0_plane:       btVector4;
    m_tri1:             GIM_TRIANGLE;
    m_tri1_plane:       btVector4;
}

gim_contact_array :: struct {
    #as using gim_array_: gim_array(GIM_CONTACT);

    Constructor :: (this: *gim_contact_array) -> void #cpp_method #foreign bullet3 "??0gim_contact_array@@QEAA@XZ";

    push_contact :: (this: *gim_contact_array, point: *btVector3, normal: *btVector3, depth: btScalar, feature1: u32, feature2: u32) -> void #cpp_method #foreign bullet3 "?push_contact@gim_contact_array@@QEAAXAEBVbtVector3@@0MII@Z";
    push_contact :: (this: *gim_contact_array, point: btVector3, normal: btVector3, depth: btScalar, feature1: u32, feature2: u32) #no_context {
        push_contact(this, *point, *normal, depth, feature1, feature2);
    }

    push_triangle_contacts :: (this: *gim_contact_array, tricontact: *GIM_TRIANGLE_CONTACT_DATA, feature1: u32, feature2: u32) -> void #cpp_method #foreign bullet3 "?push_triangle_contacts@gim_contact_array@@QEAAXAEBUGIM_TRIANGLE_CONTACT_DATA@@II@Z";
    push_triangle_contacts :: (this: *gim_contact_array, tricontact: GIM_TRIANGLE_CONTACT_DATA, feature1: u32, feature2: u32) #no_context {
        push_triangle_contacts(this, *tricontact, feature1, feature2);
    }

    merge_contacts :: (this: *gim_contact_array, contacts: *gim_contact_array, normal_contact_average := true) -> void #cpp_method #foreign bullet3 "?merge_contacts@gim_contact_array@@QEAAXAEBV1@_N@Z";
    merge_contacts :: (this: *gim_contact_array, contacts: gim_contact_array, normal_contact_average := true) #no_context {
        merge_contacts(this, *contacts, normal_contact_average);
    }
    merge_contacts_unique :: (this: *gim_contact_array, contacts: *gim_contact_array) -> void #cpp_method #foreign bullet3 "?merge_contacts_unique@gim_contact_array@@QEAAXAEBV1@@Z";
    merge_contacts_unique :: (this: *gim_contact_array, contacts: gim_contact_array) #no_context {
        merge_contacts_unique(this, *contacts);
    }
}

GIM_HASH_TABLE_NODE :: struct(T: Type) {
    m_key:  u32;
    m_data: T;
}

///Macro for getting the key
GIM_HASH_NODE_GET_KEY :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///Macro for comparing the key and the element
GIM_HASH_NODE_CMP_KEY_MACRO :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

///Macro for comparing Hash nodes
GIM_HASH_NODE_CMP_MACRO :: struct {
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

//! A compact hash table implementation
/*!
A memory aligned compact hash table that coud be treated as an array.
It could be a simple sorted array without the overhead of the hash key bucked, or could
be a formely hash table with an array of keys.
You can use switch_to_hashtable() and switch_to_sorted_array for saving space or increase speed.
</br>

<ul>
<li> if node_size = 0, then this container becomes a simple sorted array allocator. reserve_size is used for reserve memory in m_nodes.
When the array size reaches the size equivalent to 'min_hash_table_size', then it becomes a hash table by calling check_for_switching_to_hashtable.
<li> If node_size != 0, then this container becomes a hash table for ever
</ul>

*/
gim_hash_table :: struct(T: Type) {
    _node_type :: GIM_HASH_TABLE_NODE(T);

    //!The nodes
    //array< _node_type, SuperAllocator<_node_type> > m_nodes;
    m_nodes:               gim_array(_node_type);

    //SuperBufferedArray< _node_type > m_nodes;
    m_sorted:              bool;

    m_hash_table:          *u32; //!<
    m_table_size:          u32; //!<
    m_node_size:           u32; //!<
    m_min_hash_table_size: u32;
}

btGjkCollisionDescription :: struct {
    vtable: *btGjkCollisionDescription_VTable;
    m_firstDir:               btVector3;
    m_maxGjkIterations:       s32;
    m_maximumDistanceSquared: btScalar;
    m_gjkRelError2:           btScalar;
}
btGjkCollisionDescription_VTable :: struct #type_info_none {
    Destructor: (this: *btGjkCollisionDescription, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
btGjkCollisionDescription_Destructor :: inline (this: *btGjkCollisionDescription, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



btGjkEpaSolver3 :: struct {
    sResults :: struct {
        eStatus :: enum s32 {
            Separated   :: 0;
            Penetrating :: 1;
            GJK_Failed  :: 2;
            EPA_Failed  :: 3;
        }

        status:    eStatus;
        witnesses: [2] btVector3;
        normal:    btVector3;
        distance:  btScalar;
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

// Shorthands
U :: u32;
U1 :: u8;

// MinkowskiDiff
MinkowskiDiff :: struct(btConvexTemplate: Type) {
    m_convexAPtr:   *btConvexTemplate;
    m_convexBPtr:   *btConvexTemplate;

    m_toshape1:     btMatrix3x3;
    m_toshape0:     btTransform;

    m_enableMargin: bool;
}

eGjkStatus :: enum s32 {
    Valid  :: 0;
    Inside :: 1;
    Failed :: 2;

    eGjkValid  :: Valid;
    eGjkInside :: Inside;
    eGjkFailed :: Failed;
}

// GJK
GJK :: struct(btConvexTemplate: Type) {
    /* Types		*/
    sSV :: struct {
        d: btVector3;
        w: btVector3;
    }

    sSimplex :: struct {
        c:    [4] *sSV;
        p:    [4] btScalar;
        rank: U;
    }

    /* Fields		*/
    m_shape:     MinkowskiDiff(btConvexTemplate);
    m_ray:       btVector3;
    m_distance:  btScalar;
    m_simplices: [2] sSimplex;
    m_store:     [4] sSV;
    m_free:      [4] *sSV;
    m_nfree:     U;
    m_current:   U;
    m_simplex:   *sSimplex;
    m_status:    eGjkStatus;
}

eEpaStatus :: enum s32 {
    Valid           :: 0;
    Touching        :: 1;
    Degenerated     :: 2;
    NonConvex       :: 3;
    InvalidHull     :: 4;
    OutOfFaces      :: 5;
    OutOfVertices   :: 6;
    AccuraryReached :: 7;
    FallBack        :: 8;
    Failed          :: 9;

    eEpaValid           :: Valid;
    eEpaTouching        :: Touching;
    eEpaDegenerated     :: Degenerated;
    eEpaNonConvex       :: NonConvex;
    eEpaInvalidHull     :: InvalidHull;
    eEpaOutOfFaces      :: OutOfFaces;
    eEpaOutOfVertices   :: OutOfVertices;
    eEpaAccuraryReached :: AccuraryReached;
    eEpaFallBack        :: FallBack;
    eEpaFailed          :: Failed;
}

// EPA
EPA :: struct(btConvexTemplate: Type) {
    /* Types		*/
    sFace :: struct {
        n:    btVector3;
        d:    btScalar;

        f:    [3] *sFace;
        l:    [2] *sFace;
        e:    [3] U1;
        pass: U1;
    }

    sList :: struct {
        root:  *sFace;
        count: U;
    }

    sHorizon :: struct {
        cf: *sFace;
        ff: *sFace;
        nf: U;
    }

    /* Fields		*/
    m_status:   eEpaStatus;
    m_result:   GJK(UnknownTypePlaceholder /* btConvexTemplate */);
    m_normal:   btVector3;
    m_depth:    btScalar;

    m_fc_store: [128] sFace;
    m_nextsv:   U;
    m_hull:     sList;
    m_stock:    sList;
}

/// btConvexCast is an interface for Casting
btConvexCast :: struct {
    vtable: *btConvexCast_VTable;
    ///RayResult stores the closest result
    /// alternatively, add a callback method to decide about closest/all results
    CastResult :: struct {
        vtable: *CastResult_VTable;
        Constructor :: (this: *CastResult) -> void #cpp_method #foreign bullet3 "??0CastResult@btConvexCast@@QEAA@XZ";

        m_hitTransformA:               btTransform;
        m_hitTransformB:               btTransform;
        m_normal:                      btVector3;
        m_hitPoint:                    btVector3;
        m_fraction:                    btScalar; //input and output
        m_debugDrawer:                 *btIDebugDraw;
        m_allowedPenetration:          btScalar;

        m_subSimplexCastMaxIterations: s32;
        m_subSimplexCastEpsilon:       btScalar;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
        // or need to create a vtable yourself.

        //virtual bool	addRayResult(const btVector3& normal,btScalar	fraction) = 0;
        virtual_DebugDraw :: (this: *CastResult, fraction: btScalar) -> void #cpp_method #foreign bullet3 "?DebugDraw@CastResult@btConvexCast@@UEAAXM@Z";
        virtual_drawCoordSystem :: (this: *CastResult, trans: *btTransform) -> void #cpp_method #foreign bullet3 "?drawCoordSystem@CastResult@btConvexCast@@UEAAXAEBVbtTransform@@@Z";
        virtual_reportFailure :: (this: *CastResult, errNo: s32, numIterations: s32) -> void #cpp_method #foreign bullet3 "?reportFailure@CastResult@btConvexCast@@UEAAXHH@Z";

        virtual_Destructor :: (this: *CastResult, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1CastResult@btConvexCast@@UEAA@XZ";
    }
    CastResult_VTable :: struct #type_info_none {
        DebugDraw: (this: *CastResult, fraction: btScalar) -> void #cpp_method;
        drawCoordSystem: (this: *CastResult, trans: *btTransform) -> void #cpp_method;
        reportFailure: (this: *CastResult, errNo: s32, numIterations: s32) -> void #cpp_method;

        Destructor: (this: *CastResult, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    CastResult_DebugDraw :: inline (this: *CastResult, fraction: btScalar) { this.vtable.DebugDraw(this, fraction); }
    CastResult_drawCoordSystem :: inline (this: *CastResult, trans: *btTransform) { this.vtable.drawCoordSystem(this, trans); }
    CastResult_reportFailure :: inline (this: *CastResult, errNo: s32, numIterations: s32) { this.vtable.reportFailure(this, errNo, numIterations); }

    CastResult_Destructor :: inline (this: *CastResult, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConvexCast, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexCast@@UEAA@XZ";
}
btConvexCast_VTable :: struct #type_info_none {
    Destructor: (this: *btConvexCast, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    calcTimeOfImpact: (this: *btConvexCast, fromA: *btTransform, toA: *btTransform, fromB: *btTransform, toB: *btTransform, result: *btConvexCast.CastResult) -> bool #cpp_method;
}

btConvexCast_Destructor :: inline (this: *btConvexCast, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btConvexCast_calcTimeOfImpact :: inline (this: *btConvexCast, fromA: *btTransform, toA: *btTransform, fromB: *btTransform, toB: *btTransform, result: *btConvexCast.CastResult) -> bool { return this.vtable.calcTimeOfImpact(this, fromA, toA, fromB, toB, result); }



/// btContinuousConvexCollision implements angular and linear time of impact for convex objects.
/// Based on Brian Mirtich's Conservative Advancement idea (PhD thesis).
/// Algorithm operates in worldspace, in order to keep in between motion globally consistent.
/// It uses GJK at the moment. Future improvement would use minkowski sum / supporting vertex, merging innerloops
btContinuousConvexCollision :: struct {
    #as using btconvexcast: btConvexCast;

    m_simplexSolver:          *btVoronoiSimplexSolver;
    m_penetrationDepthSolver: *btConvexPenetrationDepthSolver;
    m_convexA:                *btConvexShape;

    //second object is either a convex or a plane (code sharing)
    m_convexB1:               *btConvexShape;
    m_planeShape:             *btStaticPlaneShape;

    computeClosestPoints :: (this: *btContinuousConvexCollision, transA: *btTransform, transB: *btTransform, pointCollector: *btPointCollector) -> void #cpp_method #foreign bullet3 "?computeClosestPoints@btContinuousConvexCollision@@AEAAXAEBVbtTransform@@0AEAUbtPointCollector@@@Z";
    computeClosestPoints :: (this: *btContinuousConvexCollision, transA: btTransform, transB: btTransform, pointCollector: *btPointCollector) #no_context {
        computeClosestPoints(this, *transA, *transB, pointCollector);
    }

    Constructor :: (this: *btContinuousConvexCollision, shapeA: *btConvexShape, shapeB: *btConvexShape, simplexSolver: *btVoronoiSimplexSolver, penetrationDepthSolver: *btConvexPenetrationDepthSolver) -> void #cpp_method #foreign bullet3 "??0btContinuousConvexCollision@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@PEAVbtConvexPenetrationDepthSolver@@@Z";

    Constructor :: (this: *btContinuousConvexCollision, shapeA: *btConvexShape, plane: *btStaticPlaneShape) -> void #cpp_method #foreign bullet3 "??0btContinuousConvexCollision@@QEAA@PEBVbtConvexShape@@PEBVbtStaticPlaneShape@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_calcTimeOfImpact :: (this: *btContinuousConvexCollision, fromA: *btTransform, toA: *btTransform, fromB: *btTransform, toB: *btTransform, result: *btConvexCast.CastResult) -> bool #cpp_method #foreign bullet3 "?calcTimeOfImpact@btContinuousConvexCollision@@UEAA_NAEBVbtTransform@@000AEAUCastResult@btConvexCast@@@Z";
}

///ConvexPenetrationDepthSolver provides an interface for penetration depth calculation.
btConvexPenetrationDepthSolver :: struct {
    vtable: *btConvexPenetrationDepthSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btConvexPenetrationDepthSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConvexPenetrationDepthSolver@@UEAA@XZ";
}
btConvexPenetrationDepthSolver_VTable :: struct #type_info_none {
    Destructor: (this: *btConvexPenetrationDepthSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    calcPenDepth: (this: *btConvexPenetrationDepthSolver, simplexSolver: *btVoronoiSimplexSolver, convexA: *btConvexShape, convexB: *btConvexShape, transA: *btTransform, transB: *btTransform, v: *btVector3, pa: *btVector3, pb: *btVector3, debugDraw: *btIDebugDraw) -> bool #cpp_method;
}

btConvexPenetrationDepthSolver_Destructor :: inline (this: *btConvexPenetrationDepthSolver, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
btConvexPenetrationDepthSolver_calcPenDepth :: inline (this: *btConvexPenetrationDepthSolver, simplexSolver: *btVoronoiSimplexSolver, convexA: *btConvexShape, convexB: *btConvexShape, transA: *btTransform, transB: *btTransform, v: *btVector3, pa: *btVector3, pb: *btVector3, debugDraw: *btIDebugDraw) -> bool { return this.vtable.calcPenDepth(this, simplexSolver, convexA, convexB, transA, transB, v, pa, pb, debugDraw); }



///GjkConvexCast performs a raycast on a convex object using support mapping.
btGjkConvexCast :: struct {
    #as using btconvexcast: btConvexCast;

    m_simplexSolver: *btVoronoiSimplexSolver;
    m_convexA:       *btConvexShape;
    m_convexB:       *btConvexShape;

    Constructor :: (this: *btGjkConvexCast, convexA: *btConvexShape, convexB: *btConvexShape, simplexSolver: *btVoronoiSimplexSolver) -> void #cpp_method #foreign bullet3 "??0btGjkConvexCast@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    /// cast a convex against another convex object
    virtual_calcTimeOfImpact :: (this: *btGjkConvexCast, fromA: *btTransform, toA: *btTransform, fromB: *btTransform, toB: *btTransform, result: *btConvexCast.CastResult) -> bool #cpp_method #foreign bullet3 "?calcTimeOfImpact@btGjkConvexCast@@UEAA_NAEBVbtTransform@@000AEAUCastResult@btConvexCast@@@Z";
}

///EpaPenetrationDepthSolver uses the Expanding Polytope Algorithm to
///calculate the penetration depth between two convex shapes.
btGjkEpaPenetrationDepthSolver :: struct {
    #as using btconvexpenetrationdepthsolver: btConvexPenetrationDepthSolver;

    Constructor :: (this: *btGjkEpaPenetrationDepthSolver) -> void #cpp_method #foreign bullet3 "??0btGjkEpaPenetrationDepthSolver@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_calcPenDepth :: (this: *btGjkEpaPenetrationDepthSolver, simplexSolver: *btVoronoiSimplexSolver, pConvexA: *btConvexShape, pConvexB: *btConvexShape, transformA: *btTransform, transformB: *btTransform, v: *btVector3, wWitnessOnA: *btVector3, wWitnessOnB: *btVector3, debugDraw: *btIDebugDraw) -> bool #cpp_method #foreign bullet3 "?calcPenDepth@btGjkEpaPenetrationDepthSolver@@UEAA_NAEAVbtVoronoiSimplexSolver@@PEBVbtConvexShape@@1AEBVbtTransform@@2AEAVbtVector3@@33PEAVbtIDebugDraw@@@Z";
}

///MinkowskiPenetrationDepthSolver implements bruteforce penetration depth estimation.
///Implementation is based on sampling the depth using support mapping, and using GJK step to get the witness points.
btMinkowskiPenetrationDepthSolver :: struct {
    #as using btconvexpenetrationdepthsolver: btConvexPenetrationDepthSolver;

    getPenetrationDirections :: () -> *btVector3 #foreign bullet3 "?getPenetrationDirections@btMinkowskiPenetrationDepthSolver@@KAPEAVbtVector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_calcPenDepth :: (this: *btMinkowskiPenetrationDepthSolver, simplexSolver: *btVoronoiSimplexSolver, convexA: *btConvexShape, convexB: *btConvexShape, transA: *btTransform, transB: *btTransform, v: *btVector3, pa: *btVector3, pb: *btVector3, debugDraw: *btIDebugDraw) -> bool #cpp_method #foreign bullet3 "?calcPenDepth@btMinkowskiPenetrationDepthSolver@@UEAA_NAEAVbtVoronoiSimplexSolver@@PEBVbtConvexShape@@1AEBVbtTransform@@2AEAVbtVector3@@33PEAVbtIDebugDraw@@@Z";
}

//#define MPR_AVERAGE_CONTACT_POSITIONS
btMprCollisionDescription :: struct {
    vtable: *btMprCollisionDescription_VTable;
    m_firstDir:               btVector3;
    m_maxGjkIterations:       s32;
    m_maximumDistanceSquared: btScalar;
    m_gjkRelError2:           btScalar;
}
btMprCollisionDescription_VTable :: struct #type_info_none {
    Destructor: (this: *btMprCollisionDescription, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
btMprCollisionDescription_Destructor :: inline (this: *btMprCollisionDescription, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



btMprDistanceInfo :: struct {
    m_pointOnA:   btVector3;
    m_pointOnB:   btVector3;
    m_normalBtoA: btVector3;
    m_distance:   btScalar;
}

_btMprSupport_t :: struct {
    v:  btVector3; //!< Support point in minkowski sum
    v1: btVector3; //!< Support point in obj1
    v2: btVector3; //!< Support point in obj2
}

btMprSupport_t :: _btMprSupport_t;

_btMprSimplex_t :: struct {
    ps:   [4] btMprSupport_t;
    last: s32; //!< index of last added point
}

btMprSimplex_t :: _btMprSimplex_t;

btPointCollector :: struct {
    #as using result: btDiscreteCollisionDetectorInterface.Result;

    m_normalOnBInWorld: btVector3;
    m_pointInWorld:     btVector3;
    m_distance:         btScalar; //negative means penetration

    m_hasResult:        bool;

    Constructor :: (this: *btPointCollector) -> void #cpp_method #foreign bullet3 "??0btPointCollector@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_setShapeIdentifiersA :: (this: *btPointCollector, partId0: s32, index0: s32) -> void #cpp_method #foreign bullet3 "?setShapeIdentifiersA@btPointCollector@@UEAAXHH@Z";

    virtual_setShapeIdentifiersB :: (this: *btPointCollector, partId1: s32, index1: s32) -> void #cpp_method #foreign bullet3 "?setShapeIdentifiersB@btPointCollector@@UEAAXHH@Z";

    virtual_addContactPoint :: (this: *btPointCollector, normalOnBInWorld: *btVector3, pointInWorld: *btVector3, depth: btScalar) -> void #cpp_method #foreign bullet3 "?addContactPoint@btPointCollector@@UEAAXAEBVbtVector3@@0M@Z";
}

/// btSubsimplexConvexCast implements Gino van den Bergens' paper
///"Ray Casting against bteral Convex Objects with Application to Continuous Collision Detection"
/// GJK based Ray Cast, optimized version
/// Objects should not start in overlap, otherwise results are not defined.
btSubsimplexConvexCast :: struct {
    #as using btconvexcast: btConvexCast;

    m_simplexSolver: *btVoronoiSimplexSolver;
    m_convexA:       *btConvexShape;
    m_convexB:       *btConvexShape;

    Constructor :: (this: *btSubsimplexConvexCast, shapeA: *btConvexShape, shapeB: *btConvexShape, simplexSolver: *btVoronoiSimplexSolver) -> void #cpp_method #foreign bullet3 "??0btSubsimplexConvexCast@@QEAA@PEBVbtConvexShape@@0PEAVbtVoronoiSimplexSolver@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    //virtual ~btSubsimplexConvexCast();
    ///SimsimplexConvexCast calculateTimeOfImpact calculates the time of impact+normal for the linear cast (sweep) between two moving objects.
    ///Precondition is that objects should not penetration/overlap at the start from the interval. Overlap can be tested using btGjkPairDetector.
    virtual_calcTimeOfImpact :: (this: *btSubsimplexConvexCast, fromA: *btTransform, toA: *btTransform, fromB: *btTransform, toB: *btTransform, result: *btConvexCast.CastResult) -> bool #cpp_method #foreign bullet3 "?calcTimeOfImpact@btSubsimplexConvexCast@@UEAA_NAEBVbtTransform@@000AEAUCastResult@btConvexCast@@@Z";
}

btCharacterControllerInterface :: struct {
    #as using btactioninterface: btActionInterface;

    Constructor :: (this: *btCharacterControllerInterface) -> void #cpp_method #foreign bullet3 "??0btCharacterControllerInterface@@QEAA@XZ";
    #place btactioninterface; btcharactercontrollerinterface_vtable: *btCharacterControllerInterface_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btCharacterControllerInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btCharacterControllerInterface@@UEAA@XZ";
}
btCharacterControllerInterface_VTable :: struct #type_info_none {
    using btactioninterface: btActionInterface_VTable;
    setWalkDirection: (this: *btCharacterControllerInterface, walkDirection: *btVector3) -> void #cpp_method;
    setVelocityForTimeInterval: (this: *btCharacterControllerInterface, velocity: *btVector3, timeInterval: btScalar) -> void #cpp_method;
    reset: (this: *btCharacterControllerInterface, collisionWorld: *btCollisionWorld) -> void #cpp_method;
    warp: (this: *btCharacterControllerInterface, origin: *btVector3) -> void #cpp_method;

    preStep: (this: *btCharacterControllerInterface, collisionWorld: *btCollisionWorld) -> void #cpp_method;
    playerStep: (this: *btCharacterControllerInterface, collisionWorld: *btCollisionWorld, dt: btScalar) -> void #cpp_method;
    canJump: (this: *btCharacterControllerInterface) -> bool #cpp_method;
    jump: (this: *btCharacterControllerInterface, dir: *btVector3) -> void #cpp_method;
    jump :: (this: *btCharacterControllerInterface, dir: btVector3 = btVector3.{0, 0, 0}) #no_context {
        jump(this, *dir);
    }

    onGround: (this: *btCharacterControllerInterface) -> bool #cpp_method;
    setUpInterpolate: (this: *btCharacterControllerInterface, value: bool) -> void #cpp_method;
}

btCharacterControllerInterface_setWalkDirection :: inline (this: *btCharacterControllerInterface, walkDirection: *btVector3) { this.btcharactercontrollerinterface_vtable.setWalkDirection(this, walkDirection); }
btCharacterControllerInterface_setVelocityForTimeInterval :: inline (this: *btCharacterControllerInterface, velocity: *btVector3, timeInterval: btScalar) { this.btcharactercontrollerinterface_vtable.setVelocityForTimeInterval(this, velocity, timeInterval); }
btCharacterControllerInterface_reset :: inline (this: *btCharacterControllerInterface, collisionWorld: *btCollisionWorld) { this.btcharactercontrollerinterface_vtable.reset(this, collisionWorld); }
btCharacterControllerInterface_warp :: inline (this: *btCharacterControllerInterface, origin: *btVector3) { this.btcharactercontrollerinterface_vtable.warp(this, origin); }

btCharacterControllerInterface_preStep :: inline (this: *btCharacterControllerInterface, collisionWorld: *btCollisionWorld) { this.btcharactercontrollerinterface_vtable.preStep(this, collisionWorld); }
btCharacterControllerInterface_playerStep :: inline (this: *btCharacterControllerInterface, collisionWorld: *btCollisionWorld, dt: btScalar) { this.btcharactercontrollerinterface_vtable.playerStep(this, collisionWorld, dt); }
btCharacterControllerInterface_canJump :: inline (this: *btCharacterControllerInterface) -> bool { return this.btcharactercontrollerinterface_vtable.canJump(this); }
btCharacterControllerInterface_jump :: inline (this: *btCharacterControllerInterface, dir: *btVector3) { this.btcharactercontrollerinterface_vtable.jump(this, dir); }

btCharacterControllerInterface_onGround :: inline (this: *btCharacterControllerInterface) -> bool { return this.btcharactercontrollerinterface_vtable.onGround(this); }
btCharacterControllerInterface_setUpInterpolate :: inline (this: *btCharacterControllerInterface, value: bool) { this.btcharactercontrollerinterface_vtable.setUpInterpolate(this, value); }

vtable :: (obj: *btCharacterControllerInterface) -> *btCharacterControllerInterface_VTable { return obj.btcharactercontrollerinterface_vtable; }


///btKinematicCharacterController is an object that supports a sliding motion in a world.
///It uses a ghost object and convex sweep test to test for upcoming collisions. This is combined with discrete collision detection to recover from penetrations.
///Interaction between btKinematicCharacterController and dynamic rigid bodies needs to be explicity implemented by the user.
btKinematicCharacterController :: struct {
    #as using btcharactercontrollerinterface: btCharacterControllerInterface;

    m_halfHeight:              btScalar;

    m_ghostObject:             *btPairCachingGhostObject;
    m_convexShape:             *btConvexShape; //is also in m_ghostObject, but it needs to be convex, so we store it here to avoid upcast

    m_maxPenetrationDepth:     btScalar;
    m_verticalVelocity:        btScalar;
    m_verticalOffset:          btScalar;
    m_fallSpeed:               btScalar;
    m_jumpSpeed:               btScalar;
    m_SetjumpSpeed:            btScalar;
    m_maxJumpHeight:           btScalar;
    m_maxSlopeRadians:         btScalar; // Slope angle that is set (used for returning the exact value)
    m_maxSlopeCosine:          btScalar; // Cosine equivalent of m_maxSlopeRadians (calculated once when set, for optimization)
    m_gravity:                 btScalar;

    m_turnAngle:               btScalar;

    m_stepHeight:              btScalar;

    m_addedMargin:             btScalar; //@todo: remove this and fix the code

    ///this is the desired walk direction, set by the user
    m_walkDirection:           btVector3;
    m_normalizedDirection:     btVector3;
    m_AngVel:                  btVector3;

    m_jumpPosition:            btVector3;

    //some internal variables
    m_currentPosition:         btVector3;
    m_currentStepOffset:       btScalar;
    m_targetPosition:          btVector3;

    m_currentOrientation:      btQuaternion;
    m_targetOrientation:       btQuaternion;

    ///keep track of the contact manifolds
    m_manifoldArray:           btManifoldArray;

    m_touchingContact:         bool;
    m_touchingNormal:          btVector3;

    m_linearDamping:           btScalar;
    m_angularDamping:          btScalar;

    m_wasOnGround:             bool;
    m_wasJumping:              bool;
    m_useGhostObjectSweepTest: bool;
    m_useWalkDirection:        bool;
    m_velocityTimeInterval:    btScalar;
    m_up:                      btVector3;
    m_jumpAxis:                btVector3;

    getUpAxisDirections :: () -> *btVector3 #foreign bullet3 "?getUpAxisDirections@btKinematicCharacterController@@KAPEAVbtVector3@@XZ";
    m_interpolateUp:           bool;
    full_drop:                 bool;
    bounce_fix:                bool;

    computeReflectionDirection :: (this: *btKinematicCharacterController, direction: *btVector3, normal: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?computeReflectionDirection@btKinematicCharacterController@@IEAA?AVbtVector3@@AEBV2@0@Z";
    computeReflectionDirection :: (this: *btKinematicCharacterController, direction: btVector3, normal: btVector3) -> btVector3 #no_context {
        return computeReflectionDirection(this, *direction, *normal);
    }
    parallelComponent :: (this: *btKinematicCharacterController, direction: *btVector3, normal: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?parallelComponent@btKinematicCharacterController@@IEAA?AVbtVector3@@AEBV2@0@Z";
    parallelComponent :: (this: *btKinematicCharacterController, direction: btVector3, normal: btVector3) -> btVector3 #no_context {
        return parallelComponent(this, *direction, *normal);
    }
    perpindicularComponent :: (this: *btKinematicCharacterController, direction: *btVector3, normal: *btVector3) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?perpindicularComponent@btKinematicCharacterController@@IEAA?AVbtVector3@@AEBV2@0@Z";
    perpindicularComponent :: (this: *btKinematicCharacterController, direction: btVector3, normal: btVector3) -> btVector3 #no_context {
        return perpindicularComponent(this, *direction, *normal);
    }

    recoverFromPenetration :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld) -> bool #cpp_method #foreign bullet3 "?recoverFromPenetration@btKinematicCharacterController@@IEAA_NPEAVbtCollisionWorld@@@Z";
    stepUp :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?stepUp@btKinematicCharacterController@@IEAAXPEAVbtCollisionWorld@@@Z";
    updateTargetPositionBasedOnCollision :: (this: *btKinematicCharacterController, hit_normal: *btVector3, tangentMag: btScalar, normalMag: btScalar) -> void #cpp_method #foreign bullet3 "?updateTargetPositionBasedOnCollision@btKinematicCharacterController@@IEAAXAEBVbtVector3@@MM@Z";
    updateTargetPositionBasedOnCollision :: (this: *btKinematicCharacterController, hit_normal: btVector3, tangentMag: btScalar, normalMag: btScalar) #no_context {
        updateTargetPositionBasedOnCollision(this, *hit_normal, tangentMag, normalMag);
    }
    stepForwardAndStrafe :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld, walkMove: *btVector3) -> void #cpp_method #foreign bullet3 "?stepForwardAndStrafe@btKinematicCharacterController@@IEAAXPEAVbtCollisionWorld@@AEBVbtVector3@@@Z";
    stepForwardAndStrafe :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld, walkMove: btVector3) #no_context {
        stepForwardAndStrafe(this, collisionWorld, *walkMove);
    }
    stepDown :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld, dt: btScalar) -> void #cpp_method #foreign bullet3 "?stepDown@btKinematicCharacterController@@IEAAXPEAVbtCollisionWorld@@M@Z";

    setUpVector :: (this: *btKinematicCharacterController, up: *btVector3) -> void #cpp_method #foreign bullet3 "?setUpVector@btKinematicCharacterController@@IEAAXAEBVbtVector3@@@Z";
    setUpVector :: (this: *btKinematicCharacterController, up: btVector3) #no_context {
        setUpVector(this, *up);
    }

    getRotation :: (this: *btKinematicCharacterController, v0: *btVector3, v1: *btVector3) -> btQuaternion #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getRotation@btKinematicCharacterController@@IEBA?AVbtQuaternion@@AEAVbtVector3@@0@Z";

    Constructor :: (this: *btKinematicCharacterController, ghostObject: *btPairCachingGhostObject, convexShape: *btConvexShape, stepHeight: btScalar, up: *btVector3) -> void #cpp_method #foreign bullet3 "??0btKinematicCharacterController@@QEAA@PEAVbtPairCachingGhostObject@@PEAVbtConvexShape@@MAEBVbtVector3@@@Z";
    Constructor :: (this: *btKinematicCharacterController, ghostObject: *btPairCachingGhostObject, convexShape: *btConvexShape, stepHeight: btScalar, up: btVector3 = btVector3.{1.0, 0.0, 0.0}) #no_context {
        Constructor(this, ghostObject, convexShape, stepHeight, *up);
    }

    setUp :: (this: *btKinematicCharacterController, up: *btVector3) -> void #cpp_method #foreign bullet3 "?setUp@btKinematicCharacterController@@QEAAXAEBVbtVector3@@@Z";
    setUp :: (this: *btKinematicCharacterController, up: btVector3) #no_context {
        setUp(this, *up);
    }

    getUp :: (this: *btKinematicCharacterController) -> *btVector3 #cpp_method #foreign bullet3 "?getUp@btKinematicCharacterController@@QEAAAEBVbtVector3@@XZ";

    setLinearDamping :: (this: *btKinematicCharacterController, d: btScalar) -> void #cpp_method #foreign bullet3 "?setLinearDamping@btKinematicCharacterController@@QEAAXM@Z";
    getLinearDamping :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getLinearDamping@btKinematicCharacterController@@QEBAMXZ";
    setAngularDamping :: (this: *btKinematicCharacterController, d: btScalar) -> void #cpp_method #foreign bullet3 "?setAngularDamping@btKinematicCharacterController@@QEAAXM@Z";
    getAngularDamping :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getAngularDamping@btKinematicCharacterController@@QEBAMXZ";

    setStepHeight :: (this: *btKinematicCharacterController, h: btScalar) -> void #cpp_method #foreign bullet3 "?setStepHeight@btKinematicCharacterController@@QEAAXM@Z";
    getStepHeight :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getStepHeight@btKinematicCharacterController@@QEBAMXZ";
    setFallSpeed :: (this: *btKinematicCharacterController, fallSpeed: btScalar) -> void #cpp_method #foreign bullet3 "?setFallSpeed@btKinematicCharacterController@@QEAAXM@Z";
    getFallSpeed :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getFallSpeed@btKinematicCharacterController@@QEBAMXZ";
    setJumpSpeed :: (this: *btKinematicCharacterController, jumpSpeed: btScalar) -> void #cpp_method #foreign bullet3 "?setJumpSpeed@btKinematicCharacterController@@QEAAXM@Z";
    getJumpSpeed :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getJumpSpeed@btKinematicCharacterController@@QEBAMXZ";
    setMaxJumpHeight :: (this: *btKinematicCharacterController, maxJumpHeight: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxJumpHeight@btKinematicCharacterController@@QEAAXM@Z";

    applyImpulse :: (this: *btKinematicCharacterController, v: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btKinematicCharacterController@@QEAAXAEBVbtVector3@@@Z";
    applyImpulse :: (this: *btKinematicCharacterController, v: btVector3) #no_context {
        applyImpulse(this, *v);
    }

    setGravity :: (this: *btKinematicCharacterController, gravity: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btKinematicCharacterController@@QEAAXAEBVbtVector3@@@Z";
    setGravity :: (this: *btKinematicCharacterController, gravity: btVector3) #no_context {
        setGravity(this, *gravity);
    }
    getGravity :: (this: *btKinematicCharacterController) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getGravity@btKinematicCharacterController@@QEBA?AVbtVector3@@XZ";

    /// The max slope determines the maximum angle that the controller can walk up.
    /// The slope angle is measured in radians.
    setMaxSlope :: (this: *btKinematicCharacterController, slopeRadians: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxSlope@btKinematicCharacterController@@QEAAXM@Z";
    getMaxSlope :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getMaxSlope@btKinematicCharacterController@@QEBAMXZ";

    setMaxPenetrationDepth :: (this: *btKinematicCharacterController, d: btScalar) -> void #cpp_method #foreign bullet3 "?setMaxPenetrationDepth@btKinematicCharacterController@@QEAAXM@Z";
    getMaxPenetrationDepth :: (this: *btKinematicCharacterController) -> btScalar #cpp_method #foreign bullet3 "?getMaxPenetrationDepth@btKinematicCharacterController@@QEBAMXZ";

    getGhostObject :: (this: *btKinematicCharacterController) -> *btPairCachingGhostObject #cpp_method #foreign bullet3 "?getGhostObject@btKinematicCharacterController@@QEAAPEAVbtPairCachingGhostObject@@XZ";
    setUseGhostSweepTest :: (this: *btKinematicCharacterController, useGhostObjectSweepTest: bool) -> void #cpp_method #foreign bullet3 "?setUseGhostSweepTest@btKinematicCharacterController@@QEAAX_N@Z";
    #place btcharactercontrollerinterface; btkinematiccharactercontroller_vtable: *btKinematicCharacterController_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_needsCollision :: (this: *btKinematicCharacterController, body0: *btCollisionObject, body1: *btCollisionObject) -> bool #cpp_method #foreign bullet3 "?needsCollision@btKinematicCharacterController@@MEAA_NPEBVbtCollisionObject@@0@Z";

    virtual_Destructor :: (this: *btKinematicCharacterController, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btKinematicCharacterController@@UEAA@XZ";

    ///btActionInterface interface
    virtual_updateAction :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld, deltaTime: btScalar) -> void #cpp_method #foreign bullet3 "?updateAction@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@M@Z";

    ///btActionInterface interface
    virtual_debugDraw :: (this: *btKinematicCharacterController, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btKinematicCharacterController@@UEAAXPEAVbtIDebugDraw@@@Z";

    /// This should probably be called setPositionIncrementPerSimulatorStep.
    /// This is neither a direction nor a velocity, but the amount to
    ///	increment the position each simulation iteration, regardless
    ///	of dt.
    /// This call will reset any velocity set by setVelocityForTimeInterval().
    virtual_setWalkDirection :: (this: *btKinematicCharacterController, walkDirection: *btVector3) -> void #cpp_method #foreign bullet3 "?setWalkDirection@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z";

    /// Caller provides a velocity with which the character should move for
    ///	the given time period.  After the time period, velocity is reset
    ///	to zero.
    /// This call will reset any walk direction set by setWalkDirection().
    /// Negative time intervals will result in no motion.
    virtual_setVelocityForTimeInterval :: (this: *btKinematicCharacterController, velocity: *btVector3, timeInterval: btScalar) -> void #cpp_method #foreign bullet3 "?setVelocityForTimeInterval@btKinematicCharacterController@@UEAAXAEBVbtVector3@@M@Z";

    virtual_setAngularVelocity :: (this: *btKinematicCharacterController, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?setAngularVelocity@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z";
    virtual_getAngularVelocity :: (this: *btKinematicCharacterController) -> *btVector3 #cpp_method #foreign bullet3 "?getAngularVelocity@btKinematicCharacterController@@UEBAAEBVbtVector3@@XZ";

    virtual_setLinearVelocity :: (this: *btKinematicCharacterController, velocity: *btVector3) -> void #cpp_method #foreign bullet3 "?setLinearVelocity@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z";
    virtual_getLinearVelocity :: (this: *btKinematicCharacterController) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getLinearVelocity@btKinematicCharacterController@@UEBA?AVbtVector3@@XZ";

    virtual_reset :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?reset@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@@Z";
    virtual_warp :: (this: *btKinematicCharacterController, origin: *btVector3) -> void #cpp_method #foreign bullet3 "?warp@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z";

    virtual_preStep :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?preStep@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@@Z";
    virtual_playerStep :: (this: *btKinematicCharacterController, collisionWorld: *btCollisionWorld, dt: btScalar) -> void #cpp_method #foreign bullet3 "?playerStep@btKinematicCharacterController@@UEAAXPEAVbtCollisionWorld@@M@Z";

    virtual_canJump :: (this: *btKinematicCharacterController) -> bool #cpp_method #foreign bullet3 "?canJump@btKinematicCharacterController@@UEBA_NXZ";

    virtual_jump :: (this: *btKinematicCharacterController, v: *btVector3) -> void #cpp_method #foreign bullet3 "?jump@btKinematicCharacterController@@UEAAXAEBVbtVector3@@@Z";
    jump :: (this: *btKinematicCharacterController, v: btVector3 = btVector3.{0, 0, 0}) #no_context {
        jump(this, *v);
    }

    virtual_onGround :: (this: *btKinematicCharacterController) -> bool #cpp_method #foreign bullet3 "?onGround@btKinematicCharacterController@@UEBA_NXZ";
    virtual_setUpInterpolate :: (this: *btKinematicCharacterController, value: bool) -> void #cpp_method #foreign bullet3 "?setUpInterpolate@btKinematicCharacterController@@UEAAX_N@Z";
}
btKinematicCharacterController_VTable :: struct #type_info_none {
    using btcharactercontrollerinterface: btCharacterControllerInterface_VTable;
    needsCollision: (this: *btKinematicCharacterController, body0: *btCollisionObject, body1: *btCollisionObject) -> bool #cpp_method;

    setAngularVelocity: (this: *btKinematicCharacterController, velocity: *btVector3) -> void #cpp_method;
    getAngularVelocity: (this: *btKinematicCharacterController) -> *btVector3 #cpp_method;

    setLinearVelocity: (this: *btKinematicCharacterController, velocity: *btVector3) -> void #cpp_method;
    getLinearVelocity: (this: *btKinematicCharacterController) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;
}

btKinematicCharacterController_needsCollision :: inline (this: *btKinematicCharacterController, body0: *btCollisionObject, body1: *btCollisionObject) -> bool { return this.btkinematiccharactercontroller_vtable.needsCollision(this, body0, body1); }

btKinematicCharacterController_setAngularVelocity :: inline (this: *btKinematicCharacterController, velocity: *btVector3) { this.btkinematiccharactercontroller_vtable.setAngularVelocity(this, velocity); }
btKinematicCharacterController_getAngularVelocity :: inline (this: *btKinematicCharacterController) -> *btVector3 { return this.btkinematiccharactercontroller_vtable.getAngularVelocity(this); }

btKinematicCharacterController_setLinearVelocity :: inline (this: *btKinematicCharacterController, velocity: *btVector3) { this.btkinematiccharactercontroller_vtable.setLinearVelocity(this, velocity); }
btKinematicCharacterController_getLinearVelocity :: inline (this: *btKinematicCharacterController) -> btVector3 { return this.btkinematiccharactercontroller_vtable.getLinearVelocity(this); }

vtable :: (obj: *btKinematicCharacterController) -> *btKinematicCharacterController_VTable { return obj.btkinematiccharactercontroller_vtable; }



btBatchedConstraints :: struct {
    BatchingMethod :: enum s32 {
        SPATIAL_GRID_2D :: 0;
        SPATIAL_GRID_3D :: 1;
        COUNT           :: 2;

        BATCHING_METHOD_SPATIAL_GRID_2D :: SPATIAL_GRID_2D;
        BATCHING_METHOD_SPATIAL_GRID_3D :: SPATIAL_GRID_3D;
        BATCHING_METHOD_COUNT           :: COUNT;
    }

    Range :: struct {
        begin: s32;
        end:   s32;

        Constructor :: (this: *Range) -> void #cpp_method #foreign bullet3 "??0Range@btBatchedConstraints@@QEAA@XZ";
        Constructor :: (this: *Range, _beg: s32, _end: s32) -> void #cpp_method #foreign bullet3 "??0Range@btBatchedConstraints@@QEAA@HH@Z";
    }

    m_constraintIndices: btAlignedObjectArray(s32);
    m_batches:           btAlignedObjectArray(Range); // each batch is a range of indices in the m_constraintIndices array
    m_phases:            btAlignedObjectArray(Range); // each phase is range of indices in the m_batches array
    m_phaseGrainSize:    btAlignedObjectArray(u8); // max grain size for each phase
    m_phaseOrder:        btAlignedObjectArray(s32); // phases can be done in any order, so we can randomize the order here
    m_debugDrawer:       *btIDebugDraw;

    Constructor :: (this: *btBatchedConstraints) -> void #cpp_method #foreign bullet3 "??0btBatchedConstraints@@QEAA@XZ";
    setup :: (this: *btBatchedConstraints, constraints: *btConstraintArray, bodies: *btAlignedObjectArray(btSolverBody), batchingMethod: BatchingMethod, minBatchSize: s32, maxBatchSize: s32, scratchMemory: *btAlignedObjectArray(u8)) -> void #cpp_method #foreign bullet3 "?setup@btBatchedConstraints@@QEAAXPEAV?$btAlignedObjectArray@UbtSolverConstraint@@@@AEBV?$btAlignedObjectArray@UbtSolverBody@@@@W4BatchingMethod@1@HHPEAV?$btAlignedObjectArray@D@@@Z";
    setup :: (this: *btBatchedConstraints, constraints: *btConstraintArray, bodies: btAlignedObjectArray(btSolverBody), batchingMethod: BatchingMethod, minBatchSize: s32, maxBatchSize: s32, scratchMemory: *btAlignedObjectArray(u8)) #no_context {
        setup(this, constraints, *bodies, batchingMethod, minBatchSize, maxBatchSize, scratchMemory);
    }

    validate :: (this: *btBatchedConstraints, constraints: *btConstraintArray, bodies: *btAlignedObjectArray(btSolverBody)) -> bool #cpp_method #foreign bullet3 "?validate@btBatchedConstraints@@QEBA_NPEAV?$btAlignedObjectArray@UbtSolverConstraint@@@@AEBV?$btAlignedObjectArray@UbtSolverBody@@@@@Z";
    validate :: (this: *btBatchedConstraints, constraints: *btConstraintArray, bodies: btAlignedObjectArray(btSolverBody)) -> bool #no_context {
        return validate(this, constraints, *bodies);
    }
}

///btContactConstraint can be automatically created to solve contact constraints using the unified btTypedConstraint interface
btContactConstraint :: struct {
    #as using bttypedconstraint: btTypedConstraint;

    m_contactManifold: btPersistentManifold;

    Constructor :: (this: *btContactConstraint, contactManifold: *btPersistentManifold, rbA: *btRigidBody, rbB: *btRigidBody) -> void #cpp_method #foreign bullet3 "??0btContactConstraint@@IEAA@PEAVbtPersistentManifold@@AEAVbtRigidBody@@1@Z";

    setContactManifold :: (this: *btContactConstraint, contactManifold: *btPersistentManifold) -> void #cpp_method #foreign bullet3 "?setContactManifold@btContactConstraint@@QEAAXPEAVbtPersistentManifold@@@Z";

    getContactManifold :: (this: *btContactConstraint) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getContactManifold@btContactConstraint@@QEAAPEAVbtPersistentManifold@@XZ";

    getContactManifold_1 :: (this: /*const*/ *btContactConstraint) -> *btPersistentManifold #cpp_method #foreign bullet3 "?getContactManifold@btContactConstraint@@QEBAPEBVbtPersistentManifold@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btContactConstraint@@UEAA@XZ";

    virtual_getInfo1 :: (this: *btContactConstraint, info: *btTypedConstraint.btConstraintInfo1) -> void #cpp_method #foreign bullet3 "?getInfo1@btContactConstraint@@UEAAXPEAUbtConstraintInfo1@btTypedConstraint@@@Z";

    virtual_getInfo2 :: (this: *btContactConstraint, info: *btTypedConstraint.btConstraintInfo2) -> void #cpp_method #foreign bullet3 "?getInfo2@btContactConstraint@@UEAAXPEAUbtConstraintInfo2@btTypedConstraint@@@Z";

    ///obsolete methods
    virtual_buildJacobian :: (this: *btContactConstraint) -> void #cpp_method #foreign bullet3 "?buildJacobian@btContactConstraint@@UEAAXXZ";
}

btNNCGConstraintSolver :: struct {
    #as using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver;

    m_deltafLengthSqrPrev: btScalar;

    m_pNC:                 btAlignedObjectArray(btScalar); // p for None Contact constraints
    m_pC:                  btAlignedObjectArray(btScalar); // p for Contact constraints
    m_pCF:                 btAlignedObjectArray(btScalar); // p for ContactFriction constraints
    m_pCRF:                btAlignedObjectArray(btScalar); // p for ContactRollingFriction constraints

    m_deltafNC:            btAlignedObjectArray(btScalar); // deltaf for NoneContact constraints
    m_deltafC:             btAlignedObjectArray(btScalar); // deltaf for Contact constraints
    m_deltafCF:            btAlignedObjectArray(btScalar); // deltaf for ContactFriction constraints
    m_deltafCRF:           btAlignedObjectArray(btScalar); // deltaf for ContactRollingFriction constraints

    Constructor :: (this: *btNNCGConstraintSolver) -> void #cpp_method #foreign bullet3 "??0btNNCGConstraintSolver@@QEAA@XZ";

    m_onlyForNoneContact:  bool;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveGroupCacheFriendlyFinish :: (this: *btNNCGConstraintSolver, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyFinish@btNNCGConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";
    virtual_solveSingleIteration :: (this: *btNNCGConstraintSolver, iteration: s32, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveSingleIteration@btNNCGConstraintSolver@@MEAAMHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_solveGroupCacheFriendlySetup :: (this: *btNNCGConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@btNNCGConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_getSolverType :: (this: *btNNCGConstraintSolver) -> btConstraintSolverType #cpp_method #foreign bullet3 "?getSolverType@btNNCGConstraintSolver@@UEBA?AW4btConstraintSolverType@@XZ";
}


///
/// btSequentialImpulseConstraintSolverMt
///
///  A multithreaded variant of the sequential impulse constraint solver. The constraints to be solved are grouped into
///  batches and phases where each batch of constraints within a given phase can be solved in parallel with the rest.
///  Ideally we want as few phases as possible, and each phase should have many batches, and all of the batches should
///  have about the same number of constraints.
///  This method works best on a large island of many constraints.
///
///  Supports all of the features of the normal sequential impulse solver such as:
///    - split penetration impulse
///    - rolling friction
///    - interleaving constraints
///    - warmstarting
///    - 2 friction directions
///    - randomized constraint ordering
///    - early termination when leastSquaresResidualThreshold is satisfied
///
///  When the SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS flag is enabled, unlike the normal SequentialImpulse solver,
///  the rolling friction is interleaved as well.
///  Interleaving the contact penetration constraints with friction reduces the number of parallel loops that need to be done,
///  which reduces threading overhead so it can be a performance win, however, it does seem to produce a less stable simulation,
///  at least on stacks of blocks.
///
///  When the SOLVER_RANDMIZE_ORDER flag is enabled, the ordering of phases, and the ordering of constraints within each batch
///  is randomized, however it does not swap constraints between batches.
///  This is to avoid regenerating the batches for each solver iteration which would be quite costly in performance.
///
///  Note that a non-zero leastSquaresResidualThreshold could possibly affect the determinism of the simulation
///  if the task scheduler's parallelSum operation is non-deterministic. The parallelSum operation can be non-deterministic
///  because floating point addition is not associative due to rounding errors.
///  The task scheduler can and should ensure that the result of any parallelSum operation is deterministic.
///
btSequentialImpulseConstraintSolverMt :: struct {
    #as using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver;

    // temp struct used to collect info from persistent manifolds into a cache-friendly struct using multiple threads
    btContactManifoldCachedInfo :: struct {
        numTouchingContacts:       s32;
        solverBodyIds:             [2] s32;
        contactIndex:              s32;
        rollingFrictionIndex:      s32;
        contactHasRollingFriction: [4] bool;
        contactPoints:             [4] *btManifoldPoint;
    }

    // temp struct used for setting up joint constraints in parallel
    JointParams :: struct {
        m_solverConstraint: s32;
        m_solverBodyA:      s32;
        m_solverBodyB:      s32;
    }

    internalInitMultipleJoints :: (this: *btSequentialImpulseConstraintSolverMt, constraints: **btTypedConstraint, iBegin: s32, iEnd: s32) -> void #cpp_method #foreign bullet3 "?internalInitMultipleJoints@btSequentialImpulseConstraintSolverMt@@QEAAXPEAPEAVbtTypedConstraint@@HH@Z";
    internalConvertMultipleJoints :: (this: *btSequentialImpulseConstraintSolverMt, jointParamsArray: *btAlignedObjectArray(JointParams), constraints: **btTypedConstraint, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalConvertMultipleJoints@btSequentialImpulseConstraintSolverMt@@QEAAXAEBV?$btAlignedObjectArray@UJointParams@btSequentialImpulseConstraintSolverMt@@@@PEAPEAVbtTypedConstraint@@HHAEBUbtContactSolverInfo@@@Z";
    internalConvertMultipleJoints :: (this: *btSequentialImpulseConstraintSolverMt, jointParamsArray: btAlignedObjectArray(JointParams), constraints: **btTypedConstraint, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalConvertMultipleJoints(this, *jointParamsArray, constraints, iBegin, iEnd, *infoGlobal);
    }

    m_batchedContactConstraints:                   btBatchedConstraints;
    m_batchedJointConstraints:                     btBatchedConstraints;
    m_numFrictionDirections:                       s32;
    m_useBatching:                                 bool;
    m_useObsoleteJointConstraints:                 bool;
    m_manifoldCachedInfoArray:                     btAlignedObjectArray(btContactManifoldCachedInfo);
    m_rollingFrictionIndexTable:                   btAlignedObjectArray(s32); // lookup table mapping contact index to rolling friction index
    m_bodySolverArrayMutex:                        btSpinMutex;
    m_antiFalseSharingPadding:                     [64] u8; // padding to keep mutexes in separate cachelines
    m_kinematicBodyUniqueIdToSolverBodyTableMutex: btSpinMutex;
    m_scratchMemory:                               btAlignedObjectArray(u8);

    getOrInitSolverBodyThreadsafe :: (this: *btSequentialImpulseConstraintSolverMt, body: *btCollisionObject, timeStep: btScalar) -> s32 #cpp_method #foreign bullet3 "?getOrInitSolverBodyThreadsafe@btSequentialImpulseConstraintSolverMt@@IEAAHAEAVbtCollisionObject@@M@Z";
    allocAllContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?allocAllContactConstraints@btSequentialImpulseConstraintSolverMt@@IEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z";
    allocAllContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: btContactSolverInfo) #no_context {
        allocAllContactConstraints(this, manifoldPtr, numManifolds, *infoGlobal);
    }
    setupAllContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setupAllContactConstraints@btSequentialImpulseConstraintSolverMt@@IEAAXAEBUbtContactSolverInfo@@@Z";
    setupAllContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, infoGlobal: btContactSolverInfo) #no_context {
        setupAllContactConstraints(this, *infoGlobal);
    }
    randomizeBatchedConstraintOrdering :: (this: *btSequentialImpulseConstraintSolverMt, batchedConstraints: *btBatchedConstraints) -> void #cpp_method #foreign bullet3 "?randomizeBatchedConstraintOrdering@btSequentialImpulseConstraintSolverMt@@IEAAXPEAUbtBatchedConstraints@@@Z";

    Constructor :: (this: *btSequentialImpulseConstraintSolverMt) -> void #cpp_method #foreign bullet3 "??0btSequentialImpulseConstraintSolverMt@@QEAA@XZ";

    resolveMultipleJointConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: *btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32, iteration: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveMultipleJointConstraints@btSequentialImpulseConstraintSolverMt@@QEAAMAEBV?$btAlignedObjectArray@H@@HHH@Z";
    resolveMultipleJointConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32, iteration: s32) -> btScalar #no_context {
        return resolveMultipleJointConstraints(this, *consIndices, batchBegin, batchEnd, iteration);
    }
    resolveMultipleContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: *btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveMultipleContactConstraints@btSequentialImpulseConstraintSolverMt@@QEAAMAEBV?$btAlignedObjectArray@H@@HH@Z";
    resolveMultipleContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #no_context {
        return resolveMultipleContactConstraints(this, *consIndices, batchBegin, batchEnd);
    }
    resolveMultipleContactSplitPenetrationImpulseConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: *btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveMultipleContactSplitPenetrationImpulseConstraints@btSequentialImpulseConstraintSolverMt@@QEAAMAEBV?$btAlignedObjectArray@H@@HH@Z";
    resolveMultipleContactSplitPenetrationImpulseConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #no_context {
        return resolveMultipleContactSplitPenetrationImpulseConstraints(this, *consIndices, batchBegin, batchEnd);
    }
    resolveMultipleContactFrictionConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: *btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveMultipleContactFrictionConstraints@btSequentialImpulseConstraintSolverMt@@QEAAMAEBV?$btAlignedObjectArray@H@@HH@Z";
    resolveMultipleContactFrictionConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #no_context {
        return resolveMultipleContactFrictionConstraints(this, *consIndices, batchBegin, batchEnd);
    }
    resolveMultipleContactRollingFrictionConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: *btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveMultipleContactRollingFrictionConstraints@btSequentialImpulseConstraintSolverMt@@QEAAMAEBV?$btAlignedObjectArray@H@@HH@Z";
    resolveMultipleContactRollingFrictionConstraints :: (this: *btSequentialImpulseConstraintSolverMt, consIndices: btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #no_context {
        return resolveMultipleContactRollingFrictionConstraints(this, *consIndices, batchBegin, batchEnd);
    }
    resolveMultipleContactConstraintsInterleaved :: (this: *btSequentialImpulseConstraintSolverMt, contactIndices: *btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveMultipleContactConstraintsInterleaved@btSequentialImpulseConstraintSolverMt@@QEAAMAEBV?$btAlignedObjectArray@H@@HH@Z";
    resolveMultipleContactConstraintsInterleaved :: (this: *btSequentialImpulseConstraintSolverMt, contactIndices: btAlignedObjectArray(s32), batchBegin: s32, batchEnd: s32) -> btScalar #no_context {
        return resolveMultipleContactConstraintsInterleaved(this, *contactIndices, batchBegin, batchEnd);
    }

    internalCollectContactManifoldCachedInfo :: (this: *btSequentialImpulseConstraintSolverMt, cachedInfoArray: *btContactManifoldCachedInfo, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalCollectContactManifoldCachedInfo@btSequentialImpulseConstraintSolverMt@@QEAAXPEAUbtContactManifoldCachedInfo@1@PEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z";
    internalCollectContactManifoldCachedInfo :: (this: *btSequentialImpulseConstraintSolverMt, cachedInfoArray: *btContactManifoldCachedInfo, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalCollectContactManifoldCachedInfo(this, cachedInfoArray, manifoldPtr, numManifolds, *infoGlobal);
    }
    internalAllocContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, cachedInfoArray: *btContactManifoldCachedInfo, numManifolds: s32) -> void #cpp_method #foreign bullet3 "?internalAllocContactConstraints@btSequentialImpulseConstraintSolverMt@@QEAAXPEBUbtContactManifoldCachedInfo@1@H@Z";
    internalSetupContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, iContactConstraint: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalSetupContactConstraints@btSequentialImpulseConstraintSolverMt@@QEAAXHAEBUbtContactSolverInfo@@@Z";
    internalSetupContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt, iContactConstraint: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalSetupContactConstraints(this, iContactConstraint, *infoGlobal);
    }
    internalConvertBodies :: (this: *btSequentialImpulseConstraintSolverMt, bodies: **btCollisionObject, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalConvertBodies@btSequentialImpulseConstraintSolverMt@@QEAAXPEAPEAVbtCollisionObject@@HHAEBUbtContactSolverInfo@@@Z";
    internalConvertBodies :: (this: *btSequentialImpulseConstraintSolverMt, bodies: **btCollisionObject, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalConvertBodies(this, bodies, iBegin, iEnd, *infoGlobal);
    }
    internalWriteBackContacts :: (this: *btSequentialImpulseConstraintSolverMt, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalWriteBackContacts@btSequentialImpulseConstraintSolverMt@@QEAAXHHAEBUbtContactSolverInfo@@@Z";
    internalWriteBackContacts :: (this: *btSequentialImpulseConstraintSolverMt, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalWriteBackContacts(this, iBegin, iEnd, *infoGlobal);
    }
    internalWriteBackJoints :: (this: *btSequentialImpulseConstraintSolverMt, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalWriteBackJoints@btSequentialImpulseConstraintSolverMt@@QEAAXHHAEBUbtContactSolverInfo@@@Z";
    internalWriteBackJoints :: (this: *btSequentialImpulseConstraintSolverMt, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalWriteBackJoints(this, iBegin, iEnd, *infoGlobal);
    }
    internalWriteBackBodies :: (this: *btSequentialImpulseConstraintSolverMt, iBegin: s32, iEnd: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?internalWriteBackBodies@btSequentialImpulseConstraintSolverMt@@QEAAXHHAEBUbtContactSolverInfo@@@Z";
    internalWriteBackBodies :: (this: *btSequentialImpulseConstraintSolverMt, iBegin: s32, iEnd: s32, infoGlobal: btContactSolverInfo) #no_context {
        internalWriteBackBodies(this, iBegin, iEnd, *infoGlobal);
    }
    #place btsequentialimpulseconstraintsolver; btsequentialimpulseconstraintsolvermt_vtable: *btSequentialImpulseConstraintSolverMt_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveGroupCacheFriendlySplitImpulseIterations :: (this: *btSequentialImpulseConstraintSolverMt, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySplitImpulseIterations@btSequentialImpulseConstraintSolverMt@@UEAAXPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
    virtual_solveSingleIteration :: (this: *btSequentialImpulseConstraintSolverMt, iteration: s32, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveSingleIteration@btSequentialImpulseConstraintSolverMt@@UEAAMHPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
    virtual_solveGroupCacheFriendlySetup :: (this: *btSequentialImpulseConstraintSolverMt, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@btSequentialImpulseConstraintSolverMt@@UEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
    virtual_solveGroupCacheFriendlyFinish :: (this: *btSequentialImpulseConstraintSolverMt, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyFinish@btSequentialImpulseConstraintSolverMt@@UEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    virtual_randomizeConstraintOrdering :: (this: *btSequentialImpulseConstraintSolverMt, iteration: s32, numIterations: s32) -> void #cpp_method #foreign bullet3 "?randomizeConstraintOrdering@btSequentialImpulseConstraintSolverMt@@MEAAXHH@Z";
    virtual_resolveAllJointConstraints :: (this: *btSequentialImpulseConstraintSolverMt, iteration: s32) -> btScalar #cpp_method #foreign bullet3 "?resolveAllJointConstraints@btSequentialImpulseConstraintSolverMt@@MEAAMH@Z";
    virtual_resolveAllContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method #foreign bullet3 "?resolveAllContactConstraints@btSequentialImpulseConstraintSolverMt@@MEAAMXZ";
    virtual_resolveAllContactFrictionConstraints :: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method #foreign bullet3 "?resolveAllContactFrictionConstraints@btSequentialImpulseConstraintSolverMt@@MEAAMXZ";
    virtual_resolveAllContactConstraintsInterleaved :: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method #foreign bullet3 "?resolveAllContactConstraintsInterleaved@btSequentialImpulseConstraintSolverMt@@MEAAMXZ";
    virtual_resolveAllRollingFrictionConstraints :: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method #foreign bullet3 "?resolveAllRollingFrictionConstraints@btSequentialImpulseConstraintSolverMt@@MEAAMXZ";

    virtual_setupBatchedContactConstraints :: (this: *btSequentialImpulseConstraintSolverMt) -> void #cpp_method #foreign bullet3 "?setupBatchedContactConstraints@btSequentialImpulseConstraintSolverMt@@MEAAXXZ";
    virtual_setupBatchedJointConstraints :: (this: *btSequentialImpulseConstraintSolverMt) -> void #cpp_method #foreign bullet3 "?setupBatchedJointConstraints@btSequentialImpulseConstraintSolverMt@@MEAAXXZ";
    virtual_convertJoints :: (this: *btSequentialImpulseConstraintSolverMt, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertJoints@btSequentialImpulseConstraintSolverMt@@MEAAXPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@@Z";
    virtual_convertContacts :: (this: *btSequentialImpulseConstraintSolverMt, manifoldPtr: **btPersistentManifold, numManifolds: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertContacts@btSequentialImpulseConstraintSolverMt@@MEAAXPEAPEAVbtPersistentManifold@@HAEBUbtContactSolverInfo@@@Z";
    virtual_convertBodies :: (this: *btSequentialImpulseConstraintSolverMt, bodies: **btCollisionObject, numBodies: s32, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?convertBodies@btSequentialImpulseConstraintSolverMt@@MEAAXPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    virtual_Destructor :: (this: *btSequentialImpulseConstraintSolverMt, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSequentialImpulseConstraintSolverMt@@UEAA@XZ";
}
btSequentialImpulseConstraintSolverMt_VTable :: struct #type_info_none {
    using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver_VTable;
    randomizeConstraintOrdering: (this: *btSequentialImpulseConstraintSolverMt, iteration: s32, numIterations: s32) -> void #cpp_method;
    resolveAllJointConstraints: (this: *btSequentialImpulseConstraintSolverMt, iteration: s32) -> btScalar #cpp_method;
    resolveAllContactConstraints: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method;
    resolveAllContactFrictionConstraints: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method;
    resolveAllContactConstraintsInterleaved: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method;
    resolveAllRollingFrictionConstraints: (this: *btSequentialImpulseConstraintSolverMt) -> btScalar #cpp_method;

    setupBatchedContactConstraints: (this: *btSequentialImpulseConstraintSolverMt) -> void #cpp_method;
    setupBatchedJointConstraints: (this: *btSequentialImpulseConstraintSolverMt) -> void #cpp_method;
}

btSequentialImpulseConstraintSolverMt_randomizeConstraintOrdering :: inline (this: *btSequentialImpulseConstraintSolverMt, iteration: s32, numIterations: s32) { this.btsequentialimpulseconstraintsolvermt_vtable.randomizeConstraintOrdering(this, iteration, numIterations); }
btSequentialImpulseConstraintSolverMt_resolveAllJointConstraints :: inline (this: *btSequentialImpulseConstraintSolverMt, iteration: s32) -> btScalar { return this.btsequentialimpulseconstraintsolvermt_vtable.resolveAllJointConstraints(this, iteration); }
btSequentialImpulseConstraintSolverMt_resolveAllContactConstraints :: inline (this: *btSequentialImpulseConstraintSolverMt) -> btScalar { return this.btsequentialimpulseconstraintsolvermt_vtable.resolveAllContactConstraints(this); }
btSequentialImpulseConstraintSolverMt_resolveAllContactFrictionConstraints :: inline (this: *btSequentialImpulseConstraintSolverMt) -> btScalar { return this.btsequentialimpulseconstraintsolvermt_vtable.resolveAllContactFrictionConstraints(this); }
btSequentialImpulseConstraintSolverMt_resolveAllContactConstraintsInterleaved :: inline (this: *btSequentialImpulseConstraintSolverMt) -> btScalar { return this.btsequentialimpulseconstraintsolvermt_vtable.resolveAllContactConstraintsInterleaved(this); }
btSequentialImpulseConstraintSolverMt_resolveAllRollingFrictionConstraints :: inline (this: *btSequentialImpulseConstraintSolverMt) -> btScalar { return this.btsequentialimpulseconstraintsolvermt_vtable.resolveAllRollingFrictionConstraints(this); }

btSequentialImpulseConstraintSolverMt_setupBatchedContactConstraints :: inline (this: *btSequentialImpulseConstraintSolverMt) { this.btsequentialimpulseconstraintsolvermt_vtable.setupBatchedContactConstraints(this); }
btSequentialImpulseConstraintSolverMt_setupBatchedJointConstraints :: inline (this: *btSequentialImpulseConstraintSolverMt) { this.btsequentialimpulseconstraintsolvermt_vtable.setupBatchedJointConstraints(this); }

vtable :: (obj: *btSequentialImpulseConstraintSolverMt) -> *btSequentialImpulseConstraintSolverMt_VTable { return obj.btsequentialimpulseconstraintsolvermt_vtable; }



/// constraint class used for lateral tyre friction.
btSolve2LinearConstraint :: struct {
    m_tau:     btScalar;
    m_damping: btScalar;

    Constructor :: (this: *btSolve2LinearConstraint, tau: btScalar, damping: btScalar) -> void #cpp_method #foreign bullet3 "??0btSolve2LinearConstraint@@QEAA@MM@Z";

    //
    // solve unilateral constraint (equality, direct method)
    //
    resolveUnilateralPairConstraint :: (this: *btSolve2LinearConstraint, body0: *btRigidBody, body1: *btRigidBody, world2A: *btMatrix3x3, world2B: *btMatrix3x3, invInertiaADiag: *btVector3, invMassA: btScalar, linvelA: *btVector3, angvelA: *btVector3, rel_posA1: *btVector3, invInertiaBDiag: *btVector3, invMassB: btScalar, linvelB: *btVector3, angvelB: *btVector3, rel_posA2: *btVector3, depthA: btScalar, normalA: *btVector3, rel_posB1: *btVector3, rel_posB2: *btVector3, depthB: btScalar, normalB: *btVector3, imp0: *btScalar, imp1: *btScalar) -> void #cpp_method #foreign bullet3 "?resolveUnilateralPairConstraint@btSolve2LinearConstraint@@QEAAXPEAVbtRigidBody@@0AEBVbtMatrix3x3@@1AEBVbtVector3@@M2222M222M222M2AEAM3@Z";
    resolveUnilateralPairConstraint :: (this: *btSolve2LinearConstraint, body0: *btRigidBody, body1: *btRigidBody, world2A: btMatrix3x3, world2B: btMatrix3x3, invInertiaADiag: btVector3, invMassA: btScalar, linvelA: btVector3, angvelA: btVector3, rel_posA1: btVector3, invInertiaBDiag: btVector3, invMassB: btScalar, linvelB: btVector3, angvelB: btVector3, rel_posA2: btVector3, depthA: btScalar, normalA: btVector3, rel_posB1: btVector3, rel_posB2: btVector3, depthB: btScalar, normalB: btVector3, imp0: *btScalar, imp1: *btScalar) #no_context {
        resolveUnilateralPairConstraint(this, body0, body1, *world2A, *world2B, *invInertiaADiag, invMassA, *linvelA, *angvelA, *rel_posA1, *invInertiaBDiag, invMassB, *linvelB, *angvelB, *rel_posA2, depthA, *normalA, *rel_posB1, *rel_posB2, depthB, *normalB, imp0, imp1);
    }

    //
    // solving 2x2 lcp problem (inequality, direct solution )
    //
    resolveBilateralPairConstraint :: (this: *btSolve2LinearConstraint, body0: *btRigidBody, body1: *btRigidBody, world2A: *btMatrix3x3, world2B: *btMatrix3x3, invInertiaADiag: *btVector3, invMassA: btScalar, linvelA: *btVector3, angvelA: *btVector3, rel_posA1: *btVector3, invInertiaBDiag: *btVector3, invMassB: btScalar, linvelB: *btVector3, angvelB: *btVector3, rel_posA2: *btVector3, depthA: btScalar, normalA: *btVector3, rel_posB1: *btVector3, rel_posB2: *btVector3, depthB: btScalar, normalB: *btVector3, imp0: *btScalar, imp1: *btScalar) -> void #cpp_method #foreign bullet3 "?resolveBilateralPairConstraint@btSolve2LinearConstraint@@QEAAXPEAVbtRigidBody@@0AEBVbtMatrix3x3@@1AEBVbtVector3@@M2222M222M222M2AEAM3@Z";
    resolveBilateralPairConstraint :: (this: *btSolve2LinearConstraint, body0: *btRigidBody, body1: *btRigidBody, world2A: btMatrix3x3, world2B: btMatrix3x3, invInertiaADiag: btVector3, invMassA: btScalar, linvelA: btVector3, angvelA: btVector3, rel_posA1: btVector3, invInertiaBDiag: btVector3, invMassB: btScalar, linvelB: btVector3, angvelB: btVector3, rel_posA2: btVector3, depthA: btScalar, normalA: btVector3, rel_posB1: btVector3, rel_posB2: btVector3, depthB: btScalar, normalB: btVector3, imp0: *btScalar, imp1: *btScalar) #no_context {
        resolveBilateralPairConstraint(this, body0, body1, *world2A, *world2B, *invInertiaADiag, invMassA, *linvelA, *angvelA, *rel_posA1, *invInertiaBDiag, invMassB, *linvelB, *angvelB, *rel_posA2, depthA, *normalA, *rel_posB1, *rel_posB2, depthB, *normalB, imp0, imp1);
    }
}

///
/// SimulationIslandManagerMt -- Multithread capable version of SimulationIslandManager
///                       Splits the world up into islands which can be solved in parallel.
///                       In order to solve islands in parallel, an IslandDispatch function
///                       must be provided which will dispatch calls to multiple threads.
///                       The amount of parallelism that can be achieved depends on the number
///                       of islands. If only a single island exists, then no parallelism is
///                       possible.
///
btSimulationIslandManagerMt :: struct {
    #as using btsimulationislandmanager: btSimulationIslandManager;

    Island :: struct {
        // a simulation island consisting of bodies, manifolds and constraints,
        // to be passed into a constraint solver.
        bodyArray:       btAlignedObjectArray(*btCollisionObject);
        manifoldArray:   btAlignedObjectArray(*btPersistentManifold);
        constraintArray: btAlignedObjectArray(*btTypedConstraint);
        id:              s32; // island id
        isSleeping:      bool;

        append :: (this: *Island, other: *Island) -> void #cpp_method #foreign bullet3 "?append@Island@btSimulationIslandManagerMt@@QEAAXAEBU12@@Z";
        append :: (this: *Island, other: Island) #no_context {
            append(this, *other);
        }
    }

    SolverParams :: struct {
        m_solverPool:  *btConstraintSolver;
        m_solverMt:    *btConstraintSolver;
        m_solverInfo:  *btContactSolverInfo;
        m_debugDrawer: *btIDebugDraw;
        m_dispatcher:  *btDispatcher;
    }

    solveIsland :: (solver: *btConstraintSolver, island: *Island, solverParams: *SolverParams) -> void #foreign bullet3 "?solveIsland@btSimulationIslandManagerMt@@SAXPEAVbtConstraintSolver@@AEAUIsland@1@AEBUSolverParams@1@@Z";
    solveIsland :: (solver: *btConstraintSolver, island: *Island, solverParams: SolverParams) #no_context {
        solveIsland(solver, island, *solverParams);
    }

    IslandDispatchFunc :: #type (islands: *btAlignedObjectArray(*Island), solverParams: *SolverParams) -> void #c_call;
    serialIslandDispatch :: (islandsPtr: *btAlignedObjectArray(*Island), solverParams: *SolverParams) -> void #foreign bullet3 "?serialIslandDispatch@btSimulationIslandManagerMt@@SAXPEAV?$btAlignedObjectArray@PEAUIsland@btSimulationIslandManagerMt@@@@AEBUSolverParams@1@@Z";
    serialIslandDispatch :: (islandsPtr: *btAlignedObjectArray(*Island), solverParams: SolverParams) #no_context {
        serialIslandDispatch(islandsPtr, *solverParams);
    }
    parallelIslandDispatch :: (islandsPtr: *btAlignedObjectArray(*Island), solverParams: *SolverParams) -> void #foreign bullet3 "?parallelIslandDispatch@btSimulationIslandManagerMt@@SAXPEAV?$btAlignedObjectArray@PEAUIsland@btSimulationIslandManagerMt@@@@AEBUSolverParams@1@@Z";
    parallelIslandDispatch :: (islandsPtr: *btAlignedObjectArray(*Island), solverParams: SolverParams) #no_context {
        parallelIslandDispatch(islandsPtr, *solverParams);
    }

    m_allocatedIslands:        btAlignedObjectArray(*Island); // owner of all Islands
    m_activeIslands:           btAlignedObjectArray(*Island); // islands actively in use
    m_freeIslands:             btAlignedObjectArray(*Island); // islands ready to be reused
    m_lookupIslandFromId:      btAlignedObjectArray(*Island); // big lookup table to map islandId to Island pointer
    m_batchIsland:             *Island;
    m_minimumSolverBatchSize:  s32;
    m_batchIslandMinBodyCount: s32;
    m_islandDispatch:          IslandDispatchFunc;

    getIsland :: (this: *btSimulationIslandManagerMt, id: s32) -> *Island #cpp_method #foreign bullet3 "?getIsland@btSimulationIslandManagerMt@@IEAAPEAUIsland@1@H@Z";

    Constructor :: (this: *btSimulationIslandManagerMt) -> void #cpp_method #foreign bullet3 "??0btSimulationIslandManagerMt@@QEAA@XZ";

    getMinimumSolverBatchSize :: (this: *btSimulationIslandManagerMt) -> s32 #cpp_method #foreign bullet3 "?getMinimumSolverBatchSize@btSimulationIslandManagerMt@@QEBAHXZ";

    setMinimumSolverBatchSize :: (this: *btSimulationIslandManagerMt, sz: s32) -> void #cpp_method #foreign bullet3 "?setMinimumSolverBatchSize@btSimulationIslandManagerMt@@QEAAXH@Z";

    getIslandDispatchFunction :: (this: *btSimulationIslandManagerMt) -> IslandDispatchFunc #cpp_method #foreign bullet3 "?getIslandDispatchFunction@btSimulationIslandManagerMt@@QEBAP6AXPEAV?$btAlignedObjectArray@PEAUIsland@btSimulationIslandManagerMt@@@@AEBUSolverParams@1@@ZXZ";

    // allow users to set their own dispatch function for multithreaded dispatch
    setIslandDispatchFunction :: (this: *btSimulationIslandManagerMt, func: IslandDispatchFunc) -> void #cpp_method #foreign bullet3 "?setIslandDispatchFunction@btSimulationIslandManagerMt@@QEAAXP6AXPEAV?$btAlignedObjectArray@PEAUIsland@btSimulationIslandManagerMt@@@@AEBUSolverParams@1@@Z@Z";
    #place btsimulationislandmanager; btsimulationislandmanagermt_vtable: *btSimulationIslandManagerMt_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_allocateIsland :: (this: *btSimulationIslandManagerMt, id: s32, numBodies: s32) -> *Island #cpp_method #foreign bullet3 "?allocateIsland@btSimulationIslandManagerMt@@MEAAPEAUIsland@1@HH@Z";
    virtual_initIslandPools :: (this: *btSimulationIslandManagerMt) -> void #cpp_method #foreign bullet3 "?initIslandPools@btSimulationIslandManagerMt@@MEAAXXZ";
    virtual_addBodiesToIslands :: (this: *btSimulationIslandManagerMt, collisionWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?addBodiesToIslands@btSimulationIslandManagerMt@@MEAAXPEAVbtCollisionWorld@@@Z";
    virtual_addManifoldsToIslands :: (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher) -> void #cpp_method #foreign bullet3 "?addManifoldsToIslands@btSimulationIslandManagerMt@@MEAAXPEAVbtDispatcher@@@Z";
    virtual_addConstraintsToIslands :: (this: *btSimulationIslandManagerMt, constraints: *btAlignedObjectArray(*btTypedConstraint)) -> void #cpp_method #foreign bullet3 "?addConstraintsToIslands@btSimulationIslandManagerMt@@MEAAXAEAV?$btAlignedObjectArray@PEAVbtTypedConstraint@@@@@Z";
    virtual_mergeIslands :: (this: *btSimulationIslandManagerMt) -> void #cpp_method #foreign bullet3 "?mergeIslands@btSimulationIslandManagerMt@@MEAAXXZ";

    virtual_Destructor :: (this: *btSimulationIslandManagerMt, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btSimulationIslandManagerMt@@UEAA@XZ";

    virtual_buildAndProcessIslands :: (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher, collisionWorld: *btCollisionWorld, constraints: *btAlignedObjectArray(*btTypedConstraint), solverParams: *SolverParams) -> void #cpp_method #foreign bullet3 "?buildAndProcessIslands@btSimulationIslandManagerMt@@UEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@AEAV?$btAlignedObjectArray@PEAVbtTypedConstraint@@@@AEBUSolverParams@1@@Z";

    virtual_buildIslands :: (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher, colWorld: *btCollisionWorld) -> void #cpp_method #foreign bullet3 "?buildIslands@btSimulationIslandManagerMt@@UEAAXPEAVbtDispatcher@@PEAVbtCollisionWorld@@@Z";
}
btSimulationIslandManagerMt_VTable :: struct #type_info_none {
    using btsimulationislandmanager: btSimulationIslandManager_VTable;
    allocateIsland: (this: *btSimulationIslandManagerMt, id: s32, numBodies: s32) -> *btSimulationIslandManagerMt.Island #cpp_method;
    initIslandPools: (this: *btSimulationIslandManagerMt) -> void #cpp_method;
    addBodiesToIslands: (this: *btSimulationIslandManagerMt, collisionWorld: *btCollisionWorld) -> void #cpp_method;
    addManifoldsToIslands: (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher) -> void #cpp_method;
    addConstraintsToIslands: (this: *btSimulationIslandManagerMt, constraints: *btAlignedObjectArray(*btTypedConstraint)) -> void #cpp_method;
    mergeIslands: (this: *btSimulationIslandManagerMt) -> void #cpp_method;

    buildAndProcessIslands: (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher, collisionWorld: *btCollisionWorld, constraints: *btAlignedObjectArray(*btTypedConstraint), solverParams: *btSimulationIslandManagerMt.SolverParams) -> void #cpp_method;

    buildIslands: (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher, colWorld: *btCollisionWorld) -> void #cpp_method;
}

btSimulationIslandManagerMt_allocateIsland :: inline (this: *btSimulationIslandManagerMt, id: s32, numBodies: s32) -> *btSimulationIslandManagerMt.Island { return this.btsimulationislandmanagermt_vtable.allocateIsland(this, id, numBodies); }
btSimulationIslandManagerMt_initIslandPools :: inline (this: *btSimulationIslandManagerMt) { this.btsimulationislandmanagermt_vtable.initIslandPools(this); }
btSimulationIslandManagerMt_addBodiesToIslands :: inline (this: *btSimulationIslandManagerMt, collisionWorld: *btCollisionWorld) { this.btsimulationislandmanagermt_vtable.addBodiesToIslands(this, collisionWorld); }
btSimulationIslandManagerMt_addManifoldsToIslands :: inline (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher) { this.btsimulationislandmanagermt_vtable.addManifoldsToIslands(this, dispatcher); }
btSimulationIslandManagerMt_addConstraintsToIslands :: inline (this: *btSimulationIslandManagerMt, constraints: *btAlignedObjectArray(*btTypedConstraint)) { this.btsimulationislandmanagermt_vtable.addConstraintsToIslands(this, constraints); }
btSimulationIslandManagerMt_mergeIslands :: inline (this: *btSimulationIslandManagerMt) { this.btsimulationislandmanagermt_vtable.mergeIslands(this); }

btSimulationIslandManagerMt_buildAndProcessIslands :: inline (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher, collisionWorld: *btCollisionWorld, constraints: *btAlignedObjectArray(*btTypedConstraint), solverParams: *btSimulationIslandManagerMt.SolverParams) { this.btsimulationislandmanagermt_vtable.buildAndProcessIslands(this, dispatcher, collisionWorld, constraints, solverParams); }

btSimulationIslandManagerMt_buildIslands :: inline (this: *btSimulationIslandManagerMt, dispatcher: *btDispatcher, colWorld: *btCollisionWorld) { this.btsimulationislandmanagermt_vtable.buildIslands(this, dispatcher, colWorld); }

vtable :: (obj: *btSimulationIslandManagerMt) -> *btSimulationIslandManagerMt_VTable { return obj.btsimulationislandmanagermt_vtable; }


///
/// btConstraintSolverPoolMt - masquerades as a constraint solver, but really it is a threadsafe pool of them.
///
///  Each solver in the pool is protected by a mutex.  When solveGroup is called from a thread,
///  the pool looks for a solver that isn't being used by another thread, locks it, and dispatches the
///  call to the solver.
///  So long as there are at least as many solvers as there are hardware threads, it should never need to
///  spin wait.
///
btConstraintSolverPoolMt :: struct {
    #as using btconstraintsolver: btConstraintSolver;

    // create the solvers for me
    Constructor :: (this: *btConstraintSolverPoolMt, numSolvers: s32) -> void #cpp_method #foreign bullet3 "??0btConstraintSolverPoolMt@@QEAA@H@Z";

    // pass in fully constructed solvers (destructor will delete them)
    Constructor :: (this: *btConstraintSolverPoolMt, solvers: **btConstraintSolver, numSolvers: s32) -> void #cpp_method #foreign bullet3 "??0btConstraintSolverPoolMt@@QEAA@PEAPEAVbtConstraintSolver@@H@Z";

    ThreadSolver :: struct {
        solver:            *btConstraintSolver;
        mutex:             btSpinMutex;
        _cachelinePadding: [116] u8; // keep mutexes from sharing a cache line
    }

    m_solvers:    btAlignedObjectArray(ThreadSolver);
    m_solverType: btConstraintSolverType;

    getAndLockThreadSolver :: (this: *btConstraintSolverPoolMt) -> *ThreadSolver #cpp_method #foreign bullet3 "?getAndLockThreadSolver@btConstraintSolverPoolMt@@AEAAPEAUThreadSolver@1@XZ";
    init :: (this: *btConstraintSolverPoolMt, solvers: **btConstraintSolver, numSolvers: s32) -> void #cpp_method #foreign bullet3 "?init@btConstraintSolverPoolMt@@AEAAXPEAPEAVbtConstraintSolver@@H@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btConstraintSolverPoolMt, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btConstraintSolverPoolMt@@UEAA@XZ";

    ///solve a group of constraints
    virtual_solveGroup :: (this: *btConstraintSolverPoolMt, bodies: **btCollisionObject, numBodies: s32, manifolds: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, info: *btContactSolverInfo, debugDrawer: *btIDebugDraw, dispatcher: *btDispatcher) -> btScalar #cpp_method #foreign bullet3 "?solveGroup@btConstraintSolverPoolMt@@UEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@PEAVbtDispatcher@@@Z";

    virtual_reset :: (this: *btConstraintSolverPoolMt) -> void #cpp_method #foreign bullet3 "?reset@btConstraintSolverPoolMt@@UEAAXXZ";
    virtual_getSolverType :: (this: *btConstraintSolverPoolMt) -> btConstraintSolverType #cpp_method #foreign bullet3 "?getSolverType@btConstraintSolverPoolMt@@UEBA?AW4btConstraintSolverType@@XZ";
}

///
/// btDiscreteDynamicsWorldMt -- a version of DiscreteDynamicsWorld with some minor changes to support
///                              solving simulation islands on multiple threads.
///
///  Should function exactly like btDiscreteDynamicsWorld.
///  Also 3 methods that iterate over all of the rigidbodies can run in parallel:
///     - predictUnconstraintMotion
///     - integrateTransforms
///     - createPredictiveContacts
///
btDiscreteDynamicsWorldMt :: struct {
    #as using btdiscretedynamicsworld: btDiscreteDynamicsWorld;

    m_constraintSolverMt: *btConstraintSolver;

    UpdaterCreatePredictiveContacts :: struct {
        #as using btiparallelforbody: btIParallelForBody;

        timeStep:    btScalar;
        rigidBodies: **btRigidBody;
        world:       *btDiscreteDynamicsWorldMt;
    }

    UpdaterIntegrateTransforms :: struct {
        #as using btiparallelforbody: btIParallelForBody;

        timeStep:    btScalar;
        rigidBodies: **btRigidBody;
        world:       *btDiscreteDynamicsWorldMt;
    }

    Constructor :: (this: *btDiscreteDynamicsWorldMt, dispatcher: *btDispatcher, pairCache: *btBroadphaseInterface, solverPool: *btConstraintSolverPoolMt, constraintSolverMt: *btConstraintSolver, collisionConfiguration: *btCollisionConfiguration) -> void #cpp_method #foreign bullet3 "??0btDiscreteDynamicsWorldMt@@QEAA@PEAVbtDispatcher@@PEAVbtBroadphaseInterface@@PEAVbtConstraintSolverPoolMt@@PEAVbtConstraintSolver@@PEAVbtCollisionConfiguration@@@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveConstraints :: (this: *btDiscreteDynamicsWorldMt, solverInfo: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?solveConstraints@btDiscreteDynamicsWorldMt@@MEAAXAEAUbtContactSolverInfo@@@Z";

    virtual_predictUnconstraintMotion :: (this: *btDiscreteDynamicsWorldMt, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?predictUnconstraintMotion@btDiscreteDynamicsWorldMt@@MEAAXM@Z";

    virtual_createPredictiveContacts :: (this: *btDiscreteDynamicsWorldMt, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?createPredictiveContacts@btDiscreteDynamicsWorldMt@@MEAAXM@Z";

    virtual_integrateTransforms :: (this: *btDiscreteDynamicsWorldMt, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?integrateTransforms@btDiscreteDynamicsWorldMt@@MEAAXM@Z";

    virtual_Destructor :: (this: *btDiscreteDynamicsWorldMt, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btDiscreteDynamicsWorldMt@@UEAA@XZ";

    virtual_stepSimulation :: (this: *btDiscreteDynamicsWorldMt, timeStep: btScalar, maxSubSteps: s32, fixedTimeStep: btScalar) -> s32 #cpp_method #foreign bullet3 "?stepSimulation@btDiscreteDynamicsWorldMt@@UEAAHMHM@Z";
}


btMultiBodyFixedConstraint :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_rigidBodyA: *btRigidBody;
    m_rigidBodyB: *btRigidBody;
    m_pivotInA:   btVector3;
    m_pivotInB:   btVector3;
    m_frameInA:   btMatrix3x3;
    m_frameInB:   btMatrix3x3;

    Constructor :: (this: *btMultiBodyFixedConstraint, body: *btMultiBody, link: s32, bodyB: *btRigidBody, pivotInA: *btVector3, pivotInB: *btVector3, frameInA: *btMatrix3x3, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "??0btMultiBodyFixedConstraint@@QEAA@PEAVbtMultiBody@@HPEAVbtRigidBody@@AEBVbtVector3@@2AEBVbtMatrix3x3@@3@Z";
    Constructor :: (this: *btMultiBodyFixedConstraint, body: *btMultiBody, link: s32, bodyB: *btRigidBody, pivotInA: btVector3, pivotInB: btVector3, frameInA: btMatrix3x3, frameInB: btMatrix3x3) #no_context {
        Constructor(this, body, link, bodyB, *pivotInA, *pivotInB, *frameInA, *frameInB);
    }
    Constructor :: (this: *btMultiBodyFixedConstraint, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: *btVector3, pivotInB: *btVector3, frameInA: *btMatrix3x3, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "??0btMultiBodyFixedConstraint@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1AEBVbtMatrix3x3@@2@Z";
    Constructor :: (this: *btMultiBodyFixedConstraint, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: btVector3, pivotInB: btVector3, frameInA: btMatrix3x3, frameInB: btMatrix3x3) #no_context {
        Constructor(this, bodyA, linkA, bodyB, linkB, *pivotInA, *pivotInB, *frameInA, *frameInB);
    }

    getPivotInA :: (this: *btMultiBodyFixedConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInA@btMultiBodyFixedConstraint@@QEBAAEBVbtVector3@@XZ";

    setPivotInA :: (this: *btMultiBodyFixedConstraint, pivotInA: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInA@btMultiBodyFixedConstraint@@QEAAXAEBVbtVector3@@@Z";
    setPivotInA :: (this: *btMultiBodyFixedConstraint, pivotInA: btVector3) #no_context {
        setPivotInA(this, *pivotInA);
    }

    getPivotInB :: (this: *btMultiBodyFixedConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInB@btMultiBodyFixedConstraint@@QEBAAEBVbtVector3@@XZ";

    getFrameInA :: (this: *btMultiBodyFixedConstraint) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getFrameInA@btMultiBodyFixedConstraint@@QEBAAEBVbtMatrix3x3@@XZ";

    setFrameInA :: (this: *btMultiBodyFixedConstraint, frameInA: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInA@btMultiBodyFixedConstraint@@QEAAXAEBVbtMatrix3x3@@@Z";
    setFrameInA :: (this: *btMultiBodyFixedConstraint, frameInA: btMatrix3x3) #no_context {
        setFrameInA(this, *frameInA);
    }

    getFrameInB :: (this: *btMultiBodyFixedConstraint) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getFrameInB@btMultiBodyFixedConstraint@@QEBAAEBVbtMatrix3x3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodyFixedConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyFixedConstraint@@UEAA@XZ";

    virtual_finalizeMultiDof :: (this: *btMultiBodyFixedConstraint) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodyFixedConstraint@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodyFixedConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodyFixedConstraint@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodyFixedConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodyFixedConstraint@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodyFixedConstraint, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodyFixedConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setPivotInB :: (this: *btMultiBodyFixedConstraint, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInB@btMultiBodyFixedConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_setFrameInB :: (this: *btMultiBodyFixedConstraint, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInB@btMultiBodyFixedConstraint@@UEAAXAEBVbtMatrix3x3@@@Z";

    virtual_debugDraw :: (this: *btMultiBodyFixedConstraint, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodyFixedConstraint@@UEAAXPEAVbtIDebugDraw@@@Z";
}

btMultiBodyGearConstraint :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_rigidBodyA:             *btRigidBody;
    m_rigidBodyB:             *btRigidBody;
    m_pivotInA:               btVector3;
    m_pivotInB:               btVector3;
    m_frameInA:               btMatrix3x3;
    m_frameInB:               btMatrix3x3;
    m_gearRatio:              btScalar;
    m_gearAuxLink:            s32;
    m_erp:                    btScalar;
    m_relativePositionTarget: btScalar;

    //btMultiBodyGearConstraint(btMultiBody* body, int link, btRigidBody* bodyB, const btVector3& pivotInA, const btVector3& pivotInB, const btMatrix3x3& frameInA, const btMatrix3x3& frameInB);
    Constructor :: (this: *btMultiBodyGearConstraint, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: *btVector3, pivotInB: *btVector3, frameInA: *btMatrix3x3, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "??0btMultiBodyGearConstraint@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1AEBVbtMatrix3x3@@2@Z";
    Constructor :: (this: *btMultiBodyGearConstraint, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: btVector3, pivotInB: btVector3, frameInA: btMatrix3x3, frameInB: btMatrix3x3) #no_context {
        Constructor(this, bodyA, linkA, bodyB, linkB, *pivotInA, *pivotInB, *frameInA, *frameInB);
    }

    getPivotInA :: (this: *btMultiBodyGearConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInA@btMultiBodyGearConstraint@@QEBAAEBVbtVector3@@XZ";

    setPivotInA :: (this: *btMultiBodyGearConstraint, pivotInA: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInA@btMultiBodyGearConstraint@@QEAAXAEBVbtVector3@@@Z";
    setPivotInA :: (this: *btMultiBodyGearConstraint, pivotInA: btVector3) #no_context {
        setPivotInA(this, *pivotInA);
    }

    getPivotInB :: (this: *btMultiBodyGearConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInB@btMultiBodyGearConstraint@@QEBAAEBVbtVector3@@XZ";

    getFrameInA :: (this: *btMultiBodyGearConstraint) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getFrameInA@btMultiBodyGearConstraint@@QEBAAEBVbtMatrix3x3@@XZ";

    setFrameInA :: (this: *btMultiBodyGearConstraint, frameInA: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInA@btMultiBodyGearConstraint@@QEAAXAEBVbtMatrix3x3@@@Z";
    setFrameInA :: (this: *btMultiBodyGearConstraint, frameInA: btMatrix3x3) #no_context {
        setFrameInA(this, *frameInA);
    }

    getFrameInB :: (this: *btMultiBodyGearConstraint) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getFrameInB@btMultiBodyGearConstraint@@QEBAAEBVbtMatrix3x3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodyGearConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyGearConstraint@@UEAA@XZ";

    virtual_finalizeMultiDof :: (this: *btMultiBodyGearConstraint) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodyGearConstraint@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodyGearConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodyGearConstraint@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodyGearConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodyGearConstraint@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodyGearConstraint, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodyGearConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setPivotInB :: (this: *btMultiBodyGearConstraint, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInB@btMultiBodyGearConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_setFrameInB :: (this: *btMultiBodyGearConstraint, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInB@btMultiBodyGearConstraint@@UEAAXAEBVbtMatrix3x3@@@Z";

    virtual_debugDraw :: (this: *btMultiBodyGearConstraint, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodyGearConstraint@@UEAAXPEAVbtIDebugDraw@@@Z";

    virtual_setGearRatio :: (this: *btMultiBodyGearConstraint, gearRatio: btScalar) -> void #cpp_method #foreign bullet3 "?setGearRatio@btMultiBodyGearConstraint@@UEAAXM@Z";

    virtual_setGearAuxLink :: (this: *btMultiBodyGearConstraint, gearAuxLink: s32) -> void #cpp_method #foreign bullet3 "?setGearAuxLink@btMultiBodyGearConstraint@@UEAAXH@Z";

    virtual_setRelativePositionTarget :: (this: *btMultiBodyGearConstraint, relPosTarget: btScalar) -> void #cpp_method #foreign bullet3 "?setRelativePositionTarget@btMultiBodyGearConstraint@@UEAAXM@Z";

    virtual_setErp :: (this: *btMultiBodyGearConstraint, erp: btScalar) -> void #cpp_method #foreign bullet3 "?setErp@btMultiBodyGearConstraint@@UEAAXM@Z";
}

btMultiBodyJointFeedback :: struct {
    m_reactionForces: btSpatialForceVector;
}

btMultiBodyJointLimitConstraint :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_lowerBound: btScalar;
    m_upperBound: btScalar;

    Constructor :: (this: *btMultiBodyJointLimitConstraint, body: *btMultiBody, link: s32, lower: btScalar, upper: btScalar) -> void #cpp_method #foreign bullet3 "??0btMultiBodyJointLimitConstraint@@QEAA@PEAVbtMultiBody@@HMM@Z";

    getLowerBound :: (this: *btMultiBodyJointLimitConstraint) -> btScalar #cpp_method #foreign bullet3 "?getLowerBound@btMultiBodyJointLimitConstraint@@QEBAMXZ";

    getUpperBound :: (this: *btMultiBodyJointLimitConstraint) -> btScalar #cpp_method #foreign bullet3 "?getUpperBound@btMultiBodyJointLimitConstraint@@QEBAMXZ";

    setLowerBound :: (this: *btMultiBodyJointLimitConstraint, lower: btScalar) -> void #cpp_method #foreign bullet3 "?setLowerBound@btMultiBodyJointLimitConstraint@@QEAAXM@Z";

    setUpperBound :: (this: *btMultiBodyJointLimitConstraint, upper: btScalar) -> void #cpp_method #foreign bullet3 "?setUpperBound@btMultiBodyJointLimitConstraint@@QEAAXM@Z";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodyJointLimitConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyJointLimitConstraint@@UEAA@XZ";

    virtual_finalizeMultiDof :: (this: *btMultiBodyJointLimitConstraint) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodyJointLimitConstraint@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodyJointLimitConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodyJointLimitConstraint@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodyJointLimitConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodyJointLimitConstraint@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodyJointLimitConstraint, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodyJointLimitConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_debugDraw :: (this: *btMultiBodyJointLimitConstraint, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodyJointLimitConstraint@@UEAAXPEAVbtIDebugDraw@@@Z";
}

btMultiBodyJointMotor :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_desiredVelocity: btScalar;
    m_desiredPosition: btScalar;
    m_kd:              btScalar;
    m_kp:              btScalar;
    m_erp:             btScalar;
    m_rhsClamp:        btScalar; //maximum error

    Constructor :: (this: *btMultiBodyJointMotor, body: *btMultiBody, link: s32, desiredVelocity: btScalar, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "??0btMultiBodyJointMotor@@QEAA@PEAVbtMultiBody@@HMM@Z";
    Constructor :: (this: *btMultiBodyJointMotor, body: *btMultiBody, link: s32, linkDoF: s32, desiredVelocity: btScalar, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "??0btMultiBodyJointMotor@@QEAA@PEAVbtMultiBody@@HHMM@Z";
    #place btmultibodyconstraint; btmultibodyjointmotor_vtable: *btMultiBodyJointMotor_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btMultiBodyJointMotor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyJointMotor@@UEAA@XZ";
    virtual_finalizeMultiDof :: (this: *btMultiBodyJointMotor) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodyJointMotor@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodyJointMotor) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodyJointMotor@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodyJointMotor) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodyJointMotor@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodyJointMotor, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodyJointMotor@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setVelocityTarget :: (this: *btMultiBodyJointMotor, velTarget: btScalar, kd: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setVelocityTarget@btMultiBodyJointMotor@@UEAAXMM@Z";

    virtual_setPositionTarget :: (this: *btMultiBodyJointMotor, posTarget: btScalar, kp: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setPositionTarget@btMultiBodyJointMotor@@UEAAXMM@Z";

    virtual_setErp :: (this: *btMultiBodyJointMotor, erp: btScalar) -> void #cpp_method #foreign bullet3 "?setErp@btMultiBodyJointMotor@@UEAAXM@Z";

    virtual_getErp :: (this: *btMultiBodyJointMotor) -> btScalar #cpp_method #foreign bullet3 "?getErp@btMultiBodyJointMotor@@UEBAMXZ";

    virtual_setRhsClamp :: (this: *btMultiBodyJointMotor, rhsClamp: btScalar) -> void #cpp_method #foreign bullet3 "?setRhsClamp@btMultiBodyJointMotor@@UEAAXM@Z";

    virtual_debugDraw :: (this: *btMultiBodyJointMotor, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodyJointMotor@@UEAAXPEAVbtIDebugDraw@@@Z";
}
btMultiBodyJointMotor_VTable :: struct #type_info_none {
    using btmultibodyconstraint: btMultiBodyConstraint_VTable;
    setVelocityTarget: (this: *btMultiBodyJointMotor, velTarget: btScalar, kd: btScalar = 1.0) -> void #cpp_method;

    setPositionTarget: (this: *btMultiBodyJointMotor, posTarget: btScalar, kp: btScalar = 1.0) -> void #cpp_method;

    getErp: (this: *btMultiBodyJointMotor) -> btScalar #cpp_method;

    setRhsClamp: (this: *btMultiBodyJointMotor, rhsClamp: btScalar) -> void #cpp_method;
}

btMultiBodyJointMotor_setVelocityTarget :: inline (this: *btMultiBodyJointMotor, velTarget: btScalar, kd: btScalar = 1.0) { this.btmultibodyjointmotor_vtable.setVelocityTarget(this, velTarget, kd); }

btMultiBodyJointMotor_setPositionTarget :: inline (this: *btMultiBodyJointMotor, posTarget: btScalar, kp: btScalar = 1.0) { this.btmultibodyjointmotor_vtable.setPositionTarget(this, posTarget, kp); }

btMultiBodyJointMotor_getErp :: inline (this: *btMultiBodyJointMotor) -> btScalar { return this.btmultibodyjointmotor_vtable.getErp(this); }

btMultiBodyJointMotor_setRhsClamp :: inline (this: *btMultiBodyJointMotor, rhsClamp: btScalar) { this.btmultibodyjointmotor_vtable.setRhsClamp(this, rhsClamp); }

vtable :: (obj: *btMultiBodyJointMotor) -> *btMultiBodyJointMotor_VTable { return obj.btmultibodyjointmotor_vtable; }


btMultiBodyMLCPConstraintSolver :: struct {
    #as using btmultibodyconstraintsolver: btMultiBodyConstraintSolver;

    /// A matrix in the MLCP formulation
    m_A:                              btMatrixXf;

    /// b vector in the MLCP formulation.
    m_b:                              btVectorXf;

    /// Constraint impulse, which is an output of MLCP solving.
    m_x:                              btVectorXf;

    /// Lower bound of constraint impulse, \c m_x.
    m_lo:                             btVectorXf;

    /// Upper bound of constraint impulse, \c m_x.
    m_hi:                             btVectorXf;

    /// Split impulse Cache vector corresponding to \c m_b.
    m_bSplit:                         btVectorXf;

    /// Split impulse cache vector corresponding to \c m_x.
    m_xSplit:                         btVectorXf;

    /// A matrix in the MLCP formulation
    m_multiBodyA:                     btMatrixXf;

    /// b vector in the MLCP formulation.
    m_multiBodyB:                     btVectorXf;

    /// Constraint impulse, which is an output of MLCP solving.
    m_multiBodyX:                     btVectorXf;

    /// Lower bound of constraint impulse, \c m_x.
    m_multiBodyLo:                    btVectorXf;

    /// Upper bound of constraint impulse, \c m_x.
    m_multiBodyHi:                    btVectorXf;

    /// Indices of normal contact constraint associated with frictional contact constraint for rigid bodies.
    ///
    /// This is used by the MLCP solver to update the upper bounds of frictional contact impulse given intermediate
    /// normal contact impulse. For example, i-th element represents the index of a normal constraint that is
    /// accosiated with i-th frictional contact constraint if i-th constraint is a frictional contact constraint.
    /// Otherwise, -1.
    m_limitDependencies:              btAlignedObjectArray(s32);

    /// Indices of normal contact constraint associated with frictional contact constraint for multibodies.
    ///
    /// This is used by the MLCP solver to update the upper bounds of frictional contact impulse given intermediate
    /// normal contact impulse. For example, i-th element represents the index of a normal constraint that is
    /// accosiated with i-th frictional contact constraint if i-th constraint is a frictional contact constraint.
    /// Otherwise, -1.
    m_multiBodyLimitDependencies:     btAlignedObjectArray(s32);

    /// Array of all the rigid body constraints
    m_allConstraintPtrArray:          btAlignedObjectArray(*btSolverConstraint);

    /// Array of all the multibody constraints
    m_multiBodyAllConstraintPtrArray: btAlignedObjectArray(*btMultiBodySolverConstraint);

    /// MLCP solver
    m_solver:                         *btMLCPSolverInterface;

    /// Count of fallbacks of using btSequentialImpulseConstraintSolver, which happens when the MLCP solver fails.
    m_fallback:                       s32;

    /// Cache variable for constraint Jacobian matrix.
    m_scratchJ3:                      btMatrixXf;

    /// Cache variable for constraint Jacobian times inverse mass matrix.
    m_scratchJInvM3:                  btMatrixXf;

    /// Cache variable for offsets.
    m_scratchOfs:                     btAlignedObjectArray(s32);

    /// Constructs MLCP terms for constraints of two rigid bodies
    createMLCPFastRigidBody :: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createMLCPFastRigidBody@btMultiBodyMLCPConstraintSolver@@IEAAXAEBUbtContactSolverInfo@@@Z";
    createMLCPFastRigidBody :: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: btContactSolverInfo) #no_context {
        createMLCPFastRigidBody(this, *infoGlobal);
    }

    /// Constructs MLCP terms for constraints of two multi-bodies or one rigid body and one multibody
    createMLCPFastMultiBody :: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createMLCPFastMultiBody@btMultiBodyMLCPConstraintSolver@@IEAAXAEBUbtContactSolverInfo@@@Z";
    createMLCPFastMultiBody :: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: btContactSolverInfo) #no_context {
        createMLCPFastMultiBody(this, *infoGlobal);
    }

    /// Constructor
    ///
    /// \param[in] solver MLCP solver. Assumed it's not null.
    /// \param[in] maxLCPSize Maximum size of LCP to solve using MLCP solver. If the MLCP size exceeds this number, sequaltial impulse method will be used.
    Constructor :: (this: *btMultiBodyMLCPConstraintSolver, solver: *btMLCPSolverInterface) -> void #cpp_method #foreign bullet3 "??0btMultiBodyMLCPConstraintSolver@@QEAA@PEAVbtMLCPSolverInterface@@@Z";

    /// Sets MLCP solver. Assumed it's not null.
    setMLCPSolver :: (this: *btMultiBodyMLCPConstraintSolver, solver: *btMLCPSolverInterface) -> void #cpp_method #foreign bullet3 "?setMLCPSolver@btMultiBodyMLCPConstraintSolver@@QEAAXPEAVbtMLCPSolverInterface@@@Z";

    /// Returns the number of fallbacks of using btSequentialImpulseConstraintSolver, which happens when the MLCP
    /// solver fails.
    getNumFallbacks :: (this: *btMultiBodyMLCPConstraintSolver) -> s32 #cpp_method #foreign bullet3 "?getNumFallbacks@btMultiBodyMLCPConstraintSolver@@QEBAHXZ";

    /// Sets the number of fallbacks. This function may be used to reset the number to zero.
    setNumFallbacks :: (this: *btMultiBodyMLCPConstraintSolver, num: s32) -> void #cpp_method #foreign bullet3 "?setNumFallbacks@btMultiBodyMLCPConstraintSolver@@QEAAXH@Z";
    #place btmultibodyconstraintsolver; btmultibodymlcpconstraintsolver_vtable: *btMultiBodyMLCPConstraintSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    /// Constructs MLCP terms, which are \c m_A, \c m_b, \c m_lo, and \c m_hi.
    virtual_createMLCPFast :: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createMLCPFast@btMultiBodyMLCPConstraintSolver@@MEAAXAEBUbtContactSolverInfo@@@Z";

    /// Solves MLCP and returns the success
    virtual_solveMLCP :: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> bool #cpp_method #foreign bullet3 "?solveMLCP@btMultiBodyMLCPConstraintSolver@@MEAA_NAEBUbtContactSolverInfo@@@Z";

    // Documentation inherited
    virtual_solveGroupCacheFriendlySetup :: (this: *btMultiBodyMLCPConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@btMultiBodyMLCPConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    // Documentation inherited
    virtual_solveGroupCacheFriendlyIterations :: (this: *btMultiBodyMLCPConstraintSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyIterations@btMultiBodyMLCPConstraintSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    /// Destructor
    virtual_Destructor :: (this: *btMultiBodyMLCPConstraintSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyMLCPConstraintSolver@@UEAA@XZ";

    /// Returns the constraint solver type.
    virtual_getSolverType :: (this: *btMultiBodyMLCPConstraintSolver) -> btConstraintSolverType #cpp_method #foreign bullet3 "?getSolverType@btMultiBodyMLCPConstraintSolver@@UEBA?AW4btConstraintSolverType@@XZ";
}
btMultiBodyMLCPConstraintSolver_VTable :: struct #type_info_none {
    using btmultibodyconstraintsolver: btMultiBodyConstraintSolver_VTable;
    createMLCPFast: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    solveMLCP: (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> bool #cpp_method;
}

btMultiBodyMLCPConstraintSolver_createMLCPFast :: inline (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) { this.btmultibodymlcpconstraintsolver_vtable.createMLCPFast(this, infoGlobal); }

btMultiBodyMLCPConstraintSolver_solveMLCP :: inline (this: *btMultiBodyMLCPConstraintSolver, infoGlobal: *btContactSolverInfo) -> bool { return this.btmultibodymlcpconstraintsolver_vtable.solveMLCP(this, infoGlobal); }

vtable :: (obj: *btMultiBodyMLCPConstraintSolver) -> *btMultiBodyMLCPConstraintSolver_VTable { return obj.btmultibodymlcpconstraintsolver_vtable; }



//#define BTMBP2PCONSTRAINT_BLOCK_ANGULAR_MOTION_TEST
btMultiBodyPoint2Point :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_rigidBodyA: *btRigidBody;
    m_rigidBodyB: *btRigidBody;
    m_pivotInA:   btVector3;
    m_pivotInB:   btVector3;

    Constructor :: (this: *btMultiBodyPoint2Point, body: *btMultiBody, link: s32, bodyB: *btRigidBody, pivotInA: *btVector3, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "??0btMultiBodyPoint2Point@@QEAA@PEAVbtMultiBody@@HPEAVbtRigidBody@@AEBVbtVector3@@2@Z";
    Constructor :: (this: *btMultiBodyPoint2Point, body: *btMultiBody, link: s32, bodyB: *btRigidBody, pivotInA: btVector3, pivotInB: btVector3) #no_context {
        Constructor(this, body, link, bodyB, *pivotInA, *pivotInB);
    }
    Constructor :: (this: *btMultiBodyPoint2Point, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: *btVector3, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "??0btMultiBodyPoint2Point@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1@Z";
    Constructor :: (this: *btMultiBodyPoint2Point, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: btVector3, pivotInB: btVector3) #no_context {
        Constructor(this, bodyA, linkA, bodyB, linkB, *pivotInA, *pivotInB);
    }

    getPivotInB :: (this: *btMultiBodyPoint2Point) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInB@btMultiBodyPoint2Point@@QEBAAEBVbtVector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodyPoint2Point, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodyPoint2Point@@UEAA@XZ";

    virtual_finalizeMultiDof :: (this: *btMultiBodyPoint2Point) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodyPoint2Point@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodyPoint2Point) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodyPoint2Point@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodyPoint2Point) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodyPoint2Point@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodyPoint2Point, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodyPoint2Point@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setPivotInB :: (this: *btMultiBodyPoint2Point, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInB@btMultiBodyPoint2Point@@UEAAXAEBVbtVector3@@@Z";

    virtual_debugDraw :: (this: *btMultiBodyPoint2Point, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodyPoint2Point@@UEAAXPEAVbtIDebugDraw@@@Z";
}


btMultiBodySliderConstraint :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_rigidBodyA: *btRigidBody;
    m_rigidBodyB: *btRigidBody;
    m_pivotInA:   btVector3;
    m_pivotInB:   btVector3;
    m_frameInA:   btMatrix3x3;
    m_frameInB:   btMatrix3x3;
    m_jointAxis:  btVector3;

    Constructor :: (this: *btMultiBodySliderConstraint, body: *btMultiBody, link: s32, bodyB: *btRigidBody, pivotInA: *btVector3, pivotInB: *btVector3, frameInA: *btMatrix3x3, frameInB: *btMatrix3x3, jointAxis: *btVector3) -> void #cpp_method #foreign bullet3 "??0btMultiBodySliderConstraint@@QEAA@PEAVbtMultiBody@@HPEAVbtRigidBody@@AEBVbtVector3@@2AEBVbtMatrix3x3@@32@Z";
    Constructor :: (this: *btMultiBodySliderConstraint, body: *btMultiBody, link: s32, bodyB: *btRigidBody, pivotInA: btVector3, pivotInB: btVector3, frameInA: btMatrix3x3, frameInB: btMatrix3x3, jointAxis: btVector3) #no_context {
        Constructor(this, body, link, bodyB, *pivotInA, *pivotInB, *frameInA, *frameInB, *jointAxis);
    }
    Constructor :: (this: *btMultiBodySliderConstraint, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: *btVector3, pivotInB: *btVector3, frameInA: *btMatrix3x3, frameInB: *btMatrix3x3, jointAxis: *btVector3) -> void #cpp_method #foreign bullet3 "??0btMultiBodySliderConstraint@@QEAA@PEAVbtMultiBody@@H0HAEBVbtVector3@@1AEBVbtMatrix3x3@@21@Z";
    Constructor :: (this: *btMultiBodySliderConstraint, bodyA: *btMultiBody, linkA: s32, bodyB: *btMultiBody, linkB: s32, pivotInA: btVector3, pivotInB: btVector3, frameInA: btMatrix3x3, frameInB: btMatrix3x3, jointAxis: btVector3) #no_context {
        Constructor(this, bodyA, linkA, bodyB, linkB, *pivotInA, *pivotInB, *frameInA, *frameInB, *jointAxis);
    }

    getPivotInA :: (this: *btMultiBodySliderConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInA@btMultiBodySliderConstraint@@QEBAAEBVbtVector3@@XZ";

    setPivotInA :: (this: *btMultiBodySliderConstraint, pivotInA: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInA@btMultiBodySliderConstraint@@QEAAXAEBVbtVector3@@@Z";
    setPivotInA :: (this: *btMultiBodySliderConstraint, pivotInA: btVector3) #no_context {
        setPivotInA(this, *pivotInA);
    }

    getPivotInB :: (this: *btMultiBodySliderConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getPivotInB@btMultiBodySliderConstraint@@QEBAAEBVbtVector3@@XZ";

    getFrameInA :: (this: *btMultiBodySliderConstraint) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getFrameInA@btMultiBodySliderConstraint@@QEBAAEBVbtMatrix3x3@@XZ";

    setFrameInA :: (this: *btMultiBodySliderConstraint, frameInA: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInA@btMultiBodySliderConstraint@@QEAAXAEBVbtMatrix3x3@@@Z";
    setFrameInA :: (this: *btMultiBodySliderConstraint, frameInA: btMatrix3x3) #no_context {
        setFrameInA(this, *frameInA);
    }

    getFrameInB :: (this: *btMultiBodySliderConstraint) -> *btMatrix3x3 #cpp_method #foreign bullet3 "?getFrameInB@btMultiBodySliderConstraint@@QEBAAEBVbtMatrix3x3@@XZ";

    getJointAxis :: (this: *btMultiBodySliderConstraint) -> *btVector3 #cpp_method #foreign bullet3 "?getJointAxis@btMultiBodySliderConstraint@@QEBAAEBVbtVector3@@XZ";

    setJointAxis :: (this: *btMultiBodySliderConstraint, jointAxis: *btVector3) -> void #cpp_method #foreign bullet3 "?setJointAxis@btMultiBodySliderConstraint@@QEAAXAEBVbtVector3@@@Z";
    setJointAxis :: (this: *btMultiBodySliderConstraint, jointAxis: btVector3) #no_context {
        setJointAxis(this, *jointAxis);
    }

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodySliderConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodySliderConstraint@@UEAA@XZ";

    virtual_finalizeMultiDof :: (this: *btMultiBodySliderConstraint) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodySliderConstraint@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodySliderConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodySliderConstraint@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodySliderConstraint) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodySliderConstraint@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodySliderConstraint, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodySliderConstraint@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setPivotInB :: (this: *btMultiBodySliderConstraint, pivotInB: *btVector3) -> void #cpp_method #foreign bullet3 "?setPivotInB@btMultiBodySliderConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_setFrameInB :: (this: *btMultiBodySliderConstraint, frameInB: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?setFrameInB@btMultiBodySliderConstraint@@UEAAXAEBVbtMatrix3x3@@@Z";

    virtual_debugDraw :: (this: *btMultiBodySliderConstraint, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodySliderConstraint@@UEAAXPEAVbtIDebugDraw@@@Z";
}

btMultiBodySphericalJointLimit :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_desiredVelocity:           btVector3;
    m_desiredPosition:           btQuaternion;
    m_use_multi_dof_params:      bool;
    m_kd:                        btVector3;
    m_kp:                        btVector3;
    m_erp:                       btScalar;
    m_rhsClamp:                  btScalar; //maximum error
    m_maxAppliedImpulseMultiDof: btVector3;
    m_pivotA:                    btVector3;
    m_pivotB:                    btVector3;
    m_swingxRange:               btScalar;
    m_swingyRange:               btScalar;
    m_twistRange:                btScalar;

    Constructor :: (this: *btMultiBodySphericalJointLimit, body: *btMultiBody, link: s32, swingxRange: btScalar, swingyRange: btScalar, twistRange: btScalar, maxAppliedImpulse: btScalar) -> void #cpp_method #foreign bullet3 "??0btMultiBodySphericalJointLimit@@QEAA@PEAVbtMultiBody@@HMMMM@Z";

    getMaxAppliedImpulseMultiDof :: (this: *btMultiBodySphericalJointLimit, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getMaxAppliedImpulseMultiDof@btMultiBodySphericalJointLimit@@QEBAMH@Z";

    setMaxAppliedImpulseMultiDof :: (this: *btMultiBodySphericalJointLimit, maxImp: *btVector3) -> void #cpp_method #foreign bullet3 "?setMaxAppliedImpulseMultiDof@btMultiBodySphericalJointLimit@@QEAAXAEBVbtVector3@@@Z";
    setMaxAppliedImpulseMultiDof :: (this: *btMultiBodySphericalJointLimit, maxImp: btVector3) #no_context {
        setMaxAppliedImpulseMultiDof(this, *maxImp);
    }
    #place btmultibodyconstraint; btmultibodysphericaljointlimit_vtable: *btMultiBodySphericalJointLimit_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodySphericalJointLimit, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodySphericalJointLimit@@UEAA@XZ";
    virtual_finalizeMultiDof :: (this: *btMultiBodySphericalJointLimit) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodySphericalJointLimit@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodySphericalJointLimit) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodySphericalJointLimit@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodySphericalJointLimit) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodySphericalJointLimit@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodySphericalJointLimit, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodySphericalJointLimit@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setVelocityTarget :: (this: *btMultiBodySphericalJointLimit, velTarget: *btVector3, kd: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setVelocityTarget@btMultiBodySphericalJointLimit@@UEAAXAEBVbtVector3@@M@Z";

    virtual_setVelocityTargetMultiDof :: (this: *btMultiBodySphericalJointLimit, velTarget: *btVector3, kd: *btVector3) -> void #cpp_method #foreign bullet3 "?setVelocityTargetMultiDof@btMultiBodySphericalJointLimit@@UEAAXAEBVbtVector3@@0@Z";
    setVelocityTargetMultiDof :: (this: *btMultiBodySphericalJointLimit, velTarget: btVector3, kd: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setVelocityTargetMultiDof(this, *velTarget, *kd);
    }

    virtual_setPositionTarget :: (this: *btMultiBodySphericalJointLimit, posTarget: *btQuaternion, kp: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setPositionTarget@btMultiBodySphericalJointLimit@@UEAAXAEBVbtQuaternion@@M@Z";

    virtual_setPositionTargetMultiDof :: (this: *btMultiBodySphericalJointLimit, posTarget: *btQuaternion, kp: *btVector3) -> void #cpp_method #foreign bullet3 "?setPositionTargetMultiDof@btMultiBodySphericalJointLimit@@UEAAXAEBVbtQuaternion@@AEBVbtVector3@@@Z";
    setPositionTargetMultiDof :: (this: *btMultiBodySphericalJointLimit, posTarget: btQuaternion, kp: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setPositionTargetMultiDof(this, *posTarget, *kp);
    }

    virtual_setErp :: (this: *btMultiBodySphericalJointLimit, erp: btScalar) -> void #cpp_method #foreign bullet3 "?setErp@btMultiBodySphericalJointLimit@@UEAAXM@Z";

    virtual_getErp :: (this: *btMultiBodySphericalJointLimit) -> btScalar #cpp_method #foreign bullet3 "?getErp@btMultiBodySphericalJointLimit@@UEBAMXZ";

    virtual_setRhsClamp :: (this: *btMultiBodySphericalJointLimit, rhsClamp: btScalar) -> void #cpp_method #foreign bullet3 "?setRhsClamp@btMultiBodySphericalJointLimit@@UEAAXM@Z";

    virtual_debugDraw :: (this: *btMultiBodySphericalJointLimit, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodySphericalJointLimit@@UEAAXPEAVbtIDebugDraw@@@Z";
}
btMultiBodySphericalJointLimit_VTable :: struct #type_info_none {
    using btmultibodyconstraint: btMultiBodyConstraint_VTable;
    setVelocityTarget: (this: *btMultiBodySphericalJointLimit, velTarget: *btVector3, kd: btScalar = 1.0) -> void #cpp_method;

    setVelocityTargetMultiDof: (this: *btMultiBodySphericalJointLimit, velTarget: *btVector3, kd: *btVector3) -> void #cpp_method;
    setVelocityTargetMultiDof :: (this: *btMultiBodySphericalJointLimit, velTarget: btVector3, kd: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setVelocityTargetMultiDof(this, *velTarget, *kd);
    }

    setPositionTarget: (this: *btMultiBodySphericalJointLimit, posTarget: *btQuaternion, kp: btScalar = 1.0) -> void #cpp_method;

    setPositionTargetMultiDof: (this: *btMultiBodySphericalJointLimit, posTarget: *btQuaternion, kp: *btVector3) -> void #cpp_method;
    setPositionTargetMultiDof :: (this: *btMultiBodySphericalJointLimit, posTarget: btQuaternion, kp: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setPositionTargetMultiDof(this, *posTarget, *kp);
    }

    getErp: (this: *btMultiBodySphericalJointLimit) -> btScalar #cpp_method;

    setRhsClamp: (this: *btMultiBodySphericalJointLimit, rhsClamp: btScalar) -> void #cpp_method;
}

btMultiBodySphericalJointLimit_setVelocityTarget :: inline (this: *btMultiBodySphericalJointLimit, velTarget: *btVector3, kd: btScalar = 1.0) { this.btmultibodysphericaljointlimit_vtable.setVelocityTarget(this, velTarget, kd); }

btMultiBodySphericalJointLimit_setVelocityTargetMultiDof :: inline (this: *btMultiBodySphericalJointLimit, velTarget: *btVector3, kd: *btVector3) { this.btmultibodysphericaljointlimit_vtable.setVelocityTargetMultiDof(this, velTarget, kd); }

btMultiBodySphericalJointLimit_setPositionTarget :: inline (this: *btMultiBodySphericalJointLimit, posTarget: *btQuaternion, kp: btScalar = 1.0) { this.btmultibodysphericaljointlimit_vtable.setPositionTarget(this, posTarget, kp); }

btMultiBodySphericalJointLimit_setPositionTargetMultiDof :: inline (this: *btMultiBodySphericalJointLimit, posTarget: *btQuaternion, kp: *btVector3) { this.btmultibodysphericaljointlimit_vtable.setPositionTargetMultiDof(this, posTarget, kp); }

btMultiBodySphericalJointLimit_getErp :: inline (this: *btMultiBodySphericalJointLimit) -> btScalar { return this.btmultibodysphericaljointlimit_vtable.getErp(this); }

btMultiBodySphericalJointLimit_setRhsClamp :: inline (this: *btMultiBodySphericalJointLimit, rhsClamp: btScalar) { this.btmultibodysphericaljointlimit_vtable.setRhsClamp(this, rhsClamp); }

vtable :: (obj: *btMultiBodySphericalJointLimit) -> *btMultiBodySphericalJointLimit_VTable { return obj.btmultibodysphericaljointlimit_vtable; }


btMultiBodySphericalJointMotor :: struct {
    #as using btmultibodyconstraint: btMultiBodyConstraint;

    m_desiredVelocity:           btVector3;
    m_desiredPosition:           btQuaternion;
    m_use_multi_dof_params:      bool;
    m_kd:                        btVector3;
    m_kp:                        btVector3;
    m_erp:                       btScalar;
    m_rhsClamp:                  btScalar; //maximum error
    m_maxAppliedImpulseMultiDof: btVector3;
    m_damping:                   btVector3;

    Constructor :: (this: *btMultiBodySphericalJointMotor, body: *btMultiBody, link: s32, maxMotorImpulse: btScalar) -> void #cpp_method #foreign bullet3 "??0btMultiBodySphericalJointMotor@@QEAA@PEAVbtMultiBody@@HM@Z";

    getMaxAppliedImpulseMultiDof :: (this: *btMultiBodySphericalJointMotor, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getMaxAppliedImpulseMultiDof@btMultiBodySphericalJointMotor@@QEBAMH@Z";

    setMaxAppliedImpulseMultiDof :: (this: *btMultiBodySphericalJointMotor, maxImp: *btVector3) -> void #cpp_method #foreign bullet3 "?setMaxAppliedImpulseMultiDof@btMultiBodySphericalJointMotor@@QEAAXAEBVbtVector3@@@Z";
    setMaxAppliedImpulseMultiDof :: (this: *btMultiBodySphericalJointMotor, maxImp: btVector3) #no_context {
        setMaxAppliedImpulseMultiDof(this, *maxImp);
    }

    getDamping :: (this: *btMultiBodySphericalJointMotor, i: s32) -> btScalar #cpp_method #foreign bullet3 "?getDamping@btMultiBodySphericalJointMotor@@QEBAMH@Z";

    setDamping :: (this: *btMultiBodySphericalJointMotor, damping: *btVector3) -> void #cpp_method #foreign bullet3 "?setDamping@btMultiBodySphericalJointMotor@@QEAAXAEBVbtVector3@@@Z";
    setDamping :: (this: *btMultiBodySphericalJointMotor, damping: btVector3) #no_context {
        setDamping(this, *damping);
    }
    #place btmultibodyconstraint; btmultibodysphericaljointmotor_vtable: *btMultiBodySphericalJointMotor_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btMultiBodySphericalJointMotor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMultiBodySphericalJointMotor@@UEAA@XZ";
    virtual_finalizeMultiDof :: (this: *btMultiBodySphericalJointMotor) -> void #cpp_method #foreign bullet3 "?finalizeMultiDof@btMultiBodySphericalJointMotor@@UEAAXXZ";

    virtual_getIslandIdA :: (this: *btMultiBodySphericalJointMotor) -> s32 #cpp_method #foreign bullet3 "?getIslandIdA@btMultiBodySphericalJointMotor@@UEBAHXZ";
    virtual_getIslandIdB :: (this: *btMultiBodySphericalJointMotor) -> s32 #cpp_method #foreign bullet3 "?getIslandIdB@btMultiBodySphericalJointMotor@@UEBAHXZ";

    virtual_createConstraintRows :: (this: *btMultiBodySphericalJointMotor, constraintRows: *btMultiBodyConstraintArray, data: *btMultiBodyJacobianData, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createConstraintRows@btMultiBodySphericalJointMotor@@UEAAXAEAV?$btAlignedObjectArray@UbtMultiBodySolverConstraint@@@@AEAUbtMultiBodyJacobianData@@AEBUbtContactSolverInfo@@@Z";

    virtual_setVelocityTarget :: (this: *btMultiBodySphericalJointMotor, velTarget: *btVector3, kd: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setVelocityTarget@btMultiBodySphericalJointMotor@@UEAAXAEBVbtVector3@@M@Z";

    virtual_setVelocityTargetMultiDof :: (this: *btMultiBodySphericalJointMotor, velTarget: *btVector3, kd: *btVector3) -> void #cpp_method #foreign bullet3 "?setVelocityTargetMultiDof@btMultiBodySphericalJointMotor@@UEAAXAEBVbtVector3@@0@Z";
    setVelocityTargetMultiDof :: (this: *btMultiBodySphericalJointMotor, velTarget: btVector3, kd: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setVelocityTargetMultiDof(this, *velTarget, *kd);
    }

    virtual_setPositionTarget :: (this: *btMultiBodySphericalJointMotor, posTarget: *btQuaternion, kp: btScalar = 1.0) -> void #cpp_method #foreign bullet3 "?setPositionTarget@btMultiBodySphericalJointMotor@@UEAAXAEBVbtQuaternion@@M@Z";

    virtual_setPositionTargetMultiDof :: (this: *btMultiBodySphericalJointMotor, posTarget: *btQuaternion, kp: *btVector3) -> void #cpp_method #foreign bullet3 "?setPositionTargetMultiDof@btMultiBodySphericalJointMotor@@UEAAXAEBVbtQuaternion@@AEBVbtVector3@@@Z";
    setPositionTargetMultiDof :: (this: *btMultiBodySphericalJointMotor, posTarget: btQuaternion, kp: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setPositionTargetMultiDof(this, *posTarget, *kp);
    }

    virtual_setErp :: (this: *btMultiBodySphericalJointMotor, erp: btScalar) -> void #cpp_method #foreign bullet3 "?setErp@btMultiBodySphericalJointMotor@@UEAAXM@Z";

    virtual_getErp :: (this: *btMultiBodySphericalJointMotor) -> btScalar #cpp_method #foreign bullet3 "?getErp@btMultiBodySphericalJointMotor@@UEBAMXZ";

    virtual_setRhsClamp :: (this: *btMultiBodySphericalJointMotor, rhsClamp: btScalar) -> void #cpp_method #foreign bullet3 "?setRhsClamp@btMultiBodySphericalJointMotor@@UEAAXM@Z";

    virtual_debugDraw :: (this: *btMultiBodySphericalJointMotor, drawer: *btIDebugDraw) -> void #cpp_method #foreign bullet3 "?debugDraw@btMultiBodySphericalJointMotor@@UEAAXPEAVbtIDebugDraw@@@Z";
}
btMultiBodySphericalJointMotor_VTable :: struct #type_info_none {
    using btmultibodyconstraint: btMultiBodyConstraint_VTable;
    setVelocityTarget: (this: *btMultiBodySphericalJointMotor, velTarget: *btVector3, kd: btScalar = 1.0) -> void #cpp_method;

    setVelocityTargetMultiDof: (this: *btMultiBodySphericalJointMotor, velTarget: *btVector3, kd: *btVector3) -> void #cpp_method;
    setVelocityTargetMultiDof :: (this: *btMultiBodySphericalJointMotor, velTarget: btVector3, kd: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setVelocityTargetMultiDof(this, *velTarget, *kd);
    }

    setPositionTarget: (this: *btMultiBodySphericalJointMotor, posTarget: *btQuaternion, kp: btScalar = 1.0) -> void #cpp_method;

    setPositionTargetMultiDof: (this: *btMultiBodySphericalJointMotor, posTarget: *btQuaternion, kp: *btVector3) -> void #cpp_method;
    setPositionTargetMultiDof :: (this: *btMultiBodySphericalJointMotor, posTarget: btQuaternion, kp: btVector3 = btVector3.{1.0, 1.0, 1.0}) #no_context {
        setPositionTargetMultiDof(this, *posTarget, *kp);
    }

    getErp: (this: *btMultiBodySphericalJointMotor) -> btScalar #cpp_method;

    setRhsClamp: (this: *btMultiBodySphericalJointMotor, rhsClamp: btScalar) -> void #cpp_method;
}

btMultiBodySphericalJointMotor_setVelocityTarget :: inline (this: *btMultiBodySphericalJointMotor, velTarget: *btVector3, kd: btScalar = 1.0) { this.btmultibodysphericaljointmotor_vtable.setVelocityTarget(this, velTarget, kd); }

btMultiBodySphericalJointMotor_setVelocityTargetMultiDof :: inline (this: *btMultiBodySphericalJointMotor, velTarget: *btVector3, kd: *btVector3) { this.btmultibodysphericaljointmotor_vtable.setVelocityTargetMultiDof(this, velTarget, kd); }

btMultiBodySphericalJointMotor_setPositionTarget :: inline (this: *btMultiBodySphericalJointMotor, posTarget: *btQuaternion, kp: btScalar = 1.0) { this.btmultibodysphericaljointmotor_vtable.setPositionTarget(this, posTarget, kp); }

btMultiBodySphericalJointMotor_setPositionTargetMultiDof :: inline (this: *btMultiBodySphericalJointMotor, posTarget: *btQuaternion, kp: *btVector3) { this.btmultibodysphericaljointmotor_vtable.setPositionTargetMultiDof(this, posTarget, kp); }

btMultiBodySphericalJointMotor_getErp :: inline (this: *btMultiBodySphericalJointMotor) -> btScalar { return this.btmultibodysphericaljointmotor_vtable.getErp(this); }

btMultiBodySphericalJointMotor_setRhsClamp :: inline (this: *btMultiBodySphericalJointMotor, rhsClamp: btScalar) { this.btmultibodysphericaljointmotor_vtable.setRhsClamp(this, rhsClamp); }

vtable :: (obj: *btMultiBodySphericalJointMotor) -> *btMultiBodySphericalJointMotor_VTable { return obj.btmultibodysphericaljointmotor_vtable; }


btDantzigScratchMemory :: struct {
    m_scratch: btAlignedObjectArray(btScalar);
    L:         btAlignedObjectArray(btScalar);
    d:         btAlignedObjectArray(btScalar);
    delta_w:   btAlignedObjectArray(btScalar);
    delta_x:   btAlignedObjectArray(btScalar);
    Dell:      btAlignedObjectArray(btScalar);
    ell:       btAlignedObjectArray(btScalar);
    Arows:     btAlignedObjectArray(*btScalar);
    p:         btAlignedObjectArray(s32);
    C:         btAlignedObjectArray(s32);
    state:     btAlignedObjectArray(bool);
}

btMLCPSolverInterface :: struct {
    vtable: *btMLCPSolverInterface_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btMLCPSolverInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMLCPSolverInterface@@UEAA@XZ";
}
btMLCPSolverInterface_VTable :: struct #type_info_none {
    Destructor: (this: *btMLCPSolverInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    solveMLCP: (this: *btMLCPSolverInterface, A: *btMatrixXf, b: *btVectorXf, x: *btVectorXf, lo: *btVectorXf, hi: *btVectorXf, limitDependency: *btAlignedObjectArray(s32), numIterations: s32, useSparsity := true) -> bool #cpp_method;
}

btMLCPSolverInterface_Destructor :: inline (this: *btMLCPSolverInterface, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btMLCPSolverInterface_solveMLCP :: inline (this: *btMLCPSolverInterface, A: *btMatrixXf, b: *btVectorXf, x: *btVectorXf, lo: *btVectorXf, hi: *btVectorXf, limitDependency: *btAlignedObjectArray(s32), numIterations: s32, useSparsity := true) -> bool { return this.vtable.solveMLCP(this, A, b, x, lo, hi, limitDependency, numIterations, useSparsity); }



btDantzigSolver :: struct {
    #as using btmlcpsolverinterface: btMLCPSolverInterface;

    m_acceptableUpperLimitSolution: btScalar;

    m_tempBuffer:                   btAlignedObjectArray(u8);

    m_A:                            btAlignedObjectArray(btScalar);
    m_b:                            btAlignedObjectArray(btScalar);
    m_x:                            btAlignedObjectArray(btScalar);
    m_lo:                           btAlignedObjectArray(btScalar);
    m_hi:                           btAlignedObjectArray(btScalar);
    m_dependencies:                 btAlignedObjectArray(s32);
    m_scratchMemory:                btDantzigScratchMemory;
}

btLemkeAlgorithm :: struct {
    vtable: *btLemkeAlgorithm_VTable;
    Constructor :: (this: *btLemkeAlgorithm, M_: *btMatrixXf, q_: *btVectorXf, DEBUGLEVEL_: *s32) -> void #cpp_method #foreign bullet3 "??0btLemkeAlgorithm@@QEAA@AEBU?$btMatrixX@M@@AEBU?$btVectorX@M@@AEBH@Z";
    Constructor :: (this: *btLemkeAlgorithm, M_: btMatrixXf, q_: btVectorXf, DEBUGLEVEL_: s32 = null) #no_context {
        Constructor(this, *M_, *q_, *DEBUGLEVEL_);
    }

    /* GETTER / SETTER */
    /**
    * \brief return info of solution process
    */
    getInfo :: (this: *btLemkeAlgorithm) -> s32 #cpp_method #foreign bullet3 "?getInfo@btLemkeAlgorithm@@QEAAHXZ";

    /**
    * \brief get the number of steps until the solution was found
    */
    getSteps :: (this: *btLemkeAlgorithm) -> s32 #cpp_method #foreign bullet3 "?getSteps@btLemkeAlgorithm@@QEAAHXZ";

    /**
    * \brief set system with Matrix M and vector q
    */
    setSystem :: (this: *btLemkeAlgorithm, M_: *btMatrixXf, q_: *btVectorXf) -> void #cpp_method #foreign bullet3 "?setSystem@btLemkeAlgorithm@@QEAAXAEBU?$btMatrixX@M@@AEBU?$btVectorX@M@@@Z";
    setSystem :: (this: *btLemkeAlgorithm, M_: btMatrixXf, q_: btVectorXf) #no_context {
        setSystem(this, *M_, *q_);
    }

    /**
    * \brief solve algorithm adapted from : Fast Implementation of Lemkes Algorithm for Rigid Body Contact Simulation (John E. Lloyd)
    */
    solve :: (this: *btLemkeAlgorithm, maxloops: u32 = 0) -> btVectorXf #cpp_method #foreign bullet3 "?solve@btLemkeAlgorithm@@QEAA?AU?$btVectorX@M@@I@Z";

    findLexicographicMinimum :: (this: *btLemkeAlgorithm, A: *btMatrixXf, pivotColIndex: *s32) -> s32 #cpp_method #foreign bullet3 "?findLexicographicMinimum@btLemkeAlgorithm@@IEAAHAEBU?$btMatrixX@M@@AEBH@Z";
    findLexicographicMinimum :: (this: *btLemkeAlgorithm, A: btMatrixXf, pivotColIndex: s32) -> s32 #no_context {
        return findLexicographicMinimum(this, *A, *pivotColIndex);
    }
    LexicographicPositive :: (this: *btLemkeAlgorithm, v: *btVectorXf) -> bool #cpp_method #foreign bullet3 "?LexicographicPositive@btLemkeAlgorithm@@IEAA_NAEBU?$btVectorX@M@@@Z";
    LexicographicPositive :: (this: *btLemkeAlgorithm, v: btVectorXf) -> bool #no_context {
        return LexicographicPositive(this, *v);
    }
    GaussJordanEliminationStep :: (this: *btLemkeAlgorithm, A: *btMatrixXf, pivotRowIndex: s32, pivotColumnIndex: s32, basis: *btAlignedObjectArray(s32)) -> void #cpp_method #foreign bullet3 "?GaussJordanEliminationStep@btLemkeAlgorithm@@IEAAXAEAU?$btMatrixX@M@@HHAEBV?$btAlignedObjectArray@H@@@Z";
    GaussJordanEliminationStep :: (this: *btLemkeAlgorithm, A: *btMatrixXf, pivotRowIndex: s32, pivotColumnIndex: s32, basis: btAlignedObjectArray(s32)) #no_context {
        GaussJordanEliminationStep(this, A, pivotRowIndex, pivotColumnIndex, *basis);
    }
    greaterZero :: (this: *btLemkeAlgorithm, vector: *btVectorXf) -> bool #cpp_method #foreign bullet3 "?greaterZero@btLemkeAlgorithm@@IEAA_NAEBU?$btVectorX@M@@@Z";
    greaterZero :: (this: *btLemkeAlgorithm, vector: btVectorXf) -> bool #no_context {
        return greaterZero(this, *vector);
    }
    validBasis :: (this: *btLemkeAlgorithm, basis: *btAlignedObjectArray(s32)) -> bool #cpp_method #foreign bullet3 "?validBasis@btLemkeAlgorithm@@IEAA_NAEBV?$btAlignedObjectArray@H@@@Z";
    validBasis :: (this: *btLemkeAlgorithm, basis: btAlignedObjectArray(s32)) -> bool #no_context {
        return validBasis(this, *basis);
    }

    m_M:        btMatrixXf;
    m_q:        btVectorXf;

    /**
    * \brief number of steps until the Lemke algorithm found a solution
    */
    steps:      u32;

    /**
    * \brief define level of debug output
    */
    DEBUGLEVEL: s32;

    /**
    * \brief did the algorithm find a solution
    *
    * -1 : not successful
    *  0 : successful
    */
    info:       s32;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btLemkeAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btLemkeAlgorithm@@UEAA@XZ";
}
btLemkeAlgorithm_VTable :: struct #type_info_none {
    Destructor: (this: *btLemkeAlgorithm, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
}
btLemkeAlgorithm_Destructor :: inline (this: *btLemkeAlgorithm, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }



///The btLemkeSolver is based on "Fast Implementation of Lemkes Algorithm for Rigid Body Contact Simulation (John E. Lloyd) "
///It is a slower but more accurate solver. Increase the m_maxLoops for better convergence, at the cost of more CPU time.
///The original implementation of the btLemkeAlgorithm was done by Kilian Grundl from the MBSim team
btLemkeSolver :: struct {
    #as using btmlcpsolverinterface: btMLCPSolverInterface;

    m_maxValue:        btScalar;
    m_debugLevel:      s32;
    m_maxLoops:        s32;
    m_useLoHighBounds: bool;
}

btMLCPSolver :: struct {
    #as using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver;

    m_A:                     btMatrixXf;
    m_b:                     btVectorXf;
    m_x:                     btVectorXf;
    m_lo:                    btVectorXf;
    m_hi:                    btVectorXf;

    ///when using 'split impulse' we solve two separate (M)LCPs
    m_bSplit:                btVectorXf;
    m_xSplit:                btVectorXf;
    m_bSplit1:               btVectorXf;
    m_xSplit2:               btVectorXf;

    m_limitDependencies:     btAlignedObjectArray(s32);
    m_allConstraintPtrArray: btAlignedObjectArray(*btSolverConstraint);
    m_solver:                *btMLCPSolverInterface;
    m_fallback:              s32;

    /// The following scratch variables are not stateful -- contents are cleared prior to each use.
    /// They are only cached here to avoid extra memory allocations and deallocations and to ensure
    /// that multiple instances of the solver can be run in parallel.
    m_scratchJ3:             btMatrixXf;
    m_scratchJInvM3:         btMatrixXf;
    m_scratchOfs:            btAlignedObjectArray(s32);
    m_scratchMInv:           btMatrixXf;
    m_scratchJ:              btMatrixXf;
    m_scratchJTranspose:     btMatrixXf;
    m_scratchTmp:            btMatrixXf;

    Constructor :: (this: *btMLCPSolver, solver: *btMLCPSolverInterface) -> void #cpp_method #foreign bullet3 "??0btMLCPSolver@@QEAA@PEAVbtMLCPSolverInterface@@@Z";

    setMLCPSolver :: (this: *btMLCPSolver, solver: *btMLCPSolverInterface) -> void #cpp_method #foreign bullet3 "?setMLCPSolver@btMLCPSolver@@QEAAXPEAVbtMLCPSolverInterface@@@Z";

    getNumFallbacks :: (this: *btMLCPSolver) -> s32 #cpp_method #foreign bullet3 "?getNumFallbacks@btMLCPSolver@@QEBAHXZ";

    setNumFallbacks :: (this: *btMLCPSolver, num: s32) -> void #cpp_method #foreign bullet3 "?setNumFallbacks@btMLCPSolver@@QEAAXH@Z";
    #place btsequentialimpulseconstraintsolver; btmlcpsolver_vtable: *btMLCPSolver_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveGroupCacheFriendlySetup :: (this: *btMLCPSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlySetup@btMLCPSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";
    virtual_solveGroupCacheFriendlyIterations :: (this: *btMLCPSolver, bodies: **btCollisionObject, numBodies: s32, manifoldPtr: **btPersistentManifold, numManifolds: s32, constraints: **btTypedConstraint, numConstraints: s32, infoGlobal: *btContactSolverInfo, debugDrawer: *btIDebugDraw) -> btScalar #cpp_method #foreign bullet3 "?solveGroupCacheFriendlyIterations@btMLCPSolver@@MEAAMPEAPEAVbtCollisionObject@@HPEAPEAVbtPersistentManifold@@HPEAPEAVbtTypedConstraint@@HAEBUbtContactSolverInfo@@PEAVbtIDebugDraw@@@Z";

    virtual_createMLCP :: (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createMLCP@btMLCPSolver@@MEAAXAEBUbtContactSolverInfo@@@Z";
    virtual_createMLCPFast :: (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?createMLCPFast@btMLCPSolver@@MEAAXAEBUbtContactSolverInfo@@@Z";

    //return true is it solves the problem successfully
    virtual_solveMLCP :: (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> bool #cpp_method #foreign bullet3 "?solveMLCP@btMLCPSolver@@MEAA_NAEBUbtContactSolverInfo@@@Z";

    virtual_Destructor :: (this: *btMLCPSolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btMLCPSolver@@UEAA@XZ";

    virtual_getSolverType :: (this: *btMLCPSolver) -> btConstraintSolverType #cpp_method #foreign bullet3 "?getSolverType@btMLCPSolver@@UEBA?AW4btConstraintSolverType@@XZ";
}
btMLCPSolver_VTable :: struct #type_info_none {
    using btsequentialimpulseconstraintsolver: btSequentialImpulseConstraintSolver_VTable;
    createMLCP: (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method;
    createMLCPFast: (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method;

    solveMLCP: (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> bool #cpp_method;
}

btMLCPSolver_createMLCP :: inline (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) { this.btmlcpsolver_vtable.createMLCP(this, infoGlobal); }
btMLCPSolver_createMLCPFast :: inline (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) { this.btmlcpsolver_vtable.createMLCPFast(this, infoGlobal); }

btMLCPSolver_solveMLCP :: inline (this: *btMLCPSolver, infoGlobal: *btContactSolverInfo) -> bool { return this.btmlcpsolver_vtable.solveMLCP(this, infoGlobal); }

vtable :: (obj: *btMLCPSolver) -> *btMLCPSolver_VTable { return obj.btmlcpsolver_vtable; }


///This solver is mainly for debug/learning purposes: it is functionally equivalent to the btSequentialImpulseConstraintSolver solver, but much slower (it builds the full LCP matrix)
btSolveProjectedGaussSeidel :: struct {
    #as using btmlcpsolverinterface: btMLCPSolverInterface;

    m_leastSquaresResidualThreshold: btScalar;
    m_leastSquaresResidual:          btScalar;

    Constructor :: (this: *btSolveProjectedGaussSeidel) -> void #cpp_method #foreign bullet3 "??0btSolveProjectedGaussSeidel@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_solveMLCP :: (this: *btSolveProjectedGaussSeidel, A: *btMatrixXf, b: *btVectorXf, x: *btVectorXf, lo: *btVectorXf, hi: *btVectorXf, limitDependency: *btAlignedObjectArray(s32), numIterations: s32, useSparsity := true) -> bool #cpp_method #foreign bullet3 "?solveMLCP@btSolveProjectedGaussSeidel@@UEAA_NAEBU?$btMatrixX@M@@AEBU?$btVectorX@M@@AEAU3@11AEBV?$btAlignedObjectArray@H@@H_N@Z";
}

// Reduced deformable body is a simplified deformable object embedded in a rigid frame.
btReducedDeformableBody :: struct {
    #as btsoftbody: btSoftBody; // jai: no "using" to avoid name-clashes

    //
    //  Typedefs
    //
    TVStack :: btAlignedObjectArray(btVector3);

    // typedef btAlignedObjectArray<btMatrix3x3> tBlockDiagMatrix;
    tDenseArray :: btAlignedObjectArray(btScalar);
    tDenseMatrix :: btAlignedObjectArray(btAlignedObjectArray(btScalar));

    // flag to turn off the reduced modes
    m_rigidOnly:                               bool;

    // Flags for transform. Once transform is applied, users cannot scale the mesh or change its total mass.
    m_transform_lock:                          bool;

    m_rhoScale:                                btScalar; // mass density scale
    m_ksScale:                                 btScalar; // stiffness scale

    m_projPA:                                  tDenseMatrix; // Eqn. 4.11 from Rahul Sheth's thesis
    m_projCq:                                  tDenseMatrix;
    m_STP:                                     tDenseArray;
    m_MrInvSTP:                                tDenseArray;

    m_localMomentArm:                          TVStack; // Sq + x0

    m_internalDeltaLinearVelocity:             btVector3;
    m_internalDeltaAngularVelocity:            btVector3;
    m_internalDeltaReducedVelocity:            tDenseArray;

    m_linearVelocityFromReduced:               btVector3; // contribution to the linear velocity from reduced velocity
    m_angularVelocityFromReduced:              btVector3; // contribution to the angular velocity from reduced velocity
    m_internalDeltaAngularVelocityFromReduced: btVector3;

    m_mass:                                    btScalar; // total mass of the rigid frame
    m_inverseMass:                             btScalar; // inverse of the total mass of the rigid frame
    m_linearVelocity:                          btVector3;
    m_angularVelocity:                         btVector3;
    m_linearDamping:                           btScalar; // linear damping coefficient
    m_angularDamping:                          btScalar; // angular damping coefficient
    m_linearFactor:                            btVector3;
    m_angularFactor:                           btVector3;

    // btVector3 m_invInertiaLocal;
    m_invInertiaLocal:                         btMatrix3x3;
    m_rigidTransformWorld:                     btTransform;
    m_invInertiaTensorWorldInitial:            btMatrix3x3;
    m_invInertiaTensorWorld:                   btMatrix3x3;
    m_interpolateInvInertiaTensorWorld:        btMatrix3x3;
    m_initialCoM:                              btVector3; // initial center of mass (original of the m_rigidTransformWorld)

    // damping
    m_dampingAlpha:                            btScalar;
    m_dampingBeta:                             btScalar;

    // reduced space
    m_nReduced:                                s32;
    m_nFull:                                   s32;
    m_modes:                                   tDenseMatrix; // modes of the reduced deformable model. Each inner array is a mode, outer array size = n_modes
    m_reducedDofs:                             tDenseArray; // Reduced degree of freedom
    m_reducedDofsBuffer:                       tDenseArray; // Reduced degree of freedom at t^n
    m_reducedVelocity:                         tDenseArray; // Reduced velocity array
    m_reducedVelocityBuffer:                   tDenseArray; // Reduced velocity array at t^n
    m_reducedForceExternal:                    tDenseArray; // reduced external force
    m_reducedForceElastic:                     tDenseArray; // reduced internal elastic force
    m_reducedForceDamping:                     tDenseArray; // reduced internal damping force
    m_eigenvalues:                             tDenseArray; // eigenvalues of the reduce deformable model
    m_Kr:                                      tDenseArray; // reduced stiffness matrix

    m_x0:                                      TVStack; // Rest position
    m_nodalMass:                               tDenseArray; // Mass on each node
    m_fixedNodes:                              btAlignedObjectArray(s32); // index of the fixed nodes
    m_nodeIndexOffset:                         s32; // offset of the node index needed for contact solver when there are multiple reduced deformable body in the world.

    // contacts
    m_contactNodesList:                        btAlignedObjectArray(s32);

    //
    // Api
    //
    Constructor :: (this: *btReducedDeformableBody, worldInfo: *btSoftBodyWorldInfo, node_count: s32, x: *btVector3, m: *btScalar) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableBody@@QEAA@PEAUbtSoftBodyWorldInfo@@HPEBVbtVector3@@PEBM@Z";

    //
    // initializing helpers
    //
    internalInitialization :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?internalInitialization@btReducedDeformableBody@@QEAAXXZ";

    setReducedModes :: (this: *btReducedDeformableBody, num_modes: s32, full_size: s32) -> void #cpp_method #foreign bullet3 "?setReducedModes@btReducedDeformableBody@@QEAAXHH@Z";

    setMassProps :: (this: *btReducedDeformableBody, mass_array: *tDenseArray) -> void #cpp_method #foreign bullet3 "?setMassProps@btReducedDeformableBody@@QEAAXAEBV?$btAlignedObjectArray@M@@@Z";
    setMassProps :: (this: *btReducedDeformableBody, mass_array: tDenseArray) #no_context {
        setMassProps(this, *mass_array);
    }

    setInertiaProps :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?setInertiaProps@btReducedDeformableBody@@QEAAXXZ";

    setRigidVelocity :: (this: *btReducedDeformableBody, v: *btVector3) -> void #cpp_method #foreign bullet3 "?setRigidVelocity@btReducedDeformableBody@@QEAAXAEBVbtVector3@@@Z";
    setRigidVelocity :: (this: *btReducedDeformableBody, v: btVector3) #no_context {
        setRigidVelocity(this, *v);
    }

    setRigidAngularVelocity :: (this: *btReducedDeformableBody, omega: *btVector3) -> void #cpp_method #foreign bullet3 "?setRigidAngularVelocity@btReducedDeformableBody@@QEAAXAEBVbtVector3@@@Z";
    setRigidAngularVelocity :: (this: *btReducedDeformableBody, omega: btVector3) #no_context {
        setRigidAngularVelocity(this, *omega);
    }

    setStiffnessScale :: (this: *btReducedDeformableBody, ks: btScalar) -> void #cpp_method #foreign bullet3 "?setStiffnessScale@btReducedDeformableBody@@QEAAXM@Z";

    setMassScale :: (this: *btReducedDeformableBody, rho: btScalar) -> void #cpp_method #foreign bullet3 "?setMassScale@btReducedDeformableBody@@QEAAXM@Z";

    setFixedNodes :: (this: *btReducedDeformableBody, n_node: s32) -> void #cpp_method #foreign bullet3 "?setFixedNodes@btReducedDeformableBody@@QEAAXH@Z";

    setDamping :: (this: *btReducedDeformableBody, alpha: btScalar, beta: btScalar) -> void #cpp_method #foreign bullet3 "?setDamping@btReducedDeformableBody@@QEAAXMM@Z";

    disableReducedModes :: (this: *btReducedDeformableBody, rigid_only: bool) -> void #cpp_method #foreign bullet3 "?disableReducedModes@btReducedDeformableBody@@QEAAX_N@Z";

    updateRestNodalPositions :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?updateRestNodalPositions@btReducedDeformableBody@@AEAAXXZ";

    updateInitialInertiaTensor :: (this: *btReducedDeformableBody, rotation: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?updateInitialInertiaTensor@btReducedDeformableBody@@AEAAXAEBVbtMatrix3x3@@@Z";
    updateInitialInertiaTensor :: (this: *btReducedDeformableBody, rotation: btMatrix3x3) #no_context {
        updateInitialInertiaTensor(this, *rotation);
    }

    updateLocalInertiaTensorFromNodes :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?updateLocalInertiaTensorFromNodes@btReducedDeformableBody@@AEAAXXZ";

    updateInertiaTensor :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?updateInertiaTensor@btReducedDeformableBody@@AEAAXXZ";

    updateModesByRotation :: (this: *btReducedDeformableBody, rotation: *btMatrix3x3) -> void #cpp_method #foreign bullet3 "?updateModesByRotation@btReducedDeformableBody@@AEAAXAEBVbtMatrix3x3@@@Z";
    updateModesByRotation :: (this: *btReducedDeformableBody, rotation: btMatrix3x3) #no_context {
        updateModesByRotation(this, *rotation);
    }

    updateLocalMomentArm :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?updateLocalMomentArm@btReducedDeformableBody@@QEAAXXZ";

    predictIntegratedTransform :: (this: *btReducedDeformableBody, dt: btScalar, predictedTransform: *btTransform) -> void #cpp_method #foreign bullet3 "?predictIntegratedTransform@btReducedDeformableBody@@QEAAXMAEAVbtTransform@@@Z";

    // update the external force projection matrix 
    updateExternalForceProjectMatrix :: (this: *btReducedDeformableBody, initialized: bool) -> void #cpp_method #foreign bullet3 "?updateExternalForceProjectMatrix@btReducedDeformableBody@@QEAAX_N@Z";

    endOfTimeStepZeroing :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?endOfTimeStepZeroing@btReducedDeformableBody@@QEAAXXZ";

    applyInternalVelocityChanges :: (this: *btReducedDeformableBody) -> void #cpp_method #foreign bullet3 "?applyInternalVelocityChanges@btReducedDeformableBody@@QEAAXXZ";

    // compute reduced degree of freedoms
    updateReducedDofs :: (this: *btReducedDeformableBody, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?updateReducedDofs@btReducedDeformableBody@@QEAAXM@Z";

    // compute reduced velocity update (for explicit time stepping)
    updateReducedVelocity :: (this: *btReducedDeformableBody, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?updateReducedVelocity@btReducedDeformableBody@@QEAAXM@Z";

    // map to full degree of freedoms
    mapToFullPosition :: (this: *btReducedDeformableBody, ref_trans: *btTransform) -> void #cpp_method #foreign bullet3 "?mapToFullPosition@btReducedDeformableBody@@QEAAXAEBVbtTransform@@@Z";
    mapToFullPosition :: (this: *btReducedDeformableBody, ref_trans: btTransform) #no_context {
        mapToFullPosition(this, *ref_trans);
    }

    // compute full space velocity from the reduced velocity
    mapToFullVelocity :: (this: *btReducedDeformableBody, ref_trans: *btTransform) -> void #cpp_method #foreign bullet3 "?mapToFullVelocity@btReducedDeformableBody@@QEAAXAEBVbtTransform@@@Z";
    mapToFullVelocity :: (this: *btReducedDeformableBody, ref_trans: btTransform) #no_context {
        mapToFullVelocity(this, *ref_trans);
    }

    // compute total angular momentum
    computeTotalAngularMomentum :: (this: *btReducedDeformableBody) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?computeTotalAngularMomentum@btReducedDeformableBody@@QEBA?BVbtVector3@@XZ";

    // get a single node's full space velocity from the reduced velocity
    computeNodeFullVelocity :: (this: *btReducedDeformableBody, ref_trans: *btTransform, n_node: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?computeNodeFullVelocity@btReducedDeformableBody@@QEBA?BVbtVector3@@AEBVbtTransform@@H@Z";
    computeNodeFullVelocity :: (this: *btReducedDeformableBody, ref_trans: btTransform, n_node: s32) -> btVector3 #no_context {
        return computeNodeFullVelocity(this, *ref_trans, n_node);
    }

    // get a single node's all delta velocity
    internalComputeNodeDeltaVelocity :: (this: *btReducedDeformableBody, ref_trans: *btTransform, n_node: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?internalComputeNodeDeltaVelocity@btReducedDeformableBody@@QEBA?BVbtVector3@@AEBVbtTransform@@H@Z";
    internalComputeNodeDeltaVelocity :: (this: *btReducedDeformableBody, ref_trans: btTransform, n_node: s32) -> btVector3 #no_context {
        return internalComputeNodeDeltaVelocity(this, *ref_trans, n_node);
    }

    //
    // rigid motion related
    //
    applyDamping :: (this: *btReducedDeformableBody, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?applyDamping@btReducedDeformableBody@@QEAAXM@Z";

    applyCentralImpulse :: (this: *btReducedDeformableBody, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyCentralImpulse@btReducedDeformableBody@@QEAAXAEBVbtVector3@@@Z";
    applyCentralImpulse :: (this: *btReducedDeformableBody, impulse: btVector3) #no_context {
        applyCentralImpulse(this, *impulse);
    }

    applyTorqueImpulse :: (this: *btReducedDeformableBody, torque: *btVector3) -> void #cpp_method #foreign bullet3 "?applyTorqueImpulse@btReducedDeformableBody@@QEAAXAEBVbtVector3@@@Z";
    applyTorqueImpulse :: (this: *btReducedDeformableBody, torque: btVector3) #no_context {
        applyTorqueImpulse(this, *torque);
    }

    proceedToTransform :: (this: *btReducedDeformableBody, dt: btScalar, end_of_time_step: bool) -> void #cpp_method #foreign bullet3 "?proceedToTransform@btReducedDeformableBody@@QEAAXM_N@Z";

    // apply impulse to the rigid frame
    internalApplyRigidImpulse :: (this: *btReducedDeformableBody, impulse: *btVector3, rel_pos: *btVector3) -> void #cpp_method #foreign bullet3 "?internalApplyRigidImpulse@btReducedDeformableBody@@QEAAXAEBVbtVector3@@0@Z";
    internalApplyRigidImpulse :: (this: *btReducedDeformableBody, impulse: btVector3, rel_pos: btVector3) #no_context {
        internalApplyRigidImpulse(this, *impulse, *rel_pos);
    }

    // apply impulse to nodes in the full space
    internalApplyFullSpaceImpulse :: (this: *btReducedDeformableBody, impulse: *btVector3, rel_pos: *btVector3, n_node: s32, dt: btScalar) -> void #cpp_method #foreign bullet3 "?internalApplyFullSpaceImpulse@btReducedDeformableBody@@QEAAXAEBVbtVector3@@0HM@Z";
    internalApplyFullSpaceImpulse :: (this: *btReducedDeformableBody, impulse: btVector3, rel_pos: btVector3, n_node: s32, dt: btScalar) #no_context {
        internalApplyFullSpaceImpulse(this, *impulse, *rel_pos, n_node, dt);
    }

    // apply nodal external force in the full space
    applyFullSpaceNodalForce :: (this: *btReducedDeformableBody, f_ext: *btVector3, n_node: s32) -> void #cpp_method #foreign bullet3 "?applyFullSpaceNodalForce@btReducedDeformableBody@@QEAAXAEBVbtVector3@@H@Z";
    applyFullSpaceNodalForce :: (this: *btReducedDeformableBody, f_ext: btVector3, n_node: s32) #no_context {
        applyFullSpaceNodalForce(this, *f_ext, n_node);
    }

    // apply gravity to the rigid frame
    applyRigidGravity :: (this: *btReducedDeformableBody, gravity: *btVector3, dt: btScalar) -> void #cpp_method #foreign bullet3 "?applyRigidGravity@btReducedDeformableBody@@QEAAXAEBVbtVector3@@M@Z";
    applyRigidGravity :: (this: *btReducedDeformableBody, gravity: btVector3, dt: btScalar) #no_context {
        applyRigidGravity(this, *gravity, dt);
    }

    // apply reduced elastic force
    applyReducedElasticForce :: (this: *btReducedDeformableBody, reduce_dofs: *tDenseArray) -> void #cpp_method #foreign bullet3 "?applyReducedElasticForce@btReducedDeformableBody@@QEAAXAEBV?$btAlignedObjectArray@M@@@Z";
    applyReducedElasticForce :: (this: *btReducedDeformableBody, reduce_dofs: tDenseArray) #no_context {
        applyReducedElasticForce(this, *reduce_dofs);
    }

    // apply reduced damping force
    applyReducedDampingForce :: (this: *btReducedDeformableBody, reduce_vel: *tDenseArray) -> void #cpp_method #foreign bullet3 "?applyReducedDampingForce@btReducedDeformableBody@@QEAAXAEBV?$btAlignedObjectArray@M@@@Z";
    applyReducedDampingForce :: (this: *btReducedDeformableBody, reduce_vel: tDenseArray) #no_context {
        applyReducedDampingForce(this, *reduce_vel);
    }

    // get relative position from a node to the CoM of the rigid frame
    getRelativePos :: (this: *btReducedDeformableBody, n_node: s32) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getRelativePos@btReducedDeformableBody@@QEAA?AVbtVector3@@H@Z";

    //
    // accessors
    //
    isReducedModesOFF :: (this: *btReducedDeformableBody) -> bool #cpp_method #foreign bullet3 "?isReducedModesOFF@btReducedDeformableBody@@QEBA_NXZ";
    getTotalMass :: (this: *btReducedDeformableBody) -> btScalar #cpp_method #foreign bullet3 "?getTotalMass@btReducedDeformableBody@@QEBAMXZ";
    getRigidTransform :: (this: *btReducedDeformableBody) -> *btTransform #cpp_method #foreign bullet3 "?getRigidTransform@btReducedDeformableBody@@QEAAAEAVbtTransform@@XZ";
    getLinearVelocity :: (this: *btReducedDeformableBody) -> *btVector3 #cpp_method #foreign bullet3 "?getLinearVelocity@btReducedDeformableBody@@QEBAAEBVbtVector3@@XZ";
    getAngularVelocity :: (this: *btReducedDeformableBody) -> *btVector3 #cpp_method #foreign bullet3 "?getAngularVelocity@btReducedDeformableBody@@QEBAAEBVbtVector3@@XZ";
    #place btsoftbody; btreduceddeformablebody_vtable: *btReducedDeformableBody_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btReducedDeformableBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btReducedDeformableBody@@UEAA@XZ";

    virtual_setTotalMass :: (this: *btReducedDeformableBody, mass: btScalar, fromfaces := false) -> void #cpp_method #foreign bullet3 "?setTotalMass@btReducedDeformableBody@@UEAAXM_N@Z";

    //
    // various internal updates
    //
    virtual_transformTo :: (this: *btReducedDeformableBody, trs: *btTransform) -> void #cpp_method #foreign bullet3 "?transformTo@btReducedDeformableBody@@UEAAXAEBVbtTransform@@@Z";
    virtual_transform :: (this: *btReducedDeformableBody, trs: *btTransform) -> void #cpp_method #foreign bullet3 "?transform@btReducedDeformableBody@@UEAAXAEBVbtTransform@@@Z";

    // caution: 
    // need to use scale before using transform, because the scale is performed in the local frame 
    // (i.e., may have some rotation already, but the m_rigidTransformWorld doesn't have this info)
    virtual_scale :: (this: *btReducedDeformableBody, scl: *btVector3) -> void #cpp_method #foreign bullet3 "?scale@btReducedDeformableBody@@UEAAXAEBVbtVector3@@@Z";

    // calculate the impulse factor
    virtual_getImpulseFactor :: (this: *btReducedDeformableBody, n_node: s32) -> btMatrix3x3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getImpulseFactor@btReducedDeformableBody@@UEAA?AVbtMatrix3x3@@H@Z";
}
btReducedDeformableBody_VTable :: struct #type_info_none {
    using btsoftbody: btSoftBody_VTable;
    setTotalMass: (this: *btReducedDeformableBody, mass: btScalar, fromfaces := false) -> void #cpp_method;
}
btReducedDeformableBody_setTotalMass :: inline (this: *btReducedDeformableBody, mass: btScalar, fromfaces := false) { this.btreduceddeformablebody_vtable.setTotalMass(this, mass, fromfaces); }

vtable :: (obj: *btReducedDeformableBody) -> *btReducedDeformableBody_VTable { return obj.btreduceddeformablebody_vtable; }


btReducedDeformableBodyHelpers :: struct {
    // create a reduced deformable object
    createReducedDeformableObject :: (worldInfo: *btSoftBodyWorldInfo, file_path: *std.string, vtk_file: *std.string, num_modes: s32, rigid_only: bool) -> *btReducedDeformableBody #foreign bullet3 "?createReducedDeformableObject@btReducedDeformableBodyHelpers@@SAPEAVbtReducedDeformableBody@@AEAUbtSoftBodyWorldInfo@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@1H_N@Z";
    createReducedDeformableObject :: (worldInfo: *btSoftBodyWorldInfo, file_path: std.string, vtk_file: std.string, num_modes: s32, rigid_only: bool) -> *btReducedDeformableBody #no_context {
        return createReducedDeformableObject(worldInfo, *file_path, *vtk_file, num_modes, rigid_only);
    }

    // read in geometry info from Vtk file
    createFromVtkFile :: (worldInfo: *btSoftBodyWorldInfo, vtk_file: *u8) -> *btReducedDeformableBody #foreign bullet3 "?createFromVtkFile@btReducedDeformableBodyHelpers@@SAPEAVbtReducedDeformableBody@@AEAUbtSoftBodyWorldInfo@@PEBD@Z";

    // read in all reduced files
    readReducedDeformableInfoFromFiles :: (rsb: *btReducedDeformableBody, file_path: *u8) -> void #foreign bullet3 "?readReducedDeformableInfoFromFiles@btReducedDeformableBodyHelpers@@SAXPEAVbtReducedDeformableBody@@PEBD@Z";

    // read in a binary vector
    readBinaryVec :: (vec: *btReducedDeformableBody.tDenseArray, n_size: u32, file: *u8) -> void #foreign bullet3 "?readBinaryVec@btReducedDeformableBodyHelpers@@SAXAEAV?$btAlignedObjectArray@M@@IPEBD@Z";

    // read in a binary matrix
    readBinaryMat :: (mat: *btReducedDeformableBody.tDenseMatrix, n_modes: u32, n_full: u32, file: *u8) -> void #foreign bullet3 "?readBinaryMat@btReducedDeformableBodyHelpers@@SAXAEAV?$btAlignedObjectArray@V?$btAlignedObjectArray@M@@@@IIPEBD@Z";

    // calculate the local inertia tensor for a box shape reduced deformable object
    calculateLocalInertia :: (inertia: *btVector3, mass: btScalar, half_extents: *btVector3, margin: *btVector3) -> void #foreign bullet3 "?calculateLocalInertia@btReducedDeformableBodyHelpers@@SAXAEAVbtVector3@@MAEBV2@1@Z";
    calculateLocalInertia :: (inertia: *btVector3, mass: btScalar, half_extents: btVector3, margin: btVector3) #no_context {
        calculateLocalInertia(inertia, mass, *half_extents, *margin);
    }
    __empty_struct_padding: u8; // C++ makes empty structs have length 1
}

// ================= static constraints ===================
btReducedDeformableStaticConstraint :: struct {
    #as using btdeformablestaticconstraint: btDeformableStaticConstraint;

    m_rsb:                 *btReducedDeformableBody;
    m_dt:                  btScalar;
    m_ri:                  btVector3 #align 8;
    m_targetPos:           btVector3;
    m_impulseDirection:    btVector3;
    m_impulseFactorMatrix: btMatrix3x3;
    m_impulseFactor:       btScalar;
    m_rhs:                 btScalar;
    m_appliedImpulse:      btScalar;
    m_erp:                 btScalar;

    Constructor :: (this: *btReducedDeformableStaticConstraint, rsb: *btReducedDeformableBody, node: *btSoftBody.Node, ri: *btVector3, x0: *btVector3, dir: *btVector3, infoGlobal: *btContactSolverInfo, dt: btScalar) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableStaticConstraint@@QEAA@PEAVbtReducedDeformableBody@@PEAUNode@btSoftBody@@AEBVbtVector3@@22AEBUbtContactSolverInfo@@M@Z";
    Constructor :: (this: *btReducedDeformableStaticConstraint, rsb: *btReducedDeformableBody, node: *btSoftBody.Node, ri: btVector3, x0: btVector3, dir: btVector3, infoGlobal: btContactSolverInfo, dt: btScalar) #no_context {
        Constructor(this, rsb, node, *ri, *x0, *dir, *infoGlobal, dt);
    }

    // btReducedDeformableStaticConstraint(const btReducedDeformableStaticConstraint& other);
    Constructor :: (this: *btReducedDeformableStaticConstraint) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableStaticConstraint@@QEAA@XZ";

    getDeltaVa :: (this: *btReducedDeformableStaticConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDeltaVa@btReducedDeformableStaticConstraint@@QEBA?AVbtVector3@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btReducedDeformableStaticConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btReducedDeformableStaticConstraint@@UEAA@XZ";

    virtual_solveConstraint :: (this: *btReducedDeformableStaticConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveConstraint@btReducedDeformableStaticConstraint@@UEAAMAEBUbtContactSolverInfo@@@Z";

    // this calls reduced deformable body's applyFullSpaceImpulse
    virtual_applyImpulse :: (this: *btReducedDeformableStaticConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btReducedDeformableStaticConstraint@@UEAAXAEBVbtVector3@@@Z";
}

// ================= base contact constraints ===================
btReducedDeformableRigidContactConstraint :: struct {
    #as using btdeformablerigidcontactconstraint: btDeformableRigidContactConstraint;

    m_collideStatic:            bool; // flag for collision with static object
    m_collideMultibody:         bool; // flag for collision with multibody

    m_nodeQueryIndex:           s32;
    m_solverBodyId:             s32; // for debugging

    m_rsb:                      *btReducedDeformableBody;
    m_solverBody:               *btSolverBody;
    m_dt:                       btScalar;

    m_appliedNormalImpulse:     btScalar;
    m_appliedTangentImpulse:    btScalar;
    m_appliedTangentImpulse2:   btScalar;
    m_normalImpulseFactor:      btScalar;
    m_tangentImpulseFactor:     btScalar;
    m_tangentImpulseFactor2:    btScalar;
    m_tangentImpulseFactorInv:  btScalar;
    m_tangentImpulseFactorInv2: btScalar;
    m_rhs:                      btScalar;
    m_rhs_tangent:              btScalar;
    m_rhs_tangent2:             btScalar;

    m_cfm:                      btScalar;
    m_cfm_friction:             btScalar;
    m_erp:                      btScalar;
    m_erp_friction:             btScalar;
    m_friction:                 btScalar;

    m_contactNormalA:           btVector3; // surface normal for rigid body (opposite direction as impulse)
    m_contactNormalB:           btVector3; // surface normal for reduced deformable body (opposite direction as impulse)
    m_contactTangent:           btVector3; // tangential direction of the relative velocity
    m_contactTangent2:          btVector3; // 2nd tangential direction of the relative velocity
    m_relPosA:                  btVector3; // relative position of the contact point for A (rigid)
    m_relPosB:                  btVector3; // relative position of the contact point for B
    m_impulseFactor:            btMatrix3x3; // total impulse matrix

    m_bufferVelocityA:          btVector3; // velocity at the beginning of the iteration
    m_bufferVelocityB:          btVector3;
    m_linearComponentNormal:    btVector3; // linear components for the solver body
    m_angularComponentNormal:   btVector3; // angular components for the solver body

    // since 2nd contact direction only applies to multibody, these components will never be used
    m_linearComponentTangent:   btVector3;
    m_angularComponentTangent:  btVector3;

    Constructor :: (this: *btReducedDeformableRigidContactConstraint, rsb: *btReducedDeformableBody, c: *btSoftBody.DeformableRigidContact, infoGlobal: *btContactSolverInfo, dt: btScalar) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableRigidContactConstraint@@QEAA@PEAVbtReducedDeformableBody@@AEBVDeformableRigidContact@btSoftBody@@AEBUbtContactSolverInfo@@M@Z";
    Constructor :: (this: *btReducedDeformableRigidContactConstraint, rsb: *btReducedDeformableBody, c: btSoftBody.DeformableRigidContact, infoGlobal: btContactSolverInfo, dt: btScalar) #no_context {
        Constructor(this, rsb, *c, *infoGlobal, dt);
    }

    // btReducedDeformableRigidContactConstraint(const btReducedDeformableRigidContactConstraint& other);
    Constructor :: (this: *btReducedDeformableRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableRigidContactConstraint@@QEAA@XZ";

    setSolverBody :: (this: *btReducedDeformableRigidContactConstraint, bodyId: s32, solver_body: *btSolverBody) -> void #cpp_method #foreign bullet3 "?setSolverBody@btReducedDeformableRigidContactConstraint@@QEAAXHAEAUbtSolverBody@@@Z";

    calculateTangentialImpulse :: (this: *btReducedDeformableRigidContactConstraint, deltaImpulse_tangent: *btScalar, appliedImpulse: *btScalar, rhs_tangent: btScalar, tangentImpulseFactorInv: btScalar, tangent: *btVector3, lower_limit: btScalar, upper_limit: btScalar, deltaV_rel: *btVector3) -> void #cpp_method #foreign bullet3 "?calculateTangentialImpulse@btReducedDeformableRigidContactConstraint@@QEAAXAEAM0MMAEBVbtVector3@@MM1@Z";
    calculateTangentialImpulse :: (this: *btReducedDeformableRigidContactConstraint, deltaImpulse_tangent: *btScalar, appliedImpulse: *btScalar, rhs_tangent: btScalar, tangentImpulseFactorInv: btScalar, tangent: btVector3, lower_limit: btScalar, upper_limit: btScalar, deltaV_rel: btVector3) #no_context {
        calculateTangentialImpulse(this, deltaImpulse_tangent, appliedImpulse, rhs_tangent, tangentImpulseFactorInv, *tangent, lower_limit, upper_limit, *deltaV_rel);
    }
    #place btdeformablerigidcontactconstraint; btreduceddeformablerigidcontactconstraint_vtable: *btReducedDeformableRigidContactConstraint_VTable;

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btReducedDeformableRigidContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btReducedDeformableRigidContactConstraint@@UEAA@XZ";

    virtual_warmStarting :: (this: *btReducedDeformableRigidContactConstraint) -> void #cpp_method #foreign bullet3 "?warmStarting@btReducedDeformableRigidContactConstraint@@UEAAXXZ";

    virtual_solveConstraint :: (this: *btReducedDeformableRigidContactConstraint, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveConstraint@btReducedDeformableRigidContactConstraint@@UEAAMAEBUbtContactSolverInfo@@@Z";

    virtual_applyImpulse :: (this: *btReducedDeformableRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btReducedDeformableRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_applySplitImpulse :: (this: *btReducedDeformableRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applySplitImpulse@btReducedDeformableRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";

    virtual_getVa :: (this: *btReducedDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVa@btReducedDeformableRigidContactConstraint@@UEBA?AVbtVector3@@XZ";
}
btReducedDeformableRigidContactConstraint_VTable :: struct #type_info_none {
    using btdeformablerigidcontactconstraint: btDeformableRigidContactConstraint_VTable;
    warmStarting: (this: *btReducedDeformableRigidContactConstraint) -> void #cpp_method;

    getDeltaVa: (this: *btReducedDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;
    getDeltaVb: (this: *btReducedDeformableRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod;
}

btReducedDeformableRigidContactConstraint_warmStarting :: inline (this: *btReducedDeformableRigidContactConstraint) { this.btreduceddeformablerigidcontactconstraint_vtable.warmStarting(this); }

btReducedDeformableRigidContactConstraint_getDeltaVa :: inline (this: *btReducedDeformableRigidContactConstraint) -> btVector3 { return this.btreduceddeformablerigidcontactconstraint_vtable.getDeltaVa(this); }
btReducedDeformableRigidContactConstraint_getDeltaVb :: inline (this: *btReducedDeformableRigidContactConstraint) -> btVector3 { return this.btreduceddeformablerigidcontactconstraint_vtable.getDeltaVb(this); }

vtable :: (obj: *btReducedDeformableRigidContactConstraint) -> *btReducedDeformableRigidContactConstraint_VTable { return obj.btreduceddeformablerigidcontactconstraint_vtable; }


// ================= node vs rigid constraints ===================
btReducedDeformableNodeRigidContactConstraint :: struct {
    #as using btreduceddeformablerigidcontactconstraint: btReducedDeformableRigidContactConstraint;

    m_node: *btSoftBody.Node;

    Constructor :: (this: *btReducedDeformableNodeRigidContactConstraint, rsb: *btReducedDeformableBody, contact: *btSoftBody.DeformableNodeRigidContact, infoGlobal: *btContactSolverInfo, dt: btScalar) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableNodeRigidContactConstraint@@QEAA@PEAVbtReducedDeformableBody@@AEBVDeformableNodeRigidContact@btSoftBody@@AEBUbtContactSolverInfo@@M@Z";
    Constructor :: (this: *btReducedDeformableNodeRigidContactConstraint, rsb: *btReducedDeformableBody, contact: btSoftBody.DeformableNodeRigidContact, infoGlobal: btContactSolverInfo, dt: btScalar) #no_context {
        Constructor(this, rsb, *contact, *infoGlobal, dt);
    }

    // btReducedDeformableNodeRigidContactConstraint(const btReducedDeformableNodeRigidContactConstraint& other);
    Constructor :: (this: *btReducedDeformableNodeRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableNodeRigidContactConstraint@@QEAA@XZ";

    // cast the contact to the desired type
    getContact :: (this: *btReducedDeformableNodeRigidContactConstraint) -> *btSoftBody.DeformableNodeRigidContact #cpp_method #foreign bullet3 "?getContact@btReducedDeformableNodeRigidContactConstraint@@QEBAPEBVDeformableNodeRigidContact@btSoftBody@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btReducedDeformableNodeRigidContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btReducedDeformableNodeRigidContactConstraint@@UEAA@XZ";

    virtual_warmStarting :: (this: *btReducedDeformableNodeRigidContactConstraint) -> void #cpp_method #foreign bullet3 "?warmStarting@btReducedDeformableNodeRigidContactConstraint@@UEAAXXZ";

    // get the velocity of the deformable node in contact
    virtual_getVb :: (this: *btReducedDeformableNodeRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btReducedDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity change of the rigid body
    virtual_getDeltaVa :: (this: *btReducedDeformableNodeRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDeltaVa@btReducedDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get velocity change of the node in contat
    virtual_getDeltaVb :: (this: *btReducedDeformableNodeRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDeltaVb@btReducedDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the split impulse velocity of the deformable face at the contact point
    virtual_getSplitVb :: (this: *btReducedDeformableNodeRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getSplitVb@btReducedDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity change of the input soft body node in the constraint
    virtual_getDv :: (this: *btReducedDeformableNodeRigidContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btReducedDeformableNodeRigidContactConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    // this calls reduced deformable body's applyFullSpaceImpulse
    virtual_applyImpulse :: (this: *btReducedDeformableNodeRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btReducedDeformableNodeRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";
}

// ================= face vs rigid constraints ===================
btReducedDeformableFaceRigidContactConstraint :: struct {
    #as using btreduceddeformablerigidcontactconstraint: btReducedDeformableRigidContactConstraint;

    m_face:              *btSoftBody.Face;
    m_useStrainLimiting: bool;

    Constructor :: (this: *btReducedDeformableFaceRigidContactConstraint, rsb: *btReducedDeformableBody, contact: *btSoftBody.DeformableFaceRigidContact, infoGlobal: *btContactSolverInfo, dt: btScalar, useStrainLimiting: bool) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableFaceRigidContactConstraint@@QEAA@PEAVbtReducedDeformableBody@@AEBVDeformableFaceRigidContact@btSoftBody@@AEBUbtContactSolverInfo@@M_N@Z";
    Constructor :: (this: *btReducedDeformableFaceRigidContactConstraint, rsb: *btReducedDeformableBody, contact: btSoftBody.DeformableFaceRigidContact, infoGlobal: btContactSolverInfo, dt: btScalar, useStrainLimiting: bool) #no_context {
        Constructor(this, rsb, *contact, *infoGlobal, dt, useStrainLimiting);
    }

    // btReducedDeformableFaceRigidContactConstraint(const btReducedDeformableFaceRigidContactConstraint& other);
    Constructor :: (this: *btReducedDeformableFaceRigidContactConstraint) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableFaceRigidContactConstraint@@QEAA@XZ";

    // cast the contact to the desired type
    getContact :: (this: *btReducedDeformableFaceRigidContactConstraint) -> *btSoftBody.DeformableFaceRigidContact #cpp_method #foreign bullet3 "?getContact@btReducedDeformableFaceRigidContactConstraint@@QEBAPEBVDeformableFaceRigidContact@btSoftBody@@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.

    virtual_Destructor :: (this: *btReducedDeformableFaceRigidContactConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btReducedDeformableFaceRigidContactConstraint@@UEAA@XZ";

    // get the velocity of the deformable face at the contact point
    virtual_getVb :: (this: *btReducedDeformableFaceRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getVb@btReducedDeformableFaceRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the split impulse velocity of the deformable face at the contact point
    virtual_getSplitVb :: (this: *btReducedDeformableFaceRigidContactConstraint) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getSplitVb@btReducedDeformableFaceRigidContactConstraint@@UEBA?AVbtVector3@@XZ";

    // get the velocity change of the input soft body node in the constraint
    virtual_getDv :: (this: *btReducedDeformableFaceRigidContactConstraint, unknown0: *btSoftBody.Node) -> btVector3 #cpp_method #cpp_return_type_is_non_pod #foreign bullet3 "?getDv@btReducedDeformableFaceRigidContactConstraint@@UEBA?AVbtVector3@@PEBUNode@btSoftBody@@@Z";

    // this calls reduced deformable body's applyFullSpaceImpulse
    virtual_applyImpulse :: (this: *btReducedDeformableFaceRigidContactConstraint, impulse: *btVector3) -> void #cpp_method #foreign bullet3 "?applyImpulse@btReducedDeformableFaceRigidContactConstraint@@UEAAXAEBVbtVector3@@@Z";
}

btReducedDeformableBodySolver :: struct {
    #as using btdeformablebodysolver: btDeformableBodySolver;

    m_ascendOrder:          bool;
    m_dampingAlpha:         btScalar;
    m_dampingBeta:          btScalar;

    m_gravity:              btVector3 #align 8;

    predictReduceDeformableMotion :: (this: *btReducedDeformableBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?predictReduceDeformableMotion@btReducedDeformableBodySolver@@IEAAXM@Z";

    applyExplicitForce :: (this: *btReducedDeformableBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?applyExplicitForce@btReducedDeformableBodySolver@@IEAAXM@Z";

    m_staticConstraints:    btAlignedObjectArray(btAlignedObjectArray(btReducedDeformableStaticConstraint));
    m_nodeRigidConstraints: btAlignedObjectArray(btAlignedObjectArray(btReducedDeformableNodeRigidContactConstraint));

    //  btAlignedObjectArray<btAlignedObjectArray<btReducedDeformableFaceRigidContactConstraint> > m_faceRigidConstraints;
    Constructor :: (this: *btReducedDeformableBodySolver) -> void #cpp_method #foreign bullet3 "??0btReducedDeformableBodySolver@@QEAA@XZ";

    // Virtual functions:
    // Normally you should call them via the vtable.
    // But these bindings can be useful if you need to call the parent implementation in a sub-structs overwritten method
    // or need to create a vtable yourself.
    virtual_Destructor :: (this: *btReducedDeformableBodySolver, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign bullet3 "??1btReducedDeformableBodySolver@@UEAA@XZ";

    virtual_setGravity :: (this: *btReducedDeformableBodySolver, gravity: *btVector3) -> void #cpp_method #foreign bullet3 "?setGravity@btReducedDeformableBodySolver@@UEAAXAEBVbtVector3@@@Z";

    virtual_getSolverType :: (this: *btReducedDeformableBodySolver) -> btSoftBodySolver.SolverTypes #cpp_method #foreign bullet3 "?getSolverType@btReducedDeformableBodySolver@@UEBA?AW4SolverTypes@btSoftBodySolver@@XZ";

    // resize/clear data structures
    virtual_reinitialize :: (this: *btReducedDeformableBodySolver, bodies: *btAlignedObjectArray(*btSoftBody), dt: btScalar) -> void #cpp_method #foreign bullet3 "?reinitialize@btReducedDeformableBodySolver@@UEAAXAEBV?$btAlignedObjectArray@PEAVbtSoftBody@@@@M@Z";

    virtual_predictMotion :: (this: *btReducedDeformableBodySolver, solverdt: btScalar) -> void #cpp_method #foreign bullet3 "?predictMotion@btReducedDeformableBodySolver@@UEAAXM@Z";

    virtual_applyTransforms :: (this: *btReducedDeformableBodySolver, timeStep: btScalar) -> void #cpp_method #foreign bullet3 "?applyTransforms@btReducedDeformableBodySolver@@UEAAXM@Z";

    // set up contact constraints
    virtual_setConstraints :: (this: *btReducedDeformableBodySolver, infoGlobal: *btContactSolverInfo) -> void #cpp_method #foreign bullet3 "?setConstraints@btReducedDeformableBodySolver@@UEAAXAEBUbtContactSolverInfo@@@Z";

    // solve all constraints (fixed and contact)
    virtual_solveContactConstraints :: (this: *btReducedDeformableBodySolver, deformableBodies: **btCollisionObject, numDeformableBodies: s32, infoGlobal: *btContactSolverInfo) -> btScalar #cpp_method #foreign bullet3 "?solveContactConstraints@btReducedDeformableBodySolver@@UEAAMPEAPEAVbtCollisionObject@@HAEBUbtContactSolverInfo@@@Z";

    // apply all the delta velocities
    virtual_deformableBodyInternalWriteBack :: (this: *btReducedDeformableBodySolver) -> void #cpp_method #foreign bullet3 "?deformableBodyInternalWriteBack@btReducedDeformableBodySolver@@UEAAXXZ";
}

btCriticalSection :: struct {
    vtable: *btCriticalSection_VTable;
}
btCriticalSection_VTable :: struct #type_info_none {
    Destructor: (this: *btCriticalSection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    lock: (this: *btCriticalSection) -> void #cpp_method;
    unlock: (this: *btCriticalSection) -> void #cpp_method;
}

btCriticalSection_Destructor :: inline (this: *btCriticalSection, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btCriticalSection_lock :: inline (this: *btCriticalSection) { this.vtable.lock(this); }
btCriticalSection_unlock :: inline (this: *btCriticalSection) { this.vtable.unlock(this); }



btThreadSupportInterface :: struct {
    vtable: *btThreadSupportInterface_VTable;
    ThreadFunc :: #type (userPtr: *void) -> void #c_call;

    ConstructionInfo :: struct {
        m_uniqueName:      *u8;
        m_userThreadFunc:  ThreadFunc;
        m_threadStackSize: s32;
    }
}
btThreadSupportInterface_VTable :: struct #type_info_none {
    Destructor: (this: *btThreadSupportInterface, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getNumWorkerThreads: (this: *btThreadSupportInterface) -> s32 #cpp_method;
    getCacheFriendlyNumThreads: (this: *btThreadSupportInterface) -> s32 #cpp_method;
    getLogicalToPhysicalCoreRatio: (this: *btThreadSupportInterface) -> s32 #cpp_method;
    runTask: (this: *btThreadSupportInterface, threadIndex: s32, userData: *void) -> void #cpp_method;
    waitForAllTasks: (this: *btThreadSupportInterface) -> void #cpp_method;

    createCriticalSection: (this: *btThreadSupportInterface) -> *btCriticalSection #cpp_method;
    deleteCriticalSection: (this: *btThreadSupportInterface, criticalSection: *btCriticalSection) -> void #cpp_method;
}

btThreadSupportInterface_Destructor :: inline (this: *btThreadSupportInterface, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

btThreadSupportInterface_getNumWorkerThreads :: inline (this: *btThreadSupportInterface) -> s32 { return this.vtable.getNumWorkerThreads(this); }
btThreadSupportInterface_getCacheFriendlyNumThreads :: inline (this: *btThreadSupportInterface) -> s32 { return this.vtable.getCacheFriendlyNumThreads(this); }
btThreadSupportInterface_getLogicalToPhysicalCoreRatio :: inline (this: *btThreadSupportInterface) -> s32 { return this.vtable.getLogicalToPhysicalCoreRatio(this); }
btThreadSupportInterface_runTask :: inline (this: *btThreadSupportInterface, threadIndex: s32, userData: *void) { this.vtable.runTask(this, threadIndex, userData); }
btThreadSupportInterface_waitForAllTasks :: inline (this: *btThreadSupportInterface) { this.vtable.waitForAllTasks(this); }

btThreadSupportInterface_createCriticalSection :: inline (this: *btThreadSupportInterface) -> *btCriticalSection { return this.vtable.createCriticalSection(this); }
btThreadSupportInterface_deleteCriticalSection :: inline (this: *btThreadSupportInterface, criticalSection: *btCriticalSection) { this.vtable.deleteCriticalSection(this, criticalSection); }



b3BvhSubtreeInfoData_t :: b3BvhSubtreeInfoData;

b3BvhSubtreeInfoData :: struct {
    //12 bytes
    m_quantizedAabbMin: [3] u16;
    m_quantizedAabbMax: [3] u16;

    //4 bytes, points to the root of the subtree
    m_rootNodeIndex:    s32;

    //4 bytes
    m_subtreeSize:      s32;
    m_padding:          [3] s32;
}

///b3QuantizedBvhNodeData is a compressed aabb node, 16 bytes.
///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
b3QuantizedBvhNodeData_t :: b3QuantizedBvhNodeData;

b3QuantizedBvhNodeData :: struct {
    //12 bytes
    m_quantizedAabbMin:           [3] u16;
    m_quantizedAabbMax:           [3] u16;

    //4 bytes
    m_escapeIndexOrTriangleIndex: s32;
}

// satisfy jai
b3QuantizedBvhNode :: struct {
    #as using b3quantizedbvhnodedata: b3QuantizedBvhNodeData;
}

/// b3OptimizedBvhNode contains both internal and leaf node information.
/// Total node size is 44 bytes / node. You can use the compressed version of 16 bytes.
b3OptimizedBvhNode :: struct {
    //32 bytes
    m_aabbMinOrg:    b3Vector3;
    m_aabbMaxOrg:    b3Vector3;

    //4
    m_escapeIndex:   s32;

    //8
    //for child nodes
    m_subPart:       s32;
    m_triangleIndex: s32;

    //pad the size to 64 bytes
    m_padding:       [20] u8;
}

///b3BvhSubtreeInfo provides info to gather a subtree of limited size
b3BvhSubtreeInfo :: struct {
    #as using b3bvhsubtreeinfodata: b3BvhSubtreeInfoData;
}

b3BvhInfo :: struct {
    m_aabbMin:       b3Vector3;
    m_aabbMax:       b3Vector3;
    m_quantization:  b3Vector3;
    m_numNodes:      s32;
    m_numSubTrees:   s32;
    m_nodeOffset:    s32;
    m_subTreeOffset: s32;
}

b3GpuFace_t :: b3GpuFace;
b3GpuFace :: struct {
    m_plane:          b3Vector3;
    m_indexOffset:    s32;
    m_numIndices:     s32;
    m_unusedPadding1: s32;
    m_unusedPadding2: s32;
}

b3ConvexPolyhedronData_t :: b3ConvexPolyhedronData;

b3ConvexPolyhedronData :: struct {
    m_localCenter:       b3Vector3;
    m_extents:           b3Vector3;
    mC:                  b3Vector3;
    mE:                  b3Vector3;

    m_radius:            float;
    m_faceOffset:        s32;
    m_numFaces:          s32;
    m_numVertices:       s32;

    m_vertexOffset:      s32;
    m_uniqueEdgesOffset: s32;
    m_numUniqueEdges:    s32;
    m_unused:            s32;
}

_b3MprSupport_t :: struct {
    v:  b3Vector3; //!< Support point in minkowski sum
    v1: b3Vector3; //!< Support point in obj1
    v2: b3Vector3; //!< Support point in obj2
}

b3MprSupport_t :: _b3MprSupport_t;

_b3MprSimplex_t :: struct {
    ps:   [4] b3MprSupport_t;
    last: s32; //!< index of last added point
}

b3MprSimplex_t :: _b3MprSimplex_t;

#scope_file

bullet3 :: #foreign_library "./bullet3";
